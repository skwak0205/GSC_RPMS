/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define, Date:true*/

define('UWA/Internal/Polyfill/NativeObjects', [
], function () {
    'use strict';

    var call = Function.prototype.call,
        prototypeOfObject = Object.prototype,
        prototypeOfArray = Array.prototype,

        // Check failure of by-index access of string characters (IE < 9)
        // and failure of `0 in boxedString` (Rhino)
        boxedString = Object("a"),
        splitString = boxedString[0] !== "a" || !(0 in boxedString);

    // Global alias
    var global = Function('return this')(); // eslint-disable-line no-new-func

    // ES5 9.4
    // http://es5.github.com/#x9.4
    // http://jsperf.com/to-integer
    function toInteger(value) {

        var number = Number(value);

        if (isNaN(number)) {
            number = 0;
        } else if (number !== 0 || isFinite(number)) {
            number = ((number < 0) ? -1 : 1) * Math.floor(Math.abs(number));
        }

        return number;
    }

    // ES5 9.9
    // http://es5.github.com/#x9.9
    function toObject(o) {

        // this matches both null and undefined
        if (o === null || o === undefined) {
            throw new TypeError(o + ' is not a object');
        }

        // If the implementation doesn't support by-index access of
        // string characters (ex. IE < 7), split the string
        if (o && splitString && o instanceof String) {
            return o.split('');
        }

        return Object(o);
    }

    function isDefined(a, b) {
        return (b in a);
    }

    function toString(x) {
        return Object.prototype.toString.call(x);
    }


    // {{{ Function polyfills

    /**
     * The built in Function object.
     * @external Function
     */
    if (!Function.prototype.bind) {

        /**
         * Wraps the function in another, locking its execution scope to an object specified by context.
         *
         * @see ES5-5 15.3.4.5.
         *
         * @method
         * @param {Object} bind - Object to use as this when executing function
         * @param {...*} param - Arguments to prepend to arguments provided to the bound function when invoking the target function.
         * @return {Function} binded function.
         *
         * @example
         * var myContext = {
         *        test: 'context'
         *    },
         *
         *    myFunc = function (a, b) {
         *        return [a, b, this];
         *    },
         *
         *    myBindedFunc = myFunc.bind(myTestContext, '0');
         *
         * // Test original function
         * myFunc(1);
         * // will return [1, undefined, myFunc]
         *
         * // Test binded function
         * myBindedFunc(1);
         * // will return [0, 1, myContext]
         *
         * @alias Function.prototype.bind
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Function.prototype.bind = function bind(that) { // .length is 1

            // 1. Let Target be the this value.
            var args, bound,
                target = this,
                arraySlice = Array.prototype.slice,
                Empty = function Empty() {};

            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (typeof target !== "function") {
                throw new TypeError("Function.prototype.bind called on incompatible " + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            args = arraySlice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            bound = function () {

                var result;

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    result = target.apply(
                        this,
                        args.concat(arraySlice.call(arguments))
                    );

                    result = Object(result) === result ? result : this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    result = target.apply(
                        that,
                        args.concat(arraySlice.call(arguments))
                    );
                }

                return result;
            };

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }
            // XXX bound.length is never writable, so don't even try
            //
            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.
            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        };
    }

    // }}}

    // {{{ String polyfills
    (function () {

        var trimBeginRegexp, trimEndRegexp,
            whiteSpaces = "\x09\x0A\x0B\x0C\x0D \xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
            "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
            "\u2029\uFEFF";

        if (!String.prototype.trim || whiteSpaces.trim()) {

            // http://blog.stevenlevithan.com/archives/faster-trim-javascript
            // http://perfectionkills.com/whitespace-deviations/

            whiteSpaces = "[" + whiteSpaces + "]";
            trimBeginRegexp = new RegExp("^" + whiteSpaces + whiteSpaces + "*");
            trimEndRegexp = new RegExp(whiteSpaces + whiteSpaces + "*$");

            /**
             * Trims the leading and trailing spaces off a string.
             *
             * @see ES5 15.5.4.20.
             *
             * @method
             * @return {String} Trimed string.
             *
             * @example
             * " hello world ".trim();
             * will return "hello world"
             *
             * @alias String.prototype.trim
             * @memberOf module:UWA/Internal/Polyfill/NativeObjects
             */
            String.prototype.trim = function trim() {

                if (this === undefined || this === null) {
                    throw new TypeError("can't convert " + this + " to object");
                }

                return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
            };
        }
    }());

    (function () {

        var stringSplit = String.prototype.split,
            testAb = "ab",
            testDot = ".",
            testTesst = "tesst",
            testEmpty = "",
            testZero = "0";

        // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
        // Many browsers do not split properly with regular expressions or they
        // do not perform the split correctly under obscure conditions.
        // See http://blog.stevenlevithan.com/archives/cross-browser-split
        // I've tested in many browsers and this seems to cover the deviant ones:
        //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
        //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
        //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
        //       [undefined, "t", undefined, "e", ...]
        //    ''.split(/.?/) should be [], not [""]
        //    '.'.split(/()()/) should be ["."], not ["", "", "."]
        if (
            testAb.split(/(?:ab)*/).length !== 2 ||
                testDot.split(/(.?)(.?)/).length !== 4 ||
                    testTesst.split(/(s)*/)[1] === "t" ||
                        testEmpty.split(/.?/).length === 0 ||
                           testDot.split(/()()/).length > 1
        ) {
            (function () {

                var compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group

                /**
                 * Splits a String object into an array of strings by separating the string into substrings.
                 *
                 * @see ES5 15.5.4.14.
                 *
                 * @method
                 * @param {String} separator - Specifies the character to use for separating the string
                 *    The separator is treated as a string or a regular expression. If separator is omitted, the array returned contains one element consisting of the entire string.
                 * @param {String} limit - Integer specifying a limit on the number of splits to be found
                 *    The split method still splits on every match of separator, but it truncates the returned array to at most limit elements.
                 *
                 * @return {Array} Splited string parts.
                 *
                 * @example
                 * "Hello World. How are you doing?".split();
                 * will return ["Hello World", " How are you doing?"]
                 *
                 * @alias String.prototype.split
                 * @memberOf module:UWA/Internal/Polyfill/NativeObjects
                 */
                String.prototype.split = function (separator, limit) {

                    var output, flags, lastLastIndex, separator2,
                        match, lastIndex, lastLength,
                        string = this;

                    function cleanup() {
                        var i;
                        for (i = 1; i < arguments.length - 2; i++) {
                            if (arguments[i] === undefined) {
                                match[i] = undefined;
                            }
                        }
                    }

                    if (separator === undefined && limit === 0) {
                        output = [];

                    // If `separator` is not a regex, use native split
                    } else if (toString(separator) !== "[object RegExp]") {
                        output = stringSplit.apply(string, [separator, limit]);
                    } else {

                        output = [];
                        flags = (separator.ignoreCase ? "i" : "") +
                                (separator.multiline ? "m" : "") +
                                (separator.extended ? "x" : "") + // Proposed for ES6
                                (separator.sticky ? "y" : ""); // Firefox 3+

                        lastLastIndex = 0;

                        // Make `global` and avoid `lastIndex` issues by working with a copy
                        separator = new RegExp(separator.source, flags + "g");

                        string = String(string); // Type-convert

                        if (!compliantExecNpcg) {
                            // Doesn't need flags gy, but they don't hurt
                            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
                        }

                        // Values for `limit`, per the spec:
                        // If undefined: 4294967295 // Math.pow(2, 32) - 1
                        // If 0, Infinity, or NaN: 0
                        // If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                        // If negative number: 4294967296 - Math.floor(Math.abs(limit))
                        // If other: Type-convert, then use the above rules

                        limit = limit === undefined ?
                            -1 >>> 0 :   // Math.pow(2, 32) - 1
                            limit >>> 0; // ToUint32(limit)

                        while ((match = separator.exec(string))) {

                            // `separator.lastIndex` is not reliable cross-browser
                            lastIndex = match.index + match[0].length;

                            if (lastIndex > lastLastIndex) {

                                output.push(string.slice(lastLastIndex, match.index));

                                // Fix browsers whose `exec` methods don't consistently return `undefined` for
                                // nonparticipating capturing groups
                                if (!compliantExecNpcg && match.length > 1) {
                                    match[0].replace(separator2, cleanup);
                                }

                                if (match.length > 1 && match.index < string.length) {
                                    Array.prototype.push.apply(output, match.slice(1));
                                }

                                lastLength = match[0].length;
                                lastLastIndex = lastIndex;

                                if (output.length >= limit) {
                                    break;
                                }
                            }

                            if (separator.lastIndex === match.index) {
                                separator.lastIndex++; // Avoid an infinite loop
                            }
                        }

                        if (lastLastIndex === string.length) {
                            if (lastLength || !separator.test("")) {
                                output.push("");
                            }
                        } else {
                            output.push(string.slice(lastLastIndex));
                        }

                        output = output.length > limit ? output.slice(0, limit) : output;
                    }

                    return output;
                };
            }());

        // [bugfix, chrome]
        // If separator is undefined, then the result array contains just one String,
        // which is the this value (converted to a String). If limit is not undefined,
        // then the output array is truncated so that it contains no more than limit
        // elements.
        // "0".split(undefined, 0) -> []
        } else if (testZero.split(undefined, 0).length) {
            String.prototype.split = function G246(separator, limit) {
                return (separator === undefined && limit === 0) ?
                        [] : stringSplit.apply(this, [separator, limit]);
            };
        }
    }());

    (function () {

        // Note an ECMAScript standart, although ECMAScript 3rd Edition has a
        // non-normative section suggesting uniform semantics and it should be
        // normalized across all browsers
        // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
        if ("".substr && "0b".substr(-1) !== "b") {
            var stringSubstr = String.prototype.substr;

            /**
             * Returns the characters in a string beginning at the specified location through the specified number of characters.
             *
             * @see ECMA-262, 3rd B.2.3.
             *
             * @method
             * @param {String} start - Location at which to begin extracting characters
             * @param {String} length - The number of characters to extract
             * @return {Array} Splited string parts.
             *
             * @example
             * var str = "abcdefghij";
             * str.substr(1,2);    // "bc"
             * str.substr(-3,2);   // "hi"
             * str.substr(-3);     // "hij"
             * str.substr(1);      // "bcdefghij"
             * str.substr(-20,2);  // "ab"
             * str.substr(20,2);   // ""
             *
             * @alias String.prototype.substr
             * @memberOf module:UWA/Internal/Polyfill/NativeObjects
             */
            String.prototype.substr = function (start, length) {
                return stringSubstr.call(
                    this,
                    start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
                    length
                );
            };
        }
    }());

    /* Group: UWA String Testing extensions */

    function checkObjectCoercible(x, optMessage) {

        if (x === null || x === undefined) {
            throw new TypeError(optMessage || ('Cannot call method on ' + x));
        }

        return x;
    }

    /**
     * The built in String object.
     * @external String
     */
    if (!String.prototype.repeat) {

        /**
         * The repeat() method copies the current string a given times and returns the new string.
         *
         * @see ES6 21.1.3.13
         *
         * @method
         * @param {Number} times - An integer between 0 and +∞ : [ 0, +∞).
         * @return {String}
         *
         * @example
         * "abc".repeat(-1)     // RangeError
         * "abc".repeat(0)      // ""
         * "abc".repeat(1)      // "abc"
         * "abc".repeat(2)      // "abcabc"
         * "abc".repeat(3.5)    // "abcabcabc" (count will be converted to integer)
         * "abc".repeat(1/0)    // RangeError
         *
         * @alias String.prototype.repeat
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        String.prototype.repeat = (function () {

            var repeat = function (s, times) {

                var value;

                if (times < 1) {
                    value = '';
                } else if (times % 2) {
                    value = repeat(s, times - 1) + s;
                } else {
                    value = repeat(s, times / 2);
                    value += value;
                }

                return value;
            };

            return function (times) {

                var thisStr = String(checkObjectCoercible(this));

                times = toInteger(times);

                if (times < 0 || times === Infinity) {
                    throw new RangeError('Invalid String#repeat value');
                }

                return repeat(thisStr, times);
            };
        }());

    }

    if (!String.prototype.startsWith) {
        /**
         * The startsWith() method determines whether a string begins with the
         * characters of another string, returning true or false as appropriate.
         *
         * @see ES6 21.1.3.18
         *
         * @method
         * @param {String} searchString - The characters to be searched for at the start of this string.
         * @param {Integer} position -The position in this string at which to begin searching for searchString; defaults to 0.
         * @return {Boolean}
         *
         * @example
         * var str = "To be, or not to be, that is the question.";
         *
         * str.startsWith("To be");         // true
         * str.startsWith("not to be");     // false
         * str.startsWith("not to be", 10); // true
         *
         * @alias String.prototype.startsWith
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        String.prototype.startsWith = function (searchStr) {

            var startArg, start,
                thisStr = String(checkObjectCoercible(this));

            if (toString(searchStr) === '[object RegExp]') {
                throw new TypeError('Cannot call method "startsWith" with a regex');
            }

            searchStr = String(searchStr);
            startArg = arguments.length > 1 ? arguments[1] : undefined;
            start = Math.max(toInteger(startArg), 0);

            return thisStr.slice(start, start + searchStr.length) === searchStr;
        };

    }

    if (!String.prototype.endsWith) {
        /**
         * The endsWith() method determines whether a string ends with the
         * characters of another string, returning true or false as appropriate.
         *
         * @see ES6 21.1.3.7
         *
         * @method
         * @param {String} searchString - The characters to be searched for at
         *  the end of this string.
         * @param {Integer} position - Search within this string as if this
         *  string were only this long; defaults to this string's actual length,
         *  clamped within the range established by this string's length.
         * @return {Boolean}
         *
         * @example
         * var str = "To be, or not to be, that is the question.";
         *
         * str.endsWith("question.");   // true
         * str.endsWith("to be");       // false
         * str.endsWith("to be", 19);   // true
         *
         * @alias String.prototype.endsWith
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        String.prototype.endsWith = function (searchStr) {

            var thisLen, posArg, pos, end,
                thisStr = String(checkObjectCoercible(this));

            if (toString(searchStr) === '[object RegExp]') {
                throw new TypeError('Cannot call method "endsWith" with a regex');
            }

            searchStr = String(searchStr);
            thisLen = thisStr.length;
            posArg = arguments.length > 1 ? arguments[1] : undefined;
            pos = posArg === undefined ? thisLen : toInteger(posArg);
            end = Math.min(Math.max(pos, 0), thisLen);

            return thisStr.slice(end - searchStr.length, end) === searchStr;
        };
    }

    if (!String.prototype.codePointAt) {
        /**
         * The codePointAt() method returns a non-negative integer that is the
         * UTF-16 encoded code point value.
         *
         * @see ES6 21.1.3.13
         *
         * @method
         * @param {Number} pos - Position of an element in the String to return
         *  the code point value from.
         * @return {Integer} Trimed string.
         *
         * @example
         * 'ABC'.codePointAt(1);          // 66
         * '\uD800\uDC00'.codePointAt(0); // 65536
         *
         * 'XYZ'.codePointAt(42); // undefined
         *
         * @alias String.prototype.codePointAt
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        String.prototype.codePointAt = function (pos) {

            var first, second, isEnd,
                thisStr = String(checkObjectCoercible(this)),
                length = thisStr.length,
                position = toInteger(pos);

            if (position < 0 || position >= length) {
                return undefined;
            }

            first = thisStr.charCodeAt(position);
            isEnd = (position + 1 === length);

            if (first < 0xD800 || first > 0xDBFF || isEnd) {
                return first;
            }

            second = thisStr.charCodeAt(position + 1);
            if (second < 0xDC00 || second > 0xDFFF) {
                return first;
            }

            return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
        };
    }

    if (!String.prototype.contains) {
        /**
         * The contains() method determines whether one string may be found within
         * another string, returning true or false as appropriate.
         *
         * __Notes__:
         * If second argument is a string it's used as a separator.
         * See Examples for details.
         *
         * @see ES6 21.1.3.6
         *
         * @method
         * @param {String} word - A string to be searched for within this string.
         * @param {String|Integer} position - The position in this string at which to begin searching for searchString; defaults to 0.
         * @return {Boolean} `true` is String match requested String else `false`.
         *
         * @example
         * // EcmaScript Implementation
         * var str = "To be, or not to be, that is the question.";
         * str.contains("To be");       // true
         * str.contains("question");    // true
         * str.contains("nonexistent"); // false
         * str.contains("To be", 1);    // false
         * str.contains("TO BE");       // false
         *
         * // UWA extras separator arguments
         * "hello world".contains('world'); // true
         * "hello,world".contains('world', ','); // true
         * "hello world".contains('world', ','); // false
         *
         * @alias String.prototype.contains
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        String.prototype.contains = function (searchString, position) {
            var thisStr = String(checkObjectCoercible(this));
            return thisStr.indexOf(searchString, position) !== -1;
        };

    }

    // }}}

    // {{{ Array polyfills

    /**
     * The built in Array object.
     * @external Array
     */
    if (!Array.isArray) {

        /**
         * Returns `true` if an object is an array, `false` if it is not.
         *
         * @see ES5 15.4.3.2.
         *
         * @method
         * @param {Object} obj - The object to be checked
         * @return {Boolean} `true` if object argument is an array else `false`
         *
         * @example
         * var myArray = [];
         * Array.isArray(myArray);
         * // will return true
         *
         * var myString = "";
         * Array.isArray(myString);
         * // will return false
         *
         * @alias Array.isArray
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Array.isArray = function (obj) {
            return toString(obj) === '[object Array]';
        };
    }

    if ([1, 2].splice(0).length !== 2) {

        (function () {
            var arraySplice = prototypeOfArray.splice,
                arraySlice = prototypeOfArray.slice;

            /**
             * Changes the content of an array, adding new elements while removing old elements.
             *
             * @see ES5 15.4.4.12.
             *
             * @method
             * @param {Number} index - Index at which to start changing the array
             * If greater than the length of the array, no elements will be removed.
             * If negative, will begin that many elements from the end.
             * @param {Number} howMany - An integer indicating the number of old array elements
             * to remove. If howMany is 0, no elements are removed. In this case,
             * you should specify at least one new element. If howMany is greater
             * than the number of elements left in the array starting at index,
             * then all of the elements though the end of the array will be deleted.
             * - Void element1, ..., elementN: The elements to add to the array.
             * If you don't specify any elements, splice simply removes elements from the array.
             *
             * @return {Array} An array containing the removed elements.
             * If only one element is removed, an array of one element is returned.
             * If no elements are removed, an empty array is returned.
             *
             * @example
             * var myFish = ["angel", "clown", "mandarin", "surgeon"];
             *
             * //removes 0 elements from index 2, and inserts "drum"
             * var removed = myFish.splice(2, 0, "drum");
             * // myFish is ["angel", "clown", "drum", "mandarin", "surgeon"]
             * // removed is [], no elements removed
             *
             * // removes 1 element from index 3
             * removed = myFish.splice(3, 1);
             * // myFish is ["angel", "clown", "drum", "surgeon"]
             * // removed is ["mandarin"]
             *
             * // removes 1 element from index 2, and inserts "trumpet"
             * removed = myFish.splice(2, 1, "trumpet");
             * // myFish is ["angel", "clown", "trumpet", "surgeon"]
             * // removed is ["drum"]
             *
             * // removes 2 elements from index 0, and inserts "parrot", "anemone" and "blue"
             * removed = myFish.splice(0, 2, "parrot", "anemone", "blue");
             * // myFish is ["parrot", "anemone", "blue", "trumpet", "surgeon"]
             * // removed is ["angel", "clown"]
             *
             * // removes 2 elements from index 3
             * removed = myFish.splice(3, Number.MAX_VALUE);
             * // myFish is ["parrot", "anemone", "blue"]
             * // removed is ["trumpet", "surgeon"]
             *
             * @alias Array.prototype.splice
             * @memberOf module:UWA/Internal/Polyfill/NativeObjects
             */
            prototypeOfArray.splice = function splice(start, deleteCount) {

                var that = this,
                    result = [],
                    args = arraySlice.call(arguments);

                if (args.length) {
                    args[0] = start === undefined ? 0 : start;
                    args[1] = deleteCount === undefined ? that.length - start : deleteCount;
                    result = arraySplice.apply(that, args);
                }

                return result;
            };

        }());
    }

    if ([].unshift(0) !== 1) {
        (function () {
            var arrayUnshift = prototypeOfArray.unshift;

            /**
             * Adds one or more elements to the beginning of an array and returns the new length of the array.
             *
             * @see ES5 15.4.4.13.
             *
             * @method
             * @param {...*} - The elements to add to the front of the array
             * @return {Number} The new length property of the object upon which the method was called.
             *
             * @example
             * var arr = [1, 2];
             * arr.unshift(0); //result of call is 3, the new array length
             * // arr is [0, 1, 2]
             *
             * arr.unshift(-2, -1); // = 5
             * // arr is [-2, -1, 0, 1, 2]
             *
             * arr.unshift( [-3] );
             * // arr is [[-3], -2, -1, 0, 1, 2]
             *
             * @alias Array.prototype.unshift
             * @memberOf module:UWA/Internal/Polyfill/NativeObjects
             */
            prototypeOfArray.unshift = function unshift() {
                arrayUnshift.apply(this, arguments);
                return this.length;
            };
        }());
    }

    if (
        !prototypeOfArray.indexOf ||
            ([0, 1].indexOf(1, 2) !== -1)
    ) {

        /**
         * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
         *
         * @see ES5 15.4.4.14.
         *
         * @method
         * @param {Void} sought - Element to locate in the array
         * @param {Number} fromIndex - The index at which to begin the search. Defaults to 0, i.e. the whole array will
         * be searched. If the index is greater than or equal to the length of the array, -1 is returned, i.e.
         * the array will not be searched. If negative, it is taken as the offset from the end of the array.
         * Note that even when the index is negative, the array is still searched from front to back.
         * If the calculated index is less than 0, the whole array will be searched.
         *
         * @return {Number} Returns the index of the found element.
         *
         * @example
         * var a = ['red', 'blue', 'green', 'blue'];
         * var result = a.indexOf(a, "blue");
         * // result value is "1"
         * result = a.indexOf(a, "black");
         * // result value is "-1"
         *
         * @alias Array.prototype.indexOf
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.indexOf = function indexOf(sought, fromIndex) {

            var i = 0,
                self = toObject(this),
                length = self.length >>> 0;

            if (!length) {
                return -1;
            }

            if (arguments.length > 1) {
                i = toInteger(fromIndex);
            }

            // handle negative indices
            i = i >= 0 ? i : Math.max(0, length + i);
            for (i; i < length; i++) {
                if (isDefined(self, i) && self[i] === sought) {
                    return i;
                }
            }
            return -1;
        };
    }

    if (
        !prototypeOfArray.lastIndexOf ||
            ([0, 1].lastIndexOf(0, -3) !== -1)
    ) {

        /**
         * Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.
         *
         * @see ES5 15.4.4.15.
         *
         * @method
         * @param {Void} sought - Element to locate in the array
         * @param {Number} fromIndex - The index at which to start searching backwards.
         * Defaults to the array's length, i.e. the whole array will be searched.
         * If the index is greater than or equal to the length of the array, the
         * whole array will be searched. If negative, it is taken as the offset from the end of the array.
         *
         * @return {Number} Returns the index of the found element.
         *
         * @example
         * var index = [12, 5, 8, 130, '8', 44].lastIndexOf(8);
         * // index value is "2"
         * var index = [12, 5, 8, 130, 44, 5].lastIndexOf(5);
         * // index value is "5"
         *
         * @alias Array.prototype.lastIndexOf
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.lastIndexOf = function lastIndexOf(sought, fromIndex) {

            var self = toObject(this),
                length = self.length >>> 0,
                i = length - 1;

            if (!length) {
                return -1;
            }

            if (arguments.length > 1) {
                i = Math.min(i, toInteger(fromIndex));
            }

            // handle negative indices
            for (i = (i >= 0 ? i : length - Math.abs(i)); i >= 0; i--) {
                if (isDefined(self, i) && sought === self[i]) {
                    return i;
                }
            }
            return -1;
        };
    }

    if (!prototypeOfArray.every) {

        /**
         * Tests whether all elements in the array pass the test implemented by the provided function.
         *
         * @see ES5 15.4.4.16.
         *
         * @method
         * @param {Function} fun - Function to test for each element
         * @param {Object} thisp - Object to use as this when executing callback
         * @return {Bool} Returns `true` if every element in this array satisfies the provided testing function.
         *
         * @example
         * function isBigEnough(element, index, array) {
         *     return (element >= 10);
         * }
         *
         * var result = [12, 5, 8, 130, 44].every(isBigEnough);
         * // result value is false
         * result = [12, 54, 18, 130, 44].every(isBigEnough);
         * // result value is true
         *
         * @alias Array.prototype.every
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.every = function every(fun, thisp) {

            var i,
                self = toObject(this),
                length = self.length >>> 0;

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            for (i = 0; i < length; i++) {
                if (isDefined(self, i) && !fun.call(thisp, self[i], i, self)) {
                    return false;
                }
            }

            return true;
        };
    }

    if (!prototypeOfArray.some) {

        /**
         * Tests whether some element in the array passes the test implemented by the provided function.
         *
         * @see ES5 15.4.4.17.
         *
         * @method
         * @param {Function} fun - Function to test for each element
         * @param {Object} thisp - Object to use as this when executing callback
         * @return {Bool} If some element pass the test then it returns `true` otherwise `false`.
         *
         * @example
         * function isBigEnough(element, index, array) {
         *     return (element >= 10);
         * }
         *
         * var result = [2, 5, 8, 1, 4].some(isBigEnough);
         * // result value is false
         * result = [12, 5, 8, 1, 4].some(isBigEnough);
         * // result value is true
         *
         * @alias Array.prototype.some
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.some = function some(fun, thisp) {

            var i,
                self = toObject(this),
                length = self.length >>> 0;

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            for (i = 0; i < length; i++) {
                if (isDefined(self, i) && fun.call(thisp, self[i], i, self)) {
                    return true;
                }
            }

            return false;
        };
    }

    if (!prototypeOfArray.forEach) {

        /**
         * Calls a function for each element in the array.
         *
         * @see ES5 15.4.4.18.
         *
         * @method
         * @param {Function} fun - Function to test each element of the array
         * @param {Object} thisp - Object to use as this when executing callback
         *
         * @example
         * var result = "";
         * function addResult(element, index, array) {
         *     result += "[" + index + "] is " + element + " / ";
         * }
         *
         * [2, 5, 9].forEach(addResult);
         * // result value is "[0] is 2 / [1] is 5 / [2] is 9 / "
         *
         * @alias Array.prototype.forEach
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.forEach = function forEach(fun, thisp) {

            var i = 0,
                that = this,
                self = toObject(this),
                length = self.length >>> 0;

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            while (i < length) {
                if (isDefined(self, i)) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object context
                    fun.call(thisp, self[i], i, that);
                }
                i++;
            }
        };
    }

    if (!prototypeOfArray.map) {

        /**
         * Creates a new array with the results of calling a provided function on every element in this array.
         *
         * @see ES5 15.4.4.19.
         *
         * @method
         * @param {Function} fun - Function that produces an element of the new Array from an element of the current one
         * @param {Object} thisp - Object to use as this when executing callback
         * @return {Array}
         *
         * @example
         * var numbers = [1, 4, 9];
         * var roots = numbers.map(Math.sqrt);
         * // roots is now [1, 2, 3] and numbers is still [1, 4, 9]
         *
         * @alias Array.prototype.map
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.map = function map(fun, thisp) {
            var i,
                self = toObject(this),
                length = self.length >>> 0,
                result = Array(length);

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            for (i = 0; i < length; i++) {
                if (isDefined(self, i)) {
                    result[i] = fun.call(thisp, self[i], i, self);
                }
            }
            return result;
        };
    }

    if (!prototypeOfArray.filter) {

        /**
         * Creates a new array with all of the elements of this array for which the provided filtering function returns `true`.
         *
         * @see ES5 15.4.4.20.
         *
         * @method
         * @param {Function} fun - Function to test each element of the array
         * @param {Object} thisp - Object to use as this when executing callback
         * @return {Array} Returns created array.
         *
         * @example
         * function isBigEnough(value, index, array) {
         *     return (value <= 10);
         * }
         *
         * var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
         * // filtered value is now [5, 8]
         *
         * @alias Array.prototype.filter
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.filter = function filter(fun, thisp) {

            var i, value,
                self = toObject(this),
                length = self.length >>> 0,
                result = [];

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            for (i = 0; i < length; i++) {
                if (isDefined(self, i)) {
                    value = self[i];
                    if (fun.call(thisp, value, i, self)) {
                        result.push(value);
                    }
                }
            }

            return result;
        };
    }

    if (!prototypeOfArray.reduce) {

        /**
         * Apply a function simultaneously against two values of the array (from left-to-right) as to reduce it to a single value.
         *
         * @see ES5 15.4.4.21.
         *
         * @method
         * @param {Function} fun - Function to execute on each value in the array
         * @param {Void} initial - Object to use as the first argument to the first call of the callback
         * @return {*} Returns the reduced single value of the array.
         *
         * @example
         * var total = [0, 1, 2, 3].reduce(function (a, b){ return a + b; });
         * // total value is now 6
         *
         * @alias Array.prototype.reduce
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.reduce = function reduce(fun) {

            var result,
                loop = true,
                i = 0,
                self = toObject(this),
                length = self.length >>> 0;

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + " is not a function");
            }

            // no value to return if no initial value and an empty array
            if (!length && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            if (arguments.length >= 2) {
                result = arguments[1];
            } else {

                do {
                    if (isDefined(self, i)) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }

                } while (loop);
            }

            for (i; i < length; i++) {
                if (isDefined(self, i)) {
                    result = fun(result, self[i], i, self);
                }
            }

            return result;
        };
    }

    if (!prototypeOfArray.reduceRight) {

        /**
         * Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value.
         *
         * @see ES5  15.4.4.22.
         *
         * @method
         * @param {Function} callback - Function to execute on each value in the array
         * @param {Void} initialValue - Object to use as the first argument to the first call of the callback
         * @return {*} Returns the reduceRightd single value of the array.
         *
         * @example
         * var total = [0, 1, 2, 3].reduceRight(function (a, b){ return a + b; });
         * // total value is now 6
         *
         * @alias Array.prototype.reduceRight
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        prototypeOfArray.reduceRight = function reduceRight(fun) {

            var result,
                loop = true,
                self = toObject(this),
                length = self.length >>> 0,
                i = length - 1;

            // If no callback function or if callback is not a callable function
            if (typeof fun !== 'function') {
                throw new TypeError(fun + ' is not a function');
            }

            // no value to return if no initial value, empty array
            if (!length && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (isDefined(self, i)) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (loop);
            }

            do {
                if (isDefined(self, i)) {
                    result = fun(result, self[i], i, self);
                }
            } while (i--);

            return result;
        };
    }

    // }}}

    // {{{ Object polyfills

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally.
    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // us it in defining shortcuts.
    var defineGetter, defineSetter, lookupGetter, lookupSetter, supportsAccessors,
        hasOwn = call.bind(prototypeOfObject.hasOwnProperty),
        prototypeKey = '__proto__',
        isObject = function (object) {
            var type = typeof object;
            return (type === 'object' || type === 'function') && object !== null;
        };

    // If JS engine supports accessors creating shortcuts.
    supportsAccessors = hasOwn(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
    }

    /**
     * The built in Object object.
     * @external Object
     */
    if (!Object.assign) {

        /**
         * Copies the values of all of the enumerable own properties from a
         * source to a target.
         *
         * @see ES6 19.1.2.1
         * @see {@link http://people.mozilla.org/~jorendorff/es6-draft.html#sec-19.1.2.1|ECMAScript 6th draft}
         *
         * @method
         * @param {Object} target - The object to extends
         * @param {Object} source - The object to copy
         * @return {Object} It returns the (modified) target
         *
         * @example
         *  var target = { a: 1 };
         *  var source = { b: 2 };
         *  var returned = Object.assign(target, source);
         *  // returned == { a: 1, b: 2 }
         *
         * @alias Object.assign
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.assign = function (target) {

            var to = toObject(target);

            if (arguments.length === 1) {
                return to;
            }

            var i;
            for (i = 1; i < arguments.length; i++) {
                var nextSource = arguments[i];
                if (nextSource === null || nextSource === undefined) {
                    continue;
                }

                var from = toObject(nextSource);
                var keys = Object.getOwnPropertyNames(from);

                var j;
                for (j = 0; j < keys.length; j++) {
                    to[keys[j]] = from[keys[j]];
                }
            }

            return to;
        };

    }

    if (!Object.is) {
        /**
         * Determines whether two values are the same value.
         *
         * Two values are the same if one of the following holds:
         *
         * - both undefined
         * - both null
         * - both true or both false
         * - both strings of the same length with the same characters
         * - both the same object
         * - both numbers and
         * - both +0
         * - both -0
         * - both NaN
         * - or both non-zero and both not NaN and both have the same value
         *
         * This is not the same as being equal according to the == operator.
         * The == operator applies various coercions to both sides before testing
         * for equality (resulting in such behavior as "" == false being true),
         * but Object.is doesn't coerce either value.
         *
         * This is also not the same as being equal according to the === operator.
         * The === operator (and the == operator as well) treats the number
         * values -0 and +0 as equal, and it treats NaN as not equal to NaN.
         *
         * @see ES6 19.1.2.10
         * @see {@link http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#current_working_draft|ECMAScript 6th draft}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Sameness|Sameness in JavaScript}
         *
         * @method
         * @param {Object} value1 - The first value to compare.
         * @param {Object} value2 - The second value to compare.
         * @return {Boolean} Returns `true` if the objects are the same value, otherwise `false`.
         *
         * @example
         *  Object.is("foo", "foo");     // true
         *  Object.is(window, window);   // true
         *
         *  Object.is("foo", "bar");     // false
         *  Object.is([], []);           // false
         *
         *  var test = {a: 1};
         *  Object.is(test, test);       // true
         *
         *  Object.is(null, null);       // true
         *
         *  // Special Cases
         *  Object.is(0, -0);            // false
         *  Object.is(-0, -0);           // true
         *  Object.is(NaN, 0/0);         // true
         *  Object.is("foo", "foo");     // true
         *  Object.is(window, window);   // true
         *
         * @alias Object.is
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.is = function (value1, value2) {

            if (value1 === value2) {
                // 0 === -0, but they are not identical
                return value1 !== 0 || 1 / value1 === 1 / value2;
            }

            // NaN !== NaN, but they are identical.
            // NaNs are the only non-reflexive value, i.e., if x !== x,
            // then x is a NaN.
            // isNaN is broken: it converts its argument to number, so
            // isNaN("foo") => true
            return value1 !== value1 && value2 !== value2; // eslint-disable-line no-self-compare
        };

    }

    if (!Object.setPrototypeOf) {

        /**
         * Set the prototype (i.e. the internal [[Prototype]] property ) of a specified object to another object or null.
         *
         * When the setPrototypeOf function is called with arguments obj and proto, the following steps are taken:
         *
         * - If Type(obj) is not Object, then throw a TypeError exception.
         * - If Type(proto) is neither Object or Null, then throw a TypeError exception.
         * - Let status be the result of calling the [[SetInheritance]] internal method of obj with argument proto.
         * - ReturnIfAbrupt(status).
         * - If status is false, then throw a TypeError exception.
         * - Return obj.
         *
         * @see ES6 19.1.2.19
         * @see {@link http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#current_working_draft|ECMAScript 6th draft}
         * @see {@link http://webreflection.blogspot.com/2013/05/objectsetprototypeofo-proto-is-in-es6.html|Object.setPrototypeOf(obj, proto) IS in ES6}
         *
         * @method
         * @param {Object} obj - The object whose prototype is to be set.
         * @param {Object} proto - The object's new prototype(an object or null).
         * @return {Object} Returns new Object with new protype.
         *
         * @example
         *  var dict = Object.setPrototypeOf({}, null);
         *
         * @alias Object.setPrototypeOf
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.setPrototypeOf = (function () {

            var set;

            function checkArgs(obj, proto) {
                if (typeof obj !== 'object' || obj === null) {
                    throw new TypeError('can not set prototype on a non-object');
                } else if (typeof proto !== 'object' && proto !== null) {
                    throw new TypeError('can only set prototype to an object or null');
                }
            }

            function setPrototypeOf(obj, proto) {
                checkArgs(obj, proto);
                set.call(obj, proto);
                return obj;
            }

            try {

                // this works already in Firefox and Safari
                set = Object.getOwnPropertyDescriptor(prototypeOfObject, prototypeKey).set;
                set.call({}, null);

            } catch (error) {

                if (prototypeOfObject !== {}[prototypeKey]) {
                    // IE < 11 cannot be shimmed
                    return;
                }

                // probably Chrome or some old Mobile stock browser
                set = function (proto) {
                    this[prototypeKey] = proto;
                };

                // please note that this will **not** work
                // in those browsers that do not inherit
                // __proto__ by mistake from Object.prototype
                // in these cases we should probably throw an error
                // or at least be informed about the issue
                setPrototypeOf.polyfill = setPrototypeOf(
                    setPrototypeOf({}, null),
                    prototypeOfObject
                ) instanceof Object;

                // setPrototypeOf.polyfill === true means it works as meant
                // setPrototypeOf.polyfill === false means it's not 100% reliable
                // setPrototypeOf.polyfill === undefined
                // or
                // setPrototypeOf.polyfill ==  null means it's not a polyfill
                // which means it works as expected
                // we can even delete Object.prototype.__proto__;
            }

            return setPrototypeOf;
        }());

    }

    if (!Object.getPrototypeOf) {

        /**
         * Returns the prototype of the specified object.
         *
         * @see ES55 15.2.3.2.
         *
         * @method
         * @param {Object} object - The object whose prototype is to be returned
         * @return The prototype of the object argument. The prototype is also an object.
         * @throws Throws a TypeError exception if the object parameter isn't an Object.
         *
         * @example
         * Object.getPrototypeOf(new String("abc")) === String.prototype;
         * // will return true
         *
         * @alias Object.getPrototypeOf
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.getPrototypeOf = function (object) {
            // https://github.com/kriskowal/es5-shim/issues#issue/2
            // http://ejohn.org/blog/objectgetprototypeof/
            // recommended by fschaefer on github
            return object[prototypeKey] || (
                object.constructor ?
                        object.constructor.prototype :
                                prototypeOfObject
            );
        };
    }


    if (!Object.getOwnPropertyDescriptor) {
        /**
         * Returns a property descriptor for an own property (that is, one
         * directly present on an object, not present by dint of being along an
         * object's prototype chain) of a given object.
         *
         * @see ES55 15.2.3.3.
         *
         * This method permits examination of the precise description of a
         * property. A property in JavaScript consists of a string-valued name
         * and a property descriptor. A property descriptor is a record with
         * some of the above attributes.
         *
         * @method
         * @property {*} value - The value associated with the property (data descriptors only)
         * @property {Boolean} writable - `true` if and only if the value associated with the property may be changed (data descriptors only)
         * @property {Function} get - A function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only)
         * @property {Function} set - A function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).
         * @property {Boolean} configurable - `true` if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object
         * @property {Boolean} enumerable - `true` if and only if this property shows up during enumeration of the properties on the corresponding object.
         *
         * Further information about property attributes can be found on the Object.defineProperty description
         *
         * @example
         * var o, d;
         *
         * o = { get foo() { return 17; } };
         * d = Object.getOwnPropertyDescriptor(o, "foo");
         * // d is { configurable: `true`, enumerable: `true`, get: function foo() { return 17; }, set: undefined }
         *
         * o = { bar: 42 };
         * d = Object.getOwnPropertyDescriptor(o, "bar");
         * // d is { configurable: `true`, enumerable: `true`, value: 42, writable: `true` }
         *
         * o = {};
         * Object.defineProperty(o, "baz", { value: 8675309, writable: `false`, enumerable: `false` });
         * d = Object.getOwnPropertyDescriptor(o, "baz");
         * // d is { value: 8675309, writable: `false`, enumerable: `false`, configurable: `false` }
         *
         * @param {Object} object - The object in which to look for the property
         * @param {String} property - The name of the property whose description is
         *                   to be retrieved.
         * @return {Object} Returns a property descriptor for an own property (that is
         *  , one directly present on an object, not present by dint of being
         *  along an object's prototype chain) of a given object.
         *
         * @alias Object.getOwnPropertyDescriptor
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.getOwnPropertyDescriptor = function (object, property) {

            var prototype, descriptor, getter, setter;

            if (!isObject(object)) {
                throw new TypeError('Object.getOwnPropertyDescriptor called on a non-object:' + object);
            }

            // If object does not owns property return undefined immediately.
            if (!hasOwn(object, property)) {
                return undefined;
            }

            // If object has a property then it's for sure both `enumerable` and  `configurable`.
            descriptor = {
                enumerable: true,
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {

                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                prototype = object[prototypeKey];
                object[prototypeKey] = prototypeOfObject;

                getter = lookupGetter(object, property);
                setter = lookupSetter(object, property);

                // Once we have getter and setter we can put values back.
                object[prototypeKey] = prototype;

                if (getter || setter) {

                    if (getter) {
                        descriptor.get = getter;
                    }

                    if (setter) {
                        descriptor.set = setter;
                    }

                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            return descriptor;
        };
    }

    if (!Object.getOwnPropertyNames) {

        /**
         * Returns an array of all properties (enumerable or not) found upon a
         * given object.
         *
         * @see ES55 15.2.3.4.
         *
         * @method
         * @param {Object} object - The object whose enumerable and non-enumerable own
         * properties are to be returned.
         * @return {Array} Returns an array of all properties (enumerable or not)
         * found upon a given object.
         *
         * Object.getOwnPropertyNames returns an array whose elements are
         * strings corresponding to the enumerable and non-enumerable
         * properties found directly upon obj. The ordering of the enumerable
         * properties in the array  is consistent with the ordering exposed by
         * a  for...in loop (or by Object.keys) over the properties of the
         * object. The ordering of the non-enumerable properties in the array,
         * and among the enumerable properties, is not defined.
         *
         * @example
         * var arr = ["a", "b", "c"];
         * print(Object.getOwnPropertyNames(arr).sort()); // prints "0,1,2,length"
         *
         * // array-like object
         * var obj = { 0: "a", 1: "b", 2: "c"};
         * print(Object.getOwnPropertyNames(obj).sort()); // prints "0,1,2"
         *
         * // non-enumerable property
         * var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: `false` } });
         * my_obj.foo = 1;
         *
         * print(Object.getOwnPropertyNames(my_obj).sort()); // prints "foo, getFoo"
         *
         * // If you want only the enumerable properties, see Object.keys or use a for...in loop (although note that this will
         * // return enumerable properties not found directly upon that object but also along the prototype chain for the object).
         *
         * @alias Object.getOwnPropertyNames
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.getOwnPropertyNames = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.getOwnPropertyNames called on a non-object:' + object);
            }

            return Object.keys(object);
        };
    }

    if (!Object.create) {
        /**
         * Creates a new object with the specified prototype object and properties.
         *
         * @see ES55 15.2.3.5.
         *
         * @method
         * @param {Object} prototype - The object which should be the prototype of the newly-created object
         * @param {Object} properties - If specified and not undefined, an object whose enumerable own properties
         * (that is, those properties defined upon itself and not enumerable properties along its prototype chain)
         * specify property descriptors to be added to the newly-created object, with the corresponding property names.
         * @return {Object} The new object instance with the specified prototype object and properties.
         * @throws Throws a TypeError exception if the proto parameter isn't null or an object.
         *
         * @example
         * //Shape - superclass
         * function Shape() {
         *    this.x = 0;
         *    this.y = 0;
         * }
         *
         * Shape.prototype.move = function(x, y) {
         *    this.x += x;
         *    this.y += y;
         *    console.info("Shape moved.");
         * };
         *
         * // Rectangle - subclass
         * function Rectangle() {
         *    Shape.call(this); //call super constructor.
         * }
         *
         * Rectangle.prototype = Object.create(Shape.prototype);
         *
         * var rect = new Rectangle();
         *
         * rect instanceof Rectangle // true
         * rect.move(); //Outputs, "Shape moved."
         *
         * @alias Object.create
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.create = function (prototype, properties) {

            var object,
                Type = function () {};

            if (prototype === null) {

                object = {
                    '__proto__': null
                };

            } else {

                Type.prototype = prototype;
                object = new Type();

                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                object[prototypeKey] = prototype;
            }

            if (properties !== undefined) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

    (function () {

        // Patch for WebKit and IE8 standard mode
        // Designed by hax <hax.github.com>
        // related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
        // IE8 Reference:
        //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
        //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
        // WebKit Bugs:
        //     https://bugs.webkit.org/show_bug.cgi?id=36423

        function doesDefinePropertyWork(object) {
            try {
                Object.defineProperty(object, "sentinel", {});
                return object.hasOwnProperty('sentinel');
            } catch (exception) {
                // returns falsy
            }
        }

        // check whether defineProperty works if it's given. Otherwise,
        // shim partially.
        var nativeDefineProperty = Object.defineProperty,
            definePropertyWorksOnObject = nativeDefineProperty && doesDefinePropertyWork({}),
            definePropertyWorksOnDom = (nativeDefineProperty && global.document === undefined) || doesDefinePropertyWork(global.document.createElement("div")),
            definePropertyFallback = (nativeDefineProperty && !definePropertyWorksOnObject) || (!definePropertyWorksOnDom && Object.defineProperty);

        if (!nativeDefineProperty || definePropertyFallback) {

            /**
             * Defines a new property directly on an object, or modifies an
             * existing property on an object, and returns the object.
             *
             * @see ES55 15.2.3.6.
             *
             * @method
             * @param {Object} object - The object on which to define the property
             * @param {Object} property - The name of the property to be defined or modified
             * @param {Object} descriptor - The descriptor for the property being defined or modified
             * @return {Object} The modified Object.
             *
             * @alias Object.defineProperty
             * @memberOf module:UWA/Internal/Polyfill/NativeObjects
             */
            Object.defineProperty = function defineProperty(object, property, descriptor) {

                var prototype;

                if (!isObject(object)) {
                    throw new TypeError("Object.defineProperty called on non-object: " + object);
                }

                if (!isObject(descriptor)) {
                    throw new TypeError("Property description must be an object: " + descriptor);
                }

                // make a valiant attempt to use the real defineProperty
                // for I8's DOM elements.
                if (definePropertyFallback) {
                    try {
                        return definePropertyFallback.call(Object, object, property, descriptor);
                    } catch (exception) {
                        // try the shim if the real one doesn't work
                    }
                }

                // If it's a data property.
                if (hasOwn(descriptor, "value")) {
                    // fail silently if "writable", "enumerable", or "configurable"
                    // are requested but not supported
                    /*
                    // alternate approach:
                    if ( // can't implement these features; allow false but not true
                        !(hasOwn(descriptor, "writable") ? descriptor.writable : true) ||
                        !(hasOwn(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                        !(hasOwn(descriptor, "configurable") ? descriptor.configurable : true)
                    )
                        throw new RangeError(
                            "This implementation of Object.defineProperty does not " +
                            "support configurable, enumerable, or writable."
                        );
                    */

                    if (
                        supportsAccessors &&
                            (lookupGetter(object, property) || lookupSetter(object, property))
                    ) {
                        // As accessors are supported only on engines implementing
                        // `__proto__` we can safely override `__proto__` while defining
                        // a property to make sure that we don't hit an inherited
                        // accessor.
                        prototype = object[prototypeKey];
                        object[prototypeKey] = prototypeOfObject;
                        // Deleting a property anyway since getter / setter may be
                        // defined on object itself.
                        delete object[property];
                        object[property] = descriptor.value;
                        // Setting original `__proto__` back now.
                        object[prototypeKey] = prototype;
                    } else {
                        object[property] = descriptor.value;
                    }

                } else {

                    if (!supportsAccessors) {
                        throw new TypeError("getters & setters can not be defined on this javascript engine");
                    }

                    // If we got that far then getters and setters can be defined !!
                    if (hasOwn(descriptor, "get")) {
                        defineGetter(object, property, descriptor.get);
                    }

                    if (hasOwn(descriptor, "set")) {
                        defineSetter(object, property, descriptor.set);
                    }
                }

                return object;
            };
        }

    }());

    if (!Object.defineProperties) {

        /**
         * Defines new or modifies existing properties directly on an object, returning the object.
         *
         * @see ES55 15.2.3.7.
         *
         * Object.defineProperties, in essence, defines all properties
         * corresponding to the enumerable own properties of props on the
         * object objrops object.
         *
         * @method
         * @param {Object} object - The object on which to define or modify properties
         * @param {Object} properties - An object whose own enumerable properties constitute descriptors for the properties to be defined or modified
         * @return {Object} The modified Object.
         *
         * @example
         * Object.defineProperties(obj, {
         *    "property1": {
         *    value: `true`,
         *    writable: `true`
         *  },
         *    "property2": {
         *    value: "Hello",
         *    writable: `false`
         *  }
         *  // etc. etc.
         * });
         *
         * @alias Object.defineProperties
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.defineProperties = function (object, properties) {

            if (!isObject(object)) {
                throw new TypeError('Object.defineProperties called on a non-object');
            }

            var property;

            // The body of a for in is wrapped in an if statement to
            // filter unwanted properties from the prototype using hasOwn.
            /*jslint forin: true*/
            for (property in properties) {
                if (hasOwn(properties, property)) {
                    Object.defineProperty(object, property, properties[property]);
                }
            }
            /*jslint forin: false*/

            return object;
        };
    }

    if (!Object.seal) {
        /**
         * Seals an object, preventing new properties from being added to it
         * and marking all existing properties as non-configurable. Values of
         * present properties can still be changed as long as they are
         * writable.
         *
         * By default, objects are extensible (new properties can be added to them).
         * Sealing an object prevents new properties from being added and marks all
         * existing properties as non-configurable. This has the effect of making
         * the set of properties on the object fixed and immutable.
         *
         * Making all properties non-configurable also prevents them from being
         * converted from data properties to accessor properties and vice versa,
         * but it does not prevent the values of data properties from being
         * changed.
         *
         * Attempting to delete or add properties to a sealed object, or to
         * convert a data property to accessor or vice versa, will fail, either
         * silently or by throwing a TypeError (most commonly, although not
         * exclusively, when in strict mode code).
         *
         * @see ES55 15.2.3.8.
         *
         * @method
         * @param {Object} object - The object which should be sealed
         * @return {Object} The object which should be sealed.
         *
         * @alias Object.seal
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.seal = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.seal called on a non-object');
            }

            // this is misleading and breaks feature-detection, but
            // allows 'securable' code to 'gracefully' degrade to working
            // but insecure code.
            return object;
        };
    }

    if (!Object.freeze) {
        /**
         * Freezes an object: that is, prevents new properties from being added
         * to it; prevents existing properties from being removed; and prevents
         * existing properties, or their enumerability, configurability, or
         * writability, from being changed. In essence the object is made
         * effectively immutable. The method returns the object being frozen.
         *
         * Nothing can be added to or removed from the properties set of a
         * frozen object. Any attempt to do so will fail, either silently or
         * by throwing a TypeError exception (most commonly, but not
         * exclusively, when in strict mode).
         *
         * Values cannot be changed for data properties. Accessor properties
         * (getters and setters) work the same (and still give the illusion
         * that you are changing the value). Note that values that are objects
         * can still be modified, unless they are also frozen.
         *
         * @see ES55 15.2.3.9.
         *
         * @method
         * @param {Object} object - The object which should be frozen
         * @return {Object} The object which should be frozen.
         *
         * @alias Object.freeze
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.freeze = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.freeze called on a non-object');
            }

            // this is misleading and breaks feature-detection, but
            // allows 'securable' code to 'gracefully' degrade to working
            // but insecure code.
            return object;
        };
    }

    if (!Object.preventExtensions) {
        /**
         * Prevents new properties from ever being added to an object (i.e.
         * prevents future extensions to the object).
         *
         * @see ES55 15.2.3.10.
         *
         * @method
         * @param {Object} object - The object which should be made non-extensible
         * @return {Object} The object which should be made non-extensible.
         *
         * @alias Object.preventExtensions
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.preventExtensions = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.preventExtensions called on a non-object');
            }

            // this is misleading and breaks feature-detection, but
            // allows 'securable' code to 'gracefully' degrade to working
            // but insecure code.
            return object;
        };
    }

    if (!Object.isSealed) {
        /**
         * Determine if an object is sealed.
         *
         * @see ES55 15.2.3.11.
         *
         * @method
         * @param {Object} object - The object which should be checked
         * @return {Boolean} Returns `true` if the object is sealed, otherwise `false`.
         *  An object is sealed if it is non-extensible and if all its
         *  properties are non-configurable and therefore not removable
         *  (but not necessarily non-writable).
         *
         * @alias Object.preventExtensions
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.isSealed = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.isSealed called on a non-object');
            }

            return false;
        };
    }

    if (!Object.isFrozen) {
        /**
         * Determine if an object is frozen.
         *
         * @see ES55 15.2.3.12.
         *
         * @method
         * @param {Object} object - The object which should be checked
         * @return {Boolean} `true` if frozen else `false`.
         *
         * @alias Object.isFrozen
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.isFrozen = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.isFrozen called on a non-object');
            }

            return false;
        };
    }

    if (!Object.isExtensible) {
        /**
         * Determines if an object is extensible (whether it can have new
         * properties added to it).
         *
         * @see ES55 15.2.3.13.
         *
         * @method
         * @param {Object} object - The object which should be checked
         * @return {Boolean} `true` if extensible else `false`.
         *
         * @alias Object.isExtensible
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.isExtensible = function (object) {

            var returnValue,
                name;

            // 1. If Type(O) is not Object throw a TypeError exception.
            if (!isObject(object)) {
                return false;
            }

            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            name = '';
            while (hasOwn(object, name)) {
                name += '?';
            }

            object[name] = true;
            returnValue = hasOwn(object, name);
            delete object[name];

            return returnValue;
        };
    } else {
        try {
            Object.isExtensible(42);
        } catch (e) {
            var previous = Object.isExtensible;
            Object.isExtensible = function (o) {
                try {
                    return previous(o);
                } catch (ee) {
                    return false;
                }
            };
        }
    }

    if (!Object.keys) {
        /**
         * Returns an array of all own enumerable properties found upon a given
         * object, in the same order as that provided by a for-in loop (the
         * difference being that a for-in loop enumerates properties in the
         * prototype chain as well).
         *
         * > See 15.2.3.14.
         *
         * @method
         * @param {Object} object - The object whose enumerable own properties are to be returned.
         * @return {Array} array of all own enumerable properties found upon a given object.
         *
         * @example
         * Object.keys({name: 'john', lastname: 'doe'});
         * // will return ['name', 'lastname']
         *
         * @alias Object.keys
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Object.keys = function (object) {

            if (!isObject(object)) {
                throw new TypeError('Object.keys called on a non-object');
            }

            // TODO Make dontEnums check once only pls

            var i, l, name, dontEnum,
                keys = [],
                hasDontEnumBug = !hasOwn({'toString': null}, 'toString'),
                dontEnums = [
                    'toString',
                    'toLocaleString',
                    'valueOf',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'constructor'
                ],
                dontEnumsLength = dontEnums.length;

            // The body of a for in is wrapped in an if statement to
            // filter unwanted properties from the prototype using hasOwn.
            /*jslint forin: true*/
            for (name in object) {
                if (hasOwn(object, name)) {
                    keys.push(name);
                }
            }
            /*jslint forin: false*/

            if (hasDontEnumBug) {
                for (i = 0, l = dontEnumsLength; i < l; i++) {
                    dontEnum = dontEnums[i];
                    if (hasOwn(object, dontEnum)) {
                        keys.push(dontEnum);
                    }
                }
            }

            return keys;
        };
    }

    // }}}

    // {{{ Date polyfills

    /**
     * Retrieve the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
     *
     * @see ES5 15.9.4.4.
     *
     * @method
     * @return {Number} Number of milliseconds since midnight of January 1, 1970.
     *
     * @example
     * var msecs = Date.now();
     * // msecs value is now number of milliseconds from 1970
     *
     * @alias Date.now
     * @memberOf module:UWA/Internal/Polyfill/NativeObjects
     */
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    /**
     * Parses a string representation of a date and time and returns the internal millisecond representation of that date.
     *
     * @see ES5 15.9.4.2.
     *
     * @method
     * @param {String} datestring - A string representing a date
     * @return {Number} Number of milliseconds since midnight of January 1, 1970.
     *
     * @example
     * var msecs = Date.parse("Jul 8, 2008");
     * // msecs value is now number of milliseconds from 1970
     *
     * @see Based on work shared by Daniel Friesen (dantman) - {@link http://gist.github.com/303249}
     * @see Based on work shared by {@link https://github.com/csnover/js-iso8601}
     *
     * @alias Date.parse
     * @memberOf module:UWA/Internal/Polyfill/NativeObjects
     */
    Date = (function (NativeDate) {

        var key,
            months = [
                0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
            ],

            // 15.9.1.15 Date Time String Format.
            isoDateExpression = new RegExp("^" +
                "(\\d{4}|[-+]\\d{6})" + // four-digit year capture or sign +
                                          // 6-digit extended year
                "(?:-(\\d{2})" + // optional month capture
                "(?:-(\\d{2})" + // optional day capture
                "(?:" + // capture hours:minutes:seconds.milliseconds
                    "T(\\d{2})" + // hours capture
                    ":(\\d{2})" + // minutes capture
                    "(?:" + // optional :seconds.milliseconds
                        ":(\\d{2})" + // seconds capture
                        "(?:(\\.\\d{1,}))?" + // milliseconds capture
                    ")?" +
                "(" + // capture UTC offset component
                    "Z|" + // UTC capture
                    "(?:" + // offset specifier +/-hours:minutes
                        "([-+])" + // sign capture
                        "(\\d{2})" + // hours offset capture
                        ":(\\d{2})" + // minutes offset capture
                    ")" +
                ")?)?)?)?" +
                "$");

        function dayFromMonth(year, month) {
            var t = month > 1 ? 1 : 0;
            return (
                months[month] +
                Math.floor((year - 1969 + t) / 4) -
                Math.floor((year - 1901 + t) / 100) +
                Math.floor((year - 1601 + t) / 400) +
                365 * (year - 1970)
            );
        }

        // Date.length === 7
        function Date(Y, M, D, h, m, s, ms) {

            var date,
                length = arguments.length;

            if (this instanceof NativeDate) {

                // We explicitly pass it through parse:
                if (length === 1 && String(Y) === Y) {
                    date = new NativeDate(Date.parse(Y));

                // We have to manually make calls depending on argument
                // length here
                } else if (length >= 7) {
                    date = new NativeDate(Y, M, D, h, m, s, ms);
                } else if (length >= 6) {
                    date = new NativeDate(Y, M, D, h, m, s);
                } else if (length >= 5) {
                    date = new NativeDate(Y, M, D, h, m);
                } else if (length >= 4) {
                    date = new NativeDate(Y, M, D, h);
                } else if (length >= 3) {
                    date = new NativeDate(Y, M, D);
                } else if (length >= 2) {
                    date = new NativeDate(Y, M);
                } else if (length >= 1) {
                    date = new NativeDate(Y);
                } else {
                    date = new NativeDate();
                }

                // Prevent mixups with unfixed Date object
                date.constructor = Date;

                return date;
            }

            return NativeDate.apply(this, arguments);
        }

        // Copy any custom methods a 3rd party library may have added
        for (key in NativeDate) {
            Date[key] = NativeDate[key];
        }

        // Copy "native" methods explicitly; they may be non-enumerable
        Date.now = NativeDate.now;
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = function parse(string) {

            var year, month, day, hour, minute, second, millisecond, offset,
                signOffset, hourOffset, minuteOffset, result,
                match = isoDateExpression.exec(string);

            if (match) {

                // parse months, days, hours, minutes, seconds, and milliseconds
                // provide default values if necessary
                // parse the UTC offset component
                year = Number(match[1]);
                month = Number(match[2] || 1) - 1;
                day = Number(match[3] || 1) - 1;
                hour = Number(match[4] || 0);
                minute = Number(match[5] || 0);
                second = Number(match[6] || 0);
                millisecond = Math.floor(Number(match[7] || 0) * 1000);

                // When time zone is missed, local offset should be used
                // (ES 5.1 bug)
                // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                offset = !match[4] || match[8] ? 0 : Number(new NativeDate(1970, 0));
                signOffset = match[9] === "-" ? 1 : -1;
                hourOffset = Number(match[10] || 0);
                minuteOffset = Number(match[11] || 0);

                if (
                    hour < (minute > 0 || second > 0 || millisecond > 0 ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                            month > -1 && month < 12 && hourOffset < 24 &&
                                minuteOffset < 60 && // detect invalid offsets
                                    day > -1 && day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                ) {
                    result = (
                        (dayFromMonth(year, month) + day) * 24 +
                        hour +
                        hourOffset * signOffset
                    ) * 60;

                    result = (
                        (result + minute + minuteOffset * signOffset) * 60 +
                        second
                    ) * 1000 + millisecond + offset;

                    if (-8.64e15 <= result && result <= 8.64e15) {
                        return result;
                    }
                }

                return NaN;
            }

            return NativeDate.parse.apply(this, arguments);
        };

        return Date;

    }(Date));


    // Detect invalid date parsing
    try {
        if ((new Date(-62198755200000).toISOString().indexOf('-000001') === -1)) {
            delete Date.prototype.toISOString;
        }
    } catch (invalidDate) {
        // ignore error
    }

    if (!Date.prototype.toISOString) {

        /**
         * It converts a date to a string following the ISO 8601 Extended Format.
         * The format is as follows: "YYYY-MM-DDTHH:mm:ss.sssZ".
         *
         * @see ES5 15.9.5.43.
         *
         * @method
         * @return {String} Date as following string format: "YYYY-MM-DDTHH:mm:ss.sssZ".
         *
         * @example
         * var isoDate = new Date("Jul 8, 2008").toISOString();
         * // isoDate value is now "2008-07-07T22:00:00.000Z"
         *
         * @alias Date.prototype.toISOString
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Date.prototype.toISOString = function toISOString() {

            var result, length, value, year,
                that = this;

            if (!isFinite(that)) {
                throw new RangeError("Date.prototype.toISOString called on non-finite value.");
            }

            // the date time string format is specified in 15.9.1.15.
            result = [that.getUTCMonth() + 1, that.getUTCDate(),
                that.getUTCHours(), that.getUTCMinutes(), that.getUTCSeconds()];
            year = that.getUTCFullYear();
            year = (year < 0 ? '-' : (year > 9999 ? '+' : '')) + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);

            length = result.length;
            while (length--) {
                value = result[length];
                // pad months, days, hours, minutes, and seconds to have two digits.
                if (value < 10) {
                    result[length] = '0' + value;
                }
            }
            // pad milliseconds to have three digits.
            return year + '-' + result.slice(0, 2).join('-') + 'T' + result.slice(2).join(':') + '.' +
                ('000' + that.getUTCMilliseconds()).slice(-3) + 'Z';
        };
    }

    var invalidDatesCanBeSerialized = true;

    try {
        new Date(NaN).toJSON();
    } catch (e) {
        invalidDatesCanBeSerialized = false;
    }

    if (!Date.prototype.toJSON || !invalidDatesCanBeSerialized) {

        /**
         * It converts a date to a string following the ISO 8601 Extended Format.
         * The format is as follows: "YYYY-MM-DDTHH:mm:ss.sssZ".
         *
         * @see ES5 15.9.5.44.
         *
         * @method
         * @return {String} Date as following string format: "YYYY-MM-DDTHH:mm:ss.sssZ".
         *
         * @example
         * var jsonDate = new Date("Jul 8, 2008").toJSON();
         * // jsonDate value is now "2008-07-07T22:00:00.000Z"
         *
         * @alias Date.prototype.toJSON
         * @memberOf module:UWA/Internal/Polyfill/NativeObjects
         */
        Date.prototype.toJSON = function toJSON(/* key */) {

            var that = this;

            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ToPrimitive(O, hint Number).
            // 3. If tv is a Number and is not finite, return null.
            // XXX
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (typeof that.toISOString !== 'function') {
                throw new TypeError('toISOString property is not callable');
            }

            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            try {
                return that.toISOString();
            } catch (e) {
                return null;
            }

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // }}}

});

// vim: fdm=marker

/*
Copyright 2006-2015 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define*/

define('UWA/Internal/Immediate', function () {
    'use strict';

    var global = new Function('return this')(); // eslint-disable-line no-new-func

    var Module;

    if (global.setImmediate && global.clearImmediate) {
        Module = {
            set: global.setImmediate.bind(global),
            clear: global.clearImmediate.bind(global)
        };
    } else if (global.addEventListener && global.postMessage) {
        Module = (function () {
            var messageTypeIdentifier = 'uwa-setImmediate',
                pendingCallbacks = {},
                nextImmediateId = 0;

            global.addEventListener('message', function (event) {
                var eventData;

                try {
                    eventData = (typeof event.data === "string") && event.data[0] === '{' && JSON.parse(event.data);
                } catch (e) { /* invalid json */ }

                if (eventData && eventData.type === messageTypeIdentifier && event.source === global) {
                    event.stopPropagation();
                    if (pendingCallbacks[eventData.id]) {
                        pendingCallbacks[eventData.id]();
                        delete pendingCallbacks[eventData.id];
                    }
                }
            }, true);

            return {
                set: function (callback) {
                    var immediateId = nextImmediateId++;

                    pendingCallbacks[immediateId] = callback;
                    global.postMessage(JSON.stringify({
                        type: messageTypeIdentifier,
                        id: immediateId
                    }), '*');

                    return immediateId;
                },
                clear: function (immediateId) {
                    delete pendingCallbacks[immediateId];
                }
            };
        }());
    } else {
        Module = {
            set: function (callback) { return global.setTimeout(callback, 0); },
            clear: global.clearTimeout
        };
    }

    return Module;
});

/*
Copyright 2006-2015 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define*/

define('UWA/Internal/Polyfill/Promise', [
    'UWA/Internal/Immediate'
], function (Immediate) {
    'use strict';

    var global = new Function('return this')(); // eslint-disable-line no-new-func
    var Promise;

    if (typeof global.Promise === 'function') {
        return;
    }

    // https://github.com/domenic/promises-unwrapping
    // https://github.com/Zolmeister/promiz/blob/master/promiz.js
    // https://github.com/jakearchibald/ES6-Promises
    // http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/
    // http://www.html5rocks.com/en/tutorials/es6/promises/
    // http://www.promisejs.org/intro/
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

    function typeIsObject(x) {
        // this is expensive when it returns false; use this function
        // when you expect it to return true in the common case.
        return x !== null && x !== undefined && Object(x) === x;
    }

    function isCallable(x) {
        return typeof x === 'function' &&
            // some versions of IE say that typeof /abc/ === 'function'
            Object.prototype.toString.call(x) === '[object Function]';
    }

    function isPromise(promise) {
        return promise instanceof Promise;
    }

    function toArray(list) {
        if (Array.isArray(list)) {
            return list;
        }

        if (typeof list.length !== 'number') {
            throw new TypeError('bad iterable');
        }

        return Array.prototype.slice.call(list);
    }

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    function PromiseCapability(constructor) {

        if (!constructor) {
            constructor = Promise;
        } else if (!isCallable(constructor)) {
            throw new TypeError('bad promise constructor');
        }

        var cr,
            capability = this,
            resolver = function (resolve, reject) {
                capability.resolve = resolve;
                capability.reject = reject;
            };

        capability.promise = Object.create(constructor.prototype || null);

        cr = constructor.call(capability.promise, resolver);

        if (!(
            isCallable(capability.resolve) &&
                isCallable(capability.reject)
        )) {
            throw new TypeError('bad promise constructor');
        }

        if (typeIsObject(cr) && cr !== capability.promise) {
            throw new TypeError('bad promise constructor');
        }
    }

    function updatePromiseFromPotentialThenable(x, capability) {

        if (!typeIsObject(x)) {
            return false;
        }

        try {

            // only one invocation of accessor
            var then = x.then;

            if (!isCallable(then)) {
                return false;
            }

            then.call(
                x,
                capability.resolve,
                capability.reject
            );

        } catch (e) {
            capability.reject(e);
        }

        return true;
    }

    function promiseResolutionHandler(promise, onFulfilled, onRejected) {

        return function (x) {

            if (x === promise) {
                return onRejected(new TypeError('self resolution'));
            }

            var capability = new PromiseCapability(),
                updateResult = updatePromiseFromPotentialThenable(x, capability);

            if (updateResult) {
                return capability.promise.then(onFulfilled, onRejected);
            } else {
                return onFulfilled(x);
            }
        };
    }

    function _promiseAllResolver(index, values, capability, remaining) {

        var done = false;

        return function (x) {

            // protect against being called multiple times
            if (done) {
                return;
            }

            done = true;
            values[index] = x;

            if ((--remaining.count) === 0) {
                var resolve = capability.resolve;
                resolve(values); // call w/ this===undefined
            }
        };
    }

    function runResolveReaction(x, reaction) {

        // PromiseReactionTask
        var result, updateResult,
            handler = reaction.handler,
            capability = reaction.capability,
            resolve = capability.resolve,
            reject = capability.reject;

        try {

            result = handler(x);

            if (result === capability.promise) {
                throw new TypeError('self resolution');
            }

            updateResult = updatePromiseFromPotentialThenable(result, capability);

            if (!updateResult) {
                resolve(result);
            }

        } catch (e) {
            reject(e);
        }
    }

    function triggerPromiseReactions(reactions, x) {
        reactions.forEach(function (reaction) {
            Immediate.set(runResolveReaction.bind(null, x, reaction));
        });
    }

    function updateStatus(promise, reactions, status) {

        Immediate.clear(promise._updateStatus);

        promise._status = status;
        promise._updateStatus = Immediate.set(function () {

            promise._resolveReactions = undefined;
            promise._rejectReactions = undefined;

            triggerPromiseReactions(reactions, promise._result);
        });
    }

    Promise = global.Promise = function (resolver) {
        var resolve, reject, reactions,
            promise = this;

        if (!promise || typeof promise !== 'object') {
            throw new TypeError('bad promise');
        }

        if (promise._status !== undefined) {
            throw new TypeError('promise already initialized');
        }

        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
        if (!isCallable(resolver)) {
            throw new TypeError('not a valid resolver');
        }

        promise._status = 'unresolved';
        promise._resolveReactions = [];
        promise._rejectReactions = [];

        resolve = function (resolution) {
            if (promise._status === 'unresolved') {
                reactions = promise._resolveReactions;
                promise._result = resolution;

                updateStatus(promise, reactions, 'has-resolution');
            }
        };

        reject = function (reason) {
            if (promise._status === 'unresolved') {
                reactions = promise._rejectReactions;
                promise._result = reason;

                updateStatus(promise, reactions, 'has-rejection');
            }
        };

        // TODO use UWA.Utils.atemps ?
        try {
            resolver(resolve, reject);
        } catch (e) {
            reject(e);
        }

        return promise;
    };

    Promise.prototype = {

        constructor: Promise,

        'catch': function (onRejected) {
            return this.then(undefined, onRejected);
        },

        then: function (onFullfilled, onRejected) {

            var capability,
                resolutionHandler, resolveReaction, rejectReaction,
                promise = this;

            if (!isPromise(promise)) {
                throw new TypeError('not a promise');
            }

            // https://bugs.ecmascript.org/show_bug.cgi?id=2513
            capability = new PromiseCapability();

            if (!isCallable(onRejected)) {
                onRejected = function (e) {
                    throw e;
                };
            }

            if (!isCallable(onFullfilled)) {
                onFullfilled = function (x) {
                    return x;
                };
            }

            resolutionHandler = promiseResolutionHandler(promise, onFullfilled, onRejected);
            resolveReaction = {
                capability: capability,
                handler: resolutionHandler
            };
            rejectReaction = {
                capability: capability,
                handler: onRejected
            };

            switch (promise._status) {
            case 'unresolved':
                promise._resolveReactions.push(resolveReaction);
                promise._rejectReactions.push(rejectReaction);
                break;

            case 'has-resolution':
                triggerPromiseReactions([resolveReaction], promise._result);
                break;

            case 'has-rejection':
                triggerPromiseReactions([rejectReaction], promise._result);
                break;

            default:
                throw new TypeError('unexpected');
            }

            return capability.promise;
        }
    };

    function getIterator(object) {
        return toArray(object).map(function (value) {
            return value instanceof Promise ? value : Promise.resolve(value);
        });
    }

    Promise.all = function (iterable) {

        var capability = new PromiseCapability(),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [],
            remaining = {
                count: 1
            };

        try {

            getIterator(iterable).forEach(function (next, index) {

                var nextPromise, resolveElement,
                    result = next._result,
                    status = next._status;

                if (status === "has-resolution") {
                    nextPromise = Promise.resolve(result);
                } else if (status === 'has-rejection') {
                    nextPromise = Promise.reject(result);
                } else {
                    nextPromise = next;
                }

                if (nextPromise) {

                    resolveElement = _promiseAllResolver(
                        index, values, capability, remaining
                    );

                    remaining.count++;

                    nextPromise.then(resolveElement, capability.reject);
                }
            });

            if ((--remaining.count) === 0) {
                resolve(values); // call w/ this===undefined
            }

        } catch (e) {
            reject(e);
        }

        return capability.promise;
    };

    Promise.race = function (iterable) {

        var lastStatus,
            capability = new PromiseCapability(),
            resolve = capability.resolve,
            reject = capability.reject;

        try {

            getIterator(iterable).forEach(function (next) {

                var nextPromise,
                    result = next._result,
                    status = next._status;

                if (
                    status === 'has-resolution' &&
                        lastStatus !== 'has-rejection'
                ) {

                    nextPromise = resolve(result);

                } else if (
                    status === 'has-rejection' &&
                        lastStatus !== 'has-resolution' &&
                            lastStatus !== 'has-rejection'
                ) {

                    nextPromise = reject(result);

                } else {

                    nextPromise = next;
                }

                lastStatus = status;

                if (nextPromise) {
                    nextPromise.then(resolve, reject);
                }
            });

        } catch (e) {
            reject(e);
        }

        return capability.promise;
    };

    Promise.reject = function (reason) {

        var capability = new PromiseCapability(),
            reject = capability.reject;

        reject(reason); // call with this===undefined

        return capability.promise;
    };

    Promise.resolve = function (value) {

        if (value instanceof Promise) {
            return value;
        }

        var capability = new PromiseCapability(),
            resolve = capability.resolve;

        resolve(value); // call with this===undefined

        return capability.promise;
    };

});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Universal Web App (UWA) JavaScript namespace root object that contains UWA mains functions.
 *
 * @module UWA/Core
 */
define('UWA/Core', [
    'UWA/Internal/Polyfill/NativeObjects',
    'UWA/Internal/Polyfill/Promise'
], function () {
    'use strict';

    var Core,

        // UWA Namespace
        coreNamespace = 'UWA',

        // Global alias (tested on: Browser, Web Worker, NodeJS)
        global = new Function('return this')(), // eslint-disable-line no-new-func

        // Object.prototype alias
        hasOwn = Object.prototype.hasOwnProperty,
        toString = Object.prototype.toString,

        // Map over UWA in case of overwrite
        _UWA = global[coreNamespace] || {};

    Core = {

        /**
         * Current UWA API Version (e.g "1.3.RC4").
         *
         * @type {String}
         * @alias UWA.version
         * @memberOf module:UWA/Core
         */
        version: '1.3.RC4',

        /**
         * UWA hosts urls indexed by name.
         *
         * @property {String} netvibes - Netvibes Dashboard url
         * @property {String} uwa - UWA resources url
         * @property {String} exposition - Exposition server url
         * @property {String} ecosystem - Ecosystem url
         *
         * @type {Object}
         * @alias UWA.hosts
         * @memberOf module:UWA/Core
         */
        hosts: (function () {

            var host,
                document = global.document,
                schema = (document && document.location && 'https:' === document.location.protocol ? 'https://' : 'http://'),
                newHosts = _UWA.hosts,
                hosts = {
                    netvibes: 'netvibes.com',
                    uwa: 'uwa.{netvibes}',
                    exposition: '{uwa}',
                    ecosystem: 'eco.{netvibes}'
                };

            function template(m, i) {
                return hosts[i].split('//')[1];
            }

            // The body of a for in is wrapped in an if statement to
            // filter unwanted properties from the prototype using hasOwn.
            for (host in hosts) {
                if (hasOwn.call(hosts, host)) {
                    if (newHosts && hasOwn.call(newHosts, host)) {
                        hosts[host] = newHosts[host];
                    } else {
                        hosts[host] = schema + hosts[host].replace(/\{(\w+)\}/g, template);
                    }
                }
            }

            return hosts;
        }()),

        /**
         * UWA internal paths indexed by name.
         *
         * @property {String} lib - Internal Library path  (e.g: "/lib/")
         * @property {String} js - Internal JavaScript files  (e.g: "/lib/UWA/js/")
         * @property {String} css - Internal Style Sheets and associaded assets (e.g: "/lib/c/UWA/assets/css/")
         * @property {String} img - Internal Images, Logo and Flash files (e.g: "/lib/c/UWA/assets/img/")
         *
         * @type {Object}
         * @alias UWA.paths
         * @memberOf module:UWA/Core
         */
        paths: (function () {
            var path,
                newPaths = _UWA.paths,
                paths = {
                    lib: '/lib/',
                    js: '/lib/UWA/js/',
                    css: '/lib/c/UWA/assets/css/',
                    img: '/lib/c/UWA/assets/img/'
                };

            for (path in paths) {
                if (hasOwn.call(paths, path) && newPaths && hasOwn.call(newPaths, path)) {
                    paths[path] = newPaths[path];
                }
            }
            return paths;
        }()),

        /**
         * Whether the framework is in debug mode or not.
         *
         * If `true`, UWA will log extra messages, deactivate some caches etc.
         * If `false`, UWA will add extra try / catches to prevent the application to break
         * due to external errors.
         *
         * @type {Boolean}
         * @alias UWA.debug
         * @memberOf module:UWA/Core
         */
        debug: Boolean(_UWA.debug),

        /**
         * Store value argument into root argument using namespace argument as property name.
         *
         * If the target namespace already exists, it will behave as told by the fourth
         * argument:
         *
         * * If it is omited, it will throw an exception
         * * If it is `"extend"`, it will extend the current namespace value with the
         * properties of the new value
         * * If it is `"replace"`, it will extend the new value with the current namespace
         * value properties, then replace the namespace value
         * * Deprecated: If it is `true`, it will behave like `"extend"` but will merge
         * properties recursively
         *
         * See {@link module:UWA/Core.UWA.extend|UWA.extend}
         *
         * @method
         * @param {Object} namespace - The namespace name
         * @param {Object} value - The namespace new value
         * @param {Object} root - The Object that will store the namespace (default: global)
         * @param {String|Boolean} [extend] - Existing namespace replacement (see method
         * description)
         *
         * @example
         * // Create a namespace
         * UWA.namespace('MyProject', {
         *    myString: 'MyProject',
         *    myValues: [],
         *    myMethod: function () {
         *
         *    }
         * });
         *
         * // Create a sub namespace
         * UWA.namespace('MyProject/Utils/Tests', {
         *    myString: 'MyProject/Utils/Tests'
         * });
         *
         * // Extend a sub namespace
         * UWA.namespace('MyProject/Utils', {
         *    myString: 'MyProject/Utils'
         * }, 'extend');
         *
         * @see {@link http://blogger.ziesemer.com/2007/10/respecting-javascript-global-namespace.html|Respecting the JavaScript global namespace}
         * @see {@link http://www.zachleat.com/web/yui-code-review-yahoonamespace/|YUI Code Review: YAHOO.namespace}
         * @see {@link http://www.yuiblog.com/blog/2007/06/12/module-pattern/|A JavaScript Module Pattern}
         * @see {@link https://developer.mozilla.org/en/XUL_School/JavaScript_Object_Management|JavaScript Object Management}
         *
         * @alias UWA.namespace
         * @memberOf module:UWA/Core
         */
        namespace: function (namespace, value, root, mode) { //eslint-disable-line no-shadow

            root = root || global;

            var i, l,
                namespaces = namespace.split('/');

            for (i = 0, l = namespaces.length; i < l; i++) {

                namespace = namespaces[i];
                var isDefined = Boolean(root[namespace]);

                // Last namespace par
                if (i === (l - 1)) {

                    if (isDefined) {

                        if (!mode) {
                            throw new Error('Duplicate NameSpace "' + namespaces.join('.') + '" into "' + root + '"');
                        } else if (mode === 'extend') {
                            value = Core.extend(root[namespace], value);
                        } else if (mode === 'replace') {
                            value = Core.extend(value, root[namespace]);
                        } else if (mode === true) {  // Recursive extend, this is deprecated
                            value = Core.extend(root[namespace], value, true);
                        } else {
                            throw new Error('Unknown mode ' + mode);
                        }
                    }

                    root[namespace] = value;

                } else if (!isDefined) {
                    root[namespace] = {};
                }

                root = root[namespace];
            }

            return value;
        },

        /**
         * Returns the global object, e.g. window in browsers.
         *
         * @method
         * @return {Object} The global object.
         *
         * @alias UWA.getGlobal
         * @memberOf module:UWA/Core
         */
        getGlobal: function () {
            return global;
        },

        /**
         * Copies all the properties from the second passed object to the first passed object.
         *
         * @method
         * @param {Object} original - The object to extends
         * @param {Object} extended - The object to copy
         * @param {Boolean} recursive - Extends the sub objects too
         *
         * @example
         * var a = {key1: 'value1a', key2: 'value2a'};
         * var b = {key2: 'value2b', key3: 'value3b'};
         *
         * UWA.extend(a, b);
         * // will return {key1: 'value1a', 'key2: 'value2b', key3: 'value3b'}
         *
         * @alias UWA.extend
         * @memberOf module:UWA/Core
         */
        extend: function (original, extended, recursive) {

            var key;
            extended = extended || {};

            // The body of a for in is wrapped in an if statement to
            // filter unwanted properties from the prototype using hasOwn.
            for (key in extended) {
                if (hasOwn.call(extended, key)) {
                    if (recursive && Core.is(extended[key], 'plain')) {
                        if (!Core.is(original[key], 'plain')) {
                            original[key] = {};
                        }
                        Core.extend(original[key], extended[key], recursive);
                    } else {
                        try {
                            original[key] = extended[key];
                        } catch (e) {
                            // Ignore possible IE error :
                            // TypeError: Object doesn't support this action
                        }
                    }
                }
            }

            return original;
        },

        /**
         * Copies all the properties from the second passed object to the first passed object if it not exists already.
         *
         * @method
         * @param {Object} original - The object to extends
         * @param {Object} extended - The object to copy
         *
         * @example
         * var a = {key1: 'value1a', key2: 'value2a', key3: null};
         * var b = {key2: 'value2b', key3: 'value3b', key4: 'value4b'};
         *
         * UWA.merge(a, b);
         * // will return {key1: 'value1a', 'key2: 'value2a', key3: 'value3b', key4: 'value4b'}
         *
         * @alias UWA.merge
         * @memberOf module:UWA/Core
         */
        merge: function (original, merged) {
            var property;

            // The body of a for in is wrapped in an if statement to
            // filter unwanted properties from the prototype using hasOwn.
            for (property in merged) {
                if (hasOwn.call(merged, property)) {
                    if (original[property] === undefined || original[property] === null) {
                        original[property] = merged[property];
                    }
                }
            }

            return original;
        },

        /**
         * Copies the properties from the object to remove references.
         *
         * @method
         * @param {Object} object - The object to copy
         * @!param {Boolean} [deep=true] - If set to `false`, a shallow clone is returned
         *  instead of a deep clone
         *
         * > Note:
         * > Element and others complex or native object may fail to clone.
         *
         * @example
         * var value = {};
         * var a = {key: value};
         * var b = UWA.clone(a);
         * var c = UWA.clone(a,`false`);
         *
         * a === b;
         * // will return `false`
         *
         * a.key === b.key;
         * // will return `false`
         *
         * a === c;
         * // will return `false`
         *
         * a.key === c.key;
         * // will return `true` (because c is a shallow clone of a)
         *
         * @alias UWA.clone
         * @memberOf module:UWA/Core
         */
        clone: function (object, deep) {

            var unlinked, i, l, _deep;

            // setting default value for deep.
            // 1) faster than the usage of UWA.is or UWA.typeOf
            // 2) we want UWA.clone signature to be similar to the
            // Node.cloneNode API (deep argument default to true.)
            if (deep !== true && deep !== false) {
                _deep = true;
            } else {
                _deep = deep;
            }

            switch (Core.typeOf(object)) {
            case 'array':
                if (_deep) {
                    unlinked = [];

                    for (i = 0, l = object.length; i < l; i++) {
                        unlinked[i] = Core.clone(object[i], true);
                    }
                } else {
                    unlinked = object.slice();
                }
                break;

            case 'object':
                if (_deep) {
                    unlinked = {};

                    // The body of a for in is wrapped in an if statement to
                    // filter unwanted properties from the prototype using hasOwn.
                    for (i in object) {
                        if (hasOwn.call(object, i)) {
                            unlinked[i] = Core.clone(object[i], true);
                        }
                    }
                } else {
                    unlinked = Core.extend({}, object);
                }
                break;

            case 'date':
                unlinked = new Date(object);
                break;

            case 'element':
                unlinked = object.cloneNode(_deep);
                break;

            default:
                unlinked = object;
            }

            return unlinked;
        },

        /**
         * Resolves the value of property key on object. If the value of key is
         * a function (that should be nullary) then it is invoked with the object
         * as context and its result is returned, otherwise the property value is returned.
         * If the object or the property value is undefined, the fallback default
         * value (if provided) is used in its place.
         * The fallback default value can be a nullary function. In this case, it
         * is invoked with the object as context and its result returned.
         *
         * @example
         * var object = {
         *     user: 'fred',
         *     age: function () { return 40; }
         * };
         *
         * UWA.result(object, 'user'); // returns 'fred'
         * UWA.result(object, 'age'); // returns 40
         * UWA.result(object, 'phone'); // returns undefined
         * UWA.result(null, 'address'); // returns undefined
         * UWA.result(object, 'status', 'busy'); // returns 'busy'
         * UWA.result(null, 'status', 'busy'); // returns 'busy'
         * UWA.result(object, 'status', function () {
         *     return 'fred' === this.user ? 'busy' : 'idle';
         * }); // returns 'busy'
         *
         * @param {Object} object - The object to query.
         * @param {string} property - The key of the property to resolve.
         * @param {Void} [fallback] - The value returned if the property value
         * resolves to undefined.
         * @returns {Void} Returns the resolved value.
         *
         * @alias UWA.result
         * @memberOf module:UWA/Core
         */
        result: function (object, property, fallback) {
            var value;
            if (Core.is(object)) {
                value = object[property];
            }
            if (value === undefined) {
                value = fallback;
            }
            return Core.is(value, 'function') ? value.call(object) : value;
        },

        /**
         * Returns the real type name of an object.
         *
         * - 'window'  (string) If object is a window.
         * - 'document'   (string) If object is a DOM document node.
         * - 'element'    (string) If object is a DOM element node.
         * - 'number'     (string) If object is a number.
         * - 'boolean'    (string) If object is a Boolean.
         * - 'arguments'  (string) If object is a Arguments.
         * - 'math'       (string) If object is a Math.
         * - 'error'      (string) If object is a Error.
         * - 'array'      (string) If object is an array.
         * - 'object'     (string) If object is an object.
         * - 'string'     (string) If object is a string.
         * - 'date'       (string) If object is a Date.
         * - 'boolean'    (string) If object is a boolean.
         * - 'function'   (string) If object is a function.
         * - 'regexp'     (string) If object is a regular expression.
         * - 'class'      (string) If object is a Class (created with new Class or the extend of another class).
         * - 'file'        (string) If object is a File
         * - 'nodelist'    (string) If object is a NodeList
         * - 'typedarray'  (string) If object is a TypedArray
         * - 'dataview'    (string) If object is a DataView
         * - 'false'      (boolean) If object is undefined, null, NaN or none of the above.
         *
         * @method
         * @param {Void} object - the object to inspect
         * @return {String} Object type name or `false` if is undefined, null or NaN.
         *
         * @example
         * // Detected types
         * UWA.typeOf(window);                                  // "window"
         * UWA.typeOf(document);                                // "document"
         * UWA.typeOf({a: 4});                                  // "object"
         * UWA.typeOf(new ReferenceError);                      // "error"
         * UWA.typeOf([1, 2, 3]);                               // "array"
         * UWA.typeOf(new Date);                                // "date"
         * UWA.typeOf(/a-z/);                                   // "regexp"
         * UWA.typeOf(new RegExp(/a-z/));                       // "regexp"
         * UWA.typeOf(new Number(4));                           // "number"
         * UWA.typeOf(new String("abc"));                       // "string"
         * UWA.typeOf("");                                      // "string"
         * UWA.typeOf(true);                                    // "boolean"
         * UWA.typeOf(false);                                   // "boolean"
         * UWA.typeOf(new Boolean(true));                       // "boolean"
         * UWA.typeOf(new Boolean(true));                       // "boolean"
         * UWA.typeOf((function () {}));                        // "function"
         * UWA.typeOf(new File(...));                           // "file"
         *
         * // Invalid types
         * UWA.typeOf();                                        // false
         * UWA.typeOf(window.myUndefined);                      // false
         * UWA.typeOf(null);                                    // false
         * UWA.typeOf("x" - 111);                               // false
         *
         * // Other types
         * UWA.typeOf(Math);                                    // "object"
         * UWA.typeOf(RegExp);                                  // "function"
         *
         * @alias UWA.typeOf
         * @memberOf module:UWA/Core
         */
        typeOf: (function () {

            var stringTypes = {
                Null: false,
                Undefined: false,
                Function: 'function',
                String: 'string',
                Array: 'array',
                Date: 'date',
                RegExp: 'regexp',
                Number: 'number',
                Boolean: 'boolean',
                Error: 'error',
                Arguments: 'arguments',
                Blob: 'blob',
                ArrayBuffer: 'arraybuffer',
                FormData: 'formdata',
                HTMLDocument: 'document',
                XMLDocument: 'document',
                Document: 'document',
                global: 'window',
                Window: 'window',
                DOMWindow: 'window',
                Math: 'object',
                MouseEvent: 'event',
                NodeList: 'nodelist',

                Int8Array: 'typedarray',
                Uint8Array: 'typedarray',
                Uint8ClampedArray: 'typedarray',
                Int16Array: 'typedarray',
                Uint16Array: 'typedarray',
                Int32Array: 'typedarray',
                Uint32Array: 'typedarray',
                Float32Array: 'typedarray',
                Float64Array: 'typedarray',

                DataView: 'dataview',
                File: 'file'
            };

            return function (object) {
                var stringType = {}.toString.call(object).slice(8, -1);

                // PhantomJS 1.9.7 fix
                if (object === undefined || object === null) {
                    return false;
                }

                if (stringType === 'Function' &&
                        typeof object.extend === 'function' &&
                        typeof object.singleton === 'function') {
                    return 'class';
                }

                if (stringType === 'Number' && isNaN(object)) {
                    return false;
                }

                // This special case is for IE8
                if (stringType === 'Object' && object && typeof object.nodeType === 'number') {
                    return 'element';
                }

                var fromStringType = stringTypes[stringType];
                if (fromStringType !== undefined) {
                    return fromStringType;
                }

                if (stringType.slice(-5) === 'Event') {
                    return 'event';
                }

                if (stringType.slice(-7) === 'Element') {
                    return 'element';
                }

                // MooTools event (deprecated usage)
                if (object.$extended && object.event) {
                    return 'event';
                }

                // IE11 fix
                if (stringType === 'Object' && global.DataView && object instanceof global.DataView) {
                    return 'dataview';
                }

                return 'object';
            };
        }()),

        /**
         * Check the type of an object or if is not an undefined, null or NaN,
         * and match the type parameter if provided.
         *
         * @method
         * @param {Void} object - The object to inspect
         * @param {String} type - The expected object type
         * @return {Boolean} Return `true` if is not an undefined, null or NaN,
         *    and match the type parameter if provided.
         *
         * @example
         * // Will return false
         * UWA.is(null);                           // false
         * UWA.is();                               // false
         * UWA.is(window.myUndefined);             // false
         *
         * // Will return true
         * UWA.is({});                             // true
         * UWA.is(function () {});                 // true
         * UWA.is(UWA);                            // true
         *
         * // Check type
         * UWA.is({}, 'object');                   // true
         * UWA.is("hello", 'string');              // true
         * UWA.is(1, 'number');                    // true
         * UWA.is(true, 'boolean');                // true
         * UWA.is(true, 'boolean');                // true
         * UWA.is(new Date, 'date');               // true
         *
         * UWA.is({}, 'plain');                    // true
         * UWA.is(Object.create({a: 1}), 'plain'); // false
         *
         * // Multiple check (better performance than multiple call to UWA.is)
         * UWA.is(window, ['window', 'document']); // true
         *
         * @see {@link module:UWA/Core.UWA.typeOf|UWA.typeOf} for type parameter matching.
         *
         * @alias UWA.is
         * @memberOf module:UWA/Core
         */
        is: (function () {

            var indexOf;

            // Simple indexOf alternative due possible IE<=8 missing
            // Array.prototype.indexOf that polyfilled into Array.js that is include
            // after this file, but that is not require by Embedded package for example.
            if (Array.prototype.indexOf) {

                indexOf = function (array, value) {
                    return Array.prototype.indexOf.call(array, value);
                };

            } else {

                indexOf = function (array, value) {

                    var i, l,
                        match = false;

                    for (i = 0, l = array.length; i < l; i++) {
                        if (array[i] === value) {
                            match = true;
                            break;
                        }
                    }

                    return match ? i : -1;
                };
            }

            function isPlainObject(obj) {
                // Inspired by jQuery.

                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || Core.typeOf(obj) !== "object") {
                    return false;
                }

                try {
                    // Not own constructor property must be Object
                    if (obj.constructor && !hasOwn.call(obj, "constructor") &&
                            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                } catch (e) {
                    // IE8,9 Will throw exceptions on certain host objects #9897
                    return false;
                }

                var key;
                for (key in obj) {
                    if (!hasOwn.call(obj, key)) {
                        return false;
                    }
                }

                return true;
            }

            return function (object, type) {

                var is, typeOf;

                // Simple not Number+NaN/Null/undefined does not require UWA.typeOf call (faster)
                if (type === undefined) {
                    is = typeof object === 'number' ? !isNaN(object) : object !== undefined && object !== null;

                // Advanced type checking
                } else {

                    // Conert mono type in multi type
                    type = Core.typeOf(type) === 'array' ? type : [type];

                    // Set default result
                    is = false;

                    // Check is finite
                    if (indexOf(type, 'finite') !== -1) {
                        is = isFinite(object);
                    }

                    if (!is && indexOf(type, 'plain') !== -1) {
                        is = isPlainObject(object);
                    }

                    if (!is) {
                        var index = indexOf(type, 'arraybufferview');
                        if (index >= 0) {
                            type = type.slice();
                            type.splice(index, 1, 'typedarray', 'dataview');
                        }
                    }

                    // Check other type
                    if (!is && (typeOf = Core.typeOf(object)) !== false) {
                        is = indexOf(type, typeOf) !== -1;
                    }
                }

                return is;
            };
        }()),

        /**
         * Perform a deep comparison to check if the two objects passed as arguments
         * are equal.
         *
         * Note that this method tests the equality of the two objects, it does
         * not test whether or not they are identical. To check the identity of
         * two objects, use <Object.is Object.is> or the === operator.
         *
         * @method
         * @param {Object} x - The first object
         * @param {Object} y - The second object
         * @return {Boolean} `true` if the two objects are equal, `false` otherwise.
         *
         * @example
         * var moe   = {name : 'moe', luckyNumbers : [13, 27, 34]};
         * var clone = {name : 'moe', luckyNumbers : [13, 27, 34]};
         * var anotherClone = UWA.clone(moe);
         *
         * moe === clone;
         * // returns false
         *
         * moe === anotherClone;
         * // returns false
         *
         * UWA.equals(moe, clone);
         * // returns true
         *
         * UWA.equals(moe, anotherClone);
         * // returns true
         *
         * @alias UWA.equals
         * @memberOf module:UWA/Core
         */
        equals: (function () {

            function equals(a, b, aStack, bStack) {

                var className, length, size, aCtor, bCtor, key, isEquals;

                // Identical objects are equal. `0 === -0`, but they aren't identical.
                // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
                if (a === b) {
                    isEquals = a !== 0 || 1 / a === 1 / b;

                // A strict comparison is necessary because `null == undefined`.
                } else if (a == null || b == null) { // eslint-disable-line eqeqeq
                    isEquals = a === b;

                // Others
                } else {

                    // Compare Types names.
                    className = toString.call(a);
                    if (className !== toString.call(b)) {
                        isEquals = false;

                    // Strings, numbers, dates, and booleans are compared by value.
                    // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                    // equivalent to `new String("5")`.
                    } else if (className === '[object String]') {

                        isEquals = String(a) === String(b);

                    // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                    // other numeric values.
                    } else if (className === '[object Number]') {

                        isEquals = a != Number(a) ? b != Number(b) : (a == 0 ? 1 / a == 1 / b : a == Number(b)); // eslint-disable-line eqeqeq

                    // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                    // millisecond representations. Note that invalid dates with millisecond representations
                    // of `NaN` are not equivalent.
                    } else if (
                        className === '[object Date]' ||
                            className === '[object Boolean]'
                    ) {
                        isEquals = Number(a) === Number(b);

                    // RegExps are compared by their source patterns and flags.
                    } else if (className === '[object RegExp]') {

                        isEquals = a.source === b.source &&
                            a.global === b.global &&
                            a.multiline === b.multiline &&
                            a.ignoreCase === b.ignoreCase;

                    } else if (typeof a !== 'object' || typeof b !== 'object') {
                        isEquals = false;

                    // Assume equality for cyclic structures. The algorithm for detecting cyclic
                    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
                    } else {

                        // Linear search. Performance is inversely proportional to the number of
                        // unique nested structures.
                        length = aStack.length;
                        while (length--) {
                            if (aStack[length] === a) {
                                isEquals = bStack[length] === b;
                            }
                        }

                        if (isEquals === undefined) {

                            // Add the first object to the stack of traversed objects.
                            aStack.push(a);
                            bStack.push(b);

                            // Recursively compare objects and arrays.
                            if (className === '[object Array]') {

                                // Compare array lengths to determine if a deep comparison is necessary.
                                size = a.length;
                                isEquals = size === b.length;
                                // Deep compare the contents, ignoring non-numeric properties.
                                while (isEquals && size > 0) {
                                    size--;
                                    isEquals = equals(a[size], b[size], aStack, bStack);
                                }

                             // Objects with different constructors are not equivalent, but `Object`s
                             // from different frames are.
                            } else {

                                aCtor = a.constructor;
                                bCtor = b.constructor;

                                if (
                                    aCtor !== bCtor && !(
                                        (toString.call(aCtor) === '[object Function]') && (aCtor instanceof aCtor) &&
                                            (toString.call(bCtor) === '[object Function]') && (bCtor instanceof bCtor)
                                    )
                                ) {
                                    isEquals = false;

                                } else {

                                    size = 0;
                                    isEquals = true;

                                    // Deep compare objects.
                                    for (key in a) {
                                        if (Core.owns(a, key)) {

                                            // Count the expected number of properties.
                                            size++;

                                            // Deep compare each member.
                                            isEquals = Core.owns(b, key) &&
                                                equals(a[key], b[key], aStack, bStack);

                                            if (!isEquals) {
                                                break;
                                            }
                                        }
                                    }

                                    // Ensure that both objects contain the same number of properties.
                                    if (isEquals) {
                                        for (key in b) {
                                            if (Core.owns(b, key) && !(size--)) {
                                                break;
                                            }
                                        }
                                        isEquals = !size;
                                    }
                                }
                            }

                            // Remove the first object from the stack of traversed objects.
                            aStack.pop();
                            bStack.pop();
                        }
                    }
                }

                return isEquals;
            }

            return function (x, y) {
                return equals(x, y, [], []);
            };
        }()),

        /**
         * Returns a boolean indicating whether the object has the specified property.
         *
         * @method
         * @param {Object} object - The object owner of the property to test
         * @param {String} property - The name of the property to test
         * @return {Boolean} Return `true` if the object has the specified property.
         *
         * @example
         * // Simple Examples
         * var myObject = {
         *    myProp: true,
         *    myUndefinedProp: undefined
         * };
         *
         * UWA.owns(myObject, 'myProp');           // true
         * UWA.owns(myObject, 'myUndefinedProp');  // true
         * UWA.owns(myObject, 'myMissingProp');    // false
         *
         * @alias UWA.owns
         * @memberOf module:UWA/Core
         */
        owns: function (object, property) {
            return Core.is(object) && hasOwn.call(object, property);
        },

        /**
         * Log a message to a console, if one available.
         *
         * @method
         * @param {String} message - The message to log
         *
         * @example
         * UWA.log("Widget is loading ...");
         *
         * @alias UWA.log
         * @memberOf module:UWA/Core
         */
        log: function (message, type) {

            if (!type) {
                type = 'log';
            }

            // Firebug, safari
            if (global.console) {
                global.console[type](message);

            // Opera alternative
            } else if (global.opera && global.opera.postError) {
                global.opera.postError(message);
            }
            //else if (global.widget) global.alert(message); // dashboard
            //else global.alert(message); // IE
        },

        /**
         * Translate a string from English to the current language.
         *
         * @method
         * @param {String|Object} message - The message String to translate or the
         *    object hash message/translation pair.
         * @param {String} lang - The current locale (default: "default")
         *
         * @return {String|Object} The translated string if argument is a string else
         *    the new object hash message/translation pair if argument is an object.
         *
         * @example <caption>Simple translation</caption>
         * // Create Alias to UWA.i18n
         * var i18n = UWA.i18n;
         *
         * i18n("Hello");
         * // Will return "Hello"
         *
         * // Add French translation for "Hello"
         * i18n({
         *    "Hello": 'Bonjour'
         * });
         *
         * i18n("Hello");
         * // Will return "Bonjour"
         *
         * @example <caption>Advanced translation</caption>
         * // Create Alias to UWA.i18n
         * var i18n = UWA.i18n;
         *
         * UWA.String.format(i18n("Hello {0} welcome on {1}.", 'John', 'UWA');
         * // Will return "Hello John welcome on UWA."
         *
         * // Add French translation for "Hello"
         * i18n({
         *    "Hello {0} welcome on {1}.": 'Bonjour {0} bienvenue sur {1}.'
         * });
         *
         * UWA.String.format(i18n("Hello {0} welcome on {1}.", 'John', 'UWA');
         * // Will return "Bonjour John bienvenue sur UWA."
         *
         * @alias UWA.i18n
         * @memberOf module:UWA/Core
         */
        i18n: (function () {

            var messages, value,
                locales = {};

            return function (message, lang) {

                lang = lang || (global.navigator ? global.navigator.language || global.navigator.systemLanguage : 'default');

                messages = locales[lang] = locales[lang] || {};

                if (typeof message === 'object') {
                    value = Core.extend(messages, message);
                } else {
                    value = messages[message] || message;
                }

                return value;
            };
        }())
    };

    // Configure require only if it's a function
    // TODO requirejs.config support?
    if (define.amd && define.amd.curl) {
        (global.require || global.curl)({
            apiName: 'require',
            paths: {
                UWA: Core.hosts.uwa + Core.paths.js,
                vendors: Core.hosts.uwa + Core.paths.lib + '/vendors'
            }
        });
    }

    // We allow namespace merge because UWA can allready
    // be define into window object.
    return Core.namespace(coreNamespace, Core, global, true);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout, window
*/

/**
 * Cross-Platform API for DOM Events manipulation.
 *
 * @module   UWA/Event
 *
 *
 * @see {@link http://www.w3.org/TR/DOM-Level-2-Events/events.html}
 * @see {@link http://www.w3.org/TR/DOM-Level-3-Events/}
 * @see {@link http://www.howtocreate.co.uk/tutorials/javascript/domevents}
 */
define('UWA/Event', ['UWA/Core'], function (UWA) {
    'use strict';

    /*
      Todo:
        - Implement defaultPrevented: http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-Event-defaultPrevented
    */
    var Event = {

        /**
         * Cross-Platform method to run a callback when DOM is ready.
         *
         * @see {@link http://dev.w3.org/html5/spec/the-end.html#the-end}
         * @see {@link http://javascript.nwbox.com/ContentLoaded/}
         *
         * @param {Function} callback - Callback triggered when DOM is ready
         * @param {Object} [context] - Callback context
         * @param {Window} [window] - window object
         *
         * @example
         * UWA.Event.onDomReady(function () {
         *     // Called when DOM is ready
         * });
         *
         * @alias UWA.Event.onDomReady
         * @memberOf module:UWA/Event
         */
        onDomReady: function (callback, context) {

            context = context || window;

            var done = false,
                top = true,
                document = window.document,
                documentRoot = document.documentElement,
                hasEventListener = !!(document.addEventListener),
                addEventListener = hasEventListener ? 'addEventListener' : 'attachEvent',
                removeEventListener = hasEventListener ? 'removeEventListener' : 'detachEvent',
                prefixEvent = hasEventListener ? '' : 'on';

            function init(event) {

                var type = event.type;

                if (
                    type !== 'readystatechange' &&
                        document.readyState === 'complete'
                ) {

                    (type === 'load' ? window : document)[removeEventListener](prefixEvent + type, init, false);

                    if (!done) {
                        done = true;
                        callback.call(context, type || event);
                    }
                }
            }

            function poll() {
                try {
                    documentRoot.doScroll('left');
                    init('poll');
                } catch (error) {
                    setTimeout(poll, 50);
                }
            }

            if (document.readyState === 'complete') {
                setTimeout(callback.bind(context, 'lazy'), 1);
            } else {

                if (
                    document.createEventObject &&
                        documentRoot.doScroll
                ) {

                    try {

                        top = !window.frameElement;
                    } catch (error) { }

                    if (top) {
                        poll();
                    }
                }

                document[addEventListener](prefixEvent + 'DOMContentLoaded', init, false);
                document[addEventListener](prefixEvent + 'readystatechange', init, false);
                window[addEventListener](prefixEvent + 'load', init, false);
            }
        },

        /**
         * Dispatch Event on an element.
         *
         * Available options:
         *
         * Mouse and touch events (e.g mouseup, mousedown, click, ...):
         *
         * | Options            | Description                                           |
         * | ------------------ | ----------------------------------------------------- |
         * | `detail`           | The Event's mouse click count.                        |
         * | `screenX`          | The Event's screen x coordinate.                      |
         * | `screenY`          | The Event's screen y coordinate.                      |
         * | `clientX`          | The Event's client x coordinate.                      |
         * | `clientY`          | The Event's client y coordinate.                      |
         * | `relatedTarget`    | The Event's related EventTarget.                      |
         *
         * Touch events (e.g touchstart, touchmove, touchend, touchcancel):
         *
         * | Options            | Description                                           |
         * | ------------------ | ----------------------------------------------------- |
         * | `touches`          | A collection of Touch objects representing all touches associated with this event.  |
         * | `targetTouches`    | A collection of Touch objects representing all touches associated with this target. |
         * | `changedTouches`   | A collection of Touch objects representing all touches that changed in this event.  |
         * | `scale`            | See below                                                                           |
         * | `rotation`         | The delta rotation since the start of an event, in degrees, here clockwise is positive and counter-clockwise is negative. The initial value is 0.0. |
         *
         * Scale option:
         *
         * The distance between two fingers since the start of an event as a multiplier of the initial distance.
         * The initial value is 1.0.
         * If less than 1.0, the gesture is pinch close (to zoom out).
         * If greater than 1.0, the gesture is pinch open (to zoom in).
         *
         * Keyboard events (e.g keydown, keyup, ...):
         *
         * | Options            | Description                                                 |
         * | ------------------ | ----------------------------------------------------------- |
         * | `keyCode`          | unsigned long keyCode                                       |
         * | `charCode`         | unsigned long charCode                                      |
         *
         * All events (e.g load, unload, ...):
         *
         * | Options            | Description                                                 |
         * | ------------------ | ----------------------------------------------------------- |
         * | `ctrlKey`          | Whether or not control key was depressed during the Event.  |
         * | `altKey`           | Whether or not alt key was depressed during the Event.      |
         * | `shiftKey`         | Whether or not shift key was depressed during the Event.    |
         * | `metaKey`          | Whether or not meta key was depressed during the Event.     |
         * | `button`           | The Event's mouse event.button.                             |
         *
         *
         * @see {@link http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-MouseEvent}
         * @see {@link http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvent}
         * @see {@link http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-eventgroupings-basicevents}
         * @see {@link https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html}
         *
         * @param {Element} element - A standart DOM node
         * @param {String} eventType - An event name (e.g mouseup)
         * @param {Object} options - Options hash or a option/value pair.
         * @return {Event} A standard DOM event.
         *
         * @example
         * var element = new UWA.Element('div');
         * element.addEvent('click', function (event) {
         *
         *    // Process your event behavior here
         * });
         *
         * // Trigger click event on element
         * UWA.Event.dispatchEvent(element, 'click');
         *
         * @alias UWA.Event.dispatchEvent
         * @memberOf module:UWA/Event
         */
        dispatchEvent: function (element, eventType, options) {

            var event, eventParentType, eventInitArgs,
                document = element.nodeType === 9 ? element : (element.ownerDocument || element.document),
                window = (document.defaultView || document.parentWindow),
                defaultOptions = {

                    // All Events
                    canBubble: true,
                    cancelable: true,
                    view: window,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    metaKey: false,

                    // MouseEvent
                    detail: 0,
                    screenX: 0,
                    screenY: 0,
                    clientX: 0,
                    clientY: 0,
                    button: 0,

                    // KeyboardEvent
                    relatedTarget: null,
                    keyCode: null,
                    charCode: null,

                    // TouchEvent
                    touches: null,
                    targetTouches: null,
                    changedTouches: null,
                    scale: 1.0,
                    rotation: 0.0
                };

            options = UWA.merge(options || {}, defaultOptions);

            // W3C
            if (document.createEvent) {

                // MouseEvent
                if (
                    eventType === 'click' ||
                        eventType === 'dblclick' ||
                            eventType === 'contextmenu' ||
                                eventType.indexOf('mouse') === 0
                ) {

                    eventParentType = 'MouseEvent';

                    eventInitArgs = [
                        eventType,
                        options.canBubble,
                        options.cancelable,
                        options.view,
                        options.detail,
                        options.screenX,
                        options.screenY,
                        options.clientX,
                        options.clientY,
                        options.ctrlKey,
                        options.altKey,
                        options.shiftKey,
                        options.metaKey,
                        options.button,
                        options.relatedTarget
                    ];

                // TouchEvent
                } else if (eventType.indexOf('touch') === 0) {

                    eventParentType = 'TouchEvent';

                    eventInitArgs = [
                        eventType,
                        options.canBubble,
                        options.cancelable,
                        options.view,
                        options.detail,
                        options.screenX,
                        options.screenY,
                        options.clientX,
                        options.clientY,
                        options.ctrlKey,
                        options.altKey,
                        options.shiftKey,
                        options.metaKey,
                        options.touches,
                        options.targetTouches,
                        options.changedTouches,
                        options.scale,
                        options.rotation
                    ];

                // KeyboardEvent
                } else if (eventType.indexOf('key') === 0) {

                    eventParentType = 'KeyboardEvent';

                    // initKeyEvent (Gecko-specific; the DOM 3 Events working draft uses initKeyboardEvent instead)
                    eventInitArgs = [
                        eventType,
                        options.canBubble,
                        options.cancelable,
                        options.view,
                        options.ctrlKey,
                        options.altKey,
                        options.shiftKey,
                        options.metaKey,
                        options.keyCode,
                        options.charCode
                    ];

                // HTMLEvents
                } else {

                    eventParentType = 'HTMLEvents';

                    eventInitArgs = [
                        eventType,
                        options.canBubble,
                        options.cancelable
                    ];
                }

                event = document.createEvent(eventParentType);

                // Handle Gecko-specific; the DOM 3 Events working draft uses initKeyboardEvent instead
                if (
                    eventParentType === 'KeyboardEvent' &&
                        typeof event.initKeyEvent === 'function'
                ) {
                    eventParentType = 'KeyEvent';
                } else if (eventParentType === 'HTMLEvents' && typeof event.initHTMLEvents !== 'function') {
                    eventParentType = 'Event';
                }

                if (typeof event['init' + eventParentType] === 'function') {
                    event['init' + eventParentType].apply(event, eventInitArgs);

                } else {
                    throw new Error('Unsuported Event type ' + eventParentType);
                }

                // Fix keyboad event before dispatchEvent
                // http://code.google.com/p/chromium/issues/detail?id=52408
                // TODO http://stackoverflow.com/questions/961532/firing-a-keyboard-event-in-javascript

                element.dispatchEvent(event);

            // MSIE
            } else if (document.createEventObject) {

                event = document.createEventObject();

                UWA.extend(event, options);

                try {
                    element.fireEvent('on' + eventType, event);
                } catch (error) {
                    throw new Error('Unsuported Event type ' + eventType);
                }

            }

            // TODO https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent

            return event;
        },

        /**
         * Get element target to event parameter.
         *
         * @param {Event} event - A standard DOM event
         * @return Element attached to the event extended with <UWA.Element> methods.
         *
         * @alias UWA.Event.getElement
         * @memberOf module:UWA/Event
         */
        getElement: function (event) {

            var target = event._uwaTarget || event.target || event.srcElement;

            // On some mobile devices, if we click on a text, the target is the
            // textNode. As this behavior is not followed by any other desktop
            // browser, we fix this here.
            // Also, we do not fix it for some events as it could be useful to
            // have the TextNode on those.
            if (
                event.type !== 'DOMCharacterDataModified' &&
                    target && (target.nodeType === 3 || target.nodeType === 4)
            ) {
                target = target.parentNode;
            }

            return UWA.extendElement(target);
        },

        /**
         * Find an parent element of event target using tagName.
         *
         * @param {Event} event - A standard DOM event
         * @param {String} tagName - Parent element target tagname
         * @return Element matched extended with <UWA.Element> methods.
         *
         * @alias UWA.Event.findElement
         * @memberOf module:UWA/Event
         */
        findElement: function (event, selector) {
            return Event.getElement(event).getClosest(selector);
        },

        /**
         * The "x" and "y" positions of the event (mouse, finger) relative to the viewport.
         *
         * Note:
         * - Support touch event.
         * - In case of multi touch event and if touchIndex parameter is
         * undefined the position is the middle of touch points.
         *
         * @param {Event} event - A standard DOM event
         * @param {Event} touchIndex - Touch point index to get position from
         *
         * @example
         * var element = new UWA.Element('div');
         * element.addEvent('click', function (event) {
         *
         *    // Retrieve event position
         *    var posision = UWA.Event.getPosition(event);
         *
         *    // Process your event behavior here
         * });
         *
         * @alias UWA.Event.getPosition
         * @memberOf module:UWA/Event
         */
        getPosition: function (event, touchIndex) {

            var i, l, position,
                element = event.target || event.srcElement,
                document = element.nodeType === 9 ? element : (element.ownerDocument || element.document),
                touches = event.changedTouches || event.touches;

            if (touches) {

                if (
                    touchIndex !== undefined &&
                        touches[touchIndex]
                ) {

                    position = {
                        x: touches[touchIndex].pageX,
                        y: touches[touchIndex].pageY
                    };

                } else {

                    position = {
                        x: 0,
                        y: 0
                    };

                    for (i = 0, l = touches.length; i < l; i++) {
                        position.x += touches[i].pageX;
                        position.y += touches[i].pageY;
                    }

                    position.x /= l;
                    position.y /= l;
                }

            } else {

                position = {
                    x: event.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft),
                    y: event.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
                };
            }

            return position;
        },

        /**
         * Cross-Platform method to stop the propagation of an event.
         *
         * > This stops the event from bubbling up through the DOM.
         * > This method does not prevent the default action from being invoked, use {@link module:UWA/Event.UWA.Event#preventDefault|UWA.Event.preventDefault} for that effect.
         *
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-Event-stopPropagation}
         *
         * @param {Event} event - A standard DOM event
         *
         * @example
         * var element = new UWA.Element('span');
         * element.addEvent('click', function (event) {
         *
         *    // Prevent default action
         *    UWA.Event.stopPropagation(event);
         *
         *    // Process your event behavior here
         * });
         *
         * @alias UWA.Event.stopPropagation
         * @memberOf module:UWA/Event
         */
        stopPropagation: function (event) {

            // if stopPropagation exists run it on the original event
            if (event.stopPropagation) {
                event.stopPropagation();
            }

            // otherwise set the cancelBubble property of the original event to true (IE)
            event.cancelBubble = true;
        },

        /**
         * Cross-Platform method to prevent the default action of the event.
         *
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-Event-preventDefault}
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-Event-defaultPrevented}
         *
         * @param {Event} event - A standard DOM event
         *
         * @example
         * var element = new UWA.Element('a', {
         *     href: "http://example.com"
         * });
         * element.addEvent('click', function (event) {
         *
         *    // Prevent propagation of the event
         *    UWA.Event.preventDefault(event);
         *
         *    // Process your event behavior here
         * });
         *
         * @alias UWA.Event.preventDefault
         * @memberOf module:UWA/Event
         */
        preventDefault: function (event) {

            // if preventDefault exists run it on the original event
            if (event.preventDefault) {
                event.preventDefault();
            }

            // otherwise set the returnValue property of the original event to false (IE)
            event.returnValue = false;

            // Only update defaultPrevented if missing and
            // event is cancelable
            if (
                (event.cancelable === undefined || event.cancelable === true) &&
                    event.defaultPrevented === undefined
            ) {
                event.defaultPrevented = true;
            }
        },

        /**
         * Stop an Event from propagating and also executes preventDefault.
         *
         * @param {Event} event - A standard DOM event
         *
         * @example
         * var element = new UWA.Element('div');
         * element.addEvent('click', function (event) {
         *
         *    // Prevent default action and propagation of the event
         *    UWA.Event.stop(event);
         *
         *    // Process your event behavior here
         * });
         *
         * @alias UWA.Event.stop
         * @memberOf module:UWA/Event
         */
        stop: function (event) {
            Event.preventDefault(event);
            Event.stopPropagation(event);
        },

        /**
         * Return `true` if Event.preventDefault() has been called for this event.
         *
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-Event-defaultPrevented}
         * @param {Event} event - A standard DOM event
         * @return {Boolean} `true` if if Event.preventDefault() has been called for this event.
         *
         * @alias UWA.Event.isDefaultPrevented
         * @memberOf module:UWA/Event
         */
        isDefaultPrevented: function (event) {
            return event.defaultPrevented ||
                        (event.returnValue !== true && event.returnValue !== undefined);
        },

        /**
         * Cross-Platform method to get the mouse event used button.
         *
         * During mouse events caused by the depression or release of a mouse button,
         * button is used to indicate which mouse button changed state.
         *
         * - -1 indicates no button is pressed.
         *
         * - 0 indicates the normal button of the mouse (in general on the left
         *    or the one button on Macintosh mice, used to activate a button or select text).
         *
         * - 2 indicates the contextual property (in general on the right, used
         *    to display a context menu) button of the mouse if present.
         *
         * - 1 indicates the extra (in general in the middle and often combined
         *    with the mouse wheel) button. Some mice may provide or simulate
         *    more buttons, and values higher than 2 can be used to represent
         *    such buttons.
         *
         * @example
         * var element = new UWA.Element('div');
         * element.addEvent('click', function (event) {
         *
         *    var button = UWA.Event.whichButton(event);
         *
         *    if (button === 0) {
         *        // Process normal button
         *    } else if (button === 2) {
         *        // Process contextual button
         *    } else if (button === 1) {
         *        // Process middle button
         *    }
         * });
         *
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-MouseEvent-button}
         *
         * @param {Event} event - A standard DOM event
         * @return {Integer} The used mouse button event, or -1 if no button is pressed.
         *
         * @alias UWA.Event.whichButton
         * @memberOf module:UWA/Event
         */
        whichButton: function (event) {

            var button = event.button,
                which = event.which;

            /* Following various sources, `which` should be used as primary
             * source, and use `button` only if it is not available, even if
             * the latter is the standard, because `button` value can't be
             * trusted.
             *
             * More informations:
             * http://www.quirksmode.org/js/events_properties.html#button
             */
            if (!which && UWA.is(button)) {
                which = [0, 1, 3, 1, 2][button] || 0;
            }

            return which - 1;
        },

        whichKey: (function () {

            var actionKeys = ['alt', 'ctrl', 'meta', 'shift'],
                specialKeys = {
                    8: "backspace",
                    9: "tab",
                    13: "return",
                    16: "shift",
                    17: "ctrl",
                    18: "alt",
                    19: "pause",
                    20: "capslock",
                    27: "esc",
                    32: "space",
                    33: "pageup",
                    34: "pagedown",
                    35: "end",
                    36: "home",
                    37: "left",
                    38: "up",
                    39: "right",
                    40: "down",
                    45: "insert",
                    46: "del",
                    96: "0",
                    97: "1",
                    98: "2",
                    99: "3",
                    100: "4",
                    101: "5",
                    102: "6",
                    103: "7",
                    104: "8",
                    105: "9",
                    106: "*",
                    107: "+",
                    109: "-",
                    110: ".",
                    111 : "/",
                    112: "f1",
                    113: "f2",
                    114: "f3",
                    115: "f4",
                    116: "f5",
                    117: "f6",
                    118: "f7",
                    119: "f8",
                    120: "f9",
                    121: "f10",
                    122: "f11",
                    123: "f12",
                    144: "numlock",
                    145: "scroll",
                    191: "/",
                    224: "meta"
                };

            /**
             * Cross-Platform method to get the keyboard event pressed keys.
             *
             * Notice:
             * > Using other event type based on key (keydown, keypress, keyup) only meta keys (ctrl, alt, shift) can be expected.
             *
             * @example
             * UWA.Element.addEvent.call(document, 'keydown', function (event) {
             *    var key = UWA.Event.whichKey(event);
             *
             *    if (key === 'up') {
             *        // Process up action here
             *    } else if (key === 'down') {
             *        // Process down action here
             *    } else if (key === 'ctrl+down') {
             *        // Process ctrl+down action here
             *    }
             * });
             *
             * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-KeyboardEvents-Interfaces}
             * @see {@link http://unixpapa.com/js/key.html}
             *
             * @param {Event} event - a standart DOM event
             * @return {String} An string pressed key value (e.g "ctrl+f", "f").
             *
             * @alias UWA.Event.whichKey
             * @memberOf module:UWA/Event
             */
            return function (event) {

                // Keypress represents characters, not special keys
                var i, l, actionKey,
                    keyCode = event.which || event.keyCode,
                    specialKey = event.type !== 'keypress' && specialKeys[keyCode],
                    key = [];

                // Iterate over action keys (crtl, alt, shift, meta) to create preffix
                for (i = 0, l = actionKeys.length; i < l; i++) {

                    actionKey = actionKeys[i];

                    if (
                        event[actionKey + 'Key'] &&
                            specialKey !== actionKey
                    ) {
                        key.push(actionKey);
                    }
                }

                // Handle special keys
                if (specialKey) {
                    key.push(specialKey);

                // Handle all others key if event type is key based (keydown, keypress, keyup)
                } else if (keyCode && event.type.indexOf('key') === 0) {
                    key.push(String.fromCharCode(keyCode).toLowerCase());
                }

                return key.join('+');
            };
        }()),

        /**
         * Cross-Platform method to get how many pixels the mouse wheel scrolls
         * the page.
         *
         * @see {@link http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-UIEvent-detail}
         *
         * @param {Event} event - A standard DOM event
         * @return {Integer} Number of pixels the mouse wheel scrolls the page.
         *
         * @alias UWA.Event.wheelDelta
         * @memberOf module:UWA/Event
         */
        wheelDelta: function (event) {
            return event.wheelDelta ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
        }
    };

    return UWA.namespace('Event', Event, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define*/

/*
 *
 *                 ____
 *               /  @   \==]|[=(]       D E P R E C A T E ! !
 *              |--------|
 *              ==========       .  *                                     *
 *              ==========     .\ * . *.   *                         .    * \  .
 *             ||||||||||||      \ * ./  *    .   *                      .  \ \
 *            |||||||||| --]%%%%%% .- =--=---=-=-=-=--=-=--=-==-----=-=-=-=-=-=
 *            [=========\  ]===========(  *                             . /  /
 *           [==============|   / *  \    .                          *  *   /  .
 *           C| @ @ @ @ @ @ D         *      *                        *
 *            |              \           .                          *  *
 *          C| @  @ @  @ @ @  D       .
 *           |                 \          *                          *
 *         C| @  @  @  @  @  @  D
 *          |                    \
 *        C| @  @  @   @   @   @  D
 *         |                       \
 *        |@@@@@@@@@@@@@@@@@@@@@@@@@|
 *         -------------------------
 *
 */
define('UWA/Internal/Deprecate', [
    'UWA/Core'
], function (Core) {
    'use strict';

    var warned = {};
    var Module = {};

    Module.warn = function warn(method, message, type) {
        if (!type) {
            type = 'warn';
        }
        if (Core.debug && !warned.hasOwnProperty(method)) {
            Core.log(method + ' is deprecated.' + (message ? ' ' + message : ''), type);
            warned[method] = true;
        }
    };

    Module.alias = function warnalias(methodName, prefered, fct) {
        if (!Core.debug) {
            return fct;
        }
        var result = function () {
            Module.warn(methodName, prefered);
            return fct && fct.apply(this, arguments);
        };
        if (fct) {
            result.prototype = fct.prototype;
        }
        return result;
    };

    Module.property = function (object, property, options) {
        var value = options ? options.value : undefined;
        if (Core.debug) {
            var name = (options && options.name) || property;
            Object.defineProperty(object, property, {
                get: function () {
                    Module.warn(name, options && options.message);
                    return value;
                },
                set: function (newValue) {
                    Module.warn(name, options && options.message);
                    value = newValue;
                }
            });
        } else {
            object[property] = value;
        }
    };

    Module.uncurryAlias = function (methods, prototype, methodsName, prototypeName) {
        Object.keys(methods).forEach(function (key) {
            var fn = methods[key];
            Object.defineProperty(prototype, key, {
                value: function (arg1, arg2, arg3) {
                    Module.warn(prototypeName + '#' + key, 'Use ' + methodsName + '.' + key + '(value, ...) instead');
                    switch (arguments.length) {
                    case 0: return fn.call(methods, this);
                    case 1: return fn.call(methods, this, arg1);
                    case 2: return fn.call(methods, this, arg1, arg2);
                    case 3: return fn.call(methods, this, arg1, arg2, arg3);
                    default:
                        var args = [].slice.call(arguments);
                        args.unshift(this);
                        return fn.apply(methods, args);
                    }
                },
                writable: true
            });
        });
    };

    return Module;
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Function utility functions
 *
 * @module   UWA/Function
 */
define('UWA/Function', ['UWA/Core'], function (UWA) {
    'use strict';

    var Module = {};

    /**
     * Creates a function that always returns `value`.
     *
     * @method
     * @param {Void} value The value to return from the new function.
     * @return {Function} Returns the new function.
     *
     * @example
     * // For passing constants to APIs that expect functions :
     * someArray.filter(filterFunction || UWA.Function.always(true));
     * // api: object.position = function (time) { return coords }
     * circle.position = Utils.always([10, 10]);
     * // api: image.fill( function (x, y) { return color; });
     * image.fill(UWA.Function.always(black));
     *
     * @memberOf module:UWA/Function
     * @alias UWA.Function.always
     */
    Module.always = function (value) {
        return function () {
            return value;
        };
    };

    return UWA.namespace('Function', Module, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * String utility functions.
 *
 * @module   UWA/String
 */
define('UWA/String', [
    'UWA/Core',
    'UWA/Internal/Deprecate'
], function (UWA, Deprecate) {
    'use strict';

    var Module = {};

    /**
     * Validate if a String is a valid email adresse.
     *
     * @method
     * @param {String} string the string to test
     * @return {Boolean} True if is a valid email adresse else `false`.
     *
     * @example
     * UWA.String.isEmail("example.com");
     * // will return `false`
     * UWA.String.isEmail("john@example.com");
     * // will return `true`
     *
     * @memberOf module:UWA/String
     * @alias UWA.String.isEmail
     */
    Module.isEmail = (function () {

        var isEmailRegExp = /^([a-zA-Z0-9_.\-+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;

        return function (string) {
            return isEmailRegExp.test(string);
        };
    }());

    /**
     * Truncates a string to the given length and appends a suffix to it (indicating that it is only an excerpt).
     *
     * @method
     * @param {String} string - the string to truncate
     * @param {Number} length - max length of the string
     * @param {Number} truncation - truncation String used for elipsis, "..." by default
     * @return {String} Truncate string.
     *
     * @example
     * UWA.String.truncate("hello world", 10);
     * // will return "hello w..."
     *
     * @memberOf module:UWA/String
     * @alias UWA.String.truncate
     */
    Module.truncate = function (string, length, truncation) {
        length = length || 30;
        truncation = truncation === undefined ? '...' : truncation;
        return string.length > length ? string.slice(0, length - truncation.length) + truncation : String(string);
    };

    /**
     * Cut a string to the given length and appends a suffix to it (indicating that it is
     * only an excerpt). Unlike UWA.String.truncate, this function will try to avoid
     * breaking words.
     *
     * @method
     * @param {String} string the string to cut
     * @param {Number} length max length of the string
     * @param {Number} truncation truncation String used for elipsis, "..." by default
     * @return {String} Cut string.
     *
     * @example
     * UWA.String.cut("hello world", 10);
     * // will return "hello..."
     *
     * @alias UWA.String.cut
     * @memberOf module:UWA/String
     */
    Module.cut = function (string, length, truncation) {

        length = length || 30;
        truncation = truncation === undefined ? '...' : truncation;

        if (string.length <= length) {
            return String(string);
        }

        var i,
            exclude = ".,;!? ",
            index = -1,
            truncationLength = truncation.length;

        for (i = length - truncationLength; i >= 0; i--) {
            if (exclude.indexOf(string.charAt(i)) !== -1) {
                index = i;
                break;
            }
        }

        if (index < 0) {
            index = length - truncationLength;
        }

        return string.slice(0, index) + truncation;
    };

    /**
     * Returns a string with escaped regular expression characters.
     *
     * @method
     * @param {String} string the string to escape
     * @return {String} Escaped RegExp string.
     *
     * @example
     * UWA.String.escapeRegExp("animals.sheep[1]");
     * // will return "animals\.sheep\[1\]"
     *
     * @alias UWA.String.escapeRegExp
     * @memberOf module:UWA/String
     */
    Module.escapeRegExp = function (string) {
        return string.replace(/\\/g, '\\\\').replace(/([\-.*+\?\^$()\[\]{}|])/g, '\\$1');
    };

    /**
     * Strips a string of any HTML tags.
     *
     * WARNING: THIS IS *NOT* XSS PROOF. Use {@link module:UWA/String.UWA.String.escapeHTML|escapeHTML}.
     *
     * @method
     * @param {String} string the string containing tags
     * @return {String} Converted string.
     *
     * @example
     * UWA.String.stripTags("&lt;h1&gt;hello&lt;/h1&gt;&lt;a href=''&gt;world&lt;/a&gt;");
     * // will return "hello world"
     *
     * @alias UWA.String.stripTags
     * @memberOf module:UWA/String
     */
    Module.stripTags = function (string) {

        // 1. strip tags exepct some of them
        // 2. strip other tags and replace by space
        // 3. Remove duplicate spaces

        return string.replace(/ on\w+="[^"]*"/g, '')
            .replace(/<(?!\s*\/?\s*(div|br|dt|dd|th|td|p|pre|h1|h2|h3|h4|h5)\b)[^>]*>/gi, '')
            .replace(/<\/?[^>]+>/gi, ' ')
            .replace(/^\s+|\s+$/g, '')
            .replace(/\s+/g, ' ');
    };

    /**
     * Strips a string of any HTML scripts tags.
     *
     * WARNING: THIS IS *NOT* XSS PROOF. Use {@link module:UWA/String.UWA.String.escapeHTML|escapeHTML}.
     *
     * @method
     * @param {String} string the string containing script tags
     * @param {Boolean|Function} [evaluate] - If `true`, evaluate the
     *  script. If this is a function, run the function with the script
     *  as first argument. Default to `false`. Please use this very
     *  carefully.
     * @return {String} Converted string.
     *
     * @example
     * UWA.String.stripScripts("&lt;h1&gt;hello&lt;/h1&gt;&lt;a href=''&gt;world&lt;/a&gt;&lt;script&gt;alert('hello')&lt;/script&gt;");
     * // will return "hello world"
     *
     * @alias UWA.String.stripScripts
     * @memberOf module:UWA/String
     */
    Module.stripScripts = function (string, evaluate) {
        var scripts = '',
            text = string.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function (full, script) {
                scripts += script + '\n';
                return '';
            });
        if (evaluate === true) {
            eval(scripts); // eslint-disable-line no-eval
        } else if (UWA.is(evaluate, 'function')) {
            evaluate(scripts.trim(), text);
        }
        return text;
    };

    Module.stripComments = (function () {

        // Cache regExp
        var escapeSimpleComment = /^\/\/.*/gm,
            escapeMultiComment = /^\/\*[\S\s]*?\*\//gm;

        /**
         * Strips a string of any comments. Only comments starting at the beginning of a
         * line will be removed.
         *
         * @method
         * @param {String} string the string containing JS comments
         * @return {String} Converted string.
         *
         * @example
         * UWA.String.stripComments("hello world \n" + "// My Comment");
         * // will return "hello world \n"
         *
         * UWA.String.stripComments("hello world \n" + "/* My Comment \n *\/");
         * // will return "hello world \n"
         *
         * @alias UWA.String.stripComments
         * @memberOf module:UWA/String
         */
        return function (string) {
            return string.replace(escapeSimpleComment, '').replace(escapeMultiComment, '');
        };
    }());

    /**
     * Replace htmlentities to XHTML characters.
     *
     * @method
     * @param {String} string the string to escape
     * @return {String} Converted string.
     *
     * @example
     * UWA.String.escapeHTMLEntities("&apos;");
     * // will return "&#39;"
     *
     * @alias UWA.String.escapeHTMLEntities
     * @memberOf module:UWA/String
     */
    Module.escapeHTMLEntities = (function () {

        var entitiesRegExp = {},
            entities = {
                "apos": 39,
                "minus": 8722,
                "circ": 710,
                "tilde": 732,
                "Scaron": 352,
                "lsaquo": 8249,
                "OElig": 338,
                "lsquo": 8216,
                "rsquo": 8217,
                "ldquo": 8220,
                "rdquo": 8221,
                "bull": 8226,
                "ndash": 8211,
                "mdash": 8212,
                "trade": 8482,
                "scaron": 353,
                "rsaquo": 8250,
                "oelig": 339,
                "Yuml": 376,
                "yuml": 255,
                "fnof": 402,
                "Alpha": 913,
                "Beta": 914,
                "Gamma": 915,
                "Delta": 916,
                "Epsilon": 917,
                "Zeta": 918,
                "Eta": 919,
                "Theta": 920,
                "Iota": 921,
                "Kappa": 922,
                "Lambda": 923,
                "Mu": 924,
                "Nu": 925,
                "Xi": 926,
                "Omicron": 927,
                "Pi": 928,
                "Rho": 929,
                "Sigma": 931,
                "Tau": 932,
                "Upsilon": 933,
                "Phi": 934,
                "Chi": 935,
                "Psi": 936,
                "Omega": 937,
                "alpha": 945,
                "beta": 946,
                "gamma": 947,
                "delta": 948,
                "epsilon": 949,
                "zeta": 950,
                "eta": 951,
                "theta": 952,
                "iota": 953,
                "kappa": 954,
                "lambda": 955,
                "mu": 956,
                "nu": 957,
                "xi": 958,
                "omicron": 959,
                "pi": 960,
                "rho": 961,
                "sigmaf": 962,
                "sigma": 963,
                "tau": 964,
                "upsilon": 965,
                "phi": 966,
                "chi": 967,
                "psi": 968,
                "omega": 969,
                "thetasym": 977,
                "upsih": 978,
                "piv": 982,
                "ensp": 8194,
                "emsp": 8195,
                "thinsp": 8201,
                "zwnj": 8204,
                "zwj": 8205,
                "lrm": 8206,
                "rlm": 8207,
                "sbquo": 8218,
                "bdquo": 8222,
                "dagger": 8224,
                "Dagger": 8225,
                "hellip": 8230,
                "permil": 8240,
                "prime": 8242,
                "Prime": 8243,
                "oline": 8254,
                "frasl": 8260,
                "euro": 8364,
                "image": 8465,
                "weierp": 8472,
                "real": 8476,
                "alefsym": 8501,
                "larr": 8592,
                "uarr": 8593,
                "rarr": 8594,
                "darr": 8595,
                "harr": 8596,
                "crarr": 8629,
                "lArr": 8656,
                "uArr": 8657,
                "rArr": 8658,
                "dArr": 8659,
                "hArr": 8660,
                "forall": 8704,
                "part": 8706,
                "exist": 8707,
                "empty": 8709,
                "nabla": 8711,
                "isin": 8712,
                "notin": 8713,
                "ni": 8715,
                "prod": 8719,
                "sum": 8721,
                "lowast": 8727,
                "radic": 8730,
                "prop": 8733,
                "infin": 8734,
                "ang": 8736,
                "and": 8743,
                "or": 8744,
                "cap": 8745,
                "cup": 8746,
                "int": 8747,
                "there4": 8756,
                "sim": 8764,
                "cong": 8773,
                "asymp": 8776,
                "ne": 8800,
                "equiv": 8801,
                "le": 8804,
                "ge": 8805,
                "sub": 8834,
                "sup": 8835,
                "nsub": 8836,
                "sube": 8838,
                "supe": 8839,
                "oplus": 8853,
                "otimes": 8855,
                "perp": 8869,
                "sdot": 8901,
                "lceil": 8968,
                "rceil": 8969,
                "lfloor": 8970,
                "rfloor": 8971,
                "lang": 9001,
                "rang": 9002,
                "loz": 9674,
                "spades": 9824,
                "clubs": 9827,
                "hearts": 9829,
                "diams": 9830,
                "quot": 34,
                "amp": 38,
                "lt": 60,
                "gt": 62,
                "nbsp": 160,
                "iexcl": 161,
                "cent": 162,
                "pound": 163,
                "curren": 164,
                "yen": 165,
                "brvbar": 166,
                "sect": 167,
                "uml": 168,
                "copy": 169,
                "ordf": 170,
                "laquo": 171,
                "not": 172,
                "shy": 173,
                "reg": 174,
                "hibar": 175,
                "deg": 176,
                "plusmn": 177,
                "sup1": 185,
                "sup2": 178,
                "sup3": 179,
                "acute": 180,
                "micro": 181,
                "para": 182,
                "middot": 183,
                "cedil": 184,
                "ordm": 186,
                "raquo": 187,
                "frac14": 188,
                "frac12": 189,
                "frac34": 190,
                "iquest": 191,
                "Agrave": 192,
                "Aacute": 193,
                "Acirc": 194,
                "Atilde": 195,
                "Auml": 196,
                "Aring": 197,
                "AElig": 198,
                "Ccedil": 199,
                "Egrave": 200,
                "Eacute": 201,
                "Ecirc": 202,
                "Euml": 203,
                "Igrave": 204,
                "Iacute": 205,
                "Icirc": 206,
                "Iuml": 207,
                "ETH": 208,
                "Ntilde": 209,
                "Ograve": 210,
                "Oacute": 211,
                "Ocirc": 212,
                "Otilde": 213,
                "Ouml": 214,
                "times": 215,
                "Oslash": 216,
                "Ugrave": 217,
                "Uacute": 218,
                "Ucirc": 219,
                "Uuml": 220,
                "Yacute": 221,
                "THORN": 222,
                "szlig": 223,
                "agrave": 224,
                "aacute": 225,
                "acirc": 226,
                "atilde": 227,
                "auml": 228,
                "aring": 229,
                "aelig": 230,
                "ccedil": 231,
                "egrave": 232,
                "eacute": 233,
                "ecirc": 234,
                "euml": 235,
                "igrave": 236,
                "iacute": 237,
                "icirc": 238,
                "iuml": 239,
                "eth": 240,
                "ntilde": 241,
                "ograve": 242,
                "oacute": 243,
                "ocirc": 244,
                "otilde": 245,
                "ouml": 246,
                "divide": 247,
                "oslash": 248,
                "ugrave": 249,
                "uacute": 250,
                "ucirc": 251,
                "uuml": 252,
                "yacute": 253,
                "thorn": 254
            };

        function hasEntities(string) {
            return string.match(/&([a-z]+;)/gi);
        }

        function getEntityRegExp(entity) {

            if (!entitiesRegExp[entity]) {
                entitiesRegExp[entity] = new RegExp('&' + entity + ';', 'g');
            }

            return entitiesRegExp[entity];
        }

        return function (string) {

            var entity, entityRegExp;

            // Do not process string with no Entities
            if (hasEntities(string)) {
                for (entity in entities) {
                    if (entities.hasOwnProperty(entity)) {

                        // Get RegExp from cache
                        entityRegExp = getEntityRegExp(entity);

                        string = string.replace(entityRegExp, '&#' + entities[entity] + ';');
                    }
                }
            }

            return String(string);
        };
    }());

    /**
     * Translates a glob string expression into a JavaScript regular expression.
     *
     * The following syntax is supported for glob expressions.
     *
     * - *: Matches zero or more instances of any character. If the STAR_CANNOT_MATCH_NULL_MASK option is used,
     *        * matches one or more instances of any character.
     * - ? - Matches one instance of any character. If the QUESTION_MATCHES_ZERO_OR_ONE_MASK option is used,
     *        ? matches zero or one instances of any character.
     * - [...] - Matches any of characters enclosed by the brackets. * and ? lose their special meanings within a character class.
     *        Additionaly if the first character following the opening bracket is a ! or a ^, then any character not in the character
     *        class is matched. A - between two characters can be used to denote a range. A - at the beginning or end of the character
     *        class matches itself rather than referring to a range. A ] immediately following the opening [ matches itself rather than
     *        indicating the end of the character class, otherwise it must be escaped with a backslash to refer to itself.
     * - \ - A backslash matches itself in most situations. But when a special character such as a * follows it,
     *        a backslash escapes the character, indicating that the special chracter should be interpreted as a normal character instead of its special meaning.
     *
     * All other characters match themselves.
     *
     * Please remember that the when you construct a JavaScript string in JavaScript code, the backslash character is itself a special JavaScript character,
     * and it must be double backslashed to represent single backslash in a regular expression.
     *
     * @method
     * @param {String} string the glob to convert to regexp
     * @return {RegExp} Generated RegExp from blob string.
     *
     * @example
     * UWA.String.globToRegex("*{www,cdn}.example.com").test("https://www.example.com"); // true
     * UWA.String.globToRegex("*{www,cdn}.example.com").test("https://example.com"); // false
     *
     * @alias UWA.String.globToRegex
     * @memberOf module:UWA/String
     */
    Module.globToRegex = function (string) {

        var regexString = Module.escapeRegExp(string).replace(/\\\*/g, '.*')
                            .replace(/\\\?/g, '.')
                            .replace(/\\\{/g, '(')
                            .replace(/\\\}/g, ')')
                            .replace(/,/g, '|');

        return new RegExp('^' + regexString + '$');
    };

    /**
     * Escape HTML in a String.
     *
     * @method
     * @param {String} string the string to escape
     * @param {Boolean} tagsOnly - escape only the tags ( '>' '<' and '/' characters)
     * @return {String} The converted string.
     *
     * @example
     * UWA.String.escapeHTML("<html>hello workd</html>");
     * // will return "&lt;html&gt;hello workd&lt;&#x2F;html&gt;"
     *
     * @alias UWA.String.escapeHTML
     * @memberOf module:UWA/String
     */
    Module.escapeHTML = (function () {
        var map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '/': '&#x2F;'
            },
            re = /[&<>"'\/]/g,
            reTagsOnly = /[<>\/]/g;

        function replace(str) {
            return map[str];
        }

        return function (string, tagsOnly) {
            return String(string).replace(tagsOnly ? reTagsOnly : re, replace);
        };
    }());

    /**
     * Unescape HTML on a String. Warning: it uses a DOM element, so this function may not
     * be available following your environment
     *
     * @method
     * @param {String} string the string to unescape
     * @return {String} The converted string.
     *
     * @example
     * UWA.String.unescapeHTML("&lt;html&gt;hello workd&lt;/html&gt;");
     * // will return "<html>hello workd</html>"
     *
     * @alias UWA.String.unescapeHTML
     * @memberOf module:UWA/String
     */
    Module.unescapeHTML = function (string) {

        var div = document.createElement('div');

        div.innerHTML = Module.stripTags(string).replace(/"/g, "&quot;");

        return div.childNodes[0] ? div.childNodes[0].nodeValue : '';
    };

    /**
     * Convert first String letter to UpperCase.
     *
     * @method
     * @param {String} string the source string
     * @return {String} Updated String
     *
     * @example
     * UWA.String.ucfirst("hello world");
     * // will return "Hello world"
     *
     * @alias UWA.String.ucfirst
     * @memberOf module:UWA/String
     */
    Module.ucfirst = function (string) {
        var f = string.charAt(0).toUpperCase();
        return f + string.substr(1);
    };

    /**
     * Convert first String letter to lowerCase
     *
     * @method
     * @param {String} string the source string
     * @return {String} Updated String
     *
     * @example
     * UWA.String.lcfirst("Hello Patrick !");
     * // will return "hello Patrick !"
     *
     * @alias UWA.String.ucfirst
     * @memberOf module:UWA/String
     */
    Module.lcfirst = function (string) {
        var f = string.charAt(0).toLowerCase();
        return f + string.substr(1);
    };

    /**
     * Converts the first letter of each word in a string to uppercase.
     *
     * @method
     * @param {String} string the source string
     * @return {String} The converted string.
     *
     * @example
     * UWA.String.capitalize("hello world");
     * // will return "Hello World"
     *
     * @alias UWA.String.capitalize
     * @memberOf module:UWA/String
     */
    Module.capitalize = function (string) {
        var stringUpper = string.toUpperCase();
        var stringLower = string.toLowerCase();
        var inWord = false;
        var result = '';

        for (var i = 0; i < string.length; i++) {
            if (stringUpper[i] === stringLower[i]) {
                result += string[i];
                inWord = false;
            } else if (inWord) {
                result += string[i];
            } else {
                result += stringUpper[i];
                inWord = true;
            }
        }

        return result;
    };

    /**
     * Convert current String with space and comma in CamelCase valid string.
     *
     * @method
     * @param {String} string the source string
     * @return {String} The converted string.
     *
     * @example
     * UWA.String.camelCase("hello world");
     * // will return "helloWorld"
     * UWA.String.camelCase("hello-world");
     * // will return "helloWorld"
     * UWA.String.camelCase("hello_world");
     * // will return "helloWorld"
     * UWA.String.camelCase("hello_world_");
     * // will return "helloWorld"
     * UWA.String.camelCase("Helloworld");
     * // will return "helloworld"
     *
     * @alias UWA.String.camelCase
     * @memberOf module:UWA/String
     */
    Module.camelCase = (function () {

        var alphaUpperRegExp = /([A-Z]+)/g,
            separatorDotRegExp = /[\-_\s](.)/g,
            separatorRegExp = /[\-_\s]/g;

        return function (string) {

            string = String(string)
                .replace(alphaUpperRegExp, function (m, l) {
                    return l.substr(0, 1).toUpperCase() + l.toLowerCase().substr(1, l.length);
                })
                .replace(separatorDotRegExp, function (m, l) {
                    return l.toUpperCase();
                })
                .replace(separatorRegExp, '')
                .trim();
            return Module.lcfirst(string);
        };
    }());

    /**
     * Convert current String in CamelCase to a non CamelCase valid string.
     *
     * @method
     * @param {String} string the source string
     * @return {String} The converted string.
     *
     * @example
     * UWA.String.unCamelCase("helloWorld");
     * // will return "hello-world"
     * UWA.String.unCamelCase("helloWorld", ' ');
     * // will return "hello world"
     * UWA.String.unCamelCase("helloWorld", '_');
     * // will return "hello_world"
     *
     * @alias UWA.String.unCamelCase
     * @memberOf module:UWA/String
     */
    Module.unCamelCase = (function () {

        var alphaRegExp = /([a-z])([A-Z])/g,
            alphaUppperLowerRegExp = /\b([A-Z]+)([A-Z])([a-z])/;

        return function (string, separator) {

            separator = separator || '-';

            return string.toString()
                // insert a space between lower & upper
                .replace(alphaRegExp, '$1' + separator + '$2')
                // space before last upper in a sequence followed by lower
                .replace(alphaUppperLowerRegExp, '$1' + separator + '$2$3')
                // lowercase all characters
                .toLowerCase();
        };
    }());


    function parseColorToArray(color) {
        color = color.replace(/\s+/g, '');
        var numberWidth, number,
            result = false,
            match = color.match(/^rgb(a?)\(((?:\d{1,3},)*\d{1,3})\)/);

        if (match) {
            result = match[2].split(',').map(function (i) { return parseInt(i, 10); });
            if ((!match[1] && result.length !== 3) || (match[1] && result.length !== 4)) {
                result = false;
            }
        } else {
            match = color.match(/^#?((?:[a-f0-9]{3}){1,2})$/i);
            if (match) {
                numberWidth = match[1].length === 3 ? 1 : 2;
                result = [];
                for (var i = 0; i < match[1].length; i += numberWidth) {
                    number = parseInt(match[1].substr(i, numberWidth), 16);
                    if (numberWidth === 1) {
                        number = number * 16 + number;
                    }
                    result.push(number);
                }
            } else if (color === 'transparent') {
                result = [0, 0, 0, 0];
            }
        }
        return result;
    }

    /**
     * Converts an RGB color value to hexadecimal.
     * Input string must be in one of the following RGB color formats.
     * "rgb(255, 255, 255)", or "rgba(255, 255, 255, 1)".
     *
     * @method
     * @param {String} string a string representing a RGB color
     * @param {Boolean} array - If `true` is passed, will output an array (e.g. ['ff', '33', '00']) instead of a string (e.g. "#ff3300")
     * @return {Mixed} String or array depend array parameter value.
     *
     * @example
     * UWA.String.rgbToHex('rgb(17, 34, 51)'); // returns '#112233'
     * UWA.String.rgbToHex('rgb(17, 34, 51)', true); // returns ['11', '22', '33']
     * UWA.String.rgbToHex('rgba(17, 34, 51, 0)'); // returns 'transparent'
     *
     * @alias UWA.String.rgbToHex
     * @memberOf module:UWA/String
     */
    Module.rgbToHex = function (string, array) {
        var color = parseColorToArray(string);
        if (color) {
            if (array) {
                color = color.map(function (value) {
                    return parseInt(value.toString(16), 10);
                });
            } else if (color[3] === 0) {
                color = 'transparent';
            } else {
                color = '#' + color.slice(0, 3).map(function (value) {
                    return ('0' + value.toString(16)).slice(-2);
                }).join('');
            }
        }
        return color;
    };

    /**
     * Converts a hexadecimal color value to RGB.
     * Input string must be in one of the following hexadecimal color formats
     * (with or without the hash) '#ffffff', #fff', 'ffffff', or 'fff'.
     *
     * @method
     * @param {String} string a string representing a hexadecimal color
     * @param {Bool} array - If `true` is passed, will output an array (e.g. [255, 51, 0]) instead of a string (e.g. "rgb(255,51,0)")
     * @return {Mixed} String or array depend array parameter value.
     *
     * @example
     * UWA.String.hexToRgb('#123'); // returns 'rgb(17, 34, 51)'
     * UWA.String.hexToRgb('112233'); // returns 'rgb(17, 34, 51)'
     * UWA.String.hexToRgb('#112233', true); // returns [17, 34, 51]
     *
     * @alias UWA.String.hexToRgb
     * @memberOf module:UWA/String
     */
    Module.hexToRgb = function (string, array) {
        var color = parseColorToArray(string);
        if (color && !array) {
            color = (color.length === 3 ? 'rgb(' : 'rgba(') + color.join(', ') + ')';
        }
        return color;
    };

    /**
     * Replace {d+} into string by the respective argument position.
     *
     * @method
     * @param {String} string the template string
     * @param {String} replacements... other arguments are string replacements
     * @return {String} Current String Instance.
     *
     * @example
     * UWA.String.format('Hello {0} welcome on {1}.', 'John', 'UWA');
     * // will return 'Hello John welcome on UWA.'
     *
     * @alias UWA.String.format
     * @memberOf module:UWA/String
     */
    Module.format = (function () {

        var numRegExp = /\{(\d+)\}/g;

        return function (string) {
            var args = arguments;
            return string.replace(numRegExp, function (m, i) {
                return args[Number(i) + 1];
            });
        };
    }());

    /**
     * Convert date string to a human readable elapsed time, like "2 days ago".
     *
     * @method
     * @param {String} string a string representing a date
     * @param {Number} offset timezone offset
     * @return {String} Relative Time.
     *
     * > Notes:
     * > Supported format are:
     * >
     * > - timestamp in milli seconds
     * > - timestamp in seconds
     * > - XXX XXX DD YYYY HH:MM:SS GMT+NNNN (XXX)
     * > - YYYY/MM/DD
     * > - YYYY-MM-DD
     *
     * @alias UWA.String.parseRelativeTime
     * @memberOf module:UWA/String
     */
    Module.parseRelativeTime = function (string, offset) {

        var relativeTime, matches, time, delta,
            deltaToMidnight,
            midnight = new Date(),
            day = 86400,
            i18n = UWA.i18n;

        midnight = new Date(midnight.getFullYear(), midnight.getMonth(), midnight.getDate()).getTime();

        if (typeof offset !== 'number') {
            offset = 0;
        }

        // Parse date using format "YYYY-MM-DD HH:MM:SS"
        matches = string.match(/^(\d\d\d\d)\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/);
        if (matches) {
            time = new Date(matches[1], matches[2] - 1, matches[3], matches[4], matches[5], matches[6]).getTime();

        // Parse Date timestamp mili seconds
        } else if (/^\d{13}$/.test(string)) {

            time = parseInt(string, 10);

        // Parse Date timestamp seconds
        } else if (/^\d{10}$/.test(string)) {

            time = parseInt(string, 10) * 1000;

        // Parse Date using formats:
        // - XXX XXX DD YYYY HH:MM:SS GMT+NNNN (XXX)
        // - YYYY/MM/DD
        // - YYYY-MM-DD
        // - YYYY/MM/DD HH:MM:SSZ
        // - YYYY-MM-DDTHH:MM:SSZ
        } else {
            time = Date.parse(string.replace(/\//g, "-"));
        }

        offset *= 3600;
        delta = (new Date() - time) / 1000 + offset; // Compute the diff
        deltaToMidnight = (midnight - time) / 1000 + offset;

        if (isNaN(delta)) {
            relativeTime = false;
        } else if (delta < 60) {
            relativeTime = i18n('less than a minute ago');
        } else if (delta < 120) {
            relativeTime = i18n('about a minute ago');
        } else if (delta < (45 * 60)) {
            relativeTime = Module.format(i18n('{0} minutes ago'), Math.round(delta / 60));
        } else if (delta < (90 * 60)) {
            relativeTime = i18n('about an hour ago');
        } else if (deltaToMidnight < 0) {
            relativeTime = Module.format(i18n('about {0} hours ago'), Math.round(delta / 3600));
        } else if (deltaToMidnight < 86400) {
            relativeTime = i18n('yesterday');
        } else {
            relativeTime = Module.format(i18n('{0} days ago'), Math.ceil(deltaToMidnight / day));
        }

        return relativeTime;
    };

    /**
     * Convert URLs contained in a String as clickable link.
     *
     * @method
     * @param {String} string a source string
     * @return {String} The <a> HTML link with String value has href attribute.
     *
     * @example
     * UWA.String.makeClickable("visit http://dev.netvibes.com for more tips");
     * // will return "visit <a href="http://dev.netvibes.com" target="_blank">http://dev.netvibes.com</a> for more tips"
     *
     * @alias UWA.String.makeClickable
     * @memberOf module:UWA/String
     */
    Module.makeClickable = function (string) {
        var reLink = /((\w+:\/\/(\w+(:\w+)?@)?)|www\.)[^\s<$]+/;
        var reMail = /([\/:\w\+\_\-]+(\.[\w\+\_\-]+)*@[\w\.\-]+)/;

        return string.replace(/(^|[\s>])([^\s<>"']+?)(?=$|[\s<])/gm, function (whole, before, chunk) {
            if (reLink.test(chunk)) {
                var url = chunk.replace(/([\.!\?:;\)\]]$)/, ''),
                    text = chunk;
                // TODO fix that shit!
                if (/^www\./.test(url)) {
                    url = 'http://' + url;
                }
                return before + '<a href="' + url + '" target="_blank">' + text + '</a>';
            } else if (reMail.test(chunk)) {
                var str = chunk;
                if (!/^[\w]+:\/\//.test(str)) {
                    str = '<a href="mailto:' + str + '">' + str + '</a>';
                }
                return before + str;
            }
            return whole;
        });

    };

    /*
     * The contains() function determines whether one string may be found within
     * another string, returning true or false as appropriate.
     *
     * @method
     * @param {String} string A source string
     * @param {String} word A string to be searched for within the subject string.
     * @param {String} [separator=''] - If given, the searchString needs to be surrounded
     * by this separator, except if it is at the beginning or the end of the subject string.
     * @return {Boolean} `true` is String match requested String else `false`.
     *
     * @example
     * // EcmaScript Implementation
     * var str = "To be, or not to be, that is the question.";
     * UWA.String.contains(str, "To be");       // true
     * UWA.String.contains(str, "question");    // true
     * UWA.String.contains(str, "nonexistent"); // false
     * UWA.String.contains(str, "TO BE");       // false
     *
     * // UWA extras separator arguments
     * UWA.String.contains("hello world", 'world'); // true
     * UWA.String.contains("hello,world", 'world', ','); // true
     * UWA.String.contains("hello world", 'world', ','); // false
     */
    var originalContains = String.prototype.contains;
    var contains = function (string, searchString, separator) {
        if (UWA.is(separator, 'string')) {
            string = separator + string + separator;
            searchString = separator + searchString + separator;
        }

        return originalContains.call(string, searchString);
    };

    /**
     * Deprecated: This function does nothing, please don't use it.
     *
     * @method
     * @param {String} string
     * @return {String} updated String.
     *
     * @alias UWA.String.highlight
     * @memberOf module:UWA/String
     */
    Module.highlight = function (string) {
        Deprecate.warn('UWA.String.highlight');

        //  TODO document and implement it
        return string;
    };

    /**
     * Apply a regexp on a String. Deprecated in favor of `RegExp#test`.
     *
     * @method
     * @param {String} string - the string to test
     * @param {String} regexp - The regexp to apply on the string
     * @param {String} [modifier=''] - The modifier to apply on the regexp
     *
     * @return {String}  The RegExp results.
     *
     * @example
     * UWA.String.test("john", /^jack$/);
     * // will return false
     * UWA.String.test("jack", /^jack$/);
     * // will return true
     *
     * @memberOf module:UWA/String
     * @alias UWA.String.test
     */
    Module.test = function (string, regexp, modifier) {
        Deprecate.warn('UWA.String.test', 'Use regexp.test(string) instead');
        return ((typeof regexp === 'string') ? new RegExp(regexp, modifier) : regexp).test(string);
    };

    Deprecate.uncurryAlias(Module, String.prototype, 'UWA.String', 'String');
    String.prototype.contains = function (searchString, separator) {
        if (UWA.is(separator, 'string')) {
            Deprecate.warn('String#contains(substring, "string")', 'Use UWA.String.contains(string, substring, "string") instead');
            return contains(this, searchString, separator);
        }
        return originalContains.apply(this, arguments);
    };
    Module.contains = contains;

    // The previous module used to return the native String constructor. Let's return an
    // object that looks like this but print deprecation messages when using it.
    function FakeString() {
        Deprecate.warn('UWA/String as a constructor', 'Use the native String instead.');
        return String.apply(null, arguments);
    }

    Object.assign(FakeString, Module);

    return UWA.namespace('String', FakeString, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Array utility functions
 *
 * @module   UWA/Array
 *
 */
define('UWA/Array', [
    'UWA/Core',
    'UWA/Internal/Deprecate'
], function (UWA, Deprecate) {
    'use strict';

    var Module = {};

    /**
     * Test wether two arrays are equal. Deprecated in favor of `UWA.equals`.
     *
     * @param {Array} array - an array or array-like object
     * @param {Array} compare - Array need to compare
     * @return {Boolean} `true` if Arrays have the sames values else `false`.
     *
     * @example
     * var isEquals = UWA.Array.equals([], []);
     * // isEquals value is now `true`
     * var isEquals = UWA.Array.equals([1], [1,2,3]);
     * // isEquals value is now `false`
     *
     * @alias UWA.Array.equals
     * @memberOf module:UWA/Array
     */
    Module.equals = function (array, compare) {
        Deprecate.warn('UWA.Array.equals', 'Use UWA.equals instead');

        var i,
            l = array.length;

        if (!compare || l !== compare.length) {
            return false;
        }

        for (i = 0; i < l; i++) {
            if (array[i] !== compare[i]) {
                return false;
            }
        }

        return true;
    };

    /**
     * Find the first value using a test function iterator.
     *
     * @param {Array} array - an array or array-like object
     * @param {Function} iterator - A function applied to the values of the array
     *  The function is called with the context passed as second
     *  argument, and the current value, the current index and this array
     *  as arguments. When this function return a truthy value, the
     *  iteration stops and the current array value is returned.
     * @param {Object} context - Object to use as `this`
     * @return {*} The first value of the array matching the iterator function,
     *  or undefined if none of the values matches.
     *
     * @example
     * var search = UWA.Array.detect([8, 5, 6, 3, 5], function (v,i) { return v < 5 });
     * // search value is 3
     *
     * @alias UWA.Array.detect
     * @memberOf module:UWA/Array
     */
    Module.detect = function (array, iterator, context) {
        var i, j;
        for (i = 0, j = array.length; i < j; i++) {
            if (iterator.call(context, array[i], i, array)) {
                return array[i];
            }
        }
    };

    /**
     * Executes a provided method once per array object.
     *
     * @param {Array} array - an array
     * @param {String} fn - Method to call on every objects
     * @param {Other} parametters - parametters passed to the method call
     * @return {Array} The list of the results of method call.
     *
     * @example
     * var test = [' foo', '  bar  '];
     * UWA.Array.invoke(test, 'trim').join(',');
     * // returns "foo,bar"
     *
     * UWA.Array.invoke(document.body.getElements('.item'), 'hide');
     * // hides all .item elements
     *
     * @alias UWA.Array.invoke
     * @memberOf module:UWA/Array
     */
    Module.invoke = function (array, methodName) {
        var args = Array.prototype.slice.call(arguments, 2);
        return array.map(function (item) {
            return item[methodName].apply(item, args);
        });
    };

    /**
     * Erase every item contained in the array. Original array is modified.
     *
     * @param {Array} array - an array
     * @param {Mixed} item - An item potentially defined in the array
     * @return {Array} The original array modified
     *
     * @example
     * var test = ['red', 'green', 'red'];
     * UWA.Array.erase(test, 'red'); // returns ['green']
     * UWA.Array.erase(test, 'purple'); // returns ['red', 'green', 'red']
     *
     * @alias UWA.Array.erase
     * @memberOf module:UWA/Array
     */
    Module.erase = function (array, item) {
        for (var i = array.length; i--; i) {
            if (array[i] === item) array.splice(i, 1);
        }

        return array;
    };

    // Add those function as methods in Array.prototype, with a deprecation message.
    Deprecate.uncurryAlias(Module, Array.prototype, 'UWA.Array', 'Array');

    // The previous module used to return the native Array constructor. Let's return an
    // object that looks like this but print deprecation messages when using it.
    function FakeArray() {
        Deprecate.warn('UWA/Array as a constructor', 'Use the native Array instead.');
        return Array.apply(null, arguments);
    }

    FakeArray.isArray = Deprecate.alias('UWA/Array.isArray', 'Use the native Array.isArray instead', Array.isArray);

    // Deprecate popular prototype methods, in case one uses FakeArray.prototype.method()
    // directly.
    [ "splice", "slice" ].forEach(function (method) {
        FakeArray.prototype[method] = Deprecate.alias(
            'UWA/Array#' + method,
            'Use the native Array#' + method + ' instead',
            Array.prototype[method]
        );
    });

    Object.assign(FakeArray, Module);

    return UWA.namespace('Array', FakeArray, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Date function utilities
 *
 * @module   UWA/Date
 */
define('UWA/Date', [
    'UWA/Core',
    'UWA/Internal/Deprecate'
], function (UWA, Deprecate) {
    'use strict';


    var Module = {};

    Module.strftime = (function () {

        function pad(x, width, digits) {
            var array = Array;
            return array((digits || 2) - String(x).length + 1).join(width || 0) + x;
        }

        function fint(x) {
            return parseInt(x, 10);
        }

        var _ = UWA.i18n,

            /*
                Locales:
                a - Short names of days of week starting with Sunday
                A - Long names days of week starting with Sunday
                b - Short names of months of the year starting with January
                B - Long names of months of the year starting with February
                c - The preferred date and time representation in your locale
                p - AM or PM in your locale
                P - am or pm in your locale
                x - The  preferred date representation for the current locale without the time.
                X - The preferred time representation for the current locale without the date.
            */
            locales = {
                a: [_("Sun"), _("Mon"), _("Tue"), _("Wed"), _("Thu"), _("Fri"), _("Sat")],
                A: [_("Sunday"), _("Monday"), _("Tuesday"), _("Wednesday"), _("Thursday"), _("Friday"), _("Saturday")],
                b: [_("Jan"), _("Feb"), _("Mar"), _("Apr"), _("May"), _("Jun"), _("Jul"), _("Aug"), _("Sep"), _("Oct"), _("Nov"), _("Dec")],
                B: [_("January"), _("February"), _("March"), _("April"), _("May"), _("June"), _("July"), _("August"), _("September"), _("October"), _("November"), _("December")],
                c: _("%a %b %e %Y %T"), // this format is NOT the PHP default, but it is more readable for endusers.
                p: [_("AM"), _("PM")],
                P: [_("am"), _("pm")],
                x: _("%m/%d/%y"),
                X: _("%T")
            },

            /*
                Formats:
                %a - abbreviated weekday name according to the current locale
                %A - full weekday name according to the current locale
                %b - abbreviated month name according to the current locale
                %B - full month name according to the current locale
                %c - preferred date and time representation for the current locale
                %C - century number (the year divided by 100 and truncated to an integer, range 00 to 99)
                %d - day of the month as a decimal number (range 01 to 31)
                %D - same as %m/%d/%y
                %e - day of the month as a decimal number, a single digit is preceded by a space (range ' 1' to '31')
                %F - same as "%Y-%m-%d" (commonly used in database datestamps)
                %g - like %G, but without the century
                %G - The 4-digit year corresponding to the ISO week number
                %h - same as %b
                %H - hour as a decimal number using a 24-hour clock (range 00 to 23)
                %I - hour as a decimal number using a 12-hour clock (range 01 to 12)
                %j - day of the year as a decimal number (range 001 to 366)
                %l - hour in 12-hour format, with a space preceeding single digits
                %m - month as a decimal number (range 01 to 12)
                %M - minute as a decimal number
                %n - newline character
                %p - either `AM' or `PM' according to the given time value, or the corresponding strings for the current locale
                %P - like %p, but lower case
                %r - time in a.m. and p.m. notation equal to %I:%M:%S %p
                %R - time in 24 hour notation equal to %H:%M
                %S - second as a decimal number
                %t - tab character
                %T - current time, equal to %H:%M:%S
                %u - weekday as a decimal number [1,7], with 1 representing Monday
                %U - week number of the current year as a decimal number, starting with
                    the first Sunday as the first day of the first week
                %V - The ISO 8601:1988 week number of the current year as a decimal number,
                    range 01 to 53, where week 1 is the first week that has at least 4 days
                    in the current year, and with Monday as the first day of the week.
                %w - day of the week as a decimal, Sunday being 0
                %W - week number of the current year as a decimal number, starting with the
                    first Monday as the first day of the first week
                %x - preferred date representation for the current locale without the time
                %X - preferred time representation for the current locale without the date
                %y - year as a decimal number without a century (range 00 to 99)
                %Y - year as a decimal number including the century
                %z - numerical time zone representation
                %Z - time zone name or abbreviation
                %% - a literal `\%' character
            */
            formats = {
                // %a - abbreviated weekday name according to the current locale
                a: function (d) {
                    return locales.a[d.getDay()];
                },
                // %A - full weekday name according to the current locale
                A: function (d) {
                    return locales.A[d.getDay()];
                },
                // %b - abbreviated month name according to the current locale
                b: function (d) {
                    return locales.b[d.getMonth()];
                },
                // %B - full month name according to the current locale
                B: function (d) {
                    return locales.B[d.getMonth()];
                },
                // %c - preferred date and time representation for the current locale
                c: locales.c,
                // %C - century number (the year divided by 100 and truncated to an integer, range 00 to 99)
                C: function (d) {
                    return pad(fint(d.getFullYear() / 100));
                },
                // %d - day of the month as a decimal number (range 01 to 31)
                d: function (d) {
                    return pad(d.getDate());
                },
                // %D - same as %m/%d/%y
                D: '%m/%d/%y',
                // %e - day of the month as a decimal number, a single digit is preceded by a space (range ' 1' to '31')
                e: function (d) {
                    return pad(d.getDate(), ' ');
                },
                // %F - same as "%Y-%m-%d" (commonly used in database datestamps)
                F: '%Y-%m-%d',
                // %g - like %G, but without the century
                g: function (d) {
                    return pad(formats.G(d) % 100);
                },
                // %G - The 4-digit year corresponding to the ISO week number
                G: function (d) {
                    var y = d.getFullYear(),
                        V = fint(formats.V(d)),
                        W = fint(formats.W(d));

                    if (W > V) {
                        y++;
                    } else if (W === 0 && V >= 52) {
                        y--;
                    }

                    return y;
                },
                // %h - same as %b
                h: '%b',
                // %H - hour as a decimal number using a 24-hour clock (range 00 to 23)
                H: function (d) {
                    return pad(d.getHours());
                },
                // %I - hour as a decimal number using a 12-hour clock (range 01 to 12)
                I: function (d) {
                    return pad((d.getHours() % 12) || 12);
                },
                // %j - day of the year as a decimal number (range 001 to 366)
                j: function (d) {
                    var ms = new Date(
                            d.getFullYear() + '/' + (d.getMonth() + 1) + '/' +
                                d.getDate() + ' GMT'
                        ) - new Date(d.getFullYear() + '/1/1 GMT'),
                        doy = fint(ms / 60000 / 60 / 24) + 1;

                    return pad(doy, 0, 3);
                },
                // %l - hour in 12-hour format, with a space preceeding single digits
                l: function (d) {
                    return pad((d.getHours() % 12) || 12, ' ');
                },
                // %m - month as a decimal number (range 01 to 12)
                m: function (d) {
                    return pad(d.getMonth() + 1);
                },
                // %M - minute as a decimal number
                M: function (d) {
                    return pad(d.getMinutes());
                },
                // %n - newline character
                n: '\n',
                // %p - either `AM' or `PM' according to the given time value, or the corresponding strings for the current locale
                p: function (d) {
                    return locales.p[d.getHours() >= 12 ? 1 : 0];
                },
                // %P - like %p, but lower case
                P: function (d) {
                    return locales.P[d.getHours() >= 12 ? 1 : 0];
                },
                // %r - time in a.m. and p.m. notation equal to %I:%M:%S %p
                r: '%I:%M:%S %p',
                // %R - time in 24 hour notation equal to %H:%M
                R: '%H:%M',
                // %s - Unix Epoch Time timestamp
                s: function (d) {
                    return fint(d / 1000);
                },
                // %S - second as a decimal number
                S: function (d) {
                    return pad(d.getSeconds());
                },
                // %t - tab character
                t: '\t',
                // %T - current time, equal to %H:%M:%S
                T: '%H:%M:%S',
                // %u - weekday as a decimal number [1,7], with 1 representing Monday
                u: function (d) {
                    return d.getDay() || 7;
                },
                // %U - week number of the current year as a decimal number, starting with
                //      the first Sunday as the first day of the first week
                U: function (d) {
                    var doy = fint(formats.j(d)),
                        rdow = 6 - d.getDay();
                    return pad(fint((doy + rdow) / 7));
                },
                // %V - The ISO 8601:1988 week number of the current year as a decimal number,
                //      range 01 to 53, where week 1 is the first week that has at least 4 days
                //      in the current year, and with Monday as the first day of the week.
                V: function (d) {
                    var woy = fint(formats.W(d)),
                        dow1d1 = new Date(d.getFullYear() + '/1/1').getDay(),

                        // First week is 01 and not 00 as in the case of %U and %W,
                        // so we add 1 to the final result except if day 1 of the year
                        // is a Monday (then %W returns 01).
                        // We also need to subtract 1 if the day 1 of the year is
                        // Friday-Sunday, so the resulting equation becomes:
                        idow = woy + (dow1d1 > 4 || dow1d1 <= 1 ? 0 : 1);

                    if (idow === 53 && new Date(d.getFullYear() + '/12/31').getDay() < 4) {
                        idow = 1;
                    } else if (idow === 0) {
                        idow = formats.V(new Date((d.getFullYear() - 1) + '/12/31'));
                    }
                    return pad(idow, 0);
                },
                // %w - day of the week as a decimal, Sunday being 0
                w: function (d) {
                    return d.getDay();
                },
                // %W - week number of the current year as a decimal number, starting with the
                //      first Monday as the first day of the first week
                W: function (d) {
                    var doy = fint(formats.j(d)),
                        rdow = 7 - formats.u(d);
                    return pad(fint((doy + rdow) / 7));
                },
                // %x - preferred date representation for the current locale without the time
                x: locales.x,
                // %X - preferred time representation for the current locale without the date
                X: locales.X,
                // %y - year as a decimal number without a century (range 00 to 99)
                y: function (d) {
                    return pad(d.getFullYear() % 100);
                },
                // %Y - year as a decimal number including the century
                Y: function (d) {
                    return d.getFullYear();
                },
                // %z - numerical time zone representation
                z: function (d, utc) {
                    var o = utc ? 0 : d.getTimezoneOffset(),
                        H = pad(fint(Math.abs(o / 60))),
                        M = pad(o % 60);
                    return (o > 0 ? '-' : '+') + H + M;
                },
                // %Z - time zone name or abbreviation (from YUI3)
                Z: function (d, utc) {
                    /*jslint regexp:true*/
                    var tz;
                    if (utc) {
                        tz = 'UTC';
                    } else {
                        tz = d.toString()
                            .replace(/^.*:\d\d( GMT[+\-]\d+)? \(?([A-Za-z ]+)\)?\d*$/, "$2")
                            .replace(/[a-z ]/g, "");
                        if (tz.length > 4) {
                            tz = formats.z(d);
                        }
                    }
                    return tz;
                },
                // %% - a literal `\%' character
                '%': '%'
            };

        /**
         * Javascript implementation of strftime.
         *
         * > Implements strftime for the Date object in javascript based on the PHP implementation described at http://www.php.net/strftime
         * > This is in turn based on the Open Group specification defined at http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html
         * > This implementation does not include modified conversion specifiers (i.e., Ex and Ox).
         *
         * @param {Date} date the date to format
         * @param {String} fmt - The format to format the date in, this may be a combination of the supported format specifiers
         *
         * List of supported format specifiers:
         *
         * - %a - abbreviated weekday name according to the current locale
         * - %A - full weekday name according to the current locale
         * - %b - abbreviated month name according to the current locale
         * - %B - full month name according to the current locale
         * - %c - preferred date and time representation for the current locale
         * - %C - century number (the year divided by 100 and truncated to an integer, range 00 to 99)
         * - %d - day of the month as a decimal number (range 01 to 31)
         * - %D - same as m/d/y
         * - %e - day of the month as a decimal number, a single digit is preceded by a space (range ' 1' to '31')
         * - %g - like G, but without the century
         * - %G - The 4-digit year corresponding to the ISO week number
         * - %h - same as b
         * - %H - hour as a decimal number using a 24-hour clock (range 00 to 23)
         * - %I - hour as a decimal number using a 12-hour clock (range 01 to 12)
         * - %j - day of the year as a decimal number (range 001 to 366)
         * - %m - month as a decimal number (range 01 to 12)
         * - %M - minute as a decimal number
         * - %n - newline character
         * - %p - either `AM' or `PM' according to the given time value, or the corresponding strings for the current locale
         * - %P - like p, but lower case
         * - %r - time in a.m. and p.m. notation equal to I:M:S p
         * - %R - time in 24 hour notation equal to H:M
         * - %S - second as a decimal number
         * - %t - tab character
         * - %T - current time, equal to H:M:S
         * - %u - weekday as a decimal number [1,7], with 1 representing Monday
         * - %U - week number of the current year as a decimal number, starting with the first Sunday as the first day of the first week
         * - %V - The ISO 8601:1988 week number of the current year as a decimal number,
         * range 01 to 53, where week 1 is the first week that has at least 4 days in the current year, and with Monday as the first day of the week.
         * - %w - day of the week as a decimal, Sunday being 0
         * - %W - week number of the current year as a decimal number, starting with the first Monday as the first day of the first week
         * - %x - preferred date representation for the current locale without the time
         * - %X - preferred time representation for the current locale without the date
         * - %y - year as a decimal number without a century (range 00 to 99)
         * - %Y - year as a decimal number including the century
         * - %z - numerical time zone representation
         * - %Z - time zone name or abbreviation
         * - % - a literal `%' character
         * @return {String} A string representation of the date formatted based on the passed in parameter.
         *
         * @example
         * // Simple Example
         * var d = new Date();
         * var ymd = UWA.Date.strftime(d, '%Y/%m/%d');
         * var iso = UWA.Date.strftime(d, '%Y-%m-%dT%H:%M:%S%z');
         *
         * // To get the current time in hours and minutes:
         * var d = new Date();
         * UWA.Date.strftime(d, "%H:%M");
         *
         * // To get the current time with seconds in AM/PM notation:
         * var d = new Date();
         * UWA.Date.strftime(d, "%r");
         *
         * // To get the year and day of the year for August 23, 2009:
         * var d = new Date('2009/8/23');
         * UWA.Date.strftime(d, "%Y-%j");
         *
         * @see {@link http://tech.bluesmoon.info/2008/04/strftime-in-javascript.html}
         * @see php documentation: {@link http://fr.php.net/strftime}
         * @see documentation: {@link http://www.cplusplus.com/reference/clibrary/ctime/strftime/}
         *
         * @alias UWA.Date.strftime
         * @memberOf module:UWA/Date
         */
        return function (localDate, fmt, utc) {
            var date;

            if (utc) {
                // To format a date as a UTC string, we have two choices: either
                // use Date:getUTC* methods instead of regular ones, or shift the
                // date to be UTCish so the regular methods returns the UTC values.
                // I chose the second choice, because I think it is more efficient.
                // There is one drawback, though: the timezone value will be false,
                // so we'll have to handle this later.
                date = new Date(Number(localDate) + 6e4 * localDate.getTimezoneOffset());
            } else {
                date = localDate;
            }

            return fmt.replace(/%[A-Za-z%]/g, function (m) {
                var f = formats[m.slice(1)],
                    result;

                if (f === undefined) {
                    result = m;
                } else if (typeof f === 'string') {
                    if (f !== '%' && f.indexOf('%') >= 0) {
                        result = Module.strftime(localDate, f, utc);
                    } else {
                        result = f;
                    }
                } else {
                    result = f(date, utc);
                }
                return result;
            });
        };
    }());

    Deprecate.uncurryAlias(Module, Date.prototype, 'UWA.Date', 'Date');

    // The previous module used to return the native Date constructor. Let's return an
    // object that looks like this but print deprecation messages when using it.
    function FakeDate() {
        Deprecate.warn('UWA/Date as a constructor', 'Use the native Date instead.');

        // ES5 equivalent to: new Date(...arguments);
        var args = Array.prototype.slice.call(arguments);
        args.unshift(null);
        return new (Date.bind.apply(Date, args))();
    }

    // Deprecate popular methods
    [ 'now', 'parse', 'UTC' ].forEach(function (method) {
        FakeDate[method] = Deprecate.alias(
            'UWA/Date.' + method,
            'Use the native Date.' + method + ' instead',
            Date[method]
        );
    });

    Object.assign(FakeDate, Module);

    return UWA.namespace('Date', FakeDate, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Object utility functions
 *
 * @module   UWA/Object
 */
define('UWA/Object', [
    'UWA/Core',
    'UWA/Internal/Deprecate'
], function (UWA, Deprecate) {
    'use strict';

    // The previous module used to return the native Object constructor. Let's return an
    // object that looks like this but print deprecation messages when using it.
    function FakeObject() {
        Deprecate.warn('UWA/Object as a constructor', 'Use the native Object instead.');
        return Object.apply(null, arguments);
    }

    // Deperecate popular methods
    [
        'assign',
        'create',
        'defineProperty',
        'defineProperties',
        'freeze',
        'getOwnPropertyDescriptor',
        'getOwnPropertyNames',
        'getPrototypeOf',
        'isExtensible',
        'isFrozen',
        'isSealed',
        'keys',
        'preventExtensions',
        'seal',
        'setPrototypeOf'
    ].forEach(function (method) {
        FakeObject[method] = Deprecate.alias(
            'UWA/Object.' + method,
            'Use the native Object.' + method + ' instead',
            Object[method]
        );
    });

    return UWA.namespace('Object', FakeObject, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, unescape, escape, document
*/

/**
 * Contains UWA utils functions that is not part of the Core or Native Objects for
 * manipulate String (URLs, Simple Cryptography), Array, and inject CSS styles.
 *
 * @module   UWA/Utils
 *
 */
define('UWA/Utils', [
    'UWA/Core',
    'UWA/Array',
    'UWA/Internal/Immediate'
], function (UWA, UWAArray, Immediate) {
    'use strict';

    var Utils,
        B64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    var global = UWA.getGlobal();

    Utils = {

        buildUrl: (function () {

            var defaultScheme = (
                global.location && global.location.protocol ?
                    global.location.protocol : 'http:'
            );

            function removeDotSegments(input) {

                var output = [];

                function handleDotSegments(p) {
                    if (p === '/..') {
                        output.pop();
                    } else {
                        output.push(p);
                    }
                }

                input.replace(/^(\.\.?(\/|$))+/, '')
                     .replace(/\/(\.(\/|$))+/g, '/')
                     .replace(/\/\.\.$/, '/../')
                     .replace(/\/?[^\/]*/g, handleDotSegments);

                return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
            }

            /**
             * Build an url from linkHref param in same context than widgetUrl param.
             *
             * @example
             * UWA.Utils.buildUrl("http://example.org/mywidget.html", "/index.html");
             * // will return "http://example.org/index.html"
             *
             * @param {String} url - A full absolute url (e.g "http://example.org")
             * @param {String} href - Another url or simple file path (e.g. "/index.html")
             * @return {String} A new url related to widgetUrl url absolute value.
             *
             * @alias UWA.Utils.buildUrl
             * @memberOf module:UWA/Utils
             */
            return function (url, href) {

                // Cast to string to handle window.location for example.
                url = String(url);
                href = String(href);

                if (!Utils.isAbsoluteUrl(url)) {
                    throw new Error('First argument should be a absolute url.');
                }

                // protocol less support
                if (url.substring(0, 2) === '//') {
                    url = defaultScheme + url;
                }

                var i, l,
                    splitScheme = String(url).split('://'),
                    scheme = splitScheme[0],
                    resource = splitScheme[1],
                    splitDirectory = resource.split('/'),
                    domain = splitDirectory[0],
                    path = '';

                // protocol less
                if (href.substring(0, 2) === '//') {
                    url = scheme + ':' + href;

                // complete
                } else if (href.split('://').length > 1) {
                    url = href;

                // absolute
                } else if (href.substring(0, 1) === '/') {
                    url = scheme + '://' + domain + href;

                // relative
                } else {

                    for (i = 1, l = splitDirectory.length - 1; i < l; i++) {
                        path += '/' + splitDirectory[i];
                    }

                    url = scheme + '://' + domain + removeDotSegments(path + '/' + href);
                }

                return url;
            };
        }()),

        /**
         * Parse an Url to extract uri parts (protocol, domain, ...). The URL should include the protocol (http://).
         *
         * @example
         * UWA.Utils.parseUrl("http://me@example.com:80");
         * // will return {"source":"http://me@example.com:80","protocol":"http","authority":"me@example.com:80","domain":"me@example.com","port":"80",...}
         *
         * @param {String} sourceUri - A valid url (e.g. "http://netvibes.com")
         * @return {Object} Object with following properties: source, protocol, authority, domain, port, path, directoryPath, fileName, query, anchor.
         *
         * @alias UWA.Utils.parseUrl
         * @memberOf module:UWA/Utils
         */
        parseUrl: (function () {

            var uriPartNames = ['source', 'subprotocol', 'protocol', 'authority', 'user', 'password', 'domain', 'port', 'path', 'directoryPath', 'fileName', 'query', 'anchor'],
                uriPartRegExp = new RegExp("^" +
                    "(?:(?:(?:([^#.:]+):)?([^#.:]+):)?//)?" + // subprotocol / protocol
                    "((?:([^:/]+)(?::([^/]*?))?@)?" +             // authority (user / password /
                    "([^:/?#]*)(?::(\\d*))?)?" +              // domain / port)
                    "((/(?:[^?#](?![^?#/]*\\.[^?#/.]+(?:[\\?#]|$)))*/?)?([^?#/]*))?" + // path (directoryPath / fileName)
                    "(?:\\?([^#]*))?" + // query
                    "(?:#(.*))?"        // anchor
                );

            return function (sourceUri) {

                var i,
                    uriParts = uriPartRegExp.exec(sourceUri),
                    uri = {};

                for (i = 0; i < uriPartNames.length; i++) {
                    uri[uriPartNames[i]] = (uriParts[i] || '');
                }

                // Remove subprotocol from source
                if (uri.subprotocol) {
                    uri.source = uri.source.substr(uri.subprotocol.length + 1);
                }

                // Default port (as String)
                if (!uri.port) {
                    uri.port = uri.protocol === 'https' ? '443' : '80';
                }

                // Always end directoryPath with a trailing backslash if a path was present in the source URI
                // Note that a trailing backslash is NOT automatically inserted within or appended to the "path" key
                if (uri.directoryPath && uri.directoryPath.length > 0) {
                    uri.directoryPath = uri.directoryPath.replace(/\/?$/, "/");
                }

                // DNS RFCs says hostnames are case insensitive
                uri.domain = uri.domain.toLocaleLowerCase();
                uri.protocol = uri.protocol.toLocaleLowerCase();

                return uri;
            };
        }()),

        /**
         * Build an Url to from uri parts (protocol, domain, ...).
         *
         * @example
         * UWA.Utils.composeUrl({
         *    protocol: "https",
         *    subprotocol: "feed",
         *    authority: "example.org:8080",
         *    domain: "example.org",
         *    port: "8080",
         *    path: "/mypath/mywidget.html",
         *    directoryPath: "/mypath/",
         *    fileName: "mywidget.html",
         *    query: "lorem=ipsum&hello=world",
         *    anchor: "sit"
         * });
         * // will return "feed:https://example.org:8080/mypath/mywidget.html?lorem=ipsum&hello=world#sit"
         *
         *
         * @param {String} parts - An object with following properties: source, protocol, authority, domain, port, path, directoryPath, fileName, query, anchor
         * @return {String} A valid url (e.g. "http://netvibes.com").
         *
         * @alias UWA.Utils.composeUrl
         * @memberOf module:UWA/Utils
         */
        composeUrl: function (parts) {

            var result = '';

            if (parts.protocol) {
                result = parts.protocol + '://';
                if (parts.subprotocol) {
                    result = parts.subprotocol + ':' + result;
                }
            }

            if (parts.domain) {
                result += parts.domain;
                if (
                    parts.port &&
                        (parts.protocol !== 'http' || parseInt(parts.port, 10) !== 80) &&
                            (parts.protocol !== 'https' || parseInt(parts.port, 10) !== 443)
                ) {
                    result += ':' + parts.port;
                }
            } else if (parts.authority) {
                result += parts.authority;
            }

            if (parts.path) {
                result += parts.path;
            }

            if (parts.query) {
                result += '?' + parts.query;
            }

            if (parts.anchor) {
                result += '#' + parts.anchor;
            }

            return result;
        },

        /**
         * Compare two url to check if their domain, protocol and port match.
         *
         * @example
         * // Following will return `true`
         * UWA.Utils.matchUrl('http://example.com/mypath/index.html', '/mypath/index.html');
         * UWA.Utils.matchUrl('http://example.com/mypath/index.html', 'mypath/index.html');
         * UWA.Utils.matchUrl('http://example.com/mypath/index.html', 'http://example.com/index.html');
         *
         * // Following will return `false`
         * UWA.Utils.matchUrl('http://example.com/mypath/index.html', 'http://example.org/mypath/index.html');
         * UWA.Utils.matchUrl('http://example.com/mypath/index.html', 'https://example.com/mypath/index.html');
         *
         * @param {String} originaUrl - First url to compare
         * @param {String} requestUrl - Second url to compare
         * @return {Boolean} `true` if urls match else `false`.
         *
         * @alias UWA.Utils.matchUrl
         * @memberOf module:UWA/Utils
         */
        matchUrl: function (originaUrl, requestUrl) {

            var originalUrlParts, requestUrlParts,
                matchUrl = false,
                originalIsAbsolute = Utils.isAbsoluteUrl(originaUrl),
                requestIsAbsolute = Utils.isAbsoluteUrl(requestUrl);

            // If both are relative then match
            if (!originalIsAbsolute && !requestIsAbsolute) {
                matchUrl = true;

            // Else process check
            } else {

                // If one url is not relative fix it using buildUrl.
                // like that we support "/apps/index.html" and "apps/index.html".
                if (!originalIsAbsolute) {
                    originaUrl = Utils.buildUrl(requestUrl, originaUrl);
                } else if (!requestIsAbsolute) {
                    requestUrl = Utils.buildUrl(originaUrl, requestUrl);
                }

                originalUrlParts = Utils.parseUrl(originaUrl);
                requestUrlParts = Utils.parseUrl(requestUrl);

                matchUrl = ['domain', 'protocol', 'port'].every(function (name) {

                    // Pure match
                    return originalUrlParts[name] === requestUrlParts[name] ||
                        // Protocol less match
                        (name === 'protocol' && (originalUrlParts[name] === '' || requestUrlParts[name] === ''));
                });
            }

            return matchUrl;
        },

        isAbsoluteUrl: (function () {
            var re = /^((https?|ftp|file):)?\/\//;

            /**
             * Test if an URL is absolute.
             *
             * @example
             * UWA.Utils.isAbsoluteUrl('http://foo.com');
             * // will return true
             *
             * UWA.Utils.isAbsoluteUrl('/foo');
             * // will return false
             *
             * @param {String} url - the url to check
             * @return {Boolean} `true` if the URL is absolute.
             *
             * @alias UWA.Utils.isAbsoluteUrl
             * @memberOf module:UWA/Utils
             */
            return function (url) {
                return re.test(url);
            };
        }()),

        isValidUrl: (function () {

            // Based on http://mathiasbynens.be/demo/url-regex

            var protocol = '(?:((?:https?|ftp|file):)?\/\/)';
            var credentials = '(?:\\S+(?::\\S*)?@)?';
            var notIpAddress =
                '(?!(?:\\.\\d{1,3}){3})' +
                '(?!127(?:\\.\\d{1,3}){3})' +
                '(?!169\\.254(?:\\.\\d{1,3}){2})' +
                '(?!192\\.168(?:\\.\\d{1,3}){2})' +
                '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})';
            var ipAddress =
                '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' +
                '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' +
                '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))';

            var domainWord = '[a-z\\u00a1-\\uffff0-9]+';
            var dashedWords = '(?:' + domainWord + '-)*' + domainWord;
            var firstSubDomain = dashedWords;
            var domain = '(?:\\.' + dashedWords + ')*';
            var topLevelDomain = '\\.(?:[a-z\\u00a1-\\uffff]{2,})';
            var port = '(?::\\d{2,5})?';

            // Request parsing
            var letter = '[a-z0-9._~\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF!\\$&\'\\(\\)\\*\\+,;=:@-]';
            var encodedCharacter = '(?:%[\\da-f]{2})';
            var character = '(' + letter + '|' + encodedCharacter + ')';
            var word = character + '*';
            var extendedWord = '(' + character + '|[\\uE000-\\uF8FF]|\\/|\\?)*';
            var path = '(\\/(?!/)' + word + ')*';
            var query = '(\\?' + extendedWord + ')?';
            var hash = '(\\#' + extendedWord + ')?';
            var request = path + query + hash;

            var validUrl = new RegExp(
                '^' + protocol + credentials +
                '(?:' +
                notIpAddress + ipAddress +
                '|' +
                firstSubDomain + domain + topLevelDomain +
                ')' +
                port + request + '$',
                'i');

            var validRequest = new RegExp('^' + request + '$', 'i');

            /**
             * Test if an URL is valid.
             *
             * @example
             * UWA.Utils.isValidUrl('http://foo.com');
             * // will return true
             *
             * UWA.Utils.isValidUrl('/foo');
             * // will return true
             *
             * UWA.Utils.isValidUrl('//foo');
             * // will return false
             *
             * @param {String} url - the url to check
             * @return {Boolean} `true` if the URL is valid.
             *
             * @alias UWA.Utils.isValidUrl
             * @memberOf module:UWA/Utils
             */
            return function (url) {
                return (Utils.isAbsoluteUrl(url) ? validUrl : validRequest).test(url);
            };
        }()),


        /**
         * Simple encodeURIComponent wrapper to escape "." to "%2e" also.
         *
         * @example
         * UWA.Utils.encodeUrl("hello?/e;&.");
         * // will return "hello%3F%2Fe%3B%26%2e"
         *
         * @param {String} str - String to encode
         * @return {String} Encoded string.
         *
         * @alias UWA.Utils.encodeUrl
         * @memberOf module:UWA/Utils
         */
        encodeUrl: function (str) {
            return encodeURIComponent(str).replace(/\./g, '%2e');
        },

        /**
         * Decode an url string query string to an Object.
         *
         * @example
         * UWA.Utils.parseQuery('?example=1&array[0]=hello&array[1]=world');
         * // will return {"example":"1","array":{"0":"hello","1":"world"}}"
         *
         * @param {String} queryString - Query string to decode
         * @return {Object} Decoded query string indexed by query param key.
         *
         * @alias UWA.Utils.parseQuery
         * @memberOf module:UWA/Utils
         */
        parseQuery: function (queryString) {

            var vars = queryString.substring((queryString.indexOf('?')) + 1).split(/[&;]/),
                object = {};

            if (vars.length) {

                vars.forEach(function (val) {

                    var index = val.indexOf('=') + 1,
                        value = index ? val.substr(index) : '',
                        keys = index ? val.substr(0, index - 1).match(/([^\]\[]+|(\B)(?=\]))/g) : [val],
                        obj = object;

                    if (keys) {

                        value = decodeURIComponent(value);

                        keys.forEach(function (key, i) {

                            key = decodeURIComponent(key);

                            var current = obj[key];

                            if (i < keys.length - 1) {
                                obj = obj[key] = current || {};
                            } else if (Array.isArray(current)) {
                                current.push(value);
                            } else {
                                obj[key] = UWA.is(current) ? [current, value] : value;
                            }
                        });
                    }
                });
            }

            return object;
        },

        /**
         * Encode an Object to a url string.
         *
         * @example
         * UWA.Utils.toQueryString({
         *    example: 1,
         *    array: ['hello', 'world'],
         *    object: {key: 'value'}
         * });
         * // will return "example=1&array[0]=hello&array[1]=world"
         *
         * UWA.Utils.toQueryString({
         *    toQueryString: function () {
         *        return 'hello'
         *    }
         * });
         * // will return "hello"
         *
         * @param {Object} myObject - Object to encode
         * @param {Object} base - Sub object to encode
         * @return {String} Encoded string.
         *
         * @alias UWA.Utils.toQueryString
         * @memberOf module:UWA/Utils
         */
        toQueryString: function (myObject, base) {

            var key, value, result, queryString,
                is = UWA.is;

            if (is(myObject, 'string')) {
                queryString = myObject;

            } else if (is(myObject.toQueryString, 'function')) {
                queryString = myObject.toQueryString();

            } else {

                queryString = [];

                for (key in myObject) {
                    if (myObject.hasOwnProperty(key)) {

                        value = myObject[key];

                        if (base) {
                            key = base + '[' + key + ']';
                        }

                        if (is(value)) {
                            if (is(value, 'object') || is(value, 'array')) {
                                result = Utils.toQueryString(value, key);
                            } else if (!is(value, 'function')) {
                                result = Utils.encodeUrl(key) + '=' + Utils.encodeUrl(value);
                            }
                        }

                        if (result) {
                            queryString.push(result);
                        }

                        // Reset buffer
                        result = undefined;
                    }
                }

                queryString = queryString.join('&');
            }

            return queryString;
        },

        /**
         * Get GET param value from a query string.
         *
         * @example
         * UWA.Utils.getQueryString('example=hello', 'example');
         * // will return "hello"
         * UWA.Utils.getQueryString('http://example.com?example=hello', 'example');
         * // will return "hello"
         * UWA.Utils.getQueryString('http://example.com?example=hello', 'status');
         * // will return undefined
         * UWA.Utils.getQueryString('http://example.com?example=hello', 'status', 'bye');
         * // will return 'bye'
         *
         * @param {Object} query - Query to use as source
         * @param {Object} key - GET param key
         * @param {Object} Fallback - default value if missing
         * @return {Void} GET param value if available else fallback parameter value.
         *
         * @alias UWA.Utils.getQueryString
         * @memberOf module:UWA/Utils
         */
        getQueryString: function (query, key, fallback) {

            key = key.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");

            var queryString = new RegExp(key + '=([^&#]*)').exec(query);

            return (queryString ? decodeURIComponent(queryString[1]) : fallback);
        },

        /* Group: XML manipulation methods */

        /**
         * Convert a String into an XML Document.
         *
         * > You can navigate into the document nodes using childNodes, attributes,
         * > nodeType, nodeName and nodeValue properties.
         *
         * ##### Example
         *
         * ```
         * UWA.Utils.loadXml(
         *    '<items title="titleAttribute">' +
         *    '   <item name="item1" foo="bar">item1TagValue</item>' +
         *    '   <item name="item2" foo="bar">item2TagValue</item>' +
         *    '   <label>label1TagValue</label>' +
         *    '   <label>label2TagValue</label>' +
         *    '   <title type="foo">titleTagValue</title>' +
         *    '</items>'
         * );
         * // will return a Document object.
         * ```
         *
         * Example with xsl parameter:
         *
         * ```
         * var data = '<?xml version="1.0" encoding="utf-8"?>' +
         *        '<catalog>' +
         *        '    <cd>' +
         *        '        <title>Empire Burlesque</title>' +
         *        '        <artist>Bob Dylan</artist>' +
         *        '        <country>USA</country>' +
         *        '        <company>Columbia</company>' +
         *        '        <price>10.90</price>' +
         *        '        <year>1985</year>' +
         *        '    </cd>' +
         *        '    <cd>' +
         *        '        <title>Hide your heart</title> ' +
         *        '        <artist>Bonnie Tyler</artist>  ' +
         *        '        <country>UK</country>' +
         *        '        <company>CBS Records</company> ' +
         *        '        <price>9.90</price>' +
         *        '        <year>1988</year>' +
         *        '    </cd>' +
         *        '</catalog>',
         *
         *     template = '<?xml version="1.0" encoding="utf-8"?>' +
         *        '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' +
         *        '<xsl:template match="/">' +
         *        '  <div>' +
         *        '    <h2>My CD Collection</h2>' +
         *        '    <table width="100%">' +
         *        '      <tr bgcolor="#9acd32">' +
         *        '        <th>Title</th>' +
         *        '        <th>Artist</th>' +
         *        '      </tr>' +
         *        '      <xsl:for-each select="catalog/cd">' +
         *        '      <tr>' +
         *        '        <td><xsl:value-of select="title"/></td>' +
         *        '        <td><xsl:value-of select="artist"/></td>' +
         *        '      </tr>' +
         *        '      </xsl:for-each>' +
         *        '    </table>' +
         *        '  </div>' +
         *        '</xsl:template>' +
         *        '</xsl:stylesheet>';
         *
         * UWA.Utils.loadXml(data, template);
         * // will return a Document object.
         * ```
         *
         * @param {String} string - XML source
         * @param {Object} xsl - XSL template source to apply to the XML
         * @return {Document} The result of XML parsor.
         *
         * @alias UWA.Utils.loadXml
         * @memberOf module:UWA/Utils
         */
        loadXml: (function () {

            var matchHeaders = /<(DOCTYPE|xml)[^><]*>|<.(DOCTYPE|xml)[^><]*>/g,
                matchStyleAndSriptTags = /(<(style|script)[^>]*>)([\u0001-\uFFFF]*?)(<\/(style|script)>)/img,
                matchCDATA = /<!\[CDATA\[/;

            return function (string, xsl) {

                var xmlDoc, xsltDoc, xslt, xslProc, error;

                // Do not parse string if it's a document
                if (typeof string === 'object' && string.nodeType) {
                    xmlDoc = string;
                } else {

                    // Remove <?xml and DOCTYPE that make native parser fails
                    string = string.replace(matchHeaders, '');

                    // Here we add CDATA if missing on script and style tags to
                    // support legacy some legacy UWA widgets issues.
                    string = string.replace(matchStyleAndSriptTags, function () {

                        var matches = arguments,
                            tagOpen = matches[1],
                            tagContent = matches[3],
                            tagClose = matches[4];

                        if (!matchCDATA.test(tagContent)) {
                            tagContent = "<![CDATA[\n" + tagContent + "\n]]>";
                        }

                        return tagOpen + tagContent + tagClose;
                    });

                    // Mozilla and Netscape browsers
                    if (global.DOMParser) {

                        try {

                            xmlDoc = new global.DOMParser();
                            xmlDoc = xmlDoc.parseFromString(string, 'application/xml');

                            // Handle Error
                            error = xmlDoc.getElementsByTagName('parsererror')[0];

                            if (error) {
                                throw new Error(error.textContent || error.innerText);
                            }

                        } catch (e) {
                            throw new Error('Invalid XML: ' + e.message);
                        }

                    // Internet Explorer
                    } else if (global.ActiveXObject) {

                        xmlDoc = new global.ActiveXObject("MSXML2.DOMDocument");
                        xmlDoc.setProperty("SelectionLanguage", "XPath");
                        //xmlDoc.setProperty("SelectionNamespaces", "xmlns:widget='http://www.netvibes.com/ns/'");
                        xmlDoc.validateOnParse = false;
                        xmlDoc.resolveExternals = false;
                        xmlDoc.preserveWhiteSpace = false;
                        xmlDoc.async = false;
                        xmlDoc.loadXML(string);

                        // Handle Error
                        if (xmlDoc.parseError.errorCode !== 0) {
                            throw new Error('Invalid XML: ' + xmlDoc.parseError.line + ', ' + xmlDoc.parseError.reason);
                        }
                    } else {
                        throw new Error('No native XML parser available.');
                    }
                }

                // Handle XSLT
                if (xsl) {
                    if (global.XSLTProcessor) {
                        xsltDoc = new global.XSLTProcessor();
                        xsltDoc.importStylesheet(Utils.loadXml(xsl));
                        xmlDoc = xsltDoc.transformToDocument(xmlDoc, document);
                    } else {

                        xsltDoc = new global.ActiveXObject("Msxml2.FreeThreadedDOMDocument");
                        xsltDoc.loadXML(Utils.xmlToString(xsl));

                        xslt = new global.ActiveXObject("Msxml2.XSLTemplate");
                        xslt.stylesheet = xsltDoc;
                        xslProc = xslt.createProcessor();
                        xslProc.input = xmlDoc;
                        xslProc.transform();

                        xmlDoc = Utils.loadXml(xslProc.output);
                    }
                }

                return xmlDoc;
            };

        }()),

        /**
         * Convert a String into an HTML Document.
         *
         * __Notes:__
         * * This function support also non XHTML markup (e.g <img> VS <img/>)
         * * You can navigate into the document nodes using childNodes, attributes,
         * nodeType, nodeName and nodeValue properties.
         * * following tags may ignored for security reason on old platform:
         * script, embed, object, frameset, frame, iframe, meta, link, style.
         *
         * @param {String} string - HTML or XHTML source
         * @return {Document} The result of HTML parsor.
         *
         * @alias UWA.Utils.loadHtml
         * @memberOf module:UWA/Utils
         */
        loadHtml: (function () {

            // http://stackoverflow.com/questions/7474710/can-i-load-an-entire-html-document-into-a-document-fragment-in-internet-explorer
            var stripTags = new RegExp('<\/?(script|embed|object|frameset|frame|iframe|meta|link|style)(.|\n)*?>', 'img'), // eslint-disable-line no-control-regex
                stripAttributes = new RegExp('<([a-z][a-z0-9]*)(?:[^>]*(\s(src|href|title|style|alt|height|width|data-([a-z][a-z0-9]*))=[\'"][^\'"]*[\'"]))?[^>]*?(\/?)>', 'im');

            function sanitizeHTML(markup) {

                // Remove script|embed|object|frameset|frame|iframe|meta|link|style tags
                markup = markup.replace(stripTags, '');

                // Remove all attributes and keep only src|href|title|style|alt|height|width|data-*
                markup = markup.replace(stripAttributes, '<$1$2$4>');

                return markup;
            }

            return function (markup) {

                var doc, docElt, firstElt, iframe;

                // 1. Use standard DOMParser (DOM level 3)
                if (global.DOMParser) {
                    try {
                        // Firefox/Opera/IE throw errors on unsupported types
                        // WebKit returns null on unsupported types
                        doc = new global.DOMParser().parseFromString(markup, "text/html");
                    } catch (DOMParserError) {
                        // Ignore error
                    }
                }

                // 2. Use createHTMLDocument and innerHTML (DOM Level 2)
                if (
                    !doc &&
                        document.implementation.createHTMLDocument
                ) {

                    try {

                        doc = document.implementation.createHTMLDocument("");
                        docElt = doc.documentElement;

                        docElt.innerHTML = markup;
                        firstElt = docElt.firstElementChild;

                        if (
                            docElt.childElementCount === 1 &&
                                firstElt.localName.toLowerCase() === "html"
                        ) {
                            doc.replaceChild(firstElt, docElt);
                        }

                    // IE possible CRIPT600: Invalid target element for this operation.
                    } catch (HTMLDocumentError) {
                        // Ignore error
                        doc = null;
                    }
                }

                // Cleanup markup, because all technic above also
                //execute script and others DOM events.
                markup = sanitizeHTML(markup);

                // 4. Use IE ActiveXObject htmlfile (IE 5.01+ support)
                if (
                    !doc &&
                        global.ActiveXObject
                ) {
                    try {
                        doc = new global.ActiveXObject('htmlfile');
                        doc.write(markup);
                        doc.close();
                    } catch (ActiveXObjectError) {
                        // Ignore error
                        doc = null;
                    }
                }

                // 5. Use AsyncFrame (DOM Level 1)
                if (!doc) {

                    iframe = document.createElement('iframe');
                    iframe.style.display = 'none';

                    document.body.appendChild(iframe);
                    doc = iframe.contentDocument || iframe.contentWindow.document;
                    doc.write(markup);
                    doc.close();

                    /// Remove Frame ASAP
                    document.body.removeChild(iframe);
                    //delete iframe;
                }

                return doc;
            };
        }()),

        /**
         * Convert an XML document into DOM elements tree.
         *
         * ##### Example
         *
         * ```
         * UWA.Utils.xmlToHtml(
         *    '<items title="titleAttribute">' +
         *    '   <item name="item1" foo="bar">item1TagValue</item>' +
         *    '   <item name="item2" foo="bar">item2TagValue</item>' +
         *    '   <label>label1TagValue</label>' +
         *    '   <label>label2TagValue</label>' +
         *    '   <title type="foo">titleTagValue</title>' +
         *    '</items>'
         * );
         * // will return a Element object.
         * ```
         *
         * @param {String|Document} string - XML String source or Document instance
         *    result from UWA.Data.getXML or UWA.Utils.loadXml.
         * @return {Element} Root node that result of XML to XHTML conversion.
         *
         * @alias UWA.Utils.xmlToHtml
         * @memberOf module:UWA/Utils
         */
        xmlToHtml: function (xml) {

            if (typeof xml === 'string') {
                xml = Utils.loadXml(xml);
            }

            // Get first document node childNode
            if (xml.nodeType === 9) {
                xml = xml.childNodes[0];
            }

            var attribute, childNode, i, l,
                nodeName = xml.nodeName.toLowerCase(),
                element = document.createElement(nodeName),
                childNodes = xml.childNodes,
                attributes = xml.attributes || [];

            // Convert attributes
            for (i = 0, l = attributes.length; i < l; i++) {
                attribute = attributes[i];
                element.setAttribute(attribute.name, attribute.value);
            }

            // Convert childNodes
            for (i = 0, l = childNodes.length; i < l; i++) {

                childNode = childNodes[i];

                switch (childNode.nodeType) {
                case 1:
                    element.appendChild(Utils.xmlToHtml(childNode));
                    break;
                case 3:
                    // Handle IE styleSheet
                    if (nodeName === 'style' && element.styleSheet) {
                        element.styleSheet.cssText = childNode.nodeValue;
                    } else {
                        element.appendChild(document.createTextNode(childNode.nodeValue));
                    }
                    break;
                case 4:
                case 8:
                    // assuming .text works in every browser
                    if (nodeName === 'script') {
                        element.text = childNode.nodeValue;
                    } else {
                        element.appendChild(document.createComment(childNode.nodeValue));
                    }
                    break;
                }
            }

            return element;
        },

        /**
         * Convert a XML document into an indented XML string.
         *
         * ##### Example
         *
         * ```
         * UWA.Utils.xmlToString(UWA.Utils.loadXml(
         *    '<items title="titleAttribute">' +
         *    '   <item name="item1" foo="bar">item1TagValue</item>' +
         *    '   <item name="item2" foo="bar">item2TagValue</item>' +
         *    '   <label>label1TagValue</label>' +
         *    '   <label>label2TagValue</label>' +
         *    '   <title type="foo">titleTagValue</title>' +
         *    "   <text><![CDATA[ Hello \r\n\t\r\n World! ]]></text>" +
         *    '</items>'
         * ));
         * // will return a String.
         * ```
         *
         * @param {Document} xmlDoc - XML document to serialize
         * @return {String} XML string indented source.
         *
         * @alias UWA.Utils.xmlToString
         * @memberOf module:UWA/Utils
         */
        xmlToString: (function () {

            function xmlStringIndent(xmlSource) {

                // Could be also using xsl, but IE does not like it and remove line break.
                // Need more investigation.
                /*
                // http://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript
                xslSource = '<?xml version="1.0" encoding="utf-8"?>' +
                    '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' +
                        '<xsl:output omit-xml-declaration="yes" indent="yes"></xsl:output>' +
                        '<xsl:template match="node()|@*">' +
                            ' <xsl:copy>' +
                            '   <xsl:apply-templates select="node()|@*"/>' +
                            ' </xsl:copy>' +
                        '</xsl:template>' +
                    '</xsl:stylesheet>';

                xmlSource = Utils.loadXml(xmlDoc, xslSource);
                */

                var xmlLines, nextNodeIsData, prevNodeIsData, nodeIsData,
                    pad = 0;

                // Add line break after each tags.
                xmlLines = xmlSource.trim().replace(/(>)(\s+)?(<)(\/*)/g, '$1\r\n$3$4').split('>\r\n');

                // Reset source.
                xmlSource = '';

                // Indente the XML source.
                xmlLines.forEach(function (node, index) {

                    var i,
                        indent = 0,
                        padding = '',
                        lineBreak = '\r\n';

                    if (index !== xmlLines.length - 1) {
                        node = node + '>';
                    }

                    prevNodeIsData = nodeIsData;
                    nodeIsData = nextNodeIsData;
                    nextNodeIsData = /(<!\[CDATA\[)|(\]\]>)/.test(xmlLines[index + 1] || '');

                    if (node.match(/.+<\/\w[^>]*>$/)) {
                        indent = 0;
                    } else if (node.match(/^<\/\w/)) {
                        if (pad !== 0) {
                            pad -= 1;
                        }
                    } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                        indent = 1;
                    }

                    for (i = 0; i < pad; i++) {
                        padding += '  ';
                    }

                    if (
                        nextNodeIsData ||
                            (nodeIsData && !nextNodeIsData)
                    ) {
                        lineBreak = '';
                    }

                    if (
                        nodeIsData ||
                            (prevNodeIsData && !nodeIsData)
                    ) {
                        padding = '';
                    }

                    xmlSource += padding + node + lineBreak;
                    pad += indent;
                });

                return xmlSource;
            }

            return function (xmlDoc, indent) {

                var xmlSource;

                // Support for string argument
                if (typeof xmlDoc === 'string') {
                    xmlSource = xmlDoc;

                 // Support for object argument
                } else if (global.XMLSerializer) {
                    // XMLSerializer exists in current Mozilla browsers
                    xmlSource = new global.XMLSerializer();
                    xmlSource = xmlSource.serializeToString(xmlDoc);

                } else {
                    // Internet Explorer has a different approach to serializing XML
                    xmlSource = xmlDoc.xml;
                }

                if (indent) {
                    xmlSource = xmlStringIndent(xmlSource);
                }

                return xmlSource.trim();
            };
        }()),

        /* Group: Content manipulation methods */

        /**
         * Add a <styles> tag to current document with specific id.
         *
         * #### Example
         *
         * ```html
         * UWA.Utils.setCss("myStyle", "a.myClass { color: red; }", ".myNamespace");
         * // will insert:
         * <style id="myStyle"> .myNamespace a.myClass { color: red; } </style>
         *
         * UWA.Utils.setCss("myStyle", "body a.myClass { color: red; }", ".myNamespace");
         * // will insert:
         * <style id="myStyle">body .myNamespace a.myClass { color: red; } </style>
         *
         * UWA.Utils.setCss(
         *    "myStyle",
         *    ".firstClass ul>li, .secondClass { font: 1.1em/1.3em Tahoma, Bitstream Vera Sans, sans-serif;} .thirdClass {}",
         *    ".myNamespace"
         * );
         * // will insert:
         * <style id="myStyle">
         * .myNamespace .firstClass ul>li,
         * .myNamespace .secondClass { font: 1.1em/1.3em Tahoma, Bitstream Vera Sans, sans-serif;}
         * .myNamespace .thirdClass {  }"
         * </style>
         *
         * UWA.Utils.setCss("myStyle", "a.myClass { color: red; }");
         * // will insert with no namespace:
         * <style id="myStyle"> a.myClass { color: red; } </style>
         * ```
         *
         * @param {String} id - Style tag id attribute
         * @param {String} content - Style tag CSS content (e.g. "a.myClass { color: red; }")
         * @param {String} [namespace] - To avoid conflict you can add a prefix to id
         *
         * @alias UWA.Utils.setCss
         * @memberOf module:UWA/Utils
         */
        setCss: (function () {

            /**
             * Return a recursive structure containing the whole CSS splitted with braces
             * @example
             * parseBraces(`
             * @media rule {
             *   .foo {
             *     width: 100px;
             *   }
             * }
             * `);
             * // returns something like:
             * [
             *   {
             *     prefix: '@media rule ',
             *     children: [
             *       prefix: '\n  .foo ',
             *       content: '\n    width: 100px;\n  ',
             *       chidren: [],
             *     ],
             *     content: '\n'
             * ];
             */
            function parseBraces(s) {
                var openBrace = /\{/g;
                var closeBrace = /\}/g;
                var lastIndex = 0;
                var moreCloseBrace = closeBrace.test(s);
                var moreOpenBrace = openBrace.test(s);

                var root = [];
                var element = {children: root};

                while (true) {

                    if (moreOpenBrace && openBrace.lastIndex < closeBrace.lastIndex) {
                        var child = {
                            prefix: s.slice(lastIndex, openBrace.lastIndex - 1),
                            parent: element,
                            content: '',
                            children: []
                        };
                        element.children.push(child);
                        element = child;
                        lastIndex = openBrace.lastIndex;
                        moreOpenBrace = openBrace.test(s); // Jump to next open brace
                    } else if (moreCloseBrace) {
                        element.content = s.slice(lastIndex, closeBrace.lastIndex - 1);
                        if (element.parent) {
                            element = element.parent;
                        }
                        lastIndex = closeBrace.lastIndex;
                        moreCloseBrace = closeBrace.test(s); // Jump to next close brace
                    } else {
                        break;
                    }

                }

                return root;
            }

            function splitSelectors(parsed, areDeclarations) {
                parsed.forEach(function (declaration) {
                    var prefix = declaration.prefix.trim();
                    if (prefix[0] !== '@' && areDeclarations !== false) {
                        declaration.selectors = UWAArray.invoke(prefix.split(','), 'trim');
                    }
                    splitSelectors(declaration.children, !prefix.startsWith('@keyframes'));
                });
            }

            function prefixSelector(prefix, selector) {
                // If the selector has 'body' or 'html', we have to put the
                // namespace after that
                var hasBody = selector.match(/^[\s\S]*(?:^|\s)(?:body|html)\b(\S*)/);
                var before, after;
                if (hasBody) {
                    before = selector.slice(0, hasBody[0].length).trim() + ' ';
                    after = selector.slice(hasBody[0].length).trim();
                } else {
                    before = '';
                    after = selector;
                }

                // Remove the starting .module prefix on the selector
                after = after.replace(/^\.module\b\S*\s/, '');

                // Prepend the namespace if the selector doesn't already start with it
                if (!after.startsWith(prefix + ' ')) {
                    after = prefix + ' ' + after;
                }

                return before + after;
            }

            function prefixSelectors(parsed, prefix) {
                parsed.forEach(function (declaration) {
                    if (declaration.selectors) {
                        var i, l;
                        for (i = 0, l = declaration.selectors.length; i < l; i++) {
                            declaration.selectors[i] = prefixSelector(prefix, declaration.selectors[i]);
                        }
                    } else {
                        prefixSelectors(declaration.children, prefix);
                    }
                });
            }

            function makeAbsolutePaths(parsed, root) {
                parsed.forEach(function (declaration) {
                    declaration.content = declaration.content.replace(/\burl\(["']?([\s\S]*?)["']?\)/g, function (whole, url) {
                        if (!Utils.isAbsoluteUrl(url)) {
                            url = Utils.buildUrl(root, url);
                        }
                        return 'url("' + url + '")';
                    });
                });
            }

            function joinBraces(parsed) {
                return parsed.map(function (declaration) {
                    var prefix = declaration.selectors ? declaration.selectors.join(',\n') + ' ' : declaration.prefix;
                    return prefix + '{' + joinBraces(declaration.children) + declaration.content + '}';
                }).join('\n');
            }

            function injectStyle(styles, id) {
                // Inject the style
                var styleTag = document.getElementById(id);
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.setAttribute('id', id);
                    styleTag.setAttribute('type', 'text/css');
                    var headTag = document.getElementsByTagName('head').item(0);
                    headTag.appendChild(styleTag);
                }

                // IE
                if (styleTag.styleSheet) {
                    styleTag.styleSheet.cssText = styles;

                // W3Cs
                } else {
                    styleTag.appendChild(document.createTextNode(styles));
                }

            }

            return function (id, styles, namespace, root) {

                // Default working values
                namespace = namespace ? namespace.trim() : '';

                styles = Array.isArray(styles) ? styles.join("\n") : String(styles);

                if (!id) {
                    id = Utils.getCheckSum(styles);
                }

                // Remove styles comments
                styles = styles.replace(/\/\*[\s\S]*?\*\//g, '');

                var parsed = parseBraces(styles);

                // Namespace each selectors
                if (namespace) {
                    splitSelectors(parsed);
                    prefixSelectors(parsed, namespace);
                }

                // Make URLs absolute
                if (root) {
                    makeAbsolutePaths(parsed, root);
                }

                // Reconstitute the styles
                styles = joinBraces(parsed);

                injectStyle(styles, id);

                return styles;
            };
        }()),

        /* Group: Array manipulation methods */

        /**
         * Convert an object to an Array.
         *
         * @example
         * UWA.Utils.toArray(widget.body.getElementsByClassName('item'));
         *
         * @param {Void} iterable - Variable need to be an iterable object
         * @return {Array} Same array than param if array param is an array else an array with array param has value.
         *
         * @alias UWA.Utils.toArray
         * @memberOf module:UWA/Utils
         */
        toArray: function (iterable) {

            var i, l,
                typeOf = typeof iterable,
                array = [];

            if (typeOf === 'string') {
                array = iterable.split('');

            } else if (
                typeOf === 'object' &&
                    Array.isArray(iterable) === false
            ) {

                // Object with length attribute (Collection, Array, String)
                if (iterable.length !== undefined) {
                    for (i = 0, l = iterable.length; i < l; i++) {
                        array[i] = iterable[i];
                    }

                // Other Object
                } else {
                    for (i in iterable) {
                        if (iterable.hasOwnProperty(i)) {
                            array.push(iterable[i]);
                        }
                    }
                }

            // Handle TypeError: can't convert to object
            } else if (iterable) {
                array = Array.prototype.slice.call(iterable);
            }

            return array;
        },

        /**
         * Converts the argument passed in to an array if it is defined and not already an array.
         *
         * @example
         * var myBadArray = "abc";
         * UWA.Utils.splat(myBadArray);
         * // will return ["abc"]
         *
         * @param {String} object - Variable need to be cast has array
         * @return {Array} Same array than param if array param is an array else an array with array param has value.
         *
         * @alias UWA.Utils.splat
         * @memberOf module:UWA/Utils
         */
        splat: function (object) {

            var newArray;

            // null or undefined
            if (!UWA.is(object)) {
                newArray = [];

            // array
            } else if (Array.isArray(object)) {
                newArray = object;

            // arguments
            } else if (UWA.is(object, 'arguments')) {
                newArray = Utils.toArray(object);

            // others
            } else {
                newArray = [object];
            }

            return newArray;
        },

        /* Group: Crypto methods */

        /**
         * Return a Universally Unique IDentifier (UUID) URN Namespace based on
         * RFC 4122, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).
         *
         * @see {@link http://www.ietf.org/rfc/rfc4122.txt}
         *
         * @example
         * UWA.Utils.uuid();
         * // will return "f8572d53-0fc5-43f2-bb1f-19eb1395d2ba"
         *
         * @return {String} an UUID string (e.g: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx).
         *
         * @alias UWA.Utils.getUUID
         * @memberOf module:UWA/Utils
         */
        getUUID: function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (Math.random() * 16 | 0),
                    v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        },

        /**
         * Return an id random enough to be considered unique. The generated id is suitable for use as an HTML id or classname.
         *
         * @example
         * UWA.Utils.getUniqueId();
         * // could return "u3j9u0012"
         *
         * @return {String} a random string (e.g: u3j9u0012).
         *
         * @memberOf module:UWA/Utils
         */
        getUniqueId: (function () {
            var key = 0,
                pow = Math.pow(32, 4);
            return function (prefix) {
                key++;
                var id = (Math.random() * pow | 0) * pow + key;
                return (prefix || 'u') + ('0000' + id.toString(32)).slice(-8);
            };
        }()),

        /**
         * Get current checksum of the string parameter.
         *
         * @param {String} string - String to checksum
         * @param {Number} salt - Checksum salt (default: 0x12345678)
         * @return {String} String checksum.
         *
         * @example
         * UWA.Utils.getCheckSum('hello my name is bob!');
         * // will return "51ul56"
         * UWA.Utils.getCheckSum('hello my name is bob!', 0x666666);
         * // will return "407so"
         *
         * @alias UWA.Utils.getCheckSum
         * @memberOf module:UWA/Utils
         */
        getCheckSum: function (string, salt) {

            string = String(string);

            var i, l;

            salt = salt || 0x12345678;

            for (i = 0, l = string.length; i < l; i++) {
                salt += (string.charCodeAt(i) * i);
            }

            return Math.abs(parseInt(salt, 10)).toString(36);
        },

        /**
         * Get current CRC32 checksum of the string parameter.
         *
         * @param {String} str - String to check
         * @return {String} Checksum for string passed as argument.
         *
         * @see http://en.wikipedia.org/wiki/Cyclic_redundancy_check
         *
         * @example
         * UWA.Utils.getCRC32('123456');
         * // will return "158520161"
         *
         * @alias UWA.Utils.getCRC32
         * @memberOf module:UWA/Utils
         */
        getCRC32: (function () {

            var CRC32Table = '00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 ' +
                '9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD ' +
                'E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D ' +
                '6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC ' +
                '14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 ' +
                'A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C ' +
                'DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC ' +
                '51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F ' +
                '2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB ' +
                'B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F ' +
                '9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB ' +
                '086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E ' +
                '6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA ' +
                'FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE ' +
                'A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A ' +
                '346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 ' +
                '5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 ' +
                'CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 ' +
                'B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 ' +
                '9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 ' +
                'E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 ' +
                '6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 ' +
                '10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 ' +
                'A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B ' +
                'D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF ' +
                '4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 ' +
                '220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 ' +
                'B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A ' +
                '9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE ' +
                '0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 ' +
                '68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 ' +
                'FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 ' +
                'A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D ' +
                '3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 ' +
                '47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 ' +
                'CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 ' +
                'B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D';

            return function (string) {

                string = String(string);

                // http://kevin.vanzonneveld.net
                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
                // +   improved by: T0bsn
                // -    depends on: utf8_encode
                // *     example 1: crc32('Kevin van Zonneveld');
                // *     returns 1: 1249991249

                var i, iTop,
                    crc = 0, x = 0, y = 0;

                crc = crc ^ (-1);
                for (i = 0, iTop = string.length; i < iTop; i++) {
                    y = (crc ^ string.charCodeAt(i)) & 0xFF;
                    x = "0x" + CRC32Table.substr(y * 9, 8);
                    crc = (crc >>> 8) ^ x;
                }

                return crc ^ (-1);
            };
        }()),

        base64Encode: (function () {

            // See http://jsperf.com/isdoublebyte
            function isDoubleByte(str) {

                var i, n;

                for (i = 0, n = str.length; i < n; i++) {
                    if (str.charCodeAt(i) > 255) {
                        return true;
                    }
                }

                return false;
            }

            function encodeUtf8(s) {
                return unescape(encodeURIComponent(s));
            }

            var btoa = global.btoa || function (input) {

                var chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    length = input.length,
                    output = "",
                    i = 0;

                while (i < length) {

                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output +
                        B64chars.charAt(enc1) +
                        B64chars.charAt(enc2) +
                        B64chars.charAt(enc3) +
                        B64chars.charAt(enc4);
                }

                return output;
            };

            /**
             * Creates a base-64 encoded ASCII string from a "string" of binary data.
             * This btoa method support Unicode compare to the native window.btoa.
             *
             * @example
             * UWA.Utils.base64Encode('✓ à la mode');
             * // will return "4pyTIMOgIGxhIG1vZGU="
             *
             * @example
             * window.btoa('✓ à la mode');
             * // Error: InvalidCharacterError: DOM Exception 5
             *
             * @param {String} str - String to encode
             * @return {String} Base-64 for string passed as argument.
             *
             * @alias UWA.Utils.base64Encode
             * @memberOf module:UWA/Utils
             */
            return function (str) {

                var encoded;

                // Cast has string
                str = String(str);

                // In most browsers, calling window.btoa on a Unicode
                // string will cause a Character Out Of Range exception.

                if (str && isDoubleByte(str)) {
                // To avoid this, consider this pattern:
                    encoded = btoa(encodeUtf8(str));
                } else {
                    encoded = btoa(str);
                }

                return encoded;
            };
        }()),

        base64Decode: (function () {

            function decodeUtf8(s) {
                return decodeURIComponent(escape(s));
            }

            var cleanBase64 = /[^A-Za-z0-9\+\/\=]/g,
                atob = global.atob || function (input) {

                    var length, chr1, chr2, chr3,
                        enc1, enc2, enc3, enc4,
                        output = "",
                        i = 0;

                    if (typeof input !== 'string') {
                        input = String(input);
                    }

                    input = input.replace(cleanBase64, "");
                    length = input.length;

                    if (length % 4 === 1) {
                        throw new Error('InvalidCharacterError: DOM Exception 5');
                    }

                    while (i < length) {

                        enc1 = B64chars.indexOf(input.charAt(i++));
                        enc2 = B64chars.indexOf(input.charAt(i++));
                        enc3 = i < length && B64chars.indexOf(input.charAt(i++));
                        enc4 = i < length && B64chars.indexOf(input.charAt(i++));

                        chr1 = (enc1 << 2) | (enc2 >> 4);
                        output = output + String.fromCharCode(chr1);

                        if (enc3 !== false && enc3 !== 64) {
                            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                            output = output + String.fromCharCode(chr2);
                        }

                        if (enc4 !== false && enc4 !== 64) {
                            chr3 = ((enc3 & 3) << 6) | enc4;
                            output = output + String.fromCharCode(chr3);
                        }
                    }

                    return output;
                };

            /**
             * Decodes a string of data which has been encoded using base-64 encoding.
             * This atob method support Unicode compare to the native window.atob.
             *
             * @example
             * UWA.Utils.base64Decode('4pyTIMOgIGxhIG1vZGU=');
             * // will return "✓ à la mode"
             *
             * @example
             * window.atob('4pyTIMOgIGxhIG1vZGU=');
             * // will return "â Ã  la mode"
             *
             * @param {String} str - Base-64 string to decode
             * @return {String} Decoded base-64 string for passed argument.
             *
             * @alias UWA.Utils.base64Decode
             * @memberOf module:UWA/Utils
             */
            return function (str) {

                var decoded = atob(str);

                // In most browsers, calling window.atob on a Unicode
                // string will cause a Character Out Of Range exception.
                try {

                    // To avoid this, consider this pattern:
                    decoded = decodeUtf8(decoded);

                // Handle possible URIError: URI malformed
                } catch (error) {
                    // Ignore error
                }

                return decoded;
            };
        }()),

        /* Group: Function methods */

        /**
         * Safely execute a function who can throw an exception. If UWA is in
         * debug mode (UWA.debug is `true`), it runs the function and do NOT
         * catch any exception, so it can easily be debugged with a browser
         * developper console. Else, the exception will be catched and the
         * 'fail' callback will be executed with the error as first argument.
         *
         * Prefer using this method to run critical foreign functions instead
         * of try / catches, as it is simpler to debug.
         *
         * Extra arguments are passed to func and fail functions.
         *
         * @example
         * function userDefinedFunction(foo) {
         *    foo.bar = 42;
         *    return 32;
         * }
         *
         * UWA.Utils.attempt(userDefinedFunction, function (error, foo) {
         *    // Deal with the error
         *    UWA.log('Calling userDefinedFunction with ' + foo + ' as first argument has failed unexpectedly:' + error);
         *    return 21;
         * }, {}, null);
         *
         * // Will return 21 and log the error message
         *
         * @param {Function} func - The function to execute
         * @param {Function} [fail] - A callback to execute if the function
         *  fails, with the error as first argument and the other arguments
         *  afterward.
         * @param {Object} [context] - Passed as context to func and fail functions
         * @return The result of func or fail
         *
         * @alias UWA.Utils.attempt
         * @memberOf module:UWA/Utils
         */
        attempt: function (func, fail, context) {
            var args = Array.prototype.slice.call(arguments, 3),
                result;
            if (UWA.debug) {
                result = func.apply(context, args);
            } else {
                try {
                    result = func.apply(context, args);
                } catch (e) {
                    if (fail) {
                        result = fail.apply(context, [e].concat(args));
                    } else {
                        UWA.log('Error in Utils.attempt: ' + e);
                    }
                }
            }
            return result;
        },

        /**
         * Decorator around functions that cache the inner function's return values.
         * Its return value may only depend on its arguments and 'this' context.
         *
         * > There may be further restrictions on the arguments depending on the capabilities of the serializer used.
         *
         * @param {Function} func
         * @param {Object} serializer - A function to serialize function's arguments.
         *  By default serializer is `JSON.stringify`.
         * @return {Function} The wrapped function.
         *
         * @example
         * var nbFunctionCall = 0,
         *
         *     myFunction = function () {
         *
         *        // Your heavy javascript computation
         *
         *        return nbFunctionCall += 1;
         *    },
         *
         *    myFunctionCache = UWA.Utils.memoize(myFunction);
         *
         * myFunctionCache(1); // will return 1
         * myFunctionCache(2); // will return 2
         * myFunctionCache(1); // will return 1
         *
         * @alias UWA.Utils.memoize
         * @memberOf module:UWA/Utils
         */
        memoize: function (func, serializer) {

            var cache = {},
                sliceArray = Array.prototype.slice;

            serializer = serializer || JSON.stringify;

            return function () {
                var hash = serializer(sliceArray.call(arguments));
                if (!cache.hasOwnProperty(hash)) {
                    cache[hash] = func.apply(this, arguments);
                }
                return cache[hash];
            };
        },

        /**
         * Get the first property name of an object that match using an case insensitive property name.
         *
         * @param {Object} obj - The object whose tested.
         * @param {String} property - The name of the property to test.
         * @return {String} the real property name.
         *
         * @example
         * o = new Object();
         * o.prop = 'exists';
         * UWA.Utils.getOwnPropertyMatchName(o, 'Prop'); // returns "prop"
         * UWA.Utils.getOwnPropertyMatchName(o, 'PROP'); // returns "prop"
         * UWA.Utils.getOwnPropertyMatchName(o, 'prop'); // returns "prop"
         *
         * @alias UWA.Utils.getOwnPropertyMatchName
         * @memberOf module:UWA/Utils
         */
        getOwnPropertyMatchName: function (obj, property) {

            var objProperty, objPropertyName;

            // Cast property to string
            property = String(property);

            // Check if property match
            if (obj.hasOwnProperty(property)) {
                objPropertyName = property;

            // Else lookup case insensitive
            } else {

                property = property.toLowerCase();

                for (objProperty in obj) {
                    if (obj.hasOwnProperty(objProperty)) {
                        if (objProperty.toLowerCase() === property) {
                            objPropertyName = objProperty;
                            break;
                        }
                    }
                }
            }

            return objPropertyName;
        },

        /**
         * Get the first property value of an object that match using an case insensitive property name.
         *
         * @param {Object} obj - The object whose tested.
         * @param {String} property - The name of the property to test.
         * @return {String} the real property value.
         *
         * @example
         * o = new Object();
         * o.prop = 'exists';
         * UWA.Utils.getOwnPropertyMatchValue(o, 'Prop'); // returns "exists"
         * UWA.Utils.getOwnPropertyMatchValue(o, 'PROP'); // returns "exists"
         * UWA.Utils.getOwnPropertyMatchValue(o, 'prop'); // returns "exists"
         *
         * @alias UWA.Utils.getOwnPropertyMatchValue
         * @memberOf module:UWA/Utils
         */
        getOwnPropertyMatchValue: function (obj, property) {
            var propertyName = Utils.getOwnPropertyMatchName(obj, property);
            return propertyName ? obj[propertyName] : undefined;
        },

        /**
         * Schedule a function to be executed very soon.
         *
         * @param {Function} callback - The function to be called.
         * @return {Number} The newly defined Immediate's id, for use with {@link module:UWA/Utils.UWA.Utils#clearImmediate|Adaptor#clearImmediate}.
         *
         * @example
         * // This is an infinite calculation that doesn't block the UI.
         * findPrimes = function (currentNumber) {
         *     if (isPrime(currentNumber)) console.log(currentNumber);
         *     UWA.Utils.setImmediate(findPrimes.bind(null, currentNumber + 1));
         * };
         * findPrimes(1);
         *
         * @alias UWA.Utils.clearImmediate
         * @memberOf module:UWA/Utils
         */
        setImmediate: Immediate.set,

        /**
         * Cancels an Immediate that hasn't executed yet.
         *
         * @param {Number} immediateId - The id of the Immediate to cancel, as returned by {@link module:UWA/Utils.UWA.Utils#setImmediate|Adaptor#setImmediate}.
         *
         * @alias UWA.Utils.setImmediate
         * @memberOf module:UWA/Utils
         */
        clearImmediate: Immediate.clear,

        /**
         * Produces a random integer between `min` and `max` (inclusive). If only one
         * argument is provided a number between `0` and the given integer is returned.
         *
         * @param {Number} min - The minimum possible value.
         * @param {Number} max - The maximum possible value.
         * @return {Number} Returns the random number.
         *
         * @example
         * UWA.Utils.random(0, 5); // returns an integer between 0 and 5 inclusive
         * UWA.Utils.random(5); // also returns an integer between 0 and 5 inclusive
         *
         * @alias UWA.Utils.clearImmediate
         * @memberOf module:UWA/Utils
         */
        random: function (min, max) {
            if (!UWA.is(max)) {
                max = min;
                min = 0;
            }
            return min + Math.floor(Math.random() * (max - min + 1));
        }
    };

    // We allow namespace merge because UWA.Utils.InterCom does not
    // require UWA.Utils and can be loaded before.
    return UWA.namespace('Utils', Utils, UWA, true);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Simple Class Prototype Creation and Inheritance API for JavaScript,
 * by passing the prototype object of your Class has parameter.
 *
 * Simple Class Heritance Example:
 *
 * Create a `Person` class and extend `Ninja` from `Person`.
 *
 * ```javascript
 * var Person = UWA.Class.extend({
 *     init: function(isDancing){
 *          this.dancing = isDancing;
 *     }
 * });
 *
 * var Ninja = Person.extend({
 *     init: function(){
 *         this._parent( false );
 *     }
 * });
 *
 * var p = new Person(true);
 * p.dancing; // => true
 *
 * var n = new Ninja();
 * n.dancing; // => false
 * ```
 * Prototype properties Class Heritance Example:
 *
 * Create a `Person` class and extend `Ninja` from `Person`.
 * But share an elements object properties cause it's declared in prototype
 * until one of the instance reassign the elements properties.
 *
 * ```javascript
 * var Person = UWA.Class.extend({
 *     elements: {},
 *     init: function () {
 *
 *     },
 *     addElement: function(name, value) {
 *         this.elements[name] = value;
 *     }
 *  });
 *
 * var Ninja = Person.extend();
 *
 * var p = new Person(true);
 * p.addElement('candy', 1);
 * p.elements; // => {candy: 1}
 *
 * var n = new Ninja();
 * n.elements; // => {candy: 1}
 *
 * p.addElement('sword', 1);
 * p.elements; // => {candy: 1, sword: 1}
 * ```
 *
 * @module   UWA/Class
 */
define('UWA/Class', ['UWA/Core'], function (UWA) {
    'use strict';

    var initializing = false,

        supportFnToString = /xyz/.test(function () {
            UWA.xyz();
        }),

        fnParentTest = supportFnToString ? /\b_parent\b/ : /^/,
        fnPreviousTest = supportFnToString ? /\b_previous\b/ : /^/,

        privateConstructorName = '__uwaPrivateConstructor',

        empty = function () {},

    // The base Class implementation (does nothing)
        Class = function () {};

    // Create a method with a _parent and _previous methods bound to it if
    // necessary
    function mixMethods(parentfn, previousfn, fn, definitionIsClass) {
        if (fn._original) {
            fn = fn._original;
        }

        var result,
            parent = fnParentTest.test(fn),
            previous = fnPreviousTest.test(fn);

        if (!parent && !previous) {
            return fn;
        }

        if (typeof previousfn !== 'function') {
            if (definitionIsClass) {
                previousfn = empty;
            } else {
                // If the definition is not a class, we can fallback previous to the parent function
                // safely
                previousfn = parentfn || empty;
            }
        }

        if (typeof parentfn !== 'function') {
            // Handle legacy: if there is no call to _previous and no parent,
            // the call to _parent is in fact a _previous call
            parentfn = previous ? empty : previousfn;
        }

        result = function () {
            var ret, parenttmp, previoustmp,
                that = this,
                isNotNull = that !== null && that !== undefined;

            if (isNotNull) {
                if (parent) {
                    parenttmp = that._parent;
                    that._parent = parentfn;
                }

                if (previous) {
                    previoustmp = that._previous;
                    that._previous = previousfn;
                }

                ret = fn.apply(that, arguments);

                if (parent) {
                    that._parent = parenttmp;
                }

                if (previous) {
                    that._previous = previoustmp;
                }
            } else {
                ret = fn.apply(that, arguments);
            }

            return ret;
        };
        result.displayName = '(method wrapper)';
        result._original = fn;
        return result;
    }

    // Add a _previous call on top of a native constructor
    function wrapNativeConstructor(constructor) {
        return function () {
            this._previous.apply(this, arguments);
            constructor.apply(this, arguments);
        };
    }

    /**
     * Create a new Class that inherits from this class.
     *
     * @method
     * @method
     * @param {Object|Class|Function} - Definitions to implement. All
     * arguments are mixed with the class prototype in order to extend its
     * methods and attributes.
     * @return {Function} The new Class based with prop parameters has prototype
     *
     * @example
     * var Person = UWA.Class.extend({
     *      init: function (isDancing) {
     *          this.dancing = isDancing;
     *       }
     *  });
     *
     * var Hideable = {
     *     hide: function () {
     *         console.log('Hidden!'); // bypass
     *     }
     *  };
     *
     *  var Ninja = Person.extend(Hideable, {
     *     init: function(){
     *         this._parent( false );
     *     }
     *  });
     *
     *  var p = new Person(true);
     *  p.dancing; // => true
     *
     *  var n = new Ninja();
     *  n.dancing; // => false
     *  n.hide();
     *
     * @memberOf module:UWA/Class
     */
    Class.extend = function () {

        var prototype, UWAClass,
            That = this;

        // Instantiate a base class (but only create the instance,
        // don't run the constructor)
        initializing = true;
        prototype = new That();
        initializing = false;

        // The dummy class constructor
        UWAClass = function () {
            // All construction is actually done in the init method
            if (!initializing && this[privateConstructorName]) {
                this[privateConstructorName].apply(this, arguments);
            }
        };

        // Enforce the constructor to be what we expect
        prototype.constructor = UWAClass;

        UWA.extend(UWAClass, {
            prototype: prototype,
            parent: That,

            // Make this class extendable
            extend: Class.extend,
            singleton: Class.singleton,
            implement: Class.implement
        });

        // Implement the class
        UWAClass.implement.apply(UWAClass, arguments);

        return UWAClass;
    };

   /**
    * Add definitions (also called mixins) to this class.
    *
    * The most common usage is to pass Objects to define the class, but
    * in some cases it can be useful to aggregate methods from another
    * UWA class too.
    *
    * Passing a Function will treat it like a "native class", copying its
    * prototype methods. Note: the constructor will always do a call to
    * _previous before being called (cf Pseudo methods below)
    *
    * ### Pseudo methods:
    *
    * Those methods are bound to a method and does not exist outside. They
    * are helper to call an overriden method with the same name.
    *
    * - _parent: call the parent method with the same name as the current
    * one.
    * - _previous: call the method previous from the previous definition of
    * this class.
    *
    * Note: if you call _parent in many methods linked by a _previous call,
    * the parent method can be called multiple times.
    *
    * ### Predefined definitions:
    *
    * Some definitions can be found in the UWA.Class.* namespace (example:
    * UWA.Class.Events, UWA.Class.Options...)
    *
    * @method
    * @param {Object|Class|Function} - Definitions to implement. All
    * arguments are mixed with the class prototype in order to extend its
    * methods and attributes.
    *
    * @return {Class} this class
    *
    * @example
    * var Animal, Elephant;
    *
    * // The base class
    * Animal = Class.extend({
    *     eat: function () {
    *         console.log('nom nom nom');
    *     }
    * });
    *
    * // Create a class inheriting from Animal
    * Elephant = Animal.extend();
    *
    * // We use the Class.Events mixin (which implements the dispatchEvent method)
    * Elephant.implement(Class.Events, {
    *     eat: function () {
    *         // We override the "eat" method of Animal. Before eating, we
    *         // have to activate the trunk!
    *         this.activateTrunk();
    *          // Then we can eat.
    *         return this._parent();
    *     },
    *
    *     activateTrunk: function () {
    *         this.trunkActivated = true;
    *         // Call a method from a mixin
    *         this.dispatchEvent('onActivateTrunk');
    *     },
    *
    *     addEvent: function (name, f) {
    *         // Override the Class.Events addEvent method to prevent adding
    *         // undefined events
    *         if (name !== 'onActivateTrunk') {
    *              throw new Error('nope');
    *         }
    *
    *         // Call the previous addEvent method
    *         return this._previous(name, f);
    *     }
    * });
    *
    * // All those usages are equivalent:
    *
    * // Prefer this if you are defining a class in a single file
    * var A = B.extend(C, D);
    *
    * // You can use this to define a class, then extend its definition (or
    * // "monkeypatch" it) in a separate file
    * var A = B.extend(C);
    * A.implement(D);
    *
    * // Implement can also have multiple arguments
    * var A = B.extend();
    * A.implement(C, D);
    *
    * // If you want to separate implementations aspects of a class in one or
    * // multiple files, you can always call implement multiple times
    * var A = B.extend();
    * A.implement(C);
    * A.implement(D);
    *
    * // Advanced usage:
    *
    * // Monkey patch an object:
    * var object = {
    *     foo: function () { console.log('foo'); }
    * };
    * Class.implement.call(object, {
    *     foo: function () {
    *         this._previous();
    *         console.log('bar');
    *     }
    * });
    * object.foo();
    * // foo
    * // bar
    *
    * // Monkey patch a native class
    * function MyClass() { }
    * MyClass.prototype.foo = function () {
    *     console.log('foo');
    * };
    * Class.implement.call(MyClass, {
    *     foo: function () {
    *     this._previous();
    *     console.log('bar');
    * }
    * });
    * new MyClass().foo();
    * // foo
    * // bar
    *
    * @memberOf module:UWA/Class
    */
    Class.implement = function () {
        var i, l, definition, name, definitionType, value,
            parent,
            That = this,
            prototype = That.prototype || That;

        for (i = 0, l = arguments.length; i < l; i += 1) {

            definition = arguments[i];
            definitionType = UWA.typeOf(definition);

            if (definitionType === 'class' || definitionType === 'function') {

                // If the definition is a function (native class), we want to
                // chain the implementation nevertheless. Let's add a
                // this._previous call before calling the constructor
                if (definitionType === 'function') {
                    definition.prototype[privateConstructorName] = wrapNativeConstructor(definition);
                }
                // The definition is the prototype of the UWA class or native class
                definition = definition.prototype;

            } else if (definition.init) {

                // Rename init method so it does not create conflicts
                definition[privateConstructorName] = definition.init;
                delete definition.init;

            }

            var className;
            if (definition.name) {
                className = definition.name;
            } else if (prototype.name) {
                if (UWA.owns(prototype, 'name')) {
                    className = prototype.name;
                } else {
                    className = '(' + prototype.name + ' inheritor)';
                }
            } else {
                className = '(anonymous class)';
            }

            // Copy the all properties into the new prototype

            // JSHINT: We want also prototype properties
            /*jshint -W089 */
            for (name in definition) {

                if (name === 'constructor') {
                    continue; // skip 'constructor' property
                }

                value = definition[name];

                // Check if we're overwriting an existing parent function
                if (UWA.is(value, 'function')) {

                    // If the definition is a class, the parent function
                    // should stay the same (parent of the class). Else, use
                    // this class parent
                    parent = (definitionType === 'class' ? arguments[i] : That).parent;

                    value.displayName = className + '#' + (name === privateConstructorName ? 'init' : name);

                    prototype[name] = mixMethods(
                        parent && parent.prototype && parent.prototype[name], // _parent
                        UWA.owns(prototype, name) && prototype[name],         // _previous
                        value,                                                // new method
                        definitionType === 'class'
                    );

                } else if (UWA.is(value, 'plain')) {

                    // If the prototype does not own the object, create a new
                    // one (either an empty one or a clone of the inherited)
                    if (!UWA.owns(prototype, name)) {
                        prototype[name] = UWA.is(prototype[name], 'plain') ? UWA.clone(prototype[name]) : {};
                    }

                    // Merge the object to with current one
                    UWA.extend(prototype[name], value, true);

                } else {
                    prototype[name] = value;
                }
            }
            /*jshint +W089 */

        }

        return That;
    };

   /**
    * Creates a singleton instance, inheriting from 'this' class. This method
    * has exactly the same signature as UWA.Class.extend.
    *
    * Basically, it:
    *
    * - creates a class with UWA.Class.extend
    * - builds an instance without initializing it
    * - wraps all methods with methods who tries to initialize the
    * instance before calling the original method
    * - returns the instance.
    *
    * While the instance is not initialized, when a method is called, the
    * behavior is determined by the 'uninitializedCalls' attribute of the class:
    *
    * - with 'initialize' (the default) it will initialize the instance,
    * then call the original method.
    * - with 'ignore', nothing will be done.
    * - with 'throw', an exception will be thorwn.
    *
    * The instance can be initalized with the method 'init'. The arguments
    * are passed to the original constructor.
    *
    * Initialization consists to removing all method wrappers, then calling the
    * constructor (init).
    *
    * @method
    * @param {Object|Class|Function} - definitions to implement.
    * @return {Object} A singleton instance of a Class
    *
    * @example
    * var Person = UWA.Class.extend({
    *     init: function (isDancing) {
    *     this.dancing = isDancing;
    *     },
    *     isDancing: function () {
    *     return this.dancing;
    *     }
    * });
    *
    * var ForEverAloneGuy = Person.singleton({
    *     init: function () {
    *         this._parent(false);
    *     }
    * });
    *
    * ForEverAloneGuy.isDancing(); // false;
    *
    * var ViolentGuy = Person.singleton({
    *     uninitializedCalls: 'throw'
    * });
    *
    * try {
    *     // throws an exception (ViolentGuy does not like to be disturbed when he is not ready)
    *     ViolentGuy.isDancing();
    * } catch (e) {
    *
    * }
    *
    * ViolentGuy.init(false);
    * ViolentGuy.isDancing(); // false
    *
    * var ShyGuy = Person.singleton({
    *     uninitializedCalls: 'ignore'
    * });
    *
    * ShyGuy.isDancing(); // undefined (ShyGuy doesn't know)
    *
    * ShyGuy.init(true);
    * ShyGuy.isDancing(); // true
    *
    * @memberOf module:UWA/Class
    */
    Class.singleton = function () {
        var method, result,
            // Class creation
            MyClass = this.extend.apply(this, arguments),
            proto = MyClass.prototype,
            initialized = false,
            allMethods = [];

        function wrapMethod(method) {
            result[method] = function () {
                if (!initialized) {
                    if (result.uninitializedCalls === 'throw') {
                        throw new Error('Singleton called before being initialized');
                    } else if (result.uninitializedCalls === 'ignore') {
                        return;
                    }
                    /* uninitializedCalls === 'initialize' */
                    result.init();
                }
                return result[method].apply(this, arguments);
            };
        }

        // Instance creation. The constructor won't be called.
        initializing = true;
        result = new MyClass();
        initializing = false;

        // Wrap all methods
        // JSLINT: We want inherited methods
        /*jslint forin: true */
        for (method in proto) {
            if (typeof proto[method] === 'function' && method !== 'init' && method !== 'constructor') {
                allMethods.push(method);
                wrapMethod(method);
            }
        }
        /*jslint forin: false */

        // Manual initialization method
        result.init = function () {
            if (initialized) {
                throw new Error('Singleton is already initialized');
            }
            initialized = true;

            // Delete all wrappers
            var i, l;
            for (i = 0, l = allMethods.length; i < l; i++) {
                delete result[allMethods[i]];
            }

            // Call the constructor
            MyClass.apply(this, arguments);

            return this;
        };

        return result;
    };

    return UWA.namespace('Class', Class, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Dispatcher API for inspired by AS3-Signals.
 *
 * @module   UWA/Dispatcher
 *
 */
define('UWA/Dispatcher', ['UWA/Core', 'UWA/Utils', 'UWA/Class'], function (UWA, Utils, Class) {
    'use strict';

    /**
     * @class UWA.Dispatcher
     * @extends UWA.Class
     */
    var Dispatcher = UWA.Class.extend(/** @lends module:UWA/Dispatcher.UWA.Dispatcher# */{ // bypass

        /**
         * Class to use for bindings. It should extend Dispatcher.Binding (defaults to Dispatcher.Binding)
         *
         * @type {Class}
         */
        Binding: null,

        /**
         * Array of {@link module:UWA/Dispatcher.UWA.Dispatcher.Binding|UWA.Dispatcher.Binding} instances attached to the current dispatcher instance.
         *
         * @type {Array}
         */
        bindings: null,

        /**
         * Define if dispatcher should dispatch to next listeners on the queue.
         *
         * @type {Boolean}
         */
        shouldPropagate: true,

        /**
         * If Dispatcher is active and should broadcast events.
         *
         * > Note: Setting this property during a dispatch will only affect
         * > the next dispatch, if you want to stop the propagation of a
         * > dispatcher use `halt()` instead.
         *
         * @type {Boolean}
         */
        active: true,

        /**
         * If Dispatcher is dispatching and should prevent {@link module:UWA/Dispatcher.UWA.Dispatcher#bindings|bindings} alteration.
         *
         * @type {Number}
         */
        dispatching: 0,

        /**
         * Dispatcher API for inspired by AS3-Signals
         * (e.g Could be use to implement event or messaging systems).
         *
         * ##### Examples:
         *
         * - Setup code (required for all examples)
         *
         * ```
         *    //store local reference for brevity
         *    var Dispatcher = UWA.Dispatcher;
         *
         *    //custom object that dispatch dispatchers
         *    var myObject = {
         *      started: new Dispatcher(), //past tense is the recommended dispatcher naming convention
         *      stopped: new Dispatcher()
         *    };
         * ```
         *
         * __Basic Examples__
         *
         * - Single Listener
         *
         * ```
         *    function onStarted(param1, param2){
         *      alert(param1 + param2);
         *    }
         *    myObject.started.add(onStarted); //add listener
         *    myObject.started.dispatch(['foo', 'bar']); //dispatch dispatcher passing custom parameters
         *    myObject.started.remove(onStarted); //remove a single listener
         * ```
         *
         * - Multiple Listeners
         *
         * ```
         *    function onStopped(){
         *      alert('stopped');
         *    }
         *    function onStopped2(){
         *      alert('stopped listener 2');
         *    }
         *    myObject.stopped.add(onStopped);
         *    myObject.stopped.add(onStopped2);
         *    myObject.stopped.dispatch();
         *    myObject.stopped.removeAll(); //remove all listeners of the `stopped` dispatcher
         * ```
         *
         * - Multiple Dispatchs
         *
         * ```
         *    var i = 0;
         *    myObject.started.add(function(){
         *      i += 1;
         *      alert(i);
         *    });
         *    myObject.started.dispatch(); //will alert 1
         *    myObject.started.dispatch(); //will alert 2
         * ```
         *
         * - Multiple Dispatchs + addOnce()
         *
         * ```
         *    var i = 0;
         *    myObject.started.addOnce(function(){
         *      i += 1;
         *      alert(i);
         *    });
         *    myObject.started.dispatch(); //will alert 1
         *    myObject.started.dispatch(); //nothing happens
         * ```
         *
         * - Enable/Disable Dispatcher
         *
         * ```
         *    var i = 0;
         *    myObject.started.add(function(){
         *      i += 1;
         *      alert(i);
         *    });
         *    myObject.started.dispatch(); //will alert 1
         *    myObject.started.active = `false`;
         *    myObject.started.dispatch(); //nothing happens
         *    myObject.started.active = `true`;
         *    myObject.started.dispatch(); //will alert 2
         * ```
         *
         * - Stop/Halt Propagation (method 1)
         *
         * ```
         *    myObject.started.add(function(){
         *      myObject.started.halt(); //prevent next listeners on the queue from being executed
         *    });
         *    myObject.started.add(function(){
         *      alert('second listener'); //won't be called since first listener stops propagation
         *    });
         *    myObject.started.dispatch();
         * ```
         *
         * - Stop/Halt Propagation (method 2)
         *
         * ```
         *    myObject.started.add(function(){
         *      return `false`; //if handler returns ``false`` will also stop propagation
         *    });
         *    myObject.started.add(function(){
         *      alert('second listener'); //won't be called since first listener stops propagation
         *    });
         *    myObject.started.dispatch();
         * ```
         *
         * - Set execution context of the listener handler
         *
         * ```
         *    var foo = 'bar';
         *    var obj = {
         *      foo : 10
         *    };
         *
         *    function handler1(){
         *      alert(this.foo);
         *    }
         *    function handler2(){
         *      alert(this.foo);
         *    }
         *    //note that you cannot add the same handler twice to the same dispatcher without removing it first
         *    myObject.started.add(handler1); //default execution context
         *    myObject.started.add(handler2, obj); //set a different execution context
         *    myObject.started.dispatch(); //first handler will alert "bar", second will alert "10".
         * ```
         *
         * __Advanced Examples__:
         *
         * - Set listener priority/order
         *
         * ```
         *    var handler1 = function(){
         *      alert('foo');
         *    };
         *    var handler2 = function(){
         *      alert('bar');
         *    };
         *    myObject.started.add(handler1); //default priority is 0
         *    myObject.started.add(handler2, null, 2); //setting priority to 2 will make `handler2` execute before `handler1`
         *    myObject.started.dispatch(); //will alert "bar" than "foo"
         * ```
         *
         * - Enable/Disable a single DisPatcher.Binding
         *
         * ```
         *    var handler1 = function(){
         *      alert('foo bar');
         *    };
         *    var handler2 = function(){
         *      alert('lorem ipsum');
         *    };
         *    var binding1 = myObject.started.add(handler1); //methods `add()` and `addOnce()` returns a DisPatcher.Binding object
         *    myObject.started.add(handler2);
         *    myObject.started.dispatch(); //will alert "foo bar" than "lorem ipsum"
         *    binding1.active = `false`; //disable a single binding
         *    myObject.started.dispatch(); //will alert "lorem ipsum"
         *    binding1.active = `true`;
         *    myObject.started.dispatch(); //will alert "foo bar" than "lorem ipsum"
         * ```
         *
         * - Manually execute a dispatcher handler
         *
         * ```
         *    var handler = function(){
         *      alert('foo bar');
         *    };
         *    var binding = myObject.started.add(handler); //methods `add()` and `addOnce()` returns a DisPatcher.Binding object
         *    binding.execute(); //will alert "foo bar"
         * ```
         *
         * - Retrieve anonymous listener
         *
         * ```
         *    var binding = myObject.started.add(function(){
         *      alert('foo bar');
         *    });
         *    var handler = binding.getListener(); //reference to the anonymous function
         * ```
         *
         * - Remove / Detach anonymous listener
         *
         * ```
         *    var binding = myObject.started.add(function(){
         *      alert('foo bar');
         *    });
         *    myObject.started.dispatch(); //will alert "foo bar"
         *    binding.detach();
         *    myObject.started.dispatch(); //nothing happens
         * ```
         *
         * - Check if binding will execute only once
         *
         * ```
         *    var binding1 = myObject.started.add(function(){
         *      alert('foo bar');
         *    });
         *    var binding2 = myObject.started.addOnce(function(){
         *      alert('foo bar');
         *    });
         *    alert(binding1.isOnce); //alert "`false`"
         *    alert(binding2.isOnce); //alert "`true`"
         * ```
         *
         * - Change listener execution context on-the-fly
         *
         * ```
         *    var foo = 'bar';
         *    var obj = {
         *      foo : "it's over 9000!"
         *    };
         *    var binding = myObject.started.add(function(){
         *      alert(this.foo);
         *    });
         *    myObject.started.dispatch(); //will alert "bar"
         *    binding.context = obj;
         *    myObject.started.dispatch(); //will alert "it's over 9000!"
         * ```
         *
         * @see {@link http://millermedeiros.github.com/js-signals/}
         * @see {@link https://github.com/millermedeiros/js-signals/wiki/Comparison-between-different-Observer-Pattern-implementations}
         *
         * @constructs UWA.Dispatcher
         * @memberof module:UWA/Dispatcher
         */
        init: function () {
            this.bindings = [];
        },

        /**
         * Register a new listener to the dispatcher.
         *
         * > Listeners with higher priority will be executed before listeners with lower priority.
         * > Listeners with same priority level will be executed at the same order as they were added.
         *
         * @param {Object} listener - Dispatcher handler function or object implementing the EventListener interface
         * @param {Boolean} isOnce - If should be removed after first execution (default = `false`)
         * @param {Object} context -  Context on which listener will be executed (override EventListener context if defined)
         * @param {Number} [priority=0] -  The priority level of the event listener
         * @return {Object} An Object representing the binding between the Dispatcher and listener.
         */
        registerListener: function (listener, isOnce, context, priority) {

            if (
                !UWA.is(listener, 'function') &&
                    !(UWA.is(listener, 'object') && UWA.is(listener.handleEvent, 'function'))
            ) {
                throw new Error('listener is a required param of add() and addOnce() and should be a Function or an object implementing the EventListener interface.');
            }

            var prevIndex, binding,
                that = this;

            prevIndex = that.indexOfListener(listener, context);
            binding = that.bindings[prevIndex];

            // Avoid creating a new Binding for same listener/context if already added to list.
            if (binding) {

                // Handle duplicate isOnce binding.
                if (binding.isOnce !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }

            } else {
                binding = new this.Binding(that, listener, isOnce, context, priority);
                that.addBinding(binding);
            }

            return binding;
        },

        /**
         * Add listener to the `bindings` array and sort `bindings` by priority.
         *
         * @param {Function} binding - Instance of {@link module:UWA/Dispatcher.UWA.Dispatcher.Binding|UWA.Dispatcher.Binding}
         *   has to be added to the Dispatcher current instance.
         */
        addBinding: function (binding) {

            // simplified insertion sort
            var bindings = this.bindings,
                n = bindings.length;

            do {
                --n;
            } while (bindings[n] && binding.priority <= bindings[n].priority);

            bindings.splice(n + 1, 0, binding);
        },

        /**
         * Get listener index position.
         *
         * @param {Function} listener - Handler function that should match index.
         * @param {Void} context - Object that should match binding associated to listener context if provided.
         * @return {Number} Listener index position.
         */
        indexOfListener: function (listener, context) {

            var bindings = this.bindings,
                n = bindings.length;

            while (n--) {
                if (
                    bindings[n].listener === listener &&
                        (context === undefined || bindings[n].context === context)
                ) {
                    return n;
                }
            }

            return -1;
        },

        /**
         * Add a listener to the dispatcher.
         *
         * > Listeners with same priority level will be executed at the same order as they were added.
         * > Listeners with higher priority will be executed before listeners with lower priority.
         * > Scope is object that should represent the `this` variable inside listener function.
         *
         * @param {Function} listener - Dispatcher handler function
         * @param {Object} context - Context on which listener will be executed
         * @param {Number} [priority=0] - The priority level of the event listener
         * @return {Object} An Object representing the binding between the Dispatcher and listener.
         */
        add: function (listener, context, priority) {
            return this.registerListener(listener, false, context, priority);
        },

        /**
         * Add listener to the dispatcher that should be removed after first execution.
         *
         * > Listeners with same priority level will be executed at the same order as they were added.
         * > Listeners with higher priority will be executed before listeners with lower priority.
         *
         * @param {Function} listener - Dispatcher handler function
         * @param {Object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         * @param {Number} [priority=0] - The priority level of the event listener
         * @return {Object} An Object representing the binding between the Dispatcher and listener.
         */
        addOnce: function (listener, context, priority) {
            return this.registerListener(listener, true, context, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         *
         * @param {Function} listener - Handler function that should be removed.
         * @param {Void} context - Object that should match binding associated to listener context if provided.
         * @return {Function} Listener handler function.
         */
        remove: function (listener, context) {

            var index, binding,
                that = this;

            if (
                !UWA.is(listener, 'function') &&
                    !(UWA.is(listener, 'object') && UWA.is(listener.handleEvent, 'function'))
            ) {
                throw new Error('listener is a required param of remove() and should be a Function or an object implementing the EventListener interface.');
            }

            index = that.indexOfListener(listener, context);
            if (index !== -1) {

                binding = that.bindings[index];

                // If dispatcher is dispatching and binding should not be
                // executed just once mark binding as dispose for post dispatch destroying.
                if (that.dispatching && !binding.isOnce) {

                    var bindingIndex = that.bindings.indexOf(binding);

                    if (bindingIndex !== -1) {
                        that.bindings.splice(bindingIndex, 1);
                    }

                // No reason to a Dispatcher.Binding exist if it isn't attached to a dispatcher
                } else {
                    binding.destroy();
                }
            }

            return listener;
        },

        /**
         * Remove all listeners from the Dispatcher.
         *
         * @param {Void} context - Object that should match binding associated to listener context if provided.
         */
        removeAll: function (context) {

            var binding,
                that = this,
                bindings = that.bindings,
                n = bindings.length;

            if (context) {
                while (n--) {
                    binding = bindings[n];
                    if (binding.context === context) {
                        binding.destroy();
                    }
                }
            } else {
                while (n--) {
                    bindings[n].destroy();
                }
                bindings.length = 0;
            }
        },

        /**
         * Number of listeners attached to the Dispatcher.
         *
         * @return {Number} Number of listeners attached to the Dispatcher.
         */
        getNumListeners: function () {
            return this.bindings.length;
        },

        /**
         * Get the list of listeners attached to the Dispatcher.
         *
         * @return {Array} Listeners attached to the Dispatcher.
         */
        getListeners: function () {
            return this.bindings.map(function (binding) {
                return binding.listener;
            });
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         *
         * Should be called only during dispatcher dispatch, calling it before/after dispatch won't affect dispatcher broadcast
         * see {@link module:UWA/Dispatcher.UWA.Dispatcher#shouldPropagate|shouldPropagate} property.
         */
        halt: function () {
            this.shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Dispatcher to all listeners added to the queue.
         *
         * @param {Array} params - Array of parameters that should be passed to each handler
         * @param {Object} context - Context that should be used by each handler
         */
        dispatch: function (params, context) {

            var i, binding, bindings,
                that = this;

            if (that.active) {

                params = Utils.toArray(params);

                // Get bindings with no flags
                bindings = that.bindings.slice();

                // In case `halt` was called before dispatch or during the previous dispatch.
                that.shouldPropagate = true;

                // Flag dispatcher to dispatching
                that.dispatching++;

                try {
                    // Execute all callbacks until end of the list or until a callback returns `false` or stops propagation
                    // reverse loop since listeners with higher priority will be added at the end of the list
                    for (i = bindings.length - 1; i >= 0; i--) {
                        binding = bindings[i];

                        if (binding.execute(params, context) === false) {
                            break;
                        }

                        if (!that.shouldPropagate) {
                            break;
                        }
                    }
                } finally {

                    // Reset dispatcher to not dispatching
                    that.dispatching--;


                    if (that.bindings) {
                        // Process postDispatch bindings disposing.
                        for (i = 0; i < bindings.length; i++) {
                            if (that.bindings.indexOf(bindings[i]) < 0) {
                                bindings[i].destroy();
                            }
                        }
                    }
                }
            }
        },

        /**
         * Remove all bindings from dispatcher and destroy any reference to external objects.
         *
         * > Calling any method on the dispatcher instance after calling dispose will throw errors.
         */
        dispose: function () {

            var that = this;

            that.removeAll();
            that.active = false;
            delete that.bindings;
        },

        /**
         * Get String representation of the object.
         * @return {String} String representation of the object.
         *
         * > Internal or advanced use only.
         */
        toString: function () {

            var that = this;

            return '[Dispatcher active: ' + that.active + ' numListeners: ' + that.getNumListeners() + ']';
        }
    });

    /**
     * @class UWA.Dispatcher.Binding
     * @extends Dispatcher.prototype.Binding
     */
    Dispatcher.Binding = Dispatcher.prototype.Binding = Class.extend(/** @lends module:UWA/Dispatcher.UWA.Dispatcher.Binding# */{ // bypass

        /**
         * Handler function bound to the dispatcher.
         *
         * @type {Function}
         */
        listener: null,

        /**
         * If binding should be executed just once.
         *
         * @type {Boolean}
         */
        isOnce: false,

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         *
         * @type {Void}
         */
        context: null,

        /**
         * Reference to  {@link module:UWA/Dispatcher.UWA.Dispatcher|UWA.Dispatcher} instance that listener is currently bound to.
         *
         * @type {Class}
         */
        dispatcher: null,

        /**
         * Listener priority.
         *
         * @type {Number}
         */
        priority: 0,

        /**
         * If binding is active and should be executed.
         *
         * @type {Boolean}
         */
        active: true,

        /**
         * Custom event/messaging Object for {@link module:UWA/Dispatcher.UWA.Dispatcher|UWA.Dispatcher}
         *
         * @constructs UWA.Dispatcher.Binding
         * @memberof module:UWA/Dispatcher
         */
        init: function (dispatcher, listener, isOnce, listenerContext, priority) {

            var that = this;

            that.listener = listener;

            that.isOnce = isOnce;

            that.context = listenerContext;

            that.dispatcher = dispatcher;

            that.priority = priority || 0;
        },

        /**
         * Call listener passing arbitrary parameters.
         *
         * > If binding was added using "myDispatcher.addOnce()" it will be automatically
         * > removed from dispatcher dispatch queue, this method is used internally
         * > for the dispatcher dispatch.
         *
         * @param {Array} params - Array of parameters that should be passed to the listener
         * @return Value returned by the listener.
         */
        execute: function (params, context) {

            var r,
                that = this,
                listener = that.listener,
                execContext = UWA.is(that.context) ? that.context : context;

            if (that.active) {

                if (that.isOnce) {
                    that.detach();
                }

                if (typeof listener.handleEvent === 'function') { // EventListener
                    r = listener.handleEvent.apply((execContext === undefined) ? listener : execContext, params || []);
                } else {
                    r = listener.apply(execContext, params || []);
                }
            }

            return r;
        },

        /**
         * Detach binding from dispatcher.
         *
         * @return {Function} Handler function bound to the dispatcher.
         */
        detach: function () {

            var that = this;

            if (that.dispatcher) {
                that.dispatcher.remove(that.listener, that.context);
            }

            return that.listener;
        },

        /**
         * Get handler function bound to the dispatcher.
         *
         * @return {Function} Handler function bound to the dispatcher.
         */
        getListener: function () {
            return this.listener;
        },

        /**
         * Remove binding from dispatcher and destroy any reference to external Objects.
         *
         * > Calling methods on the binding instance after calling dispose will throw errors.
         */
        dispose: function () {

            var that = this;

            that.destroy();
        },

        /**
         * Delete all instance properties.
         */
        destroy: function () {

            var bindingIndex,
                that = this,
                dispatcher = that.dispatcher;

            if (dispatcher) {

                bindingIndex = dispatcher.bindings.indexOf(that);

                that.active = false;

                if (bindingIndex !== -1) {
                    dispatcher.bindings.splice(bindingIndex, 1);
                }

                delete that.dispatcher;
            }

            delete that.isOnce;
            delete that.listener;
            delete that.context;
        },

        /**
         * Get String representation of the object.
         *
         * > Internal or advanced use only.
         *
         * @return {String} String representation of the object.
         */
        toString: function () {
            var that = this;
            return '[Dispatcher.Binding isOnce: ' + that.isOnce + ', active: ' + that.active + ']';
        }
    });

    return UWA.namespace('Dispatcher', Dispatcher, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document, navigator, setTimeout
*/

/**
 * Cross-Platform API for Client (Browser, WebView) interaction and features detections.
 *
 * @module   UWA/Utils/Client
 *
 */
define('UWA/Utils/Client', ['UWA/Core', 'UWA/Utils'], function (UWA, Utils) {
    'use strict';

    var Client,
        // Global alias
        global = UWA.getGlobal(),
        hasWindow = Boolean(global.window),
        hasDocument = Boolean(hasWindow && window.document),
        hasNavigator = Boolean(hasWindow && window.navigator),
        getVendorProperty = (function () {

            var prefixes = [
                '',
                'moz', 'Moz', 'MOZ',
                'webkit', 'Webkit', 'WebKit', 'WEBKIT',
                'ms', 'Ms', 'MS',
                'o', 'O'
            ];

            return function (object, template, returnName) {
                var capitalizedPostfix, prefix, postfix, i, l, name,
                    index = template.indexOf('{}');

                if (index >= 0) {
                    prefix = template.slice(0, index);
                    postfix = template.slice(index + 2);
                } else {
                    prefix = '';
                    postfix = template;
                }

                capitalizedPostfix = postfix.charAt(0).toUpperCase() + postfix.slice(1);
                for (i = 0, l = prefixes.length; i < l; i++) {
                    name = prefix + prefixes[i] + postfix;
                    if (name in object) { // bypass
                        break;
                    }
                    name = prefix + prefixes[i] + capitalizedPostfix;
                    if (name in object) { // bypass
                        break;
                    }
                }

                if (i < l) {
                    return returnName ? name : object[name];
                }
                // return undefined;
            };
        }());

    Client = {

        /**
         * Stores Engine infos.
         *
         * > Engine detection is entirely object-based.
         *
         * @property {Boolean} ie - `true` if the current browser is internet explorer (any)
         * @property {Boolean} ie6 - `true` if the current browser is internet explorer 6
         * @property {Boolean} ie7 - `true` if the current browser is internet explorer 7
         * @property {Boolean} firefox - `true` if the current browser is Mozilla/Gecko
         * @property {Boolean} chrome - `true` if the current browser is Chrome/Chrommium
         * @property {Boolean} safari - `true` if the current browser is Safari/Konqueror
         * @property {Boolean} opera - `true` if the current browser is Safari/Konqueror
         * @property {Boolean} webkit - `true` if the current browser is opera
         * @property {String} name - The name of the engine (e.g "chrome")
         * @property {Number} version - The version of the engine (e.g 31)
         * @property {String} fullVersion - The version of the engine (e.g "31.0.1650.48")
         *
         * @type {Object}
         * @alias UWA.Utils.Client.Engine
         * @memberOf module:UWA/Utils/Client
         */
        Engine: {
            name: 'unknown',
            version: 0
        },

        /**
         * Stores Platform infos.
         *
         * @property {Boolean} mac - `true` if the platform is mac
         * @property {Boolean} windows - `true` if the platform is windows
         * @property {Boolean} linux - `true` if the platform is linux
         * @property {Boolean} webos - `true` if the platform is webos
         * @property {Boolean} ios - `true` if the platform is ios (ipod/iphone/ipad)
         * @property {Boolean} blackberry - `true` if the platform is blackberry
         * @property {Boolean} android - `true` if the platform is android
         * @property {Boolean} ipad - `true` if the platform is ipad
         * @property {Boolean} tablet - `true` if the platform is tablet
         * @property {Boolean} other - `true` if the platform is neither mac, windows or linux
         * @property {String} name - Is set to the name of the platform (e.g "linux")
         *
         * @type {Object}
         * @alias UWA.Utils.Client.Platform
         * @memberOf module:UWA/Utils/Client
         */
        Platform: {
            name: 'unknown'
        },

        /**
         * Stores Platform/Engine extras features infos.
         *
         * > Detect Platform/Engine/DOM features support, like XHR and XPath for example.
         *
         * @property {Boolean} window - `true` if support window global
         * @property {Boolean} document - `true`if support document global
         * @property {Boolean} navigator - `true` if support navigator global
         * @property {Boolean} xpath - `true` if support xpath
         * @property {Boolean} json - `true` if support Native JSON
         * @property {Boolean} orientation - `true` if support orientation events
         * @property {Boolean} querySelector - `true` if support querySelector
         * @property {Boolean} fullscreen - `true` if support the fullscreen API
         * @property {Boolean} inputPlaceholder - `true` if input elements supports placeholders
         * @property {Boolean} touchEvents - `true` if support touch events
         * @property {Boolean} pointerEvents - `true` if support pointer events
         * @property {Boolean} mutationEvents - `true` if support DOM MutationEvents
         * @property {Boolean} eventCapture - `true` if support event capture
         * @property {Boolean} transitionsCSS - `true` if support CSS3 Transitions
         * @property {Boolean} opacityCSS - `true` if support CSS opacity property
         * @property {Boolean} flexboxCSS - `true` if support CSS Flexbox layout (last specification)
         * @property {Boolean} filterCSS - `true` if support CSS MsFilter or CSS3 filter property
         * @property {Boolean} matrixCSS - `true` if support WebKitCSSMatrix
         * @property {Boolean} stickyCSS - `true` if support position sticky
         * @property {Boolean} dragAndDrop - `true` if support mousemove/mousedown/mouseup
         *
         * @type {Object}
         * @alias UWA.Utils.Client.Features
         * @memberOf module:UWA/Utils/Client
         */
        Features: {

            // Host Objects
            window: hasWindow,
            document: hasDocument,
            navigator: hasNavigator,

            // Host Objects Features
            xpath: hasDocument && Boolean(document.evaluate),
            json: hasWindow && Boolean(window.JSON),
            orientation: hasWindow && Boolean(window.orientation),
            querySelector: hasDocument && Boolean(document.querySelector),
            fullscreen: Boolean(getVendorProperty(document, 'exitFullscreen') ||
                getVendorProperty(document, 'cancelFullScreen')),
            inputPlaceholder: document.createElement('input').placeholder !== undefined,
            cors: hasWindow && ('withCredentials' in new window.XMLHttpRequest()),

            // Events
            touchEvents: hasWindow && Boolean('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            pointerEvents: hasNavigator && Boolean(navigator.msPointerEnable || navigator.pointerEnabled),
            mutationEvents: Boolean(hasDocument && document.implementation && document.implementation.hasFeature('MutationEvents', '2.0')) || (hasWindow && window.MutationEvent),
            eventCapture: hasWindow && Boolean(window.addEventListener),

            // CSS
            flexboxCSS: hasDocument && Boolean(getVendorProperty(document.createElement('div').style, 'flexBasis', true)),
            filterCSS: hasDocument && !(document.documentElement && document.documentElement.style.filter),
            opacityCSS: hasDocument && !(document.documentElement && document.documentElement.style.opacity),
            transitionsCSS: hasDocument && Boolean(getVendorProperty(document.createElement('div').style, 'transition', true)),

            stickyCSS: hasDocument && (function () {
                var style = document.createElement('div').style;
                style.position = '-webkit-sticky';
                style.position = 'sticky';
                return Boolean(style.position);
            }()),

            matrixCSS: (function () {
                var CSSMatrix = hasWindow && getVendorProperty(window, 'CSSMatrix');
                return Boolean(CSSMatrix) && new CSSMatrix().m11 !== undefined;
            }()),

            // Others
            dragAndDrop: hasWindow && !(window.System && window.System.Gadget)
        },

        /**
         * Stores Platform/Engine language, locale and dir infos.
         *
         * @property {String} lang - Language value (e.g. `fr_FR`)
         * @property {String} locale - Locale value (e.g. `fr`)
         * @property {String} dir - Language direction `rtl` or `ltr`
         *
         * @type {Object}
         * @alias UWA.Utils.Client.Locale
         * @memberOf module:UWA/Utils/Client
         */
        Locale: (function () {

            // TODO improve values
            // lang = fr_FR
            // locale = fr
            var fullLanguage = hasNavigator && (
                (navigator.languages && navigator.languages[0]) ||
                navigator.language ||
                navigator.userLanguage
            ) || 'en-US';

            var info = fullLanguage.toLowerCase().split('-');
            var lang = info[0] || 'en';
            var locale = info[1] || 'us';

            return {
                lang: lang,
                locale: locale,
                dir: ['ar', 'he'].indexOf(lang) !== -1 ? 'rtl' : 'ltr'
            };
        }()),

        /**
         * Populate Engine and Platform properties values.
         *
         * > Internal or advanced use only.
         *
         * @return {Object} An Object with engine and version properties.
         *
         * @private
         */
        detect: (function () {

            var userAgentRegExp1 = /(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/,
                userAgentRegExp2 = /(webkit)[\s\/:]([\w\d\.]+)/,
                userAgentRegExp3 = /(trident)\/.*rv:([\d\.]+)/,  // IE11 does not identify itself as IE
                isiOSRegExp = /ip(?:ad|od|hone)/,
                isWebOsRegExp = /webos|wossystem/,
                isBlackBerryRegExp = /blackberry/,
                isAndroidRegExp = /android/,
                isPhantomJSRegExp = /\bphantomjs\b/i,
                platformOSRegExp = /mac|win|linux/;

            function getUserAgent() {
                return (hasNavigator && navigator.userAgent.toLowerCase()) || '';
            }

            function getPlatformName() {
                // Slit by space and get first to get "linux" from "linux x86_64"
                return ((hasNavigator && navigator.platform.toLowerCase()) || '').split(' ')[0];
            }

            return function () {

                Client.Engine = (function () {

                    var Engine, userAgentMatch, mode, name, fullVersion, version,
                        userAgent = getUserAgent();

                    userAgentMatch =
                        userAgent.match(userAgentRegExp1) ||
                        userAgent.match(userAgentRegExp2) ||
                        userAgent.match(userAgentRegExp3) ||
                            (global.process ? [null, 'nodeJS', global.process.version] : [null, 'unknown', 0]);

                    mode = userAgentMatch[1] === 'ie' && hasDocument && document.documentMode;
                    fullVersion = mode || (userAgentMatch[1] === 'opera' && userAgentMatch[4] ? userAgentMatch[4] : userAgentMatch[2]);
                    version = parseInt(fullVersion, 10);
                    name = (userAgentMatch[1] === 'version') ? userAgentMatch[3] : userAgentMatch[1];

                    if (name === 'trident') {
                        name = 'ie';
                    }

                    // Set current Engine
                    Engine = {
                        name: name,
                        version: version,
                        fullVersion: fullVersion
                    };

                    // Set Engine[name] to version for easy check
                    Engine[name] = version;

                    // Set Engine[name] && Engine[name + version] to true for easy check
                    Engine[name + version] = true;

                    // Set Engine.webkit value
                    Engine.webkit = Boolean(userAgent.match(/webkit/));

                    return Engine;
                }());

                Client.Platform = (function () {

                    var Platform,
                        platform = getPlatformName(),
                        userAgent = getUserAgent();

                    // Set Platform[name] to true for easy check
                    Platform = {
                        name:
                            isiOSRegExp.test(userAgent) ? 'ios' :
                            isWebOsRegExp.test(userAgent) ? 'webos' :
                            isBlackBerryRegExp.test(userAgent) ? 'blackberry' :
                            isAndroidRegExp.test(userAgent) ? 'android' :
                            isPhantomJSRegExp.test(userAgent) ? 'phantomjs' :
                            platformOSRegExp.test(platform) || global.process ? platform :
                                'other'
                    };

                    // Set Platform[Platform.name] to true for easy check
                    Platform[Platform.name] = true;

                    // Extras Platform detection
                    Platform.ipad = Boolean(userAgent.match(/ipad/));
                    Platform.tablet = Platform.ipad || Boolean(userAgent.match(/tablet/));
                    Platform.windows = Platform.name.indexOf('win') === 0;

                    return Platform;
                }());

                // Add Custom CSS ClassName into documentElement for easy
                // custom css selector (e.g ie ie7 window)
                if (hasDocument) {
                    document.documentElement.className += ' ' +
                        Client.Engine.name + ' ' + Client.Engine.name + Client.Engine.version + ' ' + Client.Platform.name;
                }
            };
        }()),

        /**
         * Check if current Client is online or not.
         *
         * @param {Boolean} onLine - New value
         * @param {String} timeout - New value expiration
         * @return {Boolean} `true` if online else `false`.
         *
         * @alias UWA.Utils.Client.isOnline
         * @memberOf module:UWA/Utils/Client
         */
        isOnline: function (onLine, timeout) {

            if (onLine !== undefined && timeout) {

                Client.onLine = Boolean(onLine);

                setTimeout(function () {
                    delete (Client.onLine);
                }, timeout);

            } else if (Client.onLine === undefined) {
                if (Client.Platform.phantomjs || !hasNavigator || navigator.onLine === undefined) {
                    // phantomjs doesn't handle navigator.onLine correctly
                    // https://github.com/ariya/phantomjs/issues/10647
                    Client.onLine = true;
                } else {
                    Client.onLine = navigator.onLine === true;
                }
            }

            return Client.onLine;
        },

        /**
         * Get Client viewport orientation.
         *
         * > Return "portrait" when screen resolution is greater horizontally than vertically, and
         * > "landscape" when screen resolution is greater vertically than horizontally.
         *
         * @method UWA.Utils.Client.getOrientation
         * @return {String} "portrait" or "landscape".
         *
         * @memberOf module:UWA/Utils/Client
         */
        getOrientation: (function () {

            var getOrientation;

            // If that code is called from an iframe, the result may be wrong
            // (e.g. tablet in "landscape" but iframe is actually in portrait "ratio")
            // Detect iframe context then use ratio in this case.
            if (
                hasWindow &&
                    window.self === window.top &&
                       window.orientation
            ) {

                getOrientation = function () {

                    var orientation = window.orientation;

                    return Math.abs(orientation) === 90 ? 'landscape' : 'portrait';
                };

            } else {

                getOrientation = function () {

                    var size = Client.getSize();

                    return size.width / size.height < 1 ? 'portrait' : 'landscape';
                };
            }

            return getOrientation;
        }()),

        /**
         * Get viewport bounds (including page scrolling if any) of current window.
         *
         * @return {Object} With "height" and "width" properties.
         *
         * @alias UWA.Utils.Client.getSize
         * @memberOf module:UWA/Utils/Client
         */
        getSize: function () {

            var documentElement, documentBody,
                myWidth = 0,
                myHeight = 0;

            // Non-IE
            if (
                hasWindow &&
                    typeof window.innerWidth === 'number'
            ) {

                myWidth = window.innerWidth;
                myHeight = window.innerHeight;

            } else if (hasDocument) {

                documentElement = document.documentElement;
                documentBody = document.body;

                // IE 6+ in 'standards compliant mode'
                if (
                    documentElement &&
                        (documentElement.clientWidth || documentElement.clientHeight)
                ) {
                    myWidth = documentElement.clientWidth;
                    myHeight = documentElement.clientHeight;

                // IE 4 compatible
                } else if (
                    documentBody &&
                        (documentBody.clientWidth || documentBody.clientHeight)
                ) {
                    myWidth = documentBody.clientWidth;
                    myHeight = documentBody.clientHeight;
                }
            }

            return {
                width: myWidth,
                height: myHeight
            };
        },

        /**
         * Obtain the scurrent crolling offsets in both the horizontal and vertical direction.
         *
         * @return {Object} Object with "x" and "y" properties.
         *
         * @alias UWA.Utils.Client.getScrolls
         * @memberOf module:UWA/Utils/Client
         */
        getScrolls: function () {

            var documentElement, documentBody,
                scrOfX = 0,
                scrOfY = 0;

            // Netscape compliant
            if (
                hasWindow &&
                    typeof window.pageYOffset === 'number'
            ) {
                scrOfY = window.pageYOffset;
                scrOfX = window.pageXOffset;

            } else if (hasDocument) {

                // DOM compliant
                if (
                    documentBody &&
                        (documentBody.scrollLeft || documentBody.scrollTop)
                ) {

                    scrOfY = documentBody.scrollTop;
                    scrOfX = documentBody.scrollLeft;
                // IE6 standards compliant mode
                } else if (
                    documentElement &&
                        (documentElement.scrollLeft || documentElement.scrollTop)
                ) {
                    scrOfY = documentElement.scrollTop;
                    scrOfX = documentElement.scrollLeft;
                }
            }

            return {
                y: scrOfY,
                x: scrOfX
            };
        },

        /**
         * Obtain the native scrollbar width.
         *
         * @method UWA.Utils.Client.getScrollbarWidth
         * @return {Number} Native width of the scrollbar.
         *
         * @memberOf module:UWA/Utils/Client
         */
        getScrollbarWidth: Utils.memoize(function () {

            // Create the measurement node
            var documentElement, scrollDiv,
                scrollbarWidth = 0;

            if (hasDocument) {

                documentElement = document.documentElement;
                scrollDiv = document.createElement('div');
                scrollDiv.style.cssText = 'width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;';

                documentElement.appendChild(scrollDiv);

                // Get the scrollbar width
                scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

                // Delete the DIV
                documentElement.removeChild(scrollDiv);
            }

            return scrollbarWidth;
        }),

        /**
         * Add Client Rating/Star/Favorite/...
         *
         * @param {String} url - Url to Rate/Bookmark/Save
         * @param {String} title - Name of Bookmark
         *
         * @alias UWA.Utils.Client.addStar
         * @memberOf module:UWA/Utils/Client
         */
        addStar: function (url, title) {

            if (hasWindow) {
                if (window.sidebar) { // Mozilla Firefox Bookmark
                    window.sidebar.addPanel(title, url, '');
                } else if (window.external) { // IE Favorite
                    window.external.AddFavorite(url, title);
                } else if (window.opera && window.print) { // Opera Hotlist
                    return true;
                }
            }
        },

        /**
         * Helper to retrieve a prefixed vendor property.
         *
         * > For style names, please prefer Element#getStyleName
         * > Please cache the result of this function locally in order to improve performances
         *
         * @method UWA.Utils.Client.getVendorProperty
         * @param {Object} object - Where to search for the property
         * @param {String} template - The base property name. Usually, it should be
         *  the standard property name. If this string contains "{}", the
         *  prefix will be inserted here instead of at the beginning.
         * @param {Boolean} returnName - If `true`, returns the prefixed property name
         *  instead of the property value. Default to `false`.
         * @return {String|Object} The property value, or its name if returnName is `true`
         *
         * @example
         * var cancelAnimationFrame = UWA.Client.getVendorProperty(window, 'cancelAnimationFrame');
         *
         * // Is the equivalent of:
         * var cancelAnimationFrame = window.cancelAnimationFrame ||
         *    window.webkitCancelRequestAnimationFrame ||
         *    window.mozCancelRequestAnimationFrame ||
         *    window.oCancelRequestAnimationFrame ||
         *    window.msCancelRequestAnimationFrame ||
         *      // ....
         *
         * var eventName = UWA.Client.getVendorProperty(document.documentElement, 'on{}fullscreenchange');
         *
         * @memberOf module:UWA/Utils/Client
         */
        getVendorProperty: getVendorProperty
    };

    // Init UWA.Utils.Client values
    Client.detect();

    return UWA.namespace('Utils/Client', Client, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, clearTimeout, setTimeout, window, ArrayBuffer, Uint16Array, Blob
*/

/**
 * API around the XmlHttpRequest object that enables you to deal with Ajax calls
 * in a manner that is both easy and compatible with all modern browsers.
 *
 * {@link module:UWA/Data.UWA.Data.request|UWA.Data.request} provide a Cross-domain Ajax* solution that allow you to fetch data through Ajax even if your app is not
 * on the same domain than your request. That why *you should not use UWA.Ajax methods as it* but {@link module:UWA/Data.UWA.Data.request|UWA.Data.request} method
 * to perform Ajax calls into your app.
 *
 * @module   UWA/Ajax
 *
 */
define('UWA/Ajax', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/String'
], function (UWA, Utils, UWAString) {
    'use strict';

    var Ajax = {

        /**
         * Create a new XMLHttpRequest object.
         *
         * __Note on "cors" option:__
         * CORS is refering to "Cross-Origin Resource Sharing", that allow you to make cross domain AJAX request,
         * to enable it, the server that you request using AJAX need to return following headers:
         *
         * > Access-Control-Allow-Origin: *
         * >
         * > Access-Control-Allow-Headers: X-Requested-With
         *
         * Note that on some Platforms (IE Based), the headers and cookies cannot be set and will be not
         * received by the server and can cause some authentication issues. It is also not possible to
         * make synchronous request on these Platforms.
         *
         * __Note on "responseType" option:__
         * responseType value "json" and "document" work on all major browsers,
         * where "blob" and "arraybuffer" require IE 10+
         *
         * @method
         * @param {String} url - The url to request
         * @param {Object} options - Settings object
         * @param {Function} options.onComplete - Callback receiving the Ajax response
         * @param {String} [options.method=GET] - GET, POST (in uppercase!)
         * @param {Object} [options.data={}] - GET or POST params as object
         * @param {Object} [options.authentication] - Authentication object
         * @param {Object} [options.headers] - Headers object.
         * @param {Number} [options.timeout] - Set your request timeout in ms
         * @param {Function} [options.onTimeout] - Choose your own method
         * @param {Function} [options.onFailure] - Choose your own method
         * @param {Function} [options.onCancel] - Choose your own method
         * @param {Function} [options.onProgress] - progress callback, if the browser supports it
         * @param {Boolean} [options.async=true] - Asynchronous request
         * @param {cors} [options.cors] - Use Cross-Origin Resource Sharing
         * @param {String} [options.responseType] - Type/Format request response (supported: json, document, arraybuffer, blob).
         *
         * @return {XMLHttpRequest}
         *
         * @see {@link http://annevankesteren.nl/2007/10/http-method-support}
         * @see {@link http://www.mnot.net/javascript/xmlhttprequest/}
         * @see {@link http://www.w3.org/TR/XMLHttpRequest/#the-open()-method}
         *
         * @alias UWA.Ajax.getRequest
         * @memberOf module:UWA/Ajax
         */
        getRequest: function (url, options) {

            /*jshint maxstatements: 55*/

            // TODO Implement no-cache see:
            // http://www.mnot.net/javascript/xmlhttprequest/cache.html

            options = UWA.merge(options || {}, {
                url: url,
                method: 'GET',
                async: true,
                responseType: 'text',
                onComplete: function () {
                    // Nothing to do by default...
                },
                onFailure: function (error) {
                    throw error;
                },
                onTimeout: function (error) {
                    throw error;
                },
                onCancel: function () {
                    // Nothing to do by default...
                }
            });

            var header, request, splitUrl,
                method = options.method || 'GET',
                headers = options.headers || {},
                authentication = options.authentication,
                onStateChange = Ajax.onStateChange;

            // If method match OPTIONS/GET/HEAD/POST/PUT/DELETE/TRACE/CONNECT
            // set uppercase to match standart and avoid IE issues.
            if (/OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT/i.test(method)) {
                method = method.toUpperCase();
            }

            // Handle data options
            if (options.data) {

                // Clean data from object to create query string
                if (!UWA.is(options.data, ['string', 'arraybufferview', 'formdata', 'blob'])) {
                    options.data = Utils.toQueryString(options.data);
                }

                // Add data to url get params and remove them from options
                if (method === 'GET') {

                    // Update Url
                    url += ((url.indexOf('?') > -1) ? '&' : '?') + options.data;

                    // Update Url
                    options.url = url;

                    // To avoid double data
                    delete options.data;
                }
            }

            // Avoid X-Requested header in case of CORS
            if (!options.cors) {

                // Add default X-Requested-With header if not set
                if (!Utils.getOwnPropertyMatchName(headers, 'X-Requested-With')) {
                    headers['X-Requested-With'] = 'XMLHttpRequest';
                }

                // Add default X-Requested-Method header if not set
                if (!Utils.getOwnPropertyMatchName(headers, 'X-Requested-Method')) {
                    headers['X-Requested-Method'] = method;
                }
            }

            // Set Content-Type to "www-form-urlencoded header" for post if not set
            if (
                method === 'POST' &&
                    !Utils.getOwnPropertyMatchName(headers, 'Content-Type') &&
                    !UWA.is(options.data, ['arraybufferview', 'formdata', 'blob'])
            ) {
                headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';
            }

            // Add authentication parameters
            if (authentication) {
                if (authentication.username && authentication.password) {
                    splitUrl = url.split('://');
                    url = splitUrl[0] + '://' + authentication.username + ':' + authentication.password + '@' + splitUrl[1];
                } else {
                    url += (url.indexOf('?') > -1 ? '&' : '?') + Utils.toQueryString(authentication);
                }
            }

            // Get XHR request client
            if (options.cors) {
                request = Ajax.createCORSRequest();
            } else {
                request = Ajax.createRequest();
            }

            if (!request) {
                options.onFailure(new Error('Unable to initiate XMLHttpRequest object.'));
                return;
            }

            // Implement cancel method
            request.cancel = function () {
                request.aborted = true;
                request.abort();
            };

            if (request.addEventListener && options.onProgress) {
                request.addEventListener('progress', function (event) {
                    options.onProgress(event);
                });
            }

            // Initializes request
            request.open(method, url, options.async);

            // Detect responseType support and avoid it if json to
            // handle empty vs invalid JSON response and synchronous requests.
            options.responseTypeSupport = 'responseType' in request &&
                                            options.responseType !== 'json' &&
                                            (options.async || typeof window === 'undefined');

            // Set reponse type
            if (options.responseTypeSupport) {
                try {

                    // Some browsers throw when setting responseType to an unsupported value
                    request.responseType = options.responseType;

                } catch (responseTypeError) {

                    // Set default response type
                    request.responseType = 'text';
                }
            }

            // Detect withCredentials support
            options.withCredentialsSupport = 'withCredentials' in request &&
                                            (options.async || typeof window === 'undefined');

            // Check if withCredentials is requested
            if (options.withCredentials) {

                if (options.withCredentialsSupport) {
                    request.withCredentials = options.withCredentials;
                } else {
                    // Fail if not supported and used to avoid unexpected behavior.
                    options.onFailure(new Error('XMLHttpRequest does not support withCredentials.'));
                    return;
                }
            }

            // Implement timeout support
            if (options.timeout) {

                request.timeoutTimer = setTimeout(function () {
                    request.timedout = true;
                    request.abort();
                }, options.timeout);
            }

            if (options.cors) {

                // We need to found an alternative to readyState and status
                // using CORS on IE because there are undefined by using
                // UWA.extend on request object.

                request.onerror = function () {

                    UWA.merge(request, {
                        readyState: 4,
                        status: 500
                    });

                    onStateChange(request, options);
                };

                request.onload = function () {

                    UWA.merge(request, {
                        readyState: 4,
                        status: 200
                    });

                    onStateChange(request, options);
                };

            } else {
                request.onreadystatechange = onStateChange.bind(Ajax, request, options);
            }

            // Add request headers if supported
            if (request.setRequestHeader) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        request.setRequestHeader(header, headers[header]);
                    }
                }
            }

            return request;
        },

        /**
         * Create an XMLHttpRequest request object.
         *
         * __Note:__ Use feature detection and fallback on Msxml2.XMLHTTP if
         * XMLHttpRequestdoes does not exist.
         *
         * @method
         * @return {XMLHttpRequest}
         *
         * @alias UWA.Ajax.createRequest
         * @memberOf module:UWA/Ajax
         */
        createRequest: function () {

            var xhr;

            // Get XHR request client
            if (window.XMLHttpRequest) {
                xhr = new window.XMLHttpRequest();
            } else if (window.ActiveXObject) {
                xhr = new window.ActiveXObject('Msxml2.XMLHTTP');
            }

            return xhr;
        },

        /**
         * Create an XMLHttpRequest Cross-Origin Resource Sharing request object.
         *
         * __Note:__ Use feature detection and fallback on XDomainRequest if
         * XMLHttpRequest does not support CORS.
         *
         * @see {@link http://www.w3.org/TR/cors/}
         *
         * @return {XMLHttpRequest|XDomainRequest}
         *
         * @alias UWA.Ajax.createCORSRequest
         * @memberOf module:UWA/Ajax
         */
        createCORSRequest: function () {

            var xhr;

            if (window.XMLHttpRequest) {

                xhr = new window.XMLHttpRequest();

                // Using XDomainRequest if XMLHttpRequest does not support withCredentials
                if (
                    !xhr.withCredentials &&
                        window.XDomainRequest
                ) {
                    xhr = new window.XDomainRequest();
                }
            }

            return xhr;
        },

        /**
         * Initiates an Ajax request using {@link module:UWA/Ajax.UWA.Ajax.getRequest|UWA.Ajax.getRequest} and send it.
         *
         * See {@link module:UWA/Ajax.UWA.Ajax.getRequest|UWA.Ajax.getRequest} for parameters.
         *
         * @return {XMLHttpRequest}
         *
         * @alias UWA.Ajax.request
         * @memberOf module:UWA/Ajax
         */
        request: function (url, options) {

            var request;

            options = options || {};

            // Get Request
            request = Ajax.getRequest(url, options);

            // Send Request
            request.send(options.data || null);

            // Force Firefox to handle ready state 4 for synchronous requests
            if (!options.async) {
                Ajax.onStateChange(request, options);
            }

            return request;
        },

        /**
         * Parse headers from string to an hash.
         *
         * @param {String} headerStr
         * @return {Object}
         *
         * @example
         * var request = Ajax.request("http://example.com");
         * var requestHeaders =  Ajax.parseResponseHeaders(request.getAllResponseHeaders());
         * // requestHeaders example value: {"Content-Type": "text/html", ...}
         * @memberOf module:UWA/Ajax
         */
        parseResponseHeaders: function (headerStr) {

            var i,
                headerIndex, headerKey, headerValue,
                headerPair, headerPairs,
                headers = {};

            if (headerStr) {

                headerPairs = headerStr.split('\u000d\u000a');
                for (i = 0; i < headerPairs.length; i++) {

                    headerPair = headerPairs[i];

                    // Can't use split() here because it does the wrong thing
                    // if the header value has the string ": " in it.
                    headerIndex = headerPair.indexOf('\u003a\u0020');

                    if (headerIndex > 0) {
                        headerKey = headerPair.substring(0, headerIndex);
                        headerValue = headerPair.substring(headerIndex + 2);
                        headers[headerKey] = headerValue;
                    }
                }
            }

            return headers;
        },

        /**
         * Function that is invoked when the readyState of an request object is updated.
         * The function may be invoked multiple times when readyState is 3 (Receiving).
         *
         * @see {@link http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/#dfn-onreadystatechange}
         *
         * @alias UWA.Ajax.onStateChange
         * @memberOf module:UWA/Ajax
         * @private
         */
        onStateChange: (function () {
            var proxyErrorType = 'UWA_Platform_';

            function detectErrorResponse(response) {
                var errorWrapper = response,
                    error;

                // Let's first see if it looks like an error could be there
                if (UWA.is(errorWrapper, 'string') && errorWrapper.contains(proxyErrorType)) {
                    try {
                        errorWrapper = UWAString.stripComments(errorWrapper);
                        errorWrapper = JSON.parse(errorWrapper);
                    } catch (e) {
                        errorWrapper = false;
                    }
                }
                if (errorWrapper && errorWrapper.error && String(errorWrapper.error.type).startsWith(proxyErrorType)) {
                    error = new Error(UWAString.format('ProxyError: {0}', errorWrapper.error.message));
                    UWA.merge(error, errorWrapper.error);
                    return error;
                }
            }

            // Get Request response depending responseType value
            // and responseType support.
            function getRequestResponse(request, options) {

                var response, errorResponse,
                    responseType = options.responseTypeSupport ? request.responseType : options.responseType;

                // Get decoded response
                if (options.responseTypeSupport) {

                    // Get default responseType
                    if (responseType === 'text' || responseType === '') {

                        response = request.responseText;

                    // Try response from responseType
                    } else {

                        // Check response and handle possible InvalidStateError error
                        try {
                            response = request.response;
                        } catch (errorResponseType) {
                            throw new Error(
                                UWAString.format(
                                    'InvalidResponseError: request has probably invalid "Content-type" header require by responseType "{0}" causing: "{1}".',
                                    request.responseType,
                                    errorResponseType
                                )
                            );
                        }
                    }

                    if (options.fromDataRequest) {
                        errorResponse = detectErrorResponse(response);
                    }

                    if (errorResponse) {
                        throw errorResponse;
                    }

                // Get encoded response and decode manualy
                } else {

                    if (options.fromDataRequest) {
                        errorResponse = detectErrorResponse(request.responseText);
                    }

                    if (errorResponse) {

                        throw errorResponse;

                    } else if (responseType === 'text' || responseType === '') { // jshint ignore:line

                        response = request.responseText;

                    } else if (responseType === 'json') {

                        response = String(request.responseText).trim();

                        // Let parse response to json
                        if (response.length === 0) {
                            response = null;
                        } else {

                            // Remove comments before parse
                            response = UWAString.stripComments(response);

                            // Then attempt to decode
                            response = JSON.parse(response);
                        }

                    } else if (responseType === 'document') {

                        // responseXML is supposed to be valid document
                        response = request.responseXML;
                    } else if (responseType === 'arraybuffer') {

                        // Convert response to ArrayBuffer
                        response = (function (str) {

                            var i, strLen,
                                buf = new ArrayBuffer(str.length * 2), // 2 bytes for each char
                                bufView = new Uint16Array(buf);

                            for (i = 0, strLen = str.length; i < strLen; i++) {
                                bufView[i] = str.charCodeAt(i);
                            }

                            return buf;

                        }(request.responseText));

                    } else if (responseType === 'blob') {

                        // Convert response to Blob
                        response = new Blob([request.responseText], {
                            type: request.getResponseHeader("Content-Type")
                        });
                    }
                }

                return response;
            }

            function getRequestHeaders(request) {
                return Ajax.parseResponseHeaders(request.getAllResponseHeaders());
            }

            function cleanUpRequest(request, options) {

                // Internet Explorer: memory leak in XMLHttpRequest
                // We break the references to help garbage collect
                if (options.cors) {
                    request.onerror = null;
                    request.onload = null;
                } else {
                    request.onreadystatechange = null;
                }
            }

            return function (request, options) {

                var response, headers, hasError, error;

                 // Aborted request
                if (request.aborted) {
                    options.onCancel(request, options);

                // Timedout request
                } else if (request.timedout) {
                    options.onTimeout(new Error('Request timed out after ' + options.timeout + ' ms'), request, options);

                // Request is completed
                } else if (request.readyState === 4) {

                    // Clear timeoutTimer
                    if (request.timeoutTimer) {
                        clearTimeout(request.timeoutTimer);
                    }

                    // process response only once, eg in case of synchronous request where callback
                    // can be called from Ajax.request(), request.onload, request.onreadystatechange
                    if (request.completed) {
                        return;
                    } else {
                        request.completed = true;
                    }

                    var valid = true;

                    if (request.status <= 0) {
                        // Non-http protocols do not specify a response status code. We
                        // should consider the request is valid only if the protocol isn't
                        // http

                        var requestScheme = Utils.parseUrl(Utils.buildUrl(window.location, options.url)).protocol;
                        valid = requestScheme !== 'http' && requestScheme !== 'https';
                    } else if (request.status >= 400) {
                        valid = false;
                    }

                    // Valid response
                    if (valid) {

                        // Get request headers
                        headers = getRequestHeaders(request);

                        try {

                            // Get response
                            response = getRequestResponse(request, options);

                        } catch (errorResponse) {

                            hasError = errorResponse;

                            if (String(errorResponse.type).startsWith(proxyErrorType)) {
                                headers = errorResponse.headers;
                                response = errorResponse.body;
                            }

                            options.onFailure(errorResponse, response, headers);

                        } finally {

                            // Call onComplete in finally to avoid
                            // onFailure if there is an error into onComplete.
                            if (!hasError) {
                                options.onComplete(response, headers);
                            }
                        }

                    // Other Errors
                    } else {

                        // Generic error
                        error = new Error(UWAString.format(
                            'NetworkError: url "{0}" return ResponseCode with value "{1}".',
                            options.fromDataRequest || options.url,
                            request.status || 0
                        ));

                        // Get request headers
                        headers = getRequestHeaders(request);

                        try {

                            // Get response
                            response = getRequestResponse(request, options);

                        } catch (errorResponse) {

                            // If error comes from proxy, use remote server info in callback
                            if (String(errorResponse.type).startsWith(proxyErrorType)) {
                                Object.assign(error, errorResponse);
                                headers = errorResponse.headers;
                                response = errorResponse.body;
                            }

                        }

                        options.onFailure(error, response, headers);
                    }

                    cleanUpRequest(request, options);
                }
            };
        }())
    };

    return UWA.namespace('Ajax', Ajax, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document, setTimeout, clearTimeout
*/

/*jshint
    maxparams: false
*/

/**
 * API for advanced JSON manipulation, convertion and fetching.
 *
 * @see {@link http://www.json.org}
 * @see {@link http://www.json-p.org}
 *
 * @module   UWA/Json
 *
 */
define('UWA/Json', [
    'UWA/Core',
    'UWA/String',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Ajax'
], function (UWA, UWAString, Utils, Client, Ajax) {
    'use strict';

    var Json = {

        /**
         * @property {Object} jsonp - Object to hold active jsonp calls initiate by UWA.Json.request.
         * @private
         */
        jsonp: {},

        /**
         * Convert a value to JSON, optionally replacing values if a replacer
         * function is specified, or optionally including only the specified
         * properties if a replacer array is specified.
         *
         * Note:
         * Alias to JSON.stringify native browser function.
         *
         * @param {Object} value - The value to convert to a JSON string
         * @param {Function} replacer - If a function, transforms values and properties
         * encountered while stringifying; if an array, specifies the set
         * of properties included in objects in the final string
         * @param {Boolean} space - Causes the resulting string to be pretty-printed.
         * @return {String}
         *
         * @example
         * UWA.Json.encode({})                  // '{}';
         * UWA.Json.encode(true)                // 'true';
         * UWA.Json.encode("foo")               // '"foo"';
         * UWA.Json.encode([1, "false", false]) // '[1,"false",false]';
         * UWA.Json.encode({ x: 5 })            // '{"x":5}';
         * UWA.Json.encode({x: 5, y: 6});       // '{"x":5,"y":6}' or '{"y":6,"x":5}'
         *
         * @alias UWA.Json.encode
         * @memberOf module:UWA/Json
         */
        encode: JSON.stringify,

        /**
         * Parses a string as JSON and returns the parsed value.
         *
         * Note:
         * Alias to JSON.parse native browser function.
         *
         * @param {Object} text - The string to parse as JSON
         * @param {Function} reviver - If a function, prescribes how the value originally
         * produced by parsing is transformed, before being returned
         * @return {Object} or throw Error if failed to decode
         *
         * @example
         * UWA.Json.decode('{}');               // {}
         * UWA.Json.decode('true');             // true
         * UWA.Json.decode('"foo"');            // "foo"
         * UWA.Json.decode('[1, 5, "false"]');  // [1, 5, "false"]
         * UWA.Json.decode('null');             // null
         *
         * @alias UWA.Json.decode
         * @memberOf module:UWA/Json
         */
        decode: JSON.parse,

        /**
         * Clone a value by converting it to be a safely JSON serializable value. Use this to
         * convert unsupported value types to valid JSON types (null, string, number, array, object)
         * and remove circular references.
         *
         * @param {any} value - The value to convert
         * @param {Object} [options] - a hash of options
         * @param {function} [options.toJSON] - a function called on each values, recursively. The
         * value will be replaced by the result of the function in the resulting object. By default,
         * this function is checking if a `toJSON` method exists and use it to get a serializable
         * result. You normally don't need to change this (see the fallback option).
         * @param {function} [options.fallback] - a function called on each unserializable value.
         * For now, values can't be serializable for two reasons:
         *
         * * it does not have a JSON type (ea: not a plain object, null, string, number nor
         * boolean)
         *
         * * it is the reference of previous value (= circular reference)
         *
         * The value is passed as first argument. The reason is passed as second argument (can be
         * either "unsupported" or "circular"). By default, the fallback returns 'null', so all
         * unserializable values are replaced by null.
         *
         * @return {any} the JSON-safe value
         *
         * @example
         * var obj = {
         *     safe: 1,
         *     unsupported: /foo/
         * };
         *
         * obj.circular = obj;
         *
         * UWA.Json.prune(obj);
         * // will return the following object:
         * {
         *      safe: 1,
         *      unsupported: null,
         *      circular: null
         * }
         *
         * UWA.Json.prune(obj, {
         *      fallback: function (o, reason) {
         *          if (UWA.is(o, 'regexp')) {
         *              return String(o);
         *          }
         *          if (reason === 'circular') {
         *              return { error: 'Circular reference' };
         *          }
         *          return null;
         *      }
         * });
         * // Will return the following object:
         * {
         *     safe: 1,
         *     unsupported: "/foo/",
         *     circular: {
         *         error: "Circular reference"
         *     }
         * }
         *
         * @alias UWA.Json.prune
         * @memberOf module:UWA/Json
         */
        prune: function (rootObject, options) {
            var backreferences = [],
                toJSON = (options && options.toJSON) || function (i) {
                    return UWA.is(i) && UWA.is(i.toJSON, 'function') ? i.toJSON() : i;
                },
                fallback = (options && options.fallback) || function () {
                    return null;
                };

            function iter(object) {
                var result, key;

                object = toJSON(object);

                switch (UWA.typeOf(object)) {
                case 'string':
                case 'number':
                case 'boolean':
                    return object;
                case 'array':
                    if (backreferences.indexOf(object) !== -1) {
                        return fallback(object, 'circular');
                    }

                    backreferences.push(object);
                    result = object.map(iter);
                    backreferences.pop();
                    return result;
                case 'object':
                    if (!UWA.is(object, 'plain')) {
                        return fallback(object, 'unsupported');
                    }
                    if (backreferences.indexOf(object) !== -1) {
                        return fallback(object, 'circular');
                    }

                    backreferences.push(object);
                    result = {};
                    for (key in object) {
                        if (UWA.owns(object, key)) {
                            result[key] = iter(object[key]);
                        }
                    }
                    backreferences.pop();
                    return result;
                default:
                    return object === null ? object : fallback(object, 'unsupported');
                }
            }
            return iter(rootObject);
        },

        /**
         * Regular expression to test property values for being JSON.
         *
         * @param {String} value - the string to test if it's valid JSON.
         * @return {Bool} `true` is valid JSON else `false`.
         *
         * @example
         * UWA.Json.isJson('{}');     // true
         * UWA.Json.isJson('Hello');  // false
         *
         * @alias UWA.Json.isJson
         * @memberOf module:UWA/Json
         */
        isJson: function (value) {

            var isJson = false;

            if (UWA.is(value, 'string')) {

                try {

                    JSON.parse(value);

                    isJson = true;

                } catch (e) {
                    // Ignore JSON.parse errors
                }
            }

            return isJson;
        },

        /**
         * Convert a XML String or Object into and Json Object.
         *
         * @param {String|Object} xml - The XML source
         * @return {Object} The Object results from XML convertion into JSON.
         *
         * @example
         * UWA.Json.xmlToJson(
         *    '&lt;items title=&quot;titleAttribute&quot;&gt;' +
         *    '   &lt;item name=&quot;item1&quot; foo=&quot;bar&quot;&gt;item1TagValue&lt;/item&gt;' +
         *    '   &lt;item name=&quot;item2&quot; foo=&quot;bar&quot;&gt;item2TagValue&lt;/item&gt;' +
         *    '   &lt;label&gt;label1TagValue&lt;/label&gt;' +
         *    '   &lt;label&gt;label2TagValue&lt;/label&gt;' +
         *    '   &lt;title type=&quot;foo&quot;&gt;titleTagValue&lt;/title&gt;' +
         *    '&lt;/items&gt;'
         * );
         * // will return Object:
         * {
         *    "items": {
         *        "title": [
         *            "titleAttribute",
         *            {
         *                "type": "foo",
         *                "nodeValue": "titleTagValue"
         *            }
         *        ],
         *        "item": [
         *            {
         *                "name": "item1",
         *                "foo": "bar",
         *                "nodeValue": "item1TagValue"
         *            },
         *            {
         *                "name": "item2",
         *                "foo": "bar",
         *                "nodeValue": "item2TagValue"
         *            }
         *        ],
         *        "label": [
         *            "label1TagValue",
         *            "label2TagValue"
         *        ]
         *    }
         * }
         *
         * @alias UWA.Json.xmlToJson
         * @memberOf module:UWA/Json
         */
        xmlToJson: function (xml) {

            var i, l, result, childNode, attribute, nodeName,

                toString = function () {
                    return this.nodeValue;
                },

                valueOf = function () {
                    return parseInt(this.nodeValue, 10);
                };

            // Convert to XML if string
            if (typeof xml === 'string') {
                xml = Utils.loadXml(xml);
            }

            // It's Node with no attributes and value only result is a String
            if (
                (!xml.attributes || xml.attributes.length === 0) &&
                    xml.childNodes && xml.childNodes.length === 1 &&
                        xml.childNodes[0].nodeName.indexOf('#') !== -1
            ) {

                result = xml.childNodes[0].nodeValue;

            // It's Node with attributes result is a Object
            } else {

                result = {};

                // Add Attributes has property
                if (xml.attributes) {
                    for (i = 0, l = xml.attributes.length; i < l; i++) {
                        attribute = xml.attributes[i];
                        nodeName = attribute.nodeName;
                        if (result[nodeName]) {
                            result[nodeName] = Utils.splat(result[nodeName]);
                            result[nodeName].push(attribute.nodeValue);
                        } else {
                            result[nodeName] = attribute.nodeValue;
                        }
                    }
                }

                // Add childNodes by name into a Array property
                for (i = 0, l = xml.childNodes.length; i < l; i++) {

                    childNode = xml.childNodes[i];
                    nodeName = childNode.nodeName;

                    // Set existing childNode not start nodeName with # has new property array value
                    if (result[nodeName]) {
                        result[nodeName] = Utils.splat(result[nodeName]);
                        result[nodeName].push(Json.xmlToJson(childNode));

                    // Set childNode not start nodeName with # has property
                    } else if (nodeName.indexOf('#') === -1) {
                        result[nodeName] = Json.xmlToJson(childNode);

                    // Set childNode start nodeName with # (#text #cdata-section) has toString and valueOf value
                    } else if (childNode.nodeValue.trim().length > 0) {

                        result.nodeValue = childNode.nodeValue;
                        result.toString = toString;
                        result.valueOf = valueOf;
                    }
                }
            }

            return result;
        },

        /**
         * Apply and JSONPath query filter to a JSON Object.
         *
         * ##### Example
         *
         * ```javascript
         * var MyStore = {
         *    "store": {
         *        "book": [
         *            { "category": "reference",
         *              "author": "Nigel Rees",
         *              "title": "Sayings of the Century",
         *              "price": 8.95
         *            },
         *            { "category": "fiction",
         *              "author": "Evelyn Waugh",
         *              "title": "Sword of Honour",
         *              "price": 12.99
         *            },
         *            { "category": "fiction",
         *              "author": "Herman Melville",
         *              "title": "Moby Dick",
         *              "isbn": "0-553-21311-3",
         *              "price": 8.99
         *            },
         *            { "category": "fiction",
         *              "author": "J. R. R. Tolkien",
         *              "title": "The Lord of the Rings",
         *              "isbn": "0-395-19395-8",
         *              "price": 22.99
         *            }
         *        ],
         *        "bicycle": {
         *          "color": "red",
         *          "price": 19.95
         *        }
         *    }
         * };
         *
         * UWA.Json.path(MyStore, "$..author");
         * // will return ["Nigel Rees", "Evelyn Waugh", "Herman Melville", "J. R. R. Tolkien"]
         *
         * UWA.Json.path(MyStore, "$..author", {
         *     resultType:"PATH"
         * });
         * // will return [ "$['store']['book'][0]['author']", "$['store']['book'][1]['author']", ...]
         * ```
         *
         * ##### More examples
         *
         * | XPath                | JSONPath                                  | Result                                                                  |
         * | -------------------- | ----------------------------------------- | ----------------------------------------------------------------------- |
         * | /store/book/author   | $.store.book[*].author                    | the authors of all books in the store
         * | //author             | $..author                                 | all authors
         * | /store/ *            | $.store.*                                 | all things in store, which are some books and a red bicycle.
         * | /store//price        | $.store..price                            | the price of everything in the store.
         * | //book[3]            | $..book[2]                                | the third book
         * | //book[last()]       | $..book[(@.length-1)] OR $..book[-1:]     | the last book in order.
         * | //book[position()<3] | $..book[0,1] OR $..book[:2]               | the first two books
         * | //book[isbn]         | $..book[?(@.isbn)]                        | filter all books with isbn number
         * | //book[price<10]     | $..book[?(@.price<10)]                    | filter all books cheapier than 10
         * | // *                 | $..*                                      | all Elements in XML document. All members of JSON structure.
         *
         * ##### Detailed usage
         *
         * JSONPath is a means of using XPath-like syntax to query JSON structures.
         * It is not a standard, but it does offer a means of querying JavaScript
         * structures directly without needing to convert to or from XML.
         *
         * Here is a complete overview and a side by side comparison of the JSONPath syntax elements with its XPath counterparts.
         *
         * | XPath     | JSONPath               | Description                                                             |
         * | --------- | ---------------------- | ----------------------------------------------------------------------- |
         * | /         | $                      | the root object/element                                                 |
         * | .         | @                      | the current object/element                                              |
         * | /         | . or []                | child operator                                                          |
         * | //        | ..                     | recursive descent. JSONPath borrows this syntax from E4X.               |
         * | * -       | .*                     | all objects/elements regardless their names.                            |
         * | n/a       | [start:end:step]       | array slice operator borrowed from ES4.                                 |
         * | []        | ?()                    | applies a filter (script) expression.                                   |
         * | n/a       | ()                     | script expression, using the underlying script engine.                  |
         * | ..        | n/a                    | parent operator                                                         |
         * | ()        | n/a                    | grouping in Xpath                                                       |
         * | @         | n/a                    | attribute access. JSON structures don't have attributes.                |
         * | []        | []                     | subscript operator. XPath uses it to iterate over element collections and for predicates. In Javascript and JSON it is the native array operator. |
         * | pipe      | [,]                    | Union operator in XPath results in a combination of node sets. JSONPath allows alternate names or array indices as a set. |
         *
         * XPath has a lot more to offer (Location pathes in not abbreviated syntax, operators and functions)
         * than listed here. Moreover there is a remarkable difference how the subscript operator works in Xpath and JSONPath.
         *
         * Square brackets in XPath expressions always operate on the node set resulting from the previous path fragment. Indices always start by 1.
         * With JSONPath square brackets operate on the object or array addressed by the previous path fragment. Indices always start by 0.
         *
         * @see {@link http://www.sitepen.com/blog/2008/07/16/jsonquery-data-querying-beyond-jsonpath/}
         * @see {@http://goessner.net/articles/JsonPath/}
         *
         * @param {Object|Array} obj - Object representing the JSON structure
         * @param {String} expr - JSONPath expression string
         * @param {Object} [arg] - Object controlling path evaluation and output.
         * @param {String} [arg.resultType] ("VALUE"|"PATH") causes the result to be either matching values (default) or normalized path expressions
         * @return {Object|Array} Array holding either values or normalized path expressions matching the input path expression, which can be used for lazy evaluation. `false` in case of no match.
         *
         * @alias UWA.Json.path
         * @memberOf module:UWA/Json
         */
        path: (function () {


            var valueStr = 'VALUE',
                pathStr = 'PATH',
                sepStr = ';',
                queryPath = '$',

                // Cache RegExps for perfs
                regExps = [

                    // normalize
                    /[\['](\??\(.*?\))[\]']|\['(.*?)'\]/g,
                    /'?\.'?|\['?/g,
                    /;;;|;;/g,
                    /;$|'?\]|'$/g,
                    /#([0-9]+)/g,
                    /^\$;?/,

                    // run
                    /(^|[^\\])@/g,
                    /\\@/g,

                    // asPath
                    /^[0-9*]+$/,

                    // slice
                    /^(-?[0-9]*):(-?[0-9]*):?(-?[0-9]*)$/g,

                    // trace
                    /^\(.*?\)$/,
                    /^\?\(.*?\)$/,
                    /^\?\((.*?)\)$/,
                    /^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/,
                    /,/,
                    /'?,'?/

                ];

            function normalize(expr) {

                var subx = [];

                return expr.replace(regExps[0], function ($0, $1, $2) {
                    return "[#" + (subx.push($1 || $2) - 1) + "]";
                }).replace(regExps[1], sepStr)
                    .replace(regExps[2], ';..;')
                    .replace(regExps[3], '')
                    .replace(regExps[4], function ($0, $1) {
                        return subx[$1];
                    })
                    .replace(regExps[5], '');
            }

            function run(obj, query, val) {

                var queryEval = 'var valueEval = arguments[2];' +
                    query.replace(regExps[6], "$1valueEval").replace(regExps[7], "@");

                try {
                    // Required to compute query
                    return obj && val && eval(queryEval);  // eslint-disable-line no-eval
                } catch (e) {
                    throw new SyntaxError("UWA.Json.path error: " + e.message + ' for query "' + query + '"');
                }
            }

            function asPath(path) {

                var i, n,
                    x = path.split(sepStr),
                    p = queryPath;

                for (i = 1, n = x.length; i < n; i++) {
                    p += regExps[8].test(x[i]) ? ("[" + x[i] + "]") : ("['" + x[i] + "']");
                }

                return p;
            }

            function store(p, v, result, resultType) {

                if (p) {
                    result[result.length] = (resultType === pathStr ? asPath(p) : v);
                }

                return Boolean(p);
            }

            function walk(loc, expr, val, path, f) {

                var i, n, m,
                    type = UWA.typeOf(val);

                if (type === 'array') {
                    for (i = 0, n = val.length; i < n; i++) {
                        if (val.hasOwnProperty(i)) {
                            f(i, loc, expr, val, path);
                        }
                    }
                } else if (type === 'object') {
                    for (m in val) {
                        if (val.hasOwnProperty(m)) {
                            f(m, loc, expr, val, path);
                        }
                    }
                }
            }

            function slice(loc, expr, val, path, result, resultType) {

                if (Array.isArray(val)) {

                    var i,
                        len = val.length,
                        start = 0,
                        step = 1,
                        end = len;

                    loc.replace(regExps[9], function ($0, $1, $2, $3) {
                        start = parseInt($1 || start, 10);
                        end = parseInt($2 || end, 10);
                        step = parseInt($3 || step, 10);
                    });

                    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);
                    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);

                    for (i = start; i < end; i += step) {
                        trace(i + sepStr + expr, val, path, result, resultType);  // eslint-disable-line no-use-before-define
                    }
                }
            }

            function trace(expr, val, path, result, resultType) {

                if (expr !== '') {

                    var s, i, n,
                        x = expr.split(sepStr),
                        loc = x.shift();

                    x = x.join(sepStr);

                    if (val && val.hasOwnProperty(loc)) {

                        trace(x, val[loc], path + sepStr + loc, result, resultType);

                    } else if (loc === '*') {

                        walk(loc, x, val, path, function (m, l, currentX, v, p) {
                            trace(m + sepStr + currentX, v, p, result, resultType);
                        });

                    } else if (loc === '..') {

                        trace(x, val, path, result, resultType);
                        walk(loc, x, val, path, function (m, l, currentX, v, p) {
                            if (typeof v[m] === 'object') {
                                trace('..;' + currentX, v[m], p + sepStr + m, result, resultType);
                            }
                        });

                    // [(expr)]
                    } else if (regExps[10].test(loc)) {
                        expr = run(val, loc, val, path.substr(path.lastIndexOf(sepStr) + 1)) + sepStr + x;
                        trace(expr, val, path, result, resultType);

                    // [?(expr)]
                    } else if (regExps[11].test(loc)) {

                        walk(loc, x, val, path, function (m, l, currentX, v, p) {
                            if (run(val, l.replace(regExps[12], "$1"), Array.isArray(v) ? v[m] : v, m)) {
                                trace(m + sepStr + currentX, v, p, result, resultType);
                            }
                        });

                    // [start:end:step] python slice syntax
                    } else if (regExps[13].test(loc)) {
                        slice(loc, x, val, path, result, resultType);

                    // [name1,name2,...]
                    } else if (regExps[14].test(loc)) {
                        for (s = loc.split(regExps[15]), i = 0, n = s.length; i < n; i++) {
                            expr = s[i] + sepStr + x;
                            trace(expr, val, path, result, resultType);
                        }
                    }

                } else {
                    store(path, val, result, resultType);
                }
            }

            return function (obj, expr, arg) {

                var result = [],
                    resultType = (arg && arg.resultType) || valueStr;

                // Valid obj, expr and resultType
                if (obj && expr && (resultType === valueStr || resultType === pathStr)) {
                    trace(normalize(expr), obj, queryPath, result, resultType);
                }

                return result.length ? result : false;
            };

        }()),

        /**
         * Creates a JSON request using script tag injection and handles the callbacks for you.
         *
         * @see {@link http://en.wikipedia.org/wiki/JSON#JSONP}
         *
         * @example
         * // Create a Callback
         * myWidget.parse = function (response) {
         *  // your parsing code
         * }
         *
         * // Launch request
         * var myRequest = UWA.Json.request('http://example.org/api.php', {
         *    onComplete: myModule.parse,
         *    data: {
         *        name: "Bob"
         *    }
         * });
         *
         * // Cancel Json request
         * myRequest.cancel();
         *
         * // Will request url "http://example.org/api.php?callback=<random>&name=Bob"
         * // and expect has response "<random>("Your data Json or Not")"
         *
         * @param {String} url - the URL of the data source
         * @param {Object} options - Settings object
         * @param {Function} options.onComplete - Callback receiving the Ajax response
         * @param {Function} [options.onTimeout] - Choose your own method
         * @param {Function} [options.onFailure] - Choose your own method
         * @param {Function} [options.onCancel] - Choose your own method
         * @param {Object} [options.data={}] - GET params as object
         * @param {Number} [options.timeout=25000] - Set your request timeout in ms
         * @param {Boolean} [options.async=true] - Asynchronous request
         * @param {Function} [options.callback] - random (e.g jsonp123456789)
         * @param {Function} [options.callbackMode] - JsonP mode function or object
         * @param {String} [options.callbackName] - JsonP callback parameter name
         * @param {Boolean} [options.useOfflineCache=false] - enable Offline cache
         * @param {Boolean} [options.useJsonpRequest=false] - always use JsonP to do the request
         *
         * @return Nothing, but if the request is successful, the callback method is fired and receives the content as parameter.
         *
         * @alias UWA.Json.request
         * @memberOf module:UWA/Json
         */
        request: function (url, options) {

            /*jshint maxstatements: 50*/

            //
            // 1. Prepare vars
            //

            options = options || {};

            var request, jsonpId, callbackMode,
                onFailure, onComplete, onTimeout,
                useOfflineCache, fromDataRequest,
                head, script, intervalStartTime, intervalRequest, poller,

                //
                useJsonpRequest =
                    options.useJsonpRequest ? true :
                    Utils.matchUrl(url, window.location) ? false :
                    UWA.Data && UWA.Data.useJsonpRequest && !UWA.Data.allowCrossOriginRequest,

                // Save state
                originalUrl = url,

                // Alias
                isOnline = Client.isOnline,
                jsonp = Json.jsonp,

                defaultOptions = {
                    fromDataRequest: false,
                    useOfflineCache: false,
                    async: true,
                    timeout: false,
                    callback: 'jsonp' + (Date.now() + Utils.random(1, 10000)), // Generating unique IDs for jsonp calls
                    callbackName: 'callback',
                    callbackMode: 'function',
                    callbackModeName: 'callbackMode',
                    onCancel: function () {
                        // Nothing to do by default...
                    },
                    onFailure: function (error) {
                        throw error;
                    },
                    onComplete: function () {
                        // Nothing to do by default cause it could be overide by Widget developer
                    }
                };

            // Set Options
            options = UWA.merge(options || {}, defaultOptions);

            // 25 seconds by default, 15 if useOfflineCache
            if (options.timeout === false) {
                if (options.useOfflineCache) {
                    options.timeout = 15000;
                } else {
                    options.timeout = 25000;
                }
            } else {
                options.timeout = parseInt(options.timeout, 10);
            }

            //
            // 2. Update Url
            //

            // Handle data options
            if (options.data) {

                 // Update Url
                url += ((url.indexOf('?') > -1) ? '&' : '?') + Utils.toQueryString(options.data);
            }

            // Clean it to avoid bad custom Javascript callback
            jsonpId = options.callback.replace(/[^a-zA-Z0-9_.]/g, '');

            callbackMode = options.callbackMode;

            // Stick generated callback function on end of provided method URL
            if (callbackMode) {

                url = url.replace(/\=(\?|%3F)/g, '=' + jsonpId);

                // Stick callbackName
                url += (url.indexOf('?') > -1 ? '&' : '?') + options.callbackName + '=' + jsonpId;

                // Stick callbackMode
                url += '&' + options.callbackModeName + '=' + callbackMode;
            }

            // Avoid Url limit overflow
            if (url.length > 2048) {
                throw new Error('Proxified url is more than 2048 characters, you should consider using POST and CORS Ajax.');
            }

            //
            // 3. Create Callbacks
            //

            // Register callbacks & timeout interval value
            onFailure = options.onFailure;
            onTimeout = options.onTimeout || onFailure;
            onComplete = options.onComplete;
            useOfflineCache = options.useOfflineCache;
            fromDataRequest = options.fromDataRequest;

            // Create a closure onFailure callback
            options.onFailure = function (error) {

                // Clear JsonP Request
                Json.cleanRequest(jsonpId, options);

                // Use Offline cache has fallback if enable
                if (useOfflineCache && fromDataRequest === false) {

                    var cachedJsonData = Json.getFromCache(originalUrl);

                    // Call onFailure
                    if (!UWA.is(cachedJsonData)) {
                        onFailure(error);

                    // Call callback with offline cached value
                    } else {

                        // Set Offline for next 5 seconds
                        if (isOnline()) {
                            isOnline(false, 5000);
                        }

                        onComplete(cachedJsonData);
                    }

                // Call original onFailure
                } else {
                    onFailure(error);
                }
            };

            // Create a closure onFailure callback
            options.onTimeout = function (error) {

                // Clear JsonP Request
                Json.cleanRequest(jsonpId, options);

                // Use Offline cache has fallback if enable
                if (useOfflineCache && fromDataRequest === false) {

                    var cachedJsonData = Json.getFromCache(originalUrl);

                    // Call onFailure
                    if (!UWA.is(cachedJsonData)) {
                        onTimeout(error);

                    // Call callback with offline cached value
                    } else {

                        // Set Offline for next 5 seconds
                        if (isOnline()) {
                            isOnline(false, 5000);
                        }

                        onComplete(cachedJsonData);
                    }

                // Call original onFailure
                } else {
                    onTimeout(error);
                }
            };

            // Create a general callback
            options.onComplete = function (jsonData) {

                // Clear JsonP Request
                Json.cleanRequest(jsonpId, options);

                try {

                    // Detect Jsonp Proxy error
                    if (
                        fromDataRequest && jsonData &&
                                jsonData.error && jsonData.error.type &&
                                    jsonData.error.type === 'UWA_Platform_Exposition'
                    ) {

                        throw new Error(
                            UWAString.format('ObjectError: url "{0}" return Error with value "{1}"', fromDataRequest, jsonData.error.message || jsonData.error)
                        );
                    }

                    // Call callback
                    onComplete(jsonData);

                } catch (error) {
                    onFailure(error);
                }
            };

            //
            // 4. Request params
            //

            // If cache is disable, add a date.now to avoid possible cache.
            if (options.cache < 0) {
                url += (url.indexOf('?') > -1 ? '&' : '?') + '_=' + Date.now();
            }

            //
            // 5. Request
            //

            // Browser is in offline mode and useOfflineCache is enable
            if (useOfflineCache && isOnline() === false) {

                options.onFailure(new Error('Network is Offline'));

            // Simulate JsonP throw UWA Ajax request if useJsonpRequest is false
            // For Example Adobe Air do not allow JsonP request for security
            } else if (!useJsonpRequest) {

                request = Ajax.request(url, UWA.merge({
                    headers: {
                        'Accept': 'application/json,text/javascript,*/*',
                        'X-Request': 'JSON'
                    },
                    onComplete: function (data) {

                        if (callbackMode && !Json.isJson(data)) {

                            var match;

                            if (callbackMode === 'object') {
                                match = data.match(/=\s\(?([\s\S]*?)\)?;?\s*$/);
                            } else {
                                match = data.match(/\(([\s\S]*?)\);?\s*$/);
                            }

                            if (match) {
                                data = match[1];
                            }
                        }

                        if (Json.isJson(data)) {
                            options.onComplete(UWA.Json.decode(data));
                        } else {
                            options.onFailure(new Error('Invalid JSON Response: "' + data + '"'));
                        }
                    },
                    onFailure: options.onFailure
                }, options));

            // Simple JsonP with poller
            } else {

                // Keep track of script run status
                jsonp[jsonpId] = {
                    readyState: false,
                    options: options
                };

                // Handle callback Mode Object
                if (callbackMode === 'object') {

                    // Monitor Object value change
                    intervalStartTime = Date.now();
                    intervalRequest = 13;
                    poller = function () {

                        var waitingTime,
                            currentTime = Date.now();

                        // is loaded ?
                        if (window[jsonpId] !== undefined) {

                            jsonp[jsonpId].readyState = 'loaded';

                            // Call overided callback
                            options.onComplete(window[jsonpId]);

                        // is timeout ?
                        } else if (currentTime > (intervalStartTime + options.timeout)) {
                            waitingTime = (currentTime - intervalStartTime);
                            options.onTimeout(new Error('Request timed out after ' + waitingTime + 'ms with timeout value ' + options.timeout + ' ms'));

                        // is waiting
                        } else {
                            jsonp[jsonpId].poll = setTimeout(poller.bind(this), intervalRequest);
                        }
                    };

                // Handle callback Mode Function
                } else {

                    // Define callback function for JSONP call
                    window[jsonpId] = function (tmp) {

                        // Avoid possble bug exec after timeout
                        if (jsonp[jsonpId] !== undefined) {
                            jsonp[jsonpId].data = tmp;
                            jsonp[jsonpId].readyState = 'loaded';
                        }
                    };

                    // Poll for script completion on timeout interval
                    intervalStartTime = Date.now();
                    intervalRequest = 13;
                    poller = function () {

                        var waitingTime,
                            currentTime = Date.now();

                        // is loaded ?
                        if (jsonp[jsonpId].readyState === 'loaded') {

                            // Call overided callback
                            options.onComplete(jsonp[jsonpId].data);

                        // is timeout ?
                        } else if (currentTime > (intervalStartTime + options.timeout)) {
                            waitingTime = (currentTime - intervalStartTime);
                            options.onTimeout(
                                new Error('Timout request after ' + waitingTime + 'ms with timeout value ' + options.timeout + ' ms')
                            );

                        // is waiting
                        } else {
                            jsonp[jsonpId].poll = setTimeout(poller.bind(this), intervalRequest);
                        }
                    };
                }

                // Inject script URL to head
                head = document.getElementsByTagName('head')[0];
                script = UWA.createElement('script', {
                    type: 'text/javascript',
                    src: url,
                    async: options.async
                });
                script.addEvent('error', function () {
                    options.onFailure(new Error('Syntax or http error: ' + url));
                });
                script.inject(head);

                // Store Script reference into poller
                jsonp[jsonpId].script = script;

                // Start Poller
                poller(options);

                request = {
                    jsonId: jsonpId,
                    script: script,
                    cancel: function () {
                        jsonp[jsonpId].aborted = true;
                        Json.cleanRequest(jsonpId);
                    }
                };
            }

            return request;
        },

        /**
         * Remove JSONP tag script and callback function.
         *
         * @param {Object} jsonpId - The id of request callback
         *
         * @alias UWA.Json.cleanRequest
         * @memberOf module:UWA/Json
         */
        cleanRequest: function (jsonpId) {

            var options,
                head = document.getElementsByTagName('head')[0],
                jsonp = Json.jsonp[jsonpId];

            if (jsonp) {

                options = jsonp.options;

                // Clear Poller Timeout
                clearTimeout(jsonp.poll);

                if (options.callbackMode !== 'object') {

                    // Create empty function on callback to avoid js error like:
                    // Uncaught ReferenceError: jsonp1365017385630 is not defined
                    window[jsonpId] = function () {

                        // Then clean function on first call
                        try {
                            delete window[jsonpId];
                        } catch (e) {
                            // never trust delete on a host object
                        }
                    };
                }

                if (jsonp.script) {
                    head.removeChild(jsonp.script);
                    delete jsonp.script;
                }

                if (jsonp.aborted) {
                    options.onCancel(null, options);
                }
            }
        }
    };

    return UWA.namespace('Json', Json, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Classes implementing or extending this Class will have extra methods to handle options.
 *
 * @module   UWA/Class/Options
 *
 *
 * @example
 * define('MyProject/Class/Person', [
 *     'UWA/Class',
 *     'UWA/Class/Options'
 * ], function (Class, Options) {
 *
 *     var Person = Class.extend(Options, {
 *
 *         init: function (options) {
 *             this.setOptions(options);
 *         },
 *
 *         getName: function() {
 *             return this.getOption('name', 'Guest'):
 *         },
 *
 *         setName: function(value) {
 *             return this.setOption('name', value):
 *        }
 *     });
 *
 *     return Person;
 * });
 *
 * require(['MyProject/Class/Person'], function (MyClass) {
 *
 * var bob = new MyClass({
 *     name: 'Bob'
 * });
 *
 * bob.getName(); // Return Bob
 *
 * });
 */
define('UWA/Class/Options', [
    'UWA/Core',
    'UWA/Class'
], function (Core, Class) {
    'use strict';

    /**
     * Add methods to set and get instance options.
     * @constructs UWA.Class.Options
     * @memberof module:UWA/Class/Options
     */
    var Options = Class.extend(/** @lends module:UWA/Class/Options.UWA.Class.Options# */{

        /**
         * Set options of this instance.
         *
         * > Passing an 'events' field will automatically add those events.
         *
         * @param {Object} options - Options hash
         * @return {this}
         */
        setOptions: function (options) {

            var that = this;
            options = options || {};

            if (!that.hasOwnProperty('options')) {
                that.options = Core.clone(that.defaultOptions || that.options || {});
            }

            // Apply new events before extend
            if (options.events && that.addEvents) {
                that.addEvents(options.events);
            }

            // Extend new options
            Core.extend(that.options, options, true);

            return that;
        },

       /**
         * Set a single option value.
         *
         * @param {String} name - The option name
         * @param {*} value - The option value.
         * @return {this}
         */
        setOption: function (name, value) {
            var options = {};
            options[name] = value;
            return this.setOptions(options);
        },

        /**
         * Get a single option value.
         *
         * @param {String} name - the option name
         * @param {*} defaultValue - The default option value.
         * @return {this}
         */
        getOption: function (name, defaultValue) {

            var options = this.options;

            return options[name] !== undefined ? options[name] : defaultValue;
        }
    });

    return Core.namespace('Options', Options, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Classes implementing or extending this Class will have extra methods to handle debug.
 *
 * @module   UWA/Class/Debug
 *
 *
 * @example
 * define('MyProject/Class/TaskList', [
 *     'UWA/Class',
 *     'UWA/Class/Debug'
 * ], function (Class, Debug) {
 *
 *     var TaskList = Class.extend(Debug, {
 *
 *         init: function () {
 *
 *             // Add elements storage
 *             this.elements = {};
 *         },
 *
 *         addElement: function(name, value) {
 *
 *             // Display debug info using log method.
 *             this.log(UWA.String.format('addElement name={0}, value={1}', name, value));
 *
 *             this.elements[name] = value;
 *         }
 *     });
 *
 *     return TaskList;
 * });
 *
 * require(['MyProject/Class/TaskList'], function (TaskList) {
 *
 * var myTaskList = new TaskList();
 *
 * // Enable debug mode, that will enable log output into the console.
 * myTaskList.setDebugMode(true);
 *
 * // Call addElement
 * myTaskList.addElement('buy beer', 'duff');
 *
 * });
 */
define('UWA/Class/Debug', [
    'UWA/Core',
    'UWA/Class'
], function (Core, Class) {
    'use strict';

    var Debug = Class.extend({

        /**
         * The debug mode flag for the widget. The default value is `false`. When `true`, messages written with `log` method
         * will appear in the console debug.
         *
         * @type {Boolean}
         */
        debugMode: false,

        /**
         * Set the debugMode of the instance.
         *
         * @param {boolean} mode - `true` to enable debug else `false`
         * @return {this}
         */
        setDebugMode: function (mode) {
            this.debugMode = (mode === true || mode === 'true');
            return this;
        },

        /**
         * Logs instance's messages in the console if the `debugMode` is `true`.
         * It is using UWA.log which usually works with Firebug, Safari and Opera.
         *
         * @example
         * widget.log("Widget is loading");
         *
         * @param {String} message - The message to display in the console debug
         * @return {this}
         */
        log: function (message) {
            if (this.debugMode === true) {
                Core.log(message);
            }

            return this;
        }
    });

    return Core.namespace('Debug', Debug, Class);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Storage
 *
 */
define('UWA/Storage', [
    'UWA/Internal/Deprecate',
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Class/Debug',
    'UWA/Json'
], function (Deprecate, UWA, Class, Options, Debug, Json) {
    'use strict';

    var Storage = Class.extend(Options, Debug, /** @lends module:UWA/Storage.UWA.Storage# */ {

        /**
         * The current adapter instances.
         *
         * @type {Array<Object>}
         * @private
         */
        AdaptersInstances: null,

        /**
         * The current adapter to use for storage.
         *
         * @type {UWA.Storage.Adapter.Abstract}
         */
        currentAdapter: null,

        /**
         * Provide global settings for overwriting.
         *
         * @private
         */
        defaultOptions: {
            database: 'default',
            adapter: null,
            adapterOptions: {},
            availableAdapters: []
        },

        /**
         * Provide internal keys name for storage.
         *
         * @type {Object}
         * @private
         */
        internalKeys: {
            keysIndex: '_keysIndex',
            lastUpdate: '_lastUpdate'
        },

        /**
         * Boolean for ready state handling.
         *
         * @type {Boolean}
         * @private
         */
        isReady: false,

        /**
         * Cross-Platform Data Storage API providing methods for store persistent Key/Value database into the current platform.
         *
         * Features:
         *
         * - NoSQL Key/Value storage
         * - Multiple databases support
         * - API support JSON Object value storage
         * - Support expiration of data using <get> second argument.
         *
         * @example
         * var myStorage = new UWA.Storage({
         *     adapter: 'Cookies',
         *     database: 'myDatabase'
         * });
         *
         * // Store value
         * myStorage.set("toto", {
         *     "name": "titi"
         * });
         *
         * // Read value
         * myStorage.get("toto");
         *
         * // Read value that expire after one hour
         * myStorage.get("toto", 3600000);
         *
         * // Clear value
         * myStorage.remove("toto");
         *
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Storage
         * @mixes UWA.Class.Options
         * @mixes UWA.Class.Debug
         * @memberof module:UWA/Storage
         */
        init: function (options) {
            Deprecate.warn("UWA/Storage");

            var adapter,
                that = this;

            that.AdaptersInstances = {};

            Storage.Instances.push(that);

            // Set options
            that.setOptions(options);

            adapter = that.options.adapter;

            // if no adapter given, update availables ones and set first available has current
            if (!adapter || adapter === 'auto') {
                that.setCurrentAdapterFromDetected();
            } else {
                that.setCurrentAdapter(adapter);
            }
        },

        /**
         * Initialize available Adapters.
         */
        initAvailableAdapters: function () {

            var adapter,
                that = this,
                availableAdapters = that.options.availableAdapters,
                adapters = Storage.Adapter;

            // Add available adapter
            if (availableAdapters.length === 0) {
                for (adapter in adapters) {
                    if (adapters.hasOwnProperty(adapter) && adapter !== 'Abstract') {
                        availableAdapters.push(adapter);
                    }
                }
            }

            // Create Instance of all adapter
            availableAdapters.forEach(function (adapterName) {
                that.getAdapterInstance(adapterName);
            });
        },

        /**
         * Check if Adapter is available by Adapter name.
         *
         * @param {String} adapterName - Adapter name to check availability
         * @return {Boolean} `true` if available else `false`.
         */
        isAvailableAdapter: function (adapterName) {

            var adapter,
                that = this,
                isAvailable = false;

            try {

                adapter = that.getAdapterInstance(adapterName);

                if (adapter && adapter.isAvailable()) {
                    isAvailable = true;
                    that.log('UWA.Storage:detectAvailableAdapter: "' + adapterName + '" is available');
                } else {
                    that.log('UWA.Storage:detectAvailableAdapter: "' + adapterName + '" is not available');
                }

            } catch (e) {
                that.log('UWA.Storage:detectAvailableAdapter: "' + adapterName + '" is not available cause: ' + e);
            }

            return isAvailable;
        },

        /**
         * Get Adapter instance by Adapter name.
         *
         * @param {String} adapterName - Adapter name requested instance
         * @return {Object} An instance of UWA.Storage.Adapter.Abstract.
         */
        getAdapterInstance: function (adapterName) {

            var that = this,
                AdaptersInstances = that.AdaptersInstances;

            if (typeof adapterName !== 'string') {
                throw new Error('Bad adapterName param value "' + adapterName + '" for getAdapterInstance.');
            }

            if (!AdaptersInstances[adapterName]) {
                AdaptersInstances[adapterName] = new Storage.Adapter[adapterName](that, that.options.adapterOptions);

                if (!(AdaptersInstances[adapterName] instanceof Storage.Adapter.Abstract)) {
                    throw new Error('UWA.Storage.Adapter.' + adapterName + ' is not an instance of UWA.Storage.Adapter.Abstract');
                }
            }

            return AdaptersInstances[adapterName];
        },

        /**
         * Update options.availableAdapters by testing each adapter with <isAvailableAdapter>.
         */
        detectAvailableAdapter: function () {

            var that = this,
                options = that.options,
                availableAdapter = [];

            that.initAvailableAdapters();

            options.availableAdapters.forEach(function (adapterName) {
                if (that.isAvailableAdapter(adapterName)) {
                    availableAdapter.push(adapterName);
                }
            });

            options.availableAdapters = availableAdapter;
        },

        /**
         * Update <currentAdapter> with values from <detectAvailableAdapter>
         */
        setCurrentAdapterFromDetected: function () {

            var that = this,
                options = that.options;

            that.detectAvailableAdapter();

            // set first available has current
            if (options.availableAdapters.length > 0) {
                that.setCurrentAdapter(options.availableAdapters[0]);
            } else {
                throw new Error('UWA.Storage: No adapter available detected.');
            }
        },

        /**
         * Set the current storage adapter and connect it to current database.
         */
        setCurrentAdapter: function (adapterName) {

            var adapterInstance,
                that = this;

            if (typeof adapterName !== 'string') {
                throw new Error('Bad adapterName param value "' + adapterName + '" for setCurrentAdapter.');
            }

            if (that.isAvailableAdapter(adapterName)) {

                adapterInstance = that.getAdapterInstance(adapterName);
                adapterInstance.connect(that.options.database);

                that.log('UWA.Storage:setCurrentAdapter: ' + adapterName + ';');

                that.adapter = adapterName;

                that.currentAdapter = adapterInstance;
            } else {

                that.log('UWA.Storage:setCurrentAdapter: "' + adapterName + '" fail fallback in auto detect mode');

                that.setCurrentAdapterFromDetected();
            }
        },

        /* Group: Data management */

        /**
         * Provide a simple interface for storing/getting values.
         *
         * @example
         * // Store Key Value
         * myStorage.store("myKey", "Hello");
         * // Or get Key Value
         * myStorage.store("myKey");
         *
         * @param {String} key - The key of value to store/get
         * @param {String} value - The value of value to store
         * @return {Void} The current key value.
         */
        store: function (key, value) {

            var currentValue,
                that = this,
                currentAdapter = that.currentAdapter;

            if (currentAdapter) {

                currentValue = that.safeResurrect(currentAdapter.get(key));

                // Executing a get command if number of arguments is eguals 1
                if (arguments.length === 1) {

                    that.log('Get Key "' + key + '" with value "' + currentValue + '"');

                // Executing a set command
                } else if (currentValue !== value) {

                    currentValue = that.safeStore(value);

                    that.log('Update Key "' + key + '" with value "' + value + '" and stored value "' + currentValue + '"');

                    currentValue = currentAdapter.set(key, currentValue);
                }
            }

            return currentValue;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key of value to remove
         * @return {Void} Previous key value.
         */
        remove: function (key) {

            var that = this;

            if (!that.currentAdapter) {
                return false;
            }

            that._updateLastUpdateDate();
            that._removeKeyFromKeysIndex(key);

            return that.safeResurrect(that.currentAdapter.rem(key));
        },

        /**
         * Alias access for reading key value.
         *
         * @param {String} key - The key of value to get
         * @param {String} time - The key expiration time in milliseconds
         * @return {Void} Current key value.
         */
        get: function (key, time) {

            var keysIndex, value,
                that = this;

            if (time) {

                // Get all Keys
                keysIndex = that._getKeysIndex();

                // If key exists and time is less than the recorded now - time
                // get the value from storage
                if (
                    keysIndex.hasOwnProperty(key) &&
                        (Date.now() - keysIndex[key]) <= time
                ) {
                    value = that.store(key);
                }

            } else {
                value = that.store(key);
            }

            return value;
        },

        /**
         * Alias access for store key value.
         *
         * @param {String} key - The key of value to store
         * @param {String} value - The value of value to store
         * @return {Void} Current key value.
         */
        set: function (key, value) {

            var that = this;

            that._updateLastUpdateDate();
            that._addKeyToKeysIndex(key);

            return that.store(key, value);
        },

        /**
         * Get All keys values.
         *
         * @return {Array} Current keys values indexed by Key.
         */
        getAll: function () {

            var that = this,
                keysIndex = Object.keys(this._getKeysIndex()),
                data = {};

            keysIndex.forEach(function (dataKey) {
                data[dataKey] = that.get(dataKey);
            });

            return data;
        },

        /* Group: Core Methods */

        /**
         * Parse a value as JSON before its stored.
         *
         * @param {Void} value - Value to store
         * @return {String} Clean string.
         */
        safeStore: function (value) {
            return Json.encode(value);
        },

        /**
         * Restores JSON'd values before returning.
         *
         * @param {Void} value - Value to restore
         * @return {Void} Restored String/Object.
         */
        safeResurrect: function (value) {

            // Check if we need to resurrect JSON encoded string
            if (!UWA.is(value, 'undefined')) {

                try {

                    if (Json.isJson(value)) {
                        value = Json.decode(value);
                    }

                } catch (JsonException) {

                    UWA.log('unsafe Resurrect JSON with value: ' + value);
                    UWA.log(JsonException);
                }
            }

            return value;
        },

        /**
         * Get Last update timestamp.
         *
         * @return {Number} Last update timestamp.
         */
        getLastUpdateDate: function (key) {

            var lastUpdate;

            // Get the time from keyIndex
            if (key) {
                lastUpdate = this._getKeysIndex()[key];

            // Get the time from lastUpdate
            } else {
                lastUpdate = this.get(this.internalKeys.lastUpdate);
            }

            return new Date().setTime(lastUpdate);
        },

        _getKeysIndex: function () {

            var that = this,
                keysIndex = that.safeResurrect(
                    that.currentAdapter.get(this.internalKeys.keysIndex)
                ),
                keysIndexType = UWA.typeOf(keysIndex);

            that.log('Get all keys from keysIndex');

            // Support old keysIndex array formats
            if (keysIndexType === 'array') {

                (function () {

                    var tmp = {},
                        lastUpdate = that.getLastUpdateDate();

                    keysIndex.forEach(function (key) {
                        tmp[key] = lastUpdate;
                    });

                    keysIndex = tmp;
                }());

            // Empty data or corrupted index
            } else if (keysIndexType !== 'object') {
                keysIndex = {};
            }

            return keysIndex;
        },

        _removeKeyFromKeysIndex: function (key) {

            var keyIndex,
                that = this,
                keysIndex = that._getKeysIndex(),
                newKeysIndex = {};

            that.log('Remove key "' + key + '" from keysIndex');

            for (keyIndex in keysIndex) {
                if (
                    keysIndex.hasOwnProperty(keyIndex) &&
                        keyIndex !== key
                ) {
                    newKeysIndex[keyIndex] = keysIndex[keyIndex];
                }
            }

            that._storeKeysIndex(newKeysIndex);
        },

        _addKeyToKeysIndex: function (key) {

            var that = this,
                keysIndex = that._getKeysIndex();

            that.log('Add key "' + key + '" to keysIndex');

            keysIndex[key] = Date.now();

            that._storeKeysIndex(keysIndex);
        },

        _storeKeysIndex: function (keysIndex) {

            var that = this;

            that.currentAdapter.set(that.internalKeys.keysIndex, that.safeStore(keysIndex));
        },

        _updateLastUpdateDate: function () {

            var that = this,
                lastUpdate = Date.now();

            that.currentAdapter.set(that.internalKeys.lastUpdate, that.safeStore(lastUpdate));

            return lastUpdate;
        }
    });

    // TODO doc
    Storage.Instances = [];

    // TODO doc
    UWA.merge(Storage, {
        allInstancesReady: function () {
            return Storage.Instances.every(function (instance) {
                return instance.isReady;
            });
        }
    });

    return UWA.namespace('Storage', Storage, UWA);
});


/*
Copyright 2006-2017 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define*/

define('UWA/Internal/StringMap', [
    'UWA/Class'
], function (
    Class
) {
    'use strict';

    function getInternalKey(key) {
        return '_x_' + key;
    }

    return Class.extend({
        init: function () {
            this._data = {};
        },

        get: function (key) {
            return this._data[getInternalKey(key)];
        },

        set: function (key, value) {
            this._data[getInternalKey(key)] = value;
            return this;
        },

        getAll: function () {
            var result = {};
            for (var key in this._data) result[key.slice(3)] = this._data[key];
            return result;
        },

        remove: function (key) {
            delete this._data[getInternalKey(key)];
            return this;
        }
    });
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Classes implementing or extending this Class will have extra methods to handle events.
 *
 * @module   UWA/Class/Events
 *
 *
 * @example
 * define('MyProject/Class/TaskList', [
 *     'UWA/Class',
 *     'UWA/Class/Debug',
 *     'UWA/Class/Events',
 * ], function (Class, Debug, Events) {
 *
 *     var TaskList = Class.extend(Debug, Events, {
 *
 *         init: function () {
 *
 *              // Add elements storage
 *              this.elements = {};
 *         },
 *
 *         addElement: function(name, value) {
 *
 *             // Display debug info using log method.
 *             this.log(UWA.String.format('addElement name={0}, value={1}', name, value));
 *
 *             this.elements[name] = value;
 *
 *             // Dispatch onAddElement event
 *             this.dispatchEvent('onAddElement', [name, value]);
 *         },
 *
 *         onAddElement: function (name, value) {
 *             // Default MyClass "onAddElement" event listener.
 *         }
 *     });
 *
 *     return TaskList;
 * });
 *
 * require(['MyProject/Class/TaskList'], function (TaskList) {
 *
 * var myTaskList = new TaskList();
 *
 * // Enable debug mode, that will enable log output into the console.
 * myTaskList.setDebugMode(true);
 *
 * // Add custom "onAddElement" event listener.
 * myTaskList.addEvent('onAddElement', function () {
 *    // Update your view or related object here.
 * });
 *
 * // Call addElement
 * myTaskList.addElement('buy beer', 'duff');
 *
 * });
 */
define('UWA/Class/Events', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Dispatcher',
    'UWA/Utils'
], function (Core, Class, Dispatcher, Utils) {
    'use strict';

    var Events;

    function getDispatcher(object, name, temp) {
        var dispatchers = object._dispatchers,
            dispatcher = (dispatchers && dispatchers[name]) || new Dispatcher();

        if (!temp) {
            if (!dispatchers) {
                dispatchers = object._dispatchers = Object.create(null);
            }
            dispatchers[name] = dispatcher;
        }

        return dispatcher;
    }

    /**
     * Add methods to register and dispatch events.
     * @constructs UWA.Class.Events
     * @memberof module:UWA/Class/Events
     */
    Events = Class.extend(/** @lends module:UWA/Class/Events.UWA.Class.Events# */{

       /**
         * Trigger an event, executing all bound listeners. Listeners callbacks
         * are passed the same arguments as <dispatchEvents> is, apart from the
         * event name (unless you're listening on 'onAnyEvent', which will cause your
         * callback to receive the `true` name of the event as the first argument).
         *
         * @param {String} name - Event name
         * @param {Array} [args] - The arguments that will be passed to the listeners
         * @param {Object} [context] - Change callback binding
         * @return {this}
         */
        dispatchEvent: function (name, args, context) {

            var eventDispatcher, anyDispatcher,
                that = this;

            // force context value if missing
            if (context === undefined) {
                context = that;
            }

            // Force array on args
            args = Utils.splat(args);

            // Get dispatchers
            eventDispatcher = getDispatcher(that, name);

            // Add Callback function from this instance
            if (typeof that[name] === 'function') {
                eventDispatcher.addOnce(that[name], context, 1);
            }

            // If we should dispatch onAnyEvent
            if (name !== 'onAnyEvent' && that.hasEvent('onAnyEvent')) {

                // Get the onAnyEvent dispatcher
                anyDispatcher = getDispatcher(that, 'onAnyEvent');

                // Same thing as before: add the callback if it exists
                if (typeof that.onAnyEvent === 'function') {
                    anyDispatcher.addOnce(that.onAnyEvent, context);
                }

                // Postpone the event dispatch to *after* the onAnyEvent
                // listeners
                anyDispatcher.addOnce(function () {
                    eventDispatcher.dispatch(args, context);
                });

                // Then dispatch the onAnyEvent event
                anyDispatcher.dispatch([name].concat(args), context);

            } else {
                // Else simply dispatch the event
                eventDispatcher.dispatch(args, context);
            }

            return that;
        },

        /**
         * Prepare an event to be triggered with `window.event` has first argument.
         *
         * @param {String} name - Event name
         * @param {Array} [args] - The arguments that will pass to the listeners
         * @param {Object} [context] - Change callback binding
         * @return {Function} bound to dispatch the event passed as first argument
         * before the rest of the arguments.
         */
        dispatchAsEventListener: function (name, args, context) {

            var that = this;

            // force context value if missing
            if (context === undefined) {
                context = that;
            }

            // Force array on args
            args = Utils.splat(args);

            return function (event) {
                that.dispatchEvent(name, [event].concat(args), context);
            };
        },

        /**
         * Add a listener associated with the given event name. If you have a large
         * number of different events, you can namespace them, using colons for
         * example: `onPoll:start`, or `onChange:selection`.
         *
         * Listeners of the special "onAnyEvent" event will be executed
         * when any event occurs, and are passed the name of the event as the
         * first argument. See example below.
         *
         * @example
         * // Example to proxy all events from one object to another:
         * proxy.addEvent("onAnyEvent", function (eventName) {
         *    object.dispatchEvent(eventName);
         * });
         *
         * @param {String} name - The event name (e.g. "onUpdateTitle")
         * @param {Function} listener - Listener function that will be executed when event is triggered.
         * @param {Object} [context] - Context on which listener will be executed
         *    (object that should represent the `this` variable inside listener
         *    function). If left undefined, the context on which listener will
         *    be executed will be the one passed to <dispatchEvent>, which
         *    defaults to this instance of Events class.
         * @param {Number} [priority=0] - The priority level of the listener. Listeners with higher priority will be executed before listeners with lower priority
         *                   Listeners with same priority level will be executed at the same order as they were added.
         * @return {this}
         */
        addEvent: function (name, listener, context, priority) {
            getDispatcher(this, name).add(listener, context, priority);
            return this;
        },

        /**
         * Add a listener associated with the given event name.
         * Once the event is fired, the listener will be removed.
         * This is handy for saying "the next time that X happens, do this".
         *
         * @param {String} name - The event name (e.g. "onUpdateTitle")
         * @param {Function} listener - Listener function that will be executed when event is triggered
         * @param {Object} context - Context on which listener will be executed
         *    (object that should represent the `this` variable inside listener function).
         *    If left undefined, the context on which listener will
         *    be executed will be the one passed to <dispatchEvent>, which
         *    defaults to this instance of Events class.
         * @param {Number} [priority=0] - The priority level of the listener. Listeners with higher priority will be executed before listeners with lower priority
         *                   Listeners with same priority level will be executed at the same order as they were added.
         * @return {this}
         */
        addEventOnce: function (name, listener, context, priority) {
            getDispatcher(this, name).addOnce(listener, context, priority);
            return this;
        },

        /**
         * Add listeners methods associated with the given event name.
         *
         * @param {Object} events - The listeners methods indexed by name
         *  (e.g. {"onUpdateTitle", function() {}}). These listeners will be
         *  called with context passed as second argument.
         * @param {Object} context - Context on which listener will be executed
         *    (object that should represent the `this` variable inside listener function).
         *    If left undefined, the context on which listener will
         *    be executed will be the one passed to <dispatchEvent>, which
         *    defaults to this instance of Events class.
         * @param {Number} [priority=0] - The priority level of the listener. Listeners with higher priority will be executed before listeners with lower priority
         *                   Listeners with same priority level will be executed at the same order as they were added.
         * @return {this}
         */
        addEvents: function (events, context, priority) {
            var event;

            for (event in events) {
                if (events.hasOwnProperty(event)) {
                    this.addEvent(event, events[event], context, priority);
                }
            }

            return this;
        },

        /**
         * Remove some listeners. Calling it without any argument will remove all listeners.
         * Specifying a name will remove all listeners bound to this event.
         * Specifying a listener function will remove this listener only.
         * Specifying a context will remove only the listeners bound with this context
         *
         * @param {String} [name] - Event name
         * @param {Function} [listener] - Function to remove
         * @param {Void} [context] - Object that should match binding associated to listener context if provided.
         * @return {this}
         */
        removeEvent: function (name, listener, context) {

            var key,
                that = this,
                dispatchers = that._dispatchers,
                dispatcher = dispatchers && dispatchers[name];

            if (!name) {

                // The body of a for in is wrapped in an if statement to
                // do not need filter unwanted properties because of Object.create(null)
                for (key in dispatchers) { // jshint ignore:line
                    that.removeEvent(key, listener, context);
                }

            } else if (dispatcher) {

                if (listener) {
                    // remove a specific listener
                    dispatcher.remove(listener, context);
                } else {
                    // remove all listeners
                    dispatcher.removeAll(context);
                }

                // Remove reference
                if (dispatcher.getNumListeners() === 0) {
                    delete dispatchers[name];
                }
            }

            return that;
        },

        /**
         * Remove all listeners.
         *
         * @return {this}
         */
        removeEvents: function (events) {

            var name,
                that = this;

            if (events) {
                for (name in events) {
                    if (events.hasOwnProperty(name)) {
                        that.removeEvent(name, events[name]);
                    }
                }
            } else {
                that.removeEvent();
            }

            return that;
        },

        /**
         * Check if this object has an event listener attached to a specified event.
         * If no event name is specified, check if there is at least one event
         * listener attached to an event emitted by this object (in this case,
         * true is returned) or if there is no listener at all attached to any
         * event emitted by this object (in this case, false is returned)
         *
         * @param {String} [name] - The event name.
         * @param {Boolean} [skipMethod=false] - Do not check if the associated method is defined.
         * @return {Boolean} `true` if there is at least one event listener attached to this event.
         */
        hasEvent: function (eventName, skipMethod) {
            var hasListener, eventsNames, that = this;

            if (eventName) {
                eventsNames = [ eventName ];
            } else {
                eventsNames = Object.keys(that._dispatchers || {});
            }

            hasListener = function (eventName) {
                return !!(getDispatcher(that, eventName, true).getNumListeners() ||
                      (skipMethod ? false : that[eventName]));
            };

            return eventsNames.some(hasListener);
        }
    });

    return Core.namespace('Events', Events, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, Uint8Array, BlobBuilder, Blob, ArrayBuffer
*/

/*jshint
    maxparams: false
*/

/**
 * API that provide a Cross-domain Ajax solution that allow you to fetch data through Ajax even if your app is not
 * on the same domain than your request using UWA Proxy if required by the platforms that does not support Cross-domain Ajax calls.
 *
 * @module   UWA/Data
 *
 */
define('UWA/Data', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Ajax',
    'UWA/Json',
    'UWA/Internal/StringMap',
    'UWA/Class/Events'
], function (UWA, Utils, Client, Ajax, Json, StringMap, Events) {
    'use strict';

    var offlineCache = new StringMap();

    var Data = {

        /**
         * UWA Proxy urls indexed by types.
         *
         * @property {String} ajax - Used to proxify a Ajax request
         * @property {String} resolve - Used to get the final url of an url that make some redirect
         * @property {String} xml - Used to proxify a XML request
         * @property {String} soap - Used to proxify a SOAP request
         * @property {String} feed - Used to proxify a Feed request to JSON Object
         * @property {String} icon - Used to proxify an image to an ico
         * @property {String} richIcon - Used to proxify an image to an richIcon
         * @property {String} spreadsheet - Used to proxify a spreadsheet file to JSON Object
         *
         * @type {Object}
         * @alias UWA.Data.proxies
         * @memberOf module:UWA/Data
         */
        proxies: (function () {

            var hosts = UWA.hosts,
                expositionProxy = hosts.exposition + '/proxy/';

            return UWA.merge(hosts.proxies || {}, {
                ajax: expositionProxy + 'ajax',
                resolve: expositionProxy + 'resolve',
                xml: expositionProxy + 'xml',
                spreadsheet: expositionProxy + 'spreadsheet',
                soap: expositionProxy + 'soap',
                feed: expositionProxy + 'feed',
                icon: expositionProxy + 'icon',
                richIcon: expositionProxy + 'richIcon',
                rss: expositionProxy + 'feed' // Deprecated alias support
            });
        }()),

        /**
         * Enable JsonP Request for Cross domain Ajax Request.
         *
         * @private
         * @type {Boolean}
         * @alias UWA.Data.useJsonpRequest
         * @memberOf module:UWA/Data
         */
        useJsonpRequest: true,

        /**
         * Allow Cross Origin Request for Cross domain Ajax Request.
         *
         * @private
         * @type {Boolean}
         * @alias UWA.Data.allowCrossOriginRequest
         * @memberOf module:UWA/Data
         */
        allowCrossOriginRequest: false,

        /**
         * Enable Offline Request.
         *
         * @private
         * @type {Boolean}
         * @alias UWA.Data.useOfflineCache
         * @memberOf module:UWA/Data
         */
        useOfflineCache: false,

        /**
         * This method is used to get the content of an external data source even on another domain than current domain.
         * It can be used to retrieve or set any kind of data: text-based, XML, JSON or a feed.
         * The other Ajax methods (getText(), getXml(), getJson(), getFeed()) are all shortcut methods to specific uses of request().
         * This method is also the only way to perform HTTP POST request, as well as authenticated requests.
         *
         * __Specific proxy options__:
         *
         * You can pass specific options into an object that have the same name than the used proxy
         * to configure proxy behavior, see Proxy Examples bellow for detailed usage.
         *
         * | Proxy   | Options      | Description                          | Default value  |
         * | ------- | ------------ | ------------------------------------ | -------------- |
         * | `xml`   | xpath        | apply Xpath query on xml proxy side  | undefined      |
         * | `soap`  | methodName   | SOAP method name                     | undefined      |
         * | `soap`  | methodParams | SOAP method parameters               | undefined      |
         *
         * __Cache option__:
         *
         * By default the cache option is undefined, in this case it will use the Widget Server default cache duration that
         * could depend the apps server config.
         *
         * | Cache value | Description                                                                               |
         * | ----------- | ----------------------------------------------------------------------------------------- |
         * | `undefined` | Use Widget Server default cache duration                                                  |
         * | `-1`        | Never Cache response (also appends a query string parameter, "_=[TIMESTAMP]", to the URL) |
         * | `0`         | Cache response forever                                                                    |
         * | `n`         | Cache response for n seconds                                                              |
         *
         * For debuging cache purpose the Widget server return 2 headers with integer value.
         *
         * | Header name        | Description                                          |
         * | ------------------ | -----------------------------------------------------|
         * | `X-Cache-Level`    | Widget Server cache level (0 not cached, > 0 cached) |
         * | `X-Cache-Lifetime` | Widget Server cache lifetime                         |
         *
         *
         * __Basic Examples__:
         *
         * - Simple Example
         *
         * ```
         *  // Create a Callback
         *  MyOnComplete = function (text) {
         *    // your parsing code
         *  };
         *  MyOnCancel = function (text) {
         *    // your parsing code
         *  };
         *
         *  // Launch request
         *  var myRequest = UWA.Data.request('http://example.org/api.php', {
         *    type: 'text'
         *    onComplete: MyOnComplete,
         *    onCancel: MyOnCancel
         *  });
         *
         *  // Cancel request
         *  myRequest.cancel();
         * ```
         *
         * - Xml Example
         *
         * ```
         *  // Create a Callback
         *  MyOnComplete = function (document) {
         *    // your parsing code
         *  }
         *
         *  // Launch request
         *  var myRequest = UWA.Data.request('http://example.org/api.php?xml', {
         *    type: 'xml',  // Set response type to xml document
         *    cache: 3600,  // Set cache to one hour
         *    onComplete: MyOnComplete
         *  });
         *
         *  // Cancel request
         *  myRequest.cancel();
         * ```
         *
         * - Json Example
         *
         * ```
         *  // Create a Callback
         *  MyOnComplete = function (json) {
         *    // your parsing code
         *  }
         *
         *  // Launch request
         *  var myRequest = UWA.Data.request('http://example.org/api.php?json', {
         *    type: 'json',
         *    onComplete: MyOnComplete
         *  });
         *
         *  // Cancel request
         *  myRequest.cancel();
         * ```
         *
         * __Proxy Examples__:
         *
         * - XML with XPath filtering Example
         *
         * ```
         *  // Create a Callback
         *  MyOnComplete = function (document) {
         *    // your parsing code
         *  }
         *
         *  // Launch request
         *  var myRequest = UWA.Data.request('http://example.org/api.php?xpath', {
         *    type: 'xml',                        // Set response type to xml document
         *    proxy: 'xml',                       // Force proxy usage
         *    xml: {
         *        xpath "/items/item[@name='item1']", // Apply XPath query on response (server side)
         *    },
         *    onComplete: MyOnComplete
         *  });
         * ```
         *
         * Original XML response
         *
         * ```html
         *  <items title="titleAttribute">
         *      <item name="item1" foo="bar">item1TagValue</item>
         *      <item name="item2" foo="bar">item2TagValue</item>
         *      <item name="item3" foo="bar">item3TagValue</item>
         *      <item name="item4" foo="bar">item4TagValue</item>
         *      <label>label1TagValue</label>
         *      <label>label2TagValue</label>
         *      <title type="foo">titleTagValue</title>
         *  </items>
         * ```
         *
         * XML response after XPath filter
         *
         * ```html
         *  <root>
         *      <item name="item1" foo="bar">item1TagValue</item>
         *  </root>
         * ```
         *
         * - SOAP with JSON response Example
         *
         * ```
         *  // Create a Callback
         *  MyOnComplete = function (json) {
         *    // your parsing code
         *  }
         *
         *  // Launch request
         *  var myRequest = UWA.Data.request('http://www.webservicex.net/stockquote.asmx?WSDL', {
         *    type: 'json',                        // Set response type to json
         *    proxy: 'soap',                       // Force proxy usage
         *    soap: {
         *        methodName "GetQuote",
         *        methodParams: {
         *            symbol: "AAPL"
         *        }
         *    },
         *    onComplete: MyOnComplete
         *  });
         * ```
         *
         * Original XML SOAP response (e.g using type xml)
         *
         * ```html
         *  <?xml version="1.0" encoding="UTF-8"?>
         *  <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
         *     <soap:Body>
         *        <GetQuoteResponse xmlns="http://www.webserviceX.NET/">
         *           <GetQuoteResult>&lt;StockQuotes&gt;...&lt;/StockQuotes&gt;</GetQuoteResult>
         *        </GetQuoteResponse>
         *     </soap:Body>
         *  </soap:Envelope>
         * ```
         *
         * JSON response after XML conversion (e.g using type json)
         *
         * ```html
         *  {
         *    "GetQuoteResult": "<StockQuotes>...</StockQuotes>"
         *  }
         * ```
         *
         * @param {String} url - the URL of the data source
         * @param {Object} options - Settings object
         * @param {Function} options.onComplete - Callback receiving the Ajax response
         * @param {String} [options.method=GET] - GET, POST (in uppercase!)
         * @param {Object} [options.data={}] - GET or POST params as object
         * @param {String} [options.type=text] - text, json, xml, document, blob, arraybuffer
         * @param {String} [options.proxy=false] - ajax, feed, xml, soap
         * @param {Boolean} [options.async=true] - Asynchronous request
         * @param {Number} [options.cache=undefined] - Seconds of proxy caching
         * @param {Number} [options.timeout=25000] - Set your request timeout in ms
         * @param {Function} [options.onCancel] - Choose your own method
         * @param {Function} [options.onFailure] - Choose your own method
         * @param {Function} [options.onTimeout] - Choose your own method
         * @param {Function} [options.onProgress] - progress callback, if the browser supports it
         * @param {Object} [options.authentication] - Authentication object
         * @param {Object} [options.headers] - Headers object.
         * @param {cors} [options.useOfflineCache=false] - Enable Offline cache
         * @param {cors} [options.useJsonpRequest=true] - Enable JsonP Fallback
         *
         * @return {Object} An object that contains the cancel method.
         * If the request is successful, the callback onComplete is fired and receives the content as a parameter;
         * If the request is aborted the callback onCancel is fired, else the onFailure or onTimeout methods are fired.
         * If the request is made using an XHR, the XHR object is exposed in the `xhr` property.
         *
         * @alias UWA.Data.request
         * @memberOf module:UWA/Data
         */
        request: (function () {

            var isUpperCaseMethod = /OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT/i,
                isValidResponseType = /json|document|blob|arraybuffer|text/,
                isBase64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/,
                isOnline = Client.isOnline;

            function setOfflineTimer(duration) {
                if (isOnline()) {
                    isOnline(false, duration || 5000);
                }
            }

            function getJsonpResponse(data) {

                var body = data.body;

                // Force non String to be string
                if (isBase64.test(body)) {
                    body = Utils.base64Decode(body);
                }

                return body;
            }

            function convertDataURIToBlob(dataURI, mimetype) {

                var i, bb,
                    BASE64_MARKER = ';base64,',
                    base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length,
                    base64 = dataURI.substring(base64Index),
                    raw = window.atob(base64),
                    rawLength = raw.length,
                    uInt8Array = new Uint8Array(rawLength);

                for (i = 0; i < rawLength; ++i) {
                    uInt8Array[i] = raw.charCodeAt(i);
                }

                bb = new BlobBuilder();
                bb.append(uInt8Array.buffer);

                return bb.getBlob(mimetype);
            }

            function getRequestKey(url, options) {

                // Create request uniqkey
                var requestKey = {
                    url: url,
                    timeout: options.timeout,
                    method: options.method,
                    type: options.type,
                    proxy: options.proxy,
                    async: options.async,
                    data: options.data,
                    headers: options.headers
                };

                // Avoid cache on non GET method
                // TODO is it required ?
                if (
                    options.method !== 'GET' ||
                        options.useMergeRequest === false
                ) {
                    requestKey.uuid = Utils.getUUID();
                }

                // Serialize cache key
                return UWA.Json.encode(requestKey);
            }

            // Declare available callbacks
            var responseTypeHandlers = {
                text: function (data) {

                    // Force non String to be string
                    if (typeof data !== 'string') {
                        data = Json.encode(data);
                    }

                    return data;
                },
                json: function (data) {

                    // Convert to JSON if require only
                    // due possible json response in text format
                    if (typeof data === 'string') {
                        data = Json.decode(data);
                    }

                    // Check that response has been converted
                    if (!UWA.is(data, ['object', 'array'])) {
                        throw new Error('Invalid JSON Response: "' + String(data) + '"');
                    }

                    return data;
                },
                xml: function (data) {

                    // responseXML can missing cause missing content-type header text/xml
                    // or cause we use JSONP on Ligttpd it is null on apache it is undefined.
                    // We also parse the text response for IE to enable Xpath and Xslt support
                    if (typeof data === 'string') {
                        data = Utils.loadXml(data);
                    }

                    return data;
                },
                document: function (data) {

                    // Check if data is decoded already.
                    if (typeof data === 'string') {
                        data = Utils.loadHtml(data);
                    }

                    return data;
                },
                blob: function (data, headers) {

                    var contentType = Utils.getOwnPropertyMatchValue(headers, 'Content-Type') || 'text/plain';

                    // Check if data is decoded already.
                    if (typeof data === 'string') {

                        if (isBase64.test(data)) {
                            data = convertDataURIToBlob(data, contentType);
                        } else {
                            data = new Blob([data], {
                                type: contentType
                            });
                        }
                    }

                    return data;
                },
                arraybuffer: function (data) {

                    // Check if data is decoded already.
                    if (typeof data === 'string') {
                        // TODO decode and convert.
                        data = new ArrayBuffer(12);
                    }

                    return data;
                }
            };

            return function (url, options) {

                /*jshint maxstatements: 70*/

                // First argument is required.

                if (!url) {
                    throw new Error('Bad or missing url argument.');
                }

                // Second argument is and object anyway
                options = options || {};

                //
                // 1. Init Vars
                //

                var request, requestEvents, requestOptions,
                    requestFetcher, requestKey, requestSuccess, requestFailure,

                    // Response Hanlding
                    responseType,

                    // Config Alias
                    useOfflineCache, allowCrossOriginRequest, useJsonpRequest,

                    // Default Options/Values
                    originalUrl = url,
                    currentUrl = window.location,

                    defaultProxy = 'ajax',

                    defaultOptions = {

                        // SubRequest options
                        timeout: 25000,
                        method: 'GET',
                        type: 'text',
                        proxy: false,
                        async: true,
                        headers: {},

                        // Network options
                        useMergeRequest: true,
                        useOfflineCache: Data.useOfflineCache,
                        allowCrossOriginRequest: Data.allowCrossOriginRequest,
                        useJsonpRequest: Data.useJsonpRequest,

                        // Defaults Events
                        onComplete: function (/*response, headers*/) {
                            // Nothing to do by default...
                        },
                        onCancel: function () {
                            // Nothing to do by default...
                        },
                        onFailure: function (error /*, request, options*/) {
                            // throw Error by default...
                            throw error;
                        }
                    };

                //
                // Deprecated Options Support
                //

                // Handle deprecated requestHeaders options
                if (options.requestHeaders) {
                    options.headers = options.requestHeaders;
                    delete options.requestHeaders;
                }

                // Handle deprecated postBody options
                if (options.postBody) {
                    options.method = 'POST';
                    options.data = options.postBody;
                    delete options.postBody;

                // Handle deprecated parameters options
                } else if (options.parameters) {
                    options.method = 'POST';
                    options.data = options.parameters;
                    delete options.parameters;
                }

                // Handle deprecated auth options
                if (options.auth) {
                    options.authentication = options.auth;
                    delete options.auth;
                }

                // Handle deprecated types options
                if (options.type === 'html') {
                    options.type = 'document';
                } else if (options.type === 'feed') {
                    options.type = 'json';
                }

                //
                // Prepare Options (Cast, Validate)
                //

                // Merge options and defaultOptions
                options = UWA.merge(options, defaultOptions);

                // Cast some options values
                options.type = (!responseTypeHandlers[options.type] ? defaultOptions.type : options.type);
                options.timeout = parseInt(options.timeout, 10);

                // If method match OPTIONS/GET/HEAD/POST/PUT/DELETE/TRACE/CONNECT
                // set uppercase to match standart and avoid IE issues.
                if (isUpperCaseMethod.test(options.method)) {
                    options.method = options.method.toUpperCase();
                }

                // If type json add right headers if missings
                if (options.type === 'json') {

                    if (!Utils.getOwnPropertyMatchName(options.headers, 'Accept')) {
                        options.headers.Accept = 'application/json,text/javascript,*/*';
                    }

                    if (!Utils.getOwnPropertyMatchName(options.headers, 'X-Request')) {
                        options.headers['X-Request'] = 'JSON';
                    }
                }

                // options Alias
                responseType = options.type;
                useOfflineCache = options.useOfflineCache;
                allowCrossOriginRequest = options.allowCrossOriginRequest;
                useJsonpRequest = options.useJsonpRequest;

                //
                // 2. Prepare Url and detect proxy requirements
                //

                // Save originalUrl reference
                originalUrl = url;

                // Check if proxy is requested and available then proxify Url
                // and detect useJsonpRequest final value.
                if (options.proxy) {

                    url = Data.proxifyUrl(url, options);

                    useJsonpRequest = useJsonpRequest &&
                                          Utils.matchUrl(url, currentUrl) === false &&
                                              allowCrossOriginRequest === false;

                // If it's a Cross Domain Request,
                // and Cross Origin Request if disabled,
                // should we proxify it using ajax proxy aka defaultProxy.
                } else if (
                    Utils.matchUrl(url, currentUrl) === false &&
                        allowCrossOriginRequest === false
                ) {

                    // Check if JSONP is required and allowed to access Proxy
                    useJsonpRequest = useJsonpRequest &&
                        Utils.matchUrl(Data.proxies[defaultProxy], currentUrl) === false;

                    // Force defaultProxy usage
                    url = Data.proxifyUrl(url, UWA.extend(options, {
                        proxy: defaultProxy
                    }));

                // It's not a cross domain data we dont need JsonP fallback
                } else {
                    useJsonpRequest = false;
                }

                //
                // 3. Create request or reuse existing one
                //

                // Request Cache init
                Data.requests = Data.requests || {};
                requestKey = getRequestKey(url, options);

                // Create events
                requestEvents = {
                    onComplete: options.onComplete,
                    onFailure: options.onFailure,
                    onCancel: options.onCancel,
                    onTimeout: options.onTimeout || options.onFailure
                };

                // Use Existing request
                if (Data.requests[requestKey]) {

                    request = Data.requests[requestKey];
                    request.addEvents(requestEvents);

                // Create a new request
                } else {

                    request = Data.requests[requestKey] = new Events();
                    request.addEvents(requestEvents);

                    //
                    // 4. Create requestOptions
                    //

                    requestSuccess = function (response, headers) {

                        var isValidResponse,
                            originalResponse = response;

                        // Remove request
                        delete Data.requests[requestKey];

                        // Use Utils.attempt to handle JS Error into callback then
                        // trigger onFailure but not if UWA.debug is true.
                        isValidResponse = Utils.attempt(
                            function () {

                                // Json Request require to decode response
                                if (useJsonpRequest) {
                                    headers = response.headers;
                                    response = getJsonpResponse(response);
                                }

                                // Decode response based on type and headers
                                response = responseTypeHandlers[responseType](response, headers);

                                // Update Offline cache if enabled
                                if (useOfflineCache) {
                                    Data.storeInCache(originalUrl, originalResponse);
                                }

                                return true;

                            }, function () {

                                // ???
                                requestFailure('onFailure', arguments);

                                return false;
                            }
                        );

                        // Forward decoded data to request onComplete event
                        // Also, let onComplete fail with no try catch....
                        if (isValidResponse) {
                            request.dispatchEvent('onComplete', [response, headers]);
                        }
                    };

                    requestFailure = function (failureType, failureArgs) {

                        var data,
                            dispatchFailure = true;

                        // Remove request
                        delete Data.requests[requestKey];

                        // Use Offline cache has fallback if enable
                        if (useOfflineCache) {

                            data = Data.getFromCache(originalUrl);

                            // Call callback with offline cached value
                            if (UWA.is(data)) {

                                dispatchFailure = false;

                                // Set Offline for next 5 seconds
                                setOfflineTimer();

                                requestSuccess(data);
                            }
                        }

                        // Foward decoded data to request onFailure event
                        if (dispatchFailure) {
                            request.dispatchEvent(failureType, failureArgs);
                        }
                    };

                    requestOptions = {
                        method: options.method,
                        data: options.data,
                        headers: options.headers,
                        fromDataRequest: originalUrl,
                        timeout: options.timeout,
                        async: options.async,
                        withCredentials: options.withCredentials,
                        onComplete: function (response, headers) {
                            requestSuccess(response, headers);
                        },
                        onFailure: function () {
                            requestFailure('onFailure', arguments);
                        },
                        onCancel: function () {
                            requestFailure('onCancel', arguments);
                        },
                        onTimeout: function () {
                            requestFailure('onTimeout', arguments);
                        },
                        onProgress: options.onProgress
                    };

                    // Browser is in offline and useOfflineCache is enable
                    if (useOfflineCache && isOnline() === false) {
                        requestOptions.onFailure(new Error('Network is Offline'));

                    // Use JsonP via Json.request
                    } else if (useJsonpRequest) {

                        // Json.request proxy fallback do not handle POST or PUT,
                        // so we need to pass POST via GET using proxy postData GET parameter.
                        if (
                            options.data && options.data.length > 0 &&
                                ['POST', 'PUT'].indexOf(options.method) !== -1
                        ) {

                            url += (url.indexOf('?') !== -1 ? '&' : '?');

                            if (options.method === 'POST') {
                                url += Utils.toQueryString(options.data, 'postData');
                            } else if (options.method === 'PUT') {
                                url += Utils.toQueryString(options.data, 'rawData');
                            }

                            // Remove method and data options.
                            delete requestOptions.data;
                            delete requestOptions.method;
                        }

                        requestFetcher = Json.request(url, requestOptions);

                    // Use XMLRpcRequest via Ajax.request
                    } else {

                        // Ajax.request now handle reponseType,
                        // forward to options if valid responseType to use native decoding.
                        if (responseType && isValidResponseType.test(responseType)) {
                            requestOptions.responseType = responseType;
                        }

                        request.xhr = requestFetcher = Ajax.request(url, requestOptions);
                    }

                    // Expose request config
                    request.url = originalUrl;
                    request.options = options;

                    // Map request.cancel with requestFetcher.cancel method
                    request.cancel = requestFetcher.cancel;
                }

                return request;
            };
        }()),

        /**
         * Proxify an URL using UWA proxy.
         *
         * @param {String} url - url to proxify
         * @param {String} options - some options from <request> options parameter
         * @return {String} full url to proxy with proxified options (header, data) has parameter.
         *
         * @alias UWA.Data.proxifyUrl
         * @memberOf module:UWA/Data
         */
        proxifyUrl: function (url, options) {

            if (!url) {
                throw new Error('Bad or missing url argument.');
            }

            var proxyUrl,
                params = [],

                // Alias
                proxy = options.proxy,
                toQueryString = Utils.toQueryString,
                proxies = Data.proxies;

            // Add Proxy params
            if (proxy && proxies[proxy]) {

                // Proxify Url
                proxyUrl = proxies[proxy];

                // Avoid double proxy
                if (url.indexOf(proxyUrl) === 0) {
                    return url;
                }

                // Handle GET data for proxies by updating url
                if (
                    options.data &&
                        options.method &&
                            options.method.toUpperCase() === 'GET'
                ) {

                    // Add separator
                    url += (url.indexOf('?') > -1 ? '&' : '?') + toQueryString(options.data);

                    // To avoid possible double data
                    delete options.data;
                }

                // Add proxy options param if proxy is object
                if (typeof options[proxy] === 'object') {
                    params.push(toQueryString(options[proxy]));

                    // Remove proxy options
                    delete options[proxy];
                }

                // Add type param ?
                if (options.type) {

                    params.push(toQueryString({
                        type: options.type
                    }));

                    // Remove type options
                    delete options.type;
                }

                // Add auth params
                if (typeof options.authentication === 'object') {
                    params.push(toQueryString(options.authentication));
                }

                // Add cache param ?
                if (options.cache) {

                    params.push(toQueryString({
                        cache: parseInt(options.cache, 10)
                    }));

                    // If cache is disable, add a date.now to avoid possible cache.
                    if (options.cache < 0) {
                        params.push(Date.now());
                    }
                }

                // Forward headers throw get param only in proxy mode
                if (options.headers) {
                    params.push(toQueryString(options.headers, 'headers'));

                    // To avoid possible double headers
                    delete options.headers;
                }

                // TODO need to be remove in favor of UWA Platform authentication
                // This options are part of Netvibes Startpage Proxy
                // auth implementation and require to retreive password.
                if (options.connect) {
                    params.push(toQueryString({
                        connect: options.connect
                    }));
                }

                // TODO need to be remove in favor of UWA Platform authentication
                // This options are part of Netvibes Startpage Proxy
                // OAuth implementation and require to retreive token.
                if (options.service) {
                    params.push(toQueryString({
                        service: options.service
                    }));
                }

                // TODO need to be remove in favor of UWA Platform authentication
                // This options are part of Netvibes Startpage Proxy
                // OAuth implementation and require to retreive token.
                if (options.wid) {
                    params.push(toQueryString({
                        wid: options.wid
                    }));
                }

                // Add method params
                if (options.method) {
                    params.push(toQueryString({
                        method: options.method
                    }));
                }

                // Add proxified url as param
                params.push(toQueryString({
                    url: url
                }));

                url = proxyUrl + '?' + params.join('&');

                // Avoid Url limit overflow
                if (url.length > 2048) {
                    throw new Error('Proxified url is more than 2048 characters, that is the limit for most of the browsers.');
                }

            } else {
                throw new Error('Invalid proxy');
            }

            return url;
        },

        /**
         * Gets the content of a feed, in a JSON format.
         *
         * In this example, the callback method is named "dataProcessor",
         * and is used to parse the feed Object, which is contained in the 'feed' variable.
         *
         * ```
         * var dataProcessor = function (feed) {
         *  // your display code
         * }
         *
         * UWA.Data.getFeed('http://feeds.feedburner.com/NetvibesDevBlog', dataProcessor);
         * ```
         *
         * Feed Object format:
         *
         * ```
         * // Following an example of response for a feed on "http://blog.example.org/feed"
         * {
         *    "url": "http://blog.example.org/feed",
         *    "type": "atom",                             // Could be "rss" or "atom"
         *    "version": "atom10",                        // Could be "rss2" or "atom10"
         *    "title": "Example.org News Feed"            // Feed title
         *    "link": "http://blog.example.org",          // Feed website
         *    "content": "Some Example.org News",         // Feed description
         *    "language": "en",                           // Feed language
         *    "author": "john doe",                       // Feed author
         *    "date": "Fri, 04 May 2012 10:35:47 +0200"   // Last Feed update
         *    "items": [                                  // Feed items/articles objects
         *        {
         *            "title": "Article One",                                 // Article title
         *            "description": "My nice article about example.org",     // Article description
         *            "link": "http://blog.example.org/post/1",               // Article link
         *            "date": "Thu, 03 May 2012 18:08:33 +0200",              // Article publishing date
         *            "authors": {                                            // Article authors
         *                "0": {
         *                    "name": "john doe"
         *                }
         *            },
         *            // Article raw content
         *            "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit...."
         *        },
         *        ...
         *    ]
         * }
         * ```
         *
         * @param {String} url - The URL of the feed data source
         * @param {Function} callback - The callback method that will be triggered when the request is succesful
         *  This method *must have one parameter* to receive the feed (JSON format) returned by the request.
         *
         * @return {Object} An object that contains the cancel method.
         *  If the request is successful, the callback onComplete is fired and receives the content as a parameter;
         *  If the request is aborted the callback onCancel is fired, else the onFailure or onTimeout methods are fired.
         *
         * @alias UWA.Data.getFeed
         * @memberOf module:UWA/Data
         */
        getFeed: function (url, callback) {
            return Data.request(url, {
                method: 'GET',
                proxy: 'feed',
                type: 'json',
                onComplete: callback
            });
        },

        /**
         * This method is used to get the content of an external XML data source.
         * It can be used to retrieve the content of a feed in XML format.
         *
         * In this example, the callback method is named "dataProcessor",
         * and is used to parse the XML tree, which is contained in the 'xml' variable.
         *
         * ```
         * var dataProcessor = function (xml) {
         *    // your parsing code
         *    var items = xml.getElementsByTagName('item');
         * }
         *
         * var myRequest = UWA.Data.getXml('http://example.com/content.xml', dataProcessor);
         * ```
         *
         * @param {String} url - the URL of the XML data source,
         * @param {Function} callback - the callback method that will be fired when the request is succesful
         * This method *must have one parameter* to receive the XML content returned by the request.
         * @return {Object} An object that contains the cancel method.
         *  If the request is successful, the callback onComplete is fired and receives the content as a parameter;
         *  If the request is aborted the callback onCancel is fired, else the onFailure or onTimeout methods are fired.
         *
         * @alias UWA.Data.getXml
         * @memberOf module:UWA/Data
         */
        getXml: function (url, callback) {
            return Data.request(url, {
                method: 'GET',
                type: 'xml',
                onComplete: callback
            });
        },

        /**
         * This method is used to get the content of an external data source.
         * It can be used to retrieve any kind of content, as long as it is made of text.
         *
         * In this example, the callback method is named "dataProcessor",
         * and is used to test the text content, which is contained in the "data" variable.
         *
         * ```
         * var dataProcessor = function (data) {
         *    // your parsing code
         *    var isValid = data.contains('success');
         * };
         *
         * var myRequest = UWA.Data.getText('http://example.com/content.txt', dataProcessor);
         * ```
         *
         * @param {String} url - the URL of the data source,
         * @param {Function} callback - the callback method that will be fired when the request is succesful
         * This method *must have one parameter* to receive the text content returned by the request.
         * @return {Object} An object that contains the cancel method.
         *  If the request is successful, the callback onComplete is fired and receives the content as a parameter;
         *  If the request is aborted the callback onCancel is fired, else the onFailure or onTimeout methods are fired.
         *
         * @alias UWA.Data.getText
         * @memberOf module:UWA/Data
         */
        getText: function (url, callback) {
            return Data.request(url, {
                method: 'GET',
                type: 'text',
                onComplete: callback
            });
        },

        /**
         * This method is used to get the content of an external JSON data source.
         * It can be used to retrieve any kind of JSON data.
         *
         * var dataProcessor = function (json) {
         *    // your parsing code
         * };
         *
         * var myRequest = UWA.Data.getJson('http://example.com/json.php', dataProcessor);
         * ```
         *
         * @param {String} url - the URL of the data source,
         * @param {Function} callback - the callback method that will be fired when the request is succesful
         * This method *must have one parameter* to receive the JSON content returned by the request.
         * @return {Object} An object that contains the cancel method.
         *  If the request is successful, the callback onComplete is fired and receives the content as a parameter;
         *  If the request is aborted the callback onCancel is fired, else the onFailure or onTimeout methods are fired.
         *
         * @alias UWA.Data.getJson
         * @memberOf module:UWA/Data
         */
        getJson: function (url, callback) {
            return Data.request(url, {
                method: 'GET',
                type: 'json',
                onComplete: callback
            });
        },

        /* Group: Offline Cache manipulation methods */

        /**
         * Get cache instance for UWA.Data.request.
         *
         * @private
         * @method
         * @return {Object} Object with get/set/getAll/remove methods
         *
         * @alias UWA.Data.getCache
         * @memberOf module:UWA/Data
         */
        getCache: function () {
            return offlineCache;
        },

        /**
         * Store the UWA.Data.request result into the cache.
         *
         * @private
         * @method
         * @param {String} url - The URL of the request
         * @param {Object} callbackArguments - The arguments of request onComplete callback
         * @return {Void} Stored value.
         *
         * @alias UWA.Data.storeInCache
         * @memberOf module:UWA/Data
         */
        storeInCache: function (url, callbackData) {

            // Handle callbackData value possible circular reference due non cross domain request
            // on type xml and html that will be regenerated from callback parsor if missing
            callbackData = Utils.toArray(callbackData).filter(function (value) {
                return UWA.is(value) && !value.nodeType;
            });

            Data.getCache().set(Utils.getCheckSum(url), callbackData);
        },

        /**
         * Retrieve the UWA.Data.request result from the cache.
         *
         * @private
         * @method
         * @param {String} url - The URL of the request
         * @return {Array} The strored arguments of request onComplete callback.
         *
         * @alias UWA.Data.getFromCache
         * @memberOf module:UWA/Data
         */
        getFromCache: function (url) {
            return Data.getCache().get(Utils.getCheckSum(url));
        }
    };

    return UWA.namespace('Data', Data, UWA);
});


/*!
  * Qwery - A Blazing Fast query selector engine
  * https://github.com/ded/qwery
  * copyright Dustin Diaz & Jacob Thornton 2011
  * MIT License
  */

(function (name, definition) {
  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define('vendors/qwery', definition)
  else this[name] = definition()
}('qwery', function () {
  var doc = document
    , html = doc.documentElement
    , byClass = 'getElementsByClassName'
    , byTag = 'getElementsByTagName'
    , qSA = 'querySelectorAll'
    , useNativeQSA = 'useNativeQSA'
    , tagName = 'tagName'
    , nodeType = 'nodeType'
    , select // main select() method, assign later

    // OOOOOOOOOOOOH HERE COME THE ESSSXXSSPRESSSIONSSSSSSSS!!!!!
    , id = /#([\w\-]+)/
    , clas = /\.[\w\-]+/g
    , idOnly = /^#([\w\-]+)$/
    , classOnly = /^\.([\w\-]+)$/
    , tagOnly = /^([\w\-]+)$/
    , tagAndOrClass = /^([\w]+)?\.([\w\-]+)$/
    , splittable = /(^|,)\s*[>~+]/
    , normalizr = /^\s+|\s*([,\s\+\~>]|$)\s*/g
    , splitters = /[\s\>\+\~]/
    , splittersMore = /(?![\s\w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^'"]*\]|[\s\w\+\-]*\))/
    , specialChars = /([.*+?\^=!:${}()|\[\]\/\\])/g
    , simple = /^(\*|[a-z0-9]+)?(?:([\.\#]+[\w\-\.#]+)?)/
    , attr = /\[([\w\-]+)(?:([\|\^\$\*\~]?\=)['"]?([ \w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^]+)["']?)?\]/
    , pseudo = /:([\w\-]+)(\(['"]?([^()]+)['"]?\))?/
    , easy = new RegExp(idOnly.source + '|' + tagOnly.source + '|' + classOnly.source)
    , dividers = new RegExp('(' + splitters.source + ')' + splittersMore.source, 'g')
    , tokenizr = new RegExp(splitters.source + splittersMore.source)
    , chunker = new RegExp(simple.source + '(' + attr.source + ')?' + '(' + pseudo.source + ')?')
    , walker = {
        ' ': function (node) {
          return node && node !== html && node.parentNode
        }
      , '>': function (node, contestant) {
          return node && node.parentNode == contestant.parentNode && node.parentNode
        }
      , '~': function (node) {
          return node && node.previousSibling
        }
      , '+': function (node, contestant, p1, p2) {
          if (!node) return false
          return (p1 = previous(node)) && (p2 = previous(contestant)) && p1 == p2 && p1
        }
      }

  function cache() {
    this.c = {}
  }
  cache.prototype = {
    g: function (k) {
      return this.c[k] || undefined
    }
  , s: function (k, v, r) {
      v = r ? new RegExp(v) : v
      return (this.c[k] = v)
    }
  }

  var classCache = new cache()
    , cleanCache = new cache()
    , attrCache = new cache()
    , tokenCache = new cache()

  function classRegex(c) {
    return classCache.g(c) || classCache.s(c, '(^|\\s+)' + c + '(\\s+|$)', 1)
  }

  // not quite as fast as inline loops in older browsers so don't use liberally
  function each(a, fn) {
    var i = 0, l = a.length
    for (; i < l; i++) fn(a[i])
  }

  function flatten(ar) {
    for (var r = [], i = 0, l = ar.length; i < l; ++i) arrayLike(ar[i]) ? (r = r.concat(ar[i])) : (r[r.length] = ar[i])
    return r
  }

  function arrayify(ar) {
    var i = 0, l = ar.length, r = []
    for (; i < l; i++) r[i] = ar[i]
    return r
  }

  function previous(n) {
    while (n = n.previousSibling) if (n[nodeType] == 1) break;
    return n
  }

  function q(query) {
    return query.match(chunker)
  }

  // called using `this` as element and arguments from regex group results.
  // given => div.hello[title="world"]:foo('bar')
  // div.hello[title="world"]:foo('bar'), div, .hello, [title="world"], title, =, world, :foo('bar'), foo, ('bar'), bar]
  function interpret(whole, tag, idsAndClasses, wholeAttribute, attribute, qualifier, value, wholePseudo, pseudo, wholePseudoVal, pseudoVal) {
    var i, m, k, o, classes
    if (this[nodeType] !== 1) return false
    if (tag && tag !== '*' && this[tagName] && this[tagName].toLowerCase() !== tag) return false
    if (idsAndClasses && (m = idsAndClasses.match(id)) && m[1] !== this.id) return false
    if (idsAndClasses && (classes = idsAndClasses.match(clas))) {
      for (i = classes.length; i--;) if (!classRegex(classes[i].slice(1)).test(this.className)) return false
    }
    if (pseudo && qwery.pseudos[pseudo] && !qwery.pseudos[pseudo](this, pseudoVal)) return false
    if (wholeAttribute && !value) { // select is just for existance of attrib
      o = this.attributes
      for (k in o) {
        if (Object.prototype.hasOwnProperty.call(o, k) && (o[k].name || k) == attribute) {
          return this
        }
      }
    }
    if (wholeAttribute && !checkAttr(qualifier, getAttr(this, attribute) || '', value)) {
      // select is for attrib equality
      return false
    }
    return this
  }

  function clean(s) {
    return cleanCache.g(s) || cleanCache.s(s, s.replace(specialChars, '\\$1'))
  }

  function checkAttr(qualify, actual, val) {
    switch (qualify) {
    case '=':
      return actual == val
    case '^=':
      return actual.match(attrCache.g('^=' + val) || attrCache.s('^=' + val, '^' + clean(val), 1))
    case '$=':
      return actual.match(attrCache.g('$=' + val) || attrCache.s('$=' + val, clean(val) + '$', 1))
    case '*=':
      return actual.match(attrCache.g(val) || attrCache.s(val, clean(val), 1))
    case '~=':
      return actual.match(attrCache.g('~=' + val) || attrCache.s('~=' + val, '(?:^|\\s+)' + clean(val) + '(?:\\s+|$)', 1))
    case '|=':
      return actual.match(attrCache.g('|=' + val) || attrCache.s('|=' + val, '^' + clean(val) + '(-|$)', 1))
    }
    return 0
  }

  // given a selector, first check for simple cases then collect all base candidate matches and filter
  function _qwery(selector, _root) {
    var r = [], ret = [], i, l, m, token, tag, els, intr, item, root = _root
      , tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr))
      , dividedTokens = selector.match(dividers)

    if (!tokens.length) return r

    token = (tokens = tokens.slice(0)).pop() // copy cached tokens, take the last one
    if (tokens.length && (m = tokens[tokens.length - 1].match(idOnly))) root = byId(_root, m[1])
    if (!root) return r

    intr = q(token)
    // collect base candidates to filter
    els = root !== _root && root[nodeType] !== 9 && dividedTokens && /^[+~]$/.test(dividedTokens[dividedTokens.length - 1]) ?
      function (r) {
        while (root = root.nextSibling) {
          root[nodeType] == 1 && (intr[1] ? intr[1] == root[tagName].toLowerCase() : 1) && (r[r.length] = root)
        }
        return r
      }([]) :
      root[byTag](intr[1] || '*')
    // filter elements according to the right-most part of the selector
    for (i = 0, l = els.length; i < l; i++) {
      if (item = interpret.apply(els[i], intr)) r[r.length] = item
    }
    if (!tokens.length) return r

    // filter further according to the rest of the selector (the left side)
    each(r, function(e) { if (ancestorMatch(e, tokens, dividedTokens)) ret[ret.length] = e })
    return ret
  }

  // compare element to a selector
  function is(el, selector, root) {
    if (isNode(selector)) return el == selector
    if (arrayLike(selector)) return !!~flatten(selector).indexOf(el) // if selector is an array, is el a member?

    selector = selector.replace(normalizr, '$1')
    var selectors = selector.split(','), tokens, dividedTokens
    while (selector = selectors.pop()) {
      tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr))
      dividedTokens = selector.match(dividers)
      tokens = tokens.slice(0) // copy array
      if (interpret.apply(el, q(tokens.pop())) && (!tokens.length || ancestorMatch(el, tokens, dividedTokens, root))) {
        return true
      }
    }
    return false
  }

  // given elements matching the right-most part of a selector, filter out any that don't match the rest
  function ancestorMatch(el, tokens, dividedTokens, root) {
    var cand
    // recursively work backwards through the tokens and up the dom, covering all options
    function crawl(e, i, p) {
      while (p = walker[dividedTokens[i]](p, e)) {
        if (isNode(p) && (interpret.apply(p, q(tokens[i])))) {
          if (i) {
            if (cand = crawl(p, i - 1, p)) return cand
          } else return p
        }
      }
    }
    return (cand = crawl(el, tokens.length - 1, el)) && (!root || isAncestor(cand, root))
  }

  function isNode(el, t) {
    return el && typeof el === 'object' && (t = el[nodeType]) && (t == 1 || t == 9)
  }

  function uniq(ar) {
    var a = [], i, j
    o: for (i = 0; i < ar.length; ++i) {
      for (j = 0; j < a.length; ++j) if (a[j] == ar[i]) continue o
      a[a.length] = ar[i]
    }
    return a
  }

  function arrayLike(o) {
    return (typeof o === 'object' && isFinite(o.length))
  }

  function normalizeRoot(root) {
    if (!root) return doc
    if (typeof root == 'string') return qwery(root)[0]
    if (!root[nodeType] && arrayLike(root)) return root[0]
    return root
  }

  function byId(root, id, el) {
    // if doc, query on it, else query the parent doc or if a detached fragment rewrite the query and run on the fragment
    return root[nodeType] === 9 ? root.getElementById(id) :
      root.ownerDocument &&
        (((el = root.ownerDocument.getElementById(id)) && isAncestor(el, root) && el) ||
          (!isAncestor(root, root.ownerDocument) && select('[id="' + id + '"]', root)[0]))
  }

  function qwery(selector, _root) {
    var m, el, root = normalizeRoot(_root)

    // easy, fast cases that we can dispatch with simple DOM calls
    if (!root || !selector) return []
    if (selector === window || isNode(selector)) {
      return !_root || (selector !== window && isNode(root) && isAncestor(selector, root)) ? [selector] : []
    }
    if (selector && arrayLike(selector)) return flatten(selector)
    if (m = selector.match(easy)) {
      if (m[1]) return (el = byId(root, m[1])) ? [el] : []
      if (m[2]) return arrayify(root[byTag](m[2]))
      if (hasByClass && m[3]) return arrayify(root[byClass](m[3]))
    }

    return select(selector, root)
  }

  // where the root is not document and a relationship selector is first we have to
  // do some awkward adjustments to get it to work, even with qSA
  function collectSelector(root, collector) {
    return function(s) {
      var oid, nid
      if (splittable.test(s)) {
        if (root[nodeType] !== 9) {
         // make sure the el has an id, rewrite the query, set root to doc and run it
         if (!(nid = oid = root.getAttribute('id'))) root.setAttribute('id', nid = '__qwerymeupscotty')
         s = '[id="' + nid + '"]' + s // avoid byId and allow us to match context element
         collector(root.parentNode || root, s, true)
         oid || root.removeAttribute('id')
        }
        return;
      }
      s.length && collector(root, s, false)
    }
  }

  var isAncestor = 'compareDocumentPosition' in html ?
    function (element, container) {
      return (container.compareDocumentPosition(element) & 16) == 16
    } : /* 'contains' in html ? // broken in IE with Fragments
    function (element, container) {
      container = container[nodeType] === 9 || container == window ? html : container
      return container !== element && container.contains(element)
    } : */
    function (element, container) {
      while (element = element.parentNode) if (element === container) return 1
      return 0
    }
  , getAttr = function() {
      // detect buggy IE src/href getAttribute() call
      var e = doc.createElement('p')
      return ((e.innerHTML = '<a href="#x">x</a>') && e.firstChild.getAttribute('href') != '#x') ?
        function(e, a) {
          return a === 'class' ? e.className : (a === 'href' || a === 'src') ?
            e.getAttribute(a, 2) : e.getAttribute(a)
        } :
        function(e, a) { return e.getAttribute(a) }
   }()
  , hasByClass = !!doc[byClass]
    // has native qSA support
  , hasQSA = doc.querySelector && doc[qSA]
    // use native qSA
  , selectQSA = function (selector, root) {
      var result = [], ss, e
      try {
        if (root[nodeType] === 9 || !splittable.test(selector)) {
          // most work is done right here, defer to qSA
          return arrayify(root[qSA](selector))
        }
        // special case where we need the services of `collectSelector()`
        each(ss = selector.split(','), collectSelector(root, function(ctx, s) {
          e = ctx[qSA](s)
          if (e.length == 1) result[result.length] = e.item(0)
          else if (e.length) result = result.concat(arrayify(e))
        }))
        return ss.length > 1 && result.length > 1 ? uniq(result) : result
      } catch(ex) { }
      return selectNonNative(selector, root)
    }
    // no native selector support
  , selectNonNative = function (selector, root) {
      var result = [], items, m, i, l, r, ss
      selector = selector.replace(normalizr, '$1')
      if (m = selector.match(tagAndOrClass)) {
        r = classRegex(m[2])
        items = root[byTag](m[1] || '*')
        for (i = 0, l = items.length; i < l; i++) {
          if (r.test(items[i].className)) result[result.length] = items[i]
        }
        return result
      }
      // more complex selector, get `_qwery()` to do the work for us
      each(ss = selector.split(','), collectSelector(root, function(ctx, s, rewrite) {
        r = _qwery(s, ctx)
        for (i = 0, l = r.length; i < l; i++) {
          if (ctx[nodeType] === 9 || rewrite || isAncestor(r[i], root)) result[result.length] = r[i]
        }
      }))
      return ss.length > 1 && result.length > 1 ? uniq(result) : result
    }
  , configure = function (options) {
      // configNativeQSA: use fully-internal selector or native qSA where present
      if (typeof options[useNativeQSA] !== 'undefined')
        select = !options[useNativeQSA] ? selectNonNative : hasQSA ? selectQSA : selectNonNative
    }

  configure({ useNativeQSA: true })

  qwery.configure = configure
  qwery.uniq = uniq
  qwery.is = is
  qwery.pseudos = {
    not: function(el, val) { return !is(el, val) }
  }

  return qwery
}));


define('vendors/webcomponents/WeakMap', function () {
    /*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

if (typeof WeakMap === 'undefined') {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;

    var WeakMap = function() {
      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
    };

    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key)
          entry[1] = value;
        else
          defineProperty(key, this.name, {value: [key, value], writable: true});
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ?
            entry[1] : undefined;
      },
      'delete': function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };

    window.WeakMap = WeakMap;
  })();
};
    return window.WeakMap;
});



define('vendors/webcomponents/MutationObserver', ['./WeakMap'], function () {
    /*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is goverened by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(global) {

  var registrationsTable = new WeakMap();

  var setImmediate;

  // As much as we would like to use the native implementation, IE
  // (all versions) suffers a rather annoying bug where it will drop or defer
  // callbacks when heavy DOM operations are being performed concurrently.
  //
  // For a thorough discussion on this, see:
  // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/
  if (/Trident/.test(navigator.userAgent)) {
    // Sadly, this bug also affects postMessage and MessageQueues.
    //
    // We would like to use the onreadystatechange hack for IE <= 10, but it is
    // dangerous in the polyfilled environment due to requiring that the
    // observed script element be in the document.
    setImmediate = setTimeout;

  // If some other browser ever implements it, let's prefer their native
  // implementation:
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;

  // Otherwise, we fall back to postMessage as a means of emulating the next
  // task semantics of setImmediate.
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener('message', function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, '*');
    };
  }

  // This is used to ensure that we never schedule 2 callas to setImmediate
  var isScheduled = false;

  // Keep track of observers that needs to be notified next time.
  var scheduledObservers = [];

  /**
   * Schedules |dispatchCallback| to be called in the future.
   * @param {MutationObserver} observer
   */
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }

  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill &&
        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||
        node;
  }

  function dispatchCallbacks() {
    // http://dom.spec.whatwg.org/#mutation-observers

    isScheduled = false; // Used to allow a new setImmediate call above.

    var observers = scheduledObservers;
    scheduledObservers = [];
    // Sort observers based on their creation UID (incremental).
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });

    var anyNonEmpty = false;
    observers.forEach(function(observer) {

      // 2.1, 2.2
      var queue = observer.takeRecords();
      // 2.3. Remove all transient registered observers whose observer is mo.
      removeTransientObserversFor(observer);

      // 2.4
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });

    // 3.
    if (anyNonEmpty)
      dispatchCallbacks();
  }

  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }

  /**
   * This function is used for the "For each registered observer observer (with
   * observer's options as options) in target's list of registered observers,
   * run these substeps:" and the "For each ancestor ancestor of target, and for
   * each registered observer observer (with options options) in ancestor's list
   * of registered observers, run these substeps:" part of the algorithms. The
   * |options.subtree| is checked to ensure that the callback is called
   * correctly.
   *
   * @param {Node} target
   * @param {function(MutationObserverInit):MutationRecord} callback
   */
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);

      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;

          // Only target ignores subtree.
          if (node !== target && !options.subtree)
            continue;

          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }

  var uidCounter = 0;

  /**
   * The class that maps to the DOM MutationObserver interface.
   * @param {Function} callback.
   * @constructor
   */
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }

  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);

      // 1.1
      if (!options.childList && !options.attributes && !options.characterData ||

          // 1.2
          options.attributeOldValue && !options.attributes ||

          // 1.3
          options.attributeFilter && options.attributeFilter.length &&
              !options.attributes ||

          // 1.4
          options.characterDataOldValue && !options.characterData) {

        throw new SyntaxError();
      }

      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);

      // 2
      // If target's list of registered observers already includes a registered
      // observer associated with the context object, replace that registered
      // observer's options with options.
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }

      // 3.
      // Otherwise, add a new registered observer to target's list of registered
      // observers with the context object as the observer and options as the
      // options, and add target to context object's list of nodes on which it
      // is registered.
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }

      registration.addListeners();
    },

    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
      this.records_ = [];
    },

    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };

  /**
   * @param {string} type
   * @param {Node} target
   * @constructor
   */
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }

  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  };

  // We keep track of the two (possibly one) records used in a single mutation.
  var currentRecord, recordWithOldValue;

  /**
   * Creates a record without |oldValue| and caches it as |currentRecord| for
   * later use.
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }

  /**
   * Gets or creates a record with |oldValue| based in the |currentRecord|
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }

  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }

  /**
   * @param {MutationRecord} record
   * @return {boolean} Whether the record represents a record from the current
   * mutation event.
   */
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }

  /**
   * Selects which record, if any, to replace the last record in the queue.
   * This returns |null| if no record should be replaced.
   *
   * @param {MutationRecord} lastRecord
   * @param {MutationRecord} newRecord
   * @param {MutationRecord}
   */
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;

    // Check if the the record we are adding represents the same record. If
    // so, we keep the one with the oldValue in it.
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;

    return null;
  }

  /**
   * Class used to represent a registered observer.
   * @param {MutationObserver} observer
   * @param {Node} target
   * @param {MutationObserverInit} options
   * @constructor
   */
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }

  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;

      // There are cases where we replace the last record with the new record.
      // For example if the record represents the same mutation we need to use
      // the one with the oldValue. If we get same record (this can happen as we
      // walk up the tree) we ignore the new record.
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }

      records[length] = record;
    },

    addListeners: function() {
      this.addListeners_(this.target);
    },

    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.addEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.addEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.addEventListener('DOMNodeRemoved', this, true);
    },

    removeListeners: function() {
      this.removeListeners_(this.target);
    },

    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.removeEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.removeEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.removeEventListener('DOMNodeRemoved', this, true);
    },

    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     * @param {Node} node
     */
    addTransientObserver: function(node) {
      // Don't add transient observers on the target itself. We already have all
      // the required listeners set up on the target.
      if (node === this.target)
        return;

      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations)
        registrationsTable.set(node, registrations = []);

      // We know that registrations does not contain this because we already
      // checked if node === this.target.
      registrations.push(this);
    },

    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];

      transientObservedNodes.forEach(function(node) {
        // Transient observers are never added to the target.
        this.removeListeners_(node);

        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
    },

    handleEvent: function(e) {
      // Stop propagation since we are managing the propagation manually.
      // This means that other mutation events on the page will not work
      // correctly but that is by design.
      e.stopImmediatePropagation();

      switch (e.type) {
        case 'DOMAttrModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes

          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;

          // 1.
          var record = new getRecord('attributes', target);
          record.attributeName = name;
          record.attributeNamespace = namespace;

          // 2.
          var oldValue =
              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.attributes)
              return;

            // 3.2, 4.3
            if (options.attributeFilter && options.attributeFilter.length &&
                options.attributeFilter.indexOf(name) === -1 &&
                options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            // 3.3, 4.4
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.4, 4.5
            return record;
          });

          break;

        case 'DOMCharacterDataModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
          var target = e.target;

          // 1.
          var record = getRecord('characterData', target);

          // 2.
          var oldValue = e.prevValue;


          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.characterData)
              return;

            // 3.2, 4.3
            if (options.characterDataOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.3, 4.4
            return record;
          });

          break;

        case 'DOMNodeRemoved':
          this.addTransientObserver(e.target);
          // Fall through.
        case 'DOMNodeInserted':
          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist
          var target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === 'DOMNodeInserted') {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {

            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;

          // 1.
          var record = getRecord('childList', target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 2.1, 3.2
            if (!options.childList)
              return;

            // 2.2, 3.3
            return record;
          });

      }

      clearRecords();
    }
  };

  global.JsMutationObserver = JsMutationObserver;

  if (!global.MutationObserver)
    global.MutationObserver = JsMutationObserver;


})(this);;
    return window.MutationObserver;
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, window, clearTimeout, setTimeout
*/

/*jshint
    unused: false, maxparams: false
*/

/**
 * Cross-Platform API for DOM Elements manupilation.
 *
 * ##### Features
 *
 *  - Element's className manipulation.
 *    - addClassName
 *    - hasClassName
 *    - toggleClassName
 *  - Element's events manipulation, including many polyfills and custom events
 *    - addEvent
 *    - triggerEvent
 *    - removeEvent
 *  - Element's selector polyfills and enhancements
 *    - getElements
 *    - getElement
 *    - match
 *  - Element's styles manipulation including CSS3 polyfills (e.g no need preffix)
 *    - setStyles
 *    - setStyle
 *    - getStyle
 *  - Element's dimensions and position caculations
 *    - getOffsets
 *    - getSize
 *    - getPosition
 *    - getScrolls
 *    - isInViewport
 *  - Easy HTML content injection using JSON object instead of string
 *    - addContent
 *    - setContent
 *    - inject
 *    - grab
 *
 * @example
 * var myElement = UWA.createElement('ul', {
 *     'class': 'myElement items',
 *     html: [
 *         {
 *             tag: 'li',
 *             'class': 'item',
 *             text: 'My first item'
 *         },
 *         {
 *             tag: 'li',
 *             'class': 'item',
 *             text: 'My second item'
 *         }
 *     ],
 *     styles: {
 *         borderRadius: '5px',
 *         background: 'red'
 *     },
 *     events: {
 *         click: function (event) {
 *
 *             // Handle click on li here
 *             var eventElement = UWA.Event.getElement(event);
 *         }
 *     }
 * }).inject(widget.body);
 *
 * @module   UWA/Element
 *
 */
define('UWA/Element', [
    'UWA/Core',
    'UWA/String',
    'UWA/Array',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Dispatcher',
    'UWA/Json',
    'UWA/Event',
    'vendors/qwery',
    'vendors/webcomponents/MutationObserver'
], function (UWA, UWAString, UWAArray, Utils, Client, Dispatcher, Json, Event, qwery, MutationObserver) {
    'use strict';

    var Element, queryHelper, DelegatedDispatcher,
        getVendorProperty = Client.getVendorProperty,
        documentElement = document.documentElement;

    queryHelper = (function () {

        var dummyElement = document.createElement('div'),
            reGlobal = /(^|,)/g,
            reTest = /(?:^|,)\s*[>+~]/;

        // Common code for getElements, getElement and match
        // String, String, ?Element, ?Element
        return function (fct, selector, element, matches) {
            var id, originalId, parent, result,
                useParentSelector = matches || reTest.test(selector);

            if (useParentSelector) {
                if (!element) {
                    // in the case of Element:match('> foo', undefined);
                    id = '* ';
                    parent = element;

                } else {
                    // We mark the element with an ID, and we will use its parent to do
                    // the query
                    parent = element.parentNode;
                    originalId = element.id;
                    element.id = id = originalId || 'XXXSELECTORID';
                    id = '#' + id + ' ';

                    if (!matches && !parent) {
                        // If the element has no parent, put it in the dummy parent
                        parent = UWA.extendElement(dummyElement).grab(element);
                    }
                }

                // Put the ID on selectors starting by >, + or ~
                selector = selector.replace(reGlobal, '$1' + id);
            } else {
                parent = element;
            }

            // Run the selector
            if (matches) {
                // element.matchesSelector(selector, parent);
                result = (Element[fct] || matches[fct]).call(matches, selector);
            } else {
                // parent.querySelector(selector);
                result = (Element[fct] || parent[fct]).call(parent, selector);
            }

            if (element && useParentSelector) {
                // Reset to previous state
                if (!originalId) {
                    element.removeAttribute('id');
                } else {
                    element.id = originalId;
                }

                if (parent === dummyElement) {
                    parent.removeChild(element);
                }
            }

            return result;
        };
    }());

    function extractSelector(event) {
        // suggestion : use a (cached) regexp like /^(\S+)\s*(.*)$/ instead of indexOf
        // to also accept tabs and other whitespaces as a separator ?
        var index = event ? event.indexOf(' ') : -1,
            result;

        if (index < 0) {
            result = { name: event };
        } else {
            result = {
                name: event.slice(0, index),
                selector: event.slice(index + 1)
            };
        }

        return result;
    }

    DelegatedDispatcher = Dispatcher.extend({

        Binding: Dispatcher.Binding.extend({

            delegates: null,
            direct: false,
            element: null,

            init: function () {
                this._parent.apply(this, arguments);
                this.delegates = [];
            },

            addDelegate: function (selector) {
                if (selector) {
                    this.delegates.push(selector);
                } else {
                    this.direct = true;
                }
            },

            removeDelegate: function (selector) {
                if (selector) {
                    this.delegates = this.delegates.filter(function (s) {
                        return s !== selector;
                    });
                } else {
                    this.direct = false;
                }

                // This binding is not usefull anymore, detach it.
                if (!this.direct && !this.delegates.length) {
                    this.detach();
                }
            },

            execute: function (params, context) {
                var selector, event, target, result;

                if (this.active) {
                    if (this.delegates.length) {
                        selector = this.delegates.join(',');
                        event = params[0];
                        target = Event.getElement(event);

                        // In delegated events, the target can't be the element,
                        // because the selector always targets a descendant.
                        while (target && target !== this.element && result !== false) {

                            // Test if the target matches the selector
                            if (Element.match.call(target, selector, this.element)) {
                                // This will make Event.getElement to return the
                                // current "target" element instead of the real
                                // event target
                                event._uwaTarget = target;

                                // Call the listener
                                result = this._parent(params, context);

                                event._uwaTarget = null;
                            }

                            target = target.parentNode;
                        }
                    }

                    if (this.direct && result !== false) {
                        result = this._parent(params, context);
                    }
                }
                return result;
            },

            destroy: function () {
                this._parent();
                delete this.element;
            }

        }),

        init: function (element) {
            this._parent();
            this.element = element;
        },

        addDelegation: function (listener, selector, scope, priority) {
            var binding = this.add(listener, scope, priority);
            binding.addDelegate(selector);
            binding.element = this.element;

            return binding;
        },

        removeDelegation: function (listener, selector) {
            if (listener) {
                var binding = this.bindings[this.indexOfListener(listener)];
                if (binding) {
                    binding.removeDelegate(selector);
                }
            } else {
                UWAArray.invoke(this.bindings.slice(), 'removeDelegate', selector);
            }
        },

        dispose: function () {
            this._parent();
            delete this.element;
        }
    });

    /* Get and set class names of an element, with SVG support */
    function getClassName(el) {
        return typeof el.className === 'string' ? el.className : el.getAttribute('class');
    }

    function setClassName(el, cls) {
        if (typeof el.className === 'string') {
            el.className = cls;
        } else {
            el.setAttribute('class', cls);
        }
    }

   /**
    * Cross-Platform API for DOM Elements manupilation.
    *
    * ##### Warning
    * Please do not use this class directly, instead use UWA.createElement.
    *
    * This class will have major changes in the future and there will be a
    * lot of incompatibilities.
    *
    * @param {String} tagName - the new element tag name.
    * @param {Object} [options] - attributes hash or a name/value pair.
    * @returns {Element} the new Element instance.
    *
    * @constructs UWA.Element
    * @memberof module:UWA/Element
    */
    Element = (function () {

        // Here we fix document.createElement issues.

        function createElement(tagName, options) {
            var tempEl, internalEl;

            // Fix ie bug with iframe name property
            if (tagName === 'iframe' && options && options.name !== undefined) {

                tempEl = document.createElement("div");
                tempEl.innerHTML = '<' + tagName + ' name="' + options.name + '"/>';
                internalEl = tempEl.firstChild;
                delete options.name;

            // Fix tridentie bug with object classid property
            } else if (tagName === 'object' && options && options.classid !== undefined) {

                // object tag element content need to be inject using innerHTML
                // to make param tag movie work on IE.
                // See: http://pipwerks.com/2011/05/30/using-the-object-element-to-dynamically-embed-flash-swfs-in-internet-explorer/
                if (options.html) {
                    internalEl = document.createElement("div");
                    Element.setHTML.call(internalEl, options.html);
                    internalEl = Element.getHTML.call(internalEl);
                } else {

                    // TODO set default param url to file if missing?
                    internalEl = '';
                }

                tempEl = document.createElement("div");
                tempEl.innerHTML = '<' + tagName + ' classid="' + options.classid + '">' +
                                   internalEl +
                                   '</' + tagName + '>';

                internalEl = tempEl.firstChild;

                delete options.html;
                delete options.classid;

            } else {
                internalEl = document.createElement(tagName);
            }

            return internalEl;
        }

        return function (tagName, options) {

            var el = createElement(tagName, options);

            // TODO wrapper not extend later
            UWA.extendElement(el);

            if (UWA.is(options, 'object')) {
                Element.set.call(el, options);
            }

            return el;
        };
    }());

    UWA.extend(Element, /** @lends module:UWA/Element.UWA.Element# */ {

        /**
         * Shortcut to manipulates the element using setter methods.
         *
         * ##### Example of name parameter
         *
         * | name             | Description                                    |
         * | ---------------- | ----------------------------------------- ---- |
         * | "html"           | set the html (See setHTML)                     |
         * | "events"         | set the events (See addEvents)                  |
         * | "class"          | set the full classname                         |
         *
         * Any name who match a method "UWA.Element.prototype.set[Name]" will call this method with the value,
         * other names will call the setAttribute method.
         *
         * @method
         * @param {String|Object} name
         * - if this is a String, it is the name of the shortcut to set.
         * - if this is an Object, it should be a hash associating names to values to set.
         * @param {*} value - The value to set
         * @return {Element} The current Element instance.
         *
         * @example
         * var myElement = UWA.createElement('a');
         *
         * // Add some attributes, fill with text, add some events
         * myElement.set({
         *    href: "http://...",
         *    title: "MyLink",
         *    text: "pouete",
         *    events: {
         *        click: function () { }
         *    }
         * });
         *
         * // Key / value signature
         * myElement.set('styles', {
         *    color: 'red'
         * });
         *
         * // Key / value signature with more than one argument
         * myElement.set('style', 'background-color', 'blue');
         */
        set: (function () {

            var domSetters;
            return function (name, value) {

                var key, valueSetter,
                    element = this;

                if (!domSetters) {

                    // Setters for Element#set.
                    // Need to be defined after the Element.
                    // definition as it use Element methods.
                    domSetters = {
                        html: Element.setHTML,
                        events: Element.addEvents,
                        // TODO: IE<=7 required else use setAttribute
                        id: function (domValue) {
                            this.id = domValue;
                        },
                        // TODO: IE<=7 required else use setAttribute
                        'class': function (domValue) {
                            this.className = domValue;
                        },
                        value: function (domValue) {
                            this.value = domValue;
                        }
                    };

                    // Boolean attributes
                    [
                        'compact', 'nowrap', 'ismap', 'declare', 'noshade', 'checked',
                        'disabled', 'readOnly', 'multiple', 'selected', 'noresize',
                        'defer', 'defaultChecked', 'autofocus', 'controls', 'autoplay',
                        'loop'
                    ].forEach(function (attrName) {
                        domSetters[attrName.toLowerCase()] = function (v) {
                            this[attrName] = Boolean(v);
                        };
                    });
                }

                if (UWA.is(name, 'object')) {
                    for (key in name) {
                        if (name.hasOwnProperty(key)) {
                            Element.set.call(element, key, name[key]);
                        }
                    }
                } else {

                    valueSetter = Element['set' + UWAString.capitalize(name)];

                    // Only call Element method with arguments execpt first one
                    if (UWA.is(valueSetter, 'function')) {
                        valueSetter.apply(element, Array.prototype.slice.call(arguments, 1));

                    // Call setAttribute if domSetters does not exist, and do not returm false
                    } else if (
                        !domSetters.hasOwnProperty(name) ||
                            domSetters[name].call(element, value) === false
                    ) {
                        // Note: You can't change the type attribute of an
                        // <input> or <button> after adding it to the DOM in IE.
                        element.setAttribute(name, value);
                    }
                }
                return element;
            };
        }()),

        /**
         * Sets the attributes values of the element.
         * Attributes are passed as either a hash or a name/value pair.
         *
         * @param {Object} attributes - Attributes hash or a name/value pair
         * @return {Element} The current Element instance.
         *
         * @example
         * var myElement = UWA.createElement('a');
         *
         * // Add "href" and "title" attributes
         * myElement.setAttributes({
         *    href: "http://...",
         *    title: "MyLink"
         * });
         * // Will render "&lt;a href=&quot;http://...&quot; title=&quot;MyLink&quot;&gt;&lt;/a&gt;"
         */
        setAttributes: function (attributes) {

            var element = this,
                attribute;

            for (attribute in attributes) {
                if (attributes.hasOwnProperty(attribute)) {
                    element.setAttribute(attribute, attributes[attribute]);
                }
            }

            return element;
        },

        /**
         * Get the element tagName in lowercase.
         *
         * @return {String} The current element tagName.
         *
         * @example
         * var myElement = UWA.createElement('div');
         * myElement.getTagName();
         * // Will return "div"
         */
        getTagName: function () {

            var element = this,
                tagName = (element.tagName || element.nodeName);

            return tagName ? tagName.toLowerCase() : '';
        },

        /**
         * Replace element's existing content by a new text node.
         *
         * @param {String} text - The text value
         * @return {Element} The current Element instance.
         *
         * @example
         * var myText = UWA.createElement('p', {
         *    text: "Hello!"
         * });
         *
         * // Replace element text by "Loading...".
         * myText.setText("Loading...");
         * // Will render "&lt;p&gt;Loading...&lt;/p&gt;"
         */
        setText: function (text) {

            var element = this;

            // Clear content
            Element.empty.call(element);

            return Element.appendText.call(element, text);
        },

        /**
         * Adds a new text node at the end of the element's existing content.
         *
         * @param {String} text - The text value
         * @return {Element} The current Element instance.
         *
         * @example
         * var myText = UWA.createElement('p', {
         *    text: "Hello"
         * });
         *
         * // Append " World!" text into the element.
         * myText.appendText(" World!");
         * // Will render "&lt;p&gt;Hello World!&lt;/p&gt;"
         */
        appendText: function (text) {

            var element = this,
                document = Element.getDocument.call(element);

            element.appendChild(document.createTextNode(text));

            return element;
        },

        /**
         * Get the inner text of the element.
         *
         * @return {String} text contained by the element.
         *
         * @example
         * var myContent = UWA.createElement('p', {
         *    html: '<a href="http://...">Hello <span>World!</span></a>'
         * });
         *
         * myContent.getText();
         * // Will return "Hello World!"
         *
         * @see {@link http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent}
         */
        getText: function () {

            var element = this;

            return element.textContent || element.innerText || UWAString.stripTags(element.innerHTML);
        },

        /**
         * Replace the content of the element by another.
         *
         * Content parameter could be:
         *
         * - a String, considered as XHTML
         * - a DOM Element
         * - an Object used to create an DOM element by using the 'tag'
         *  field as tag and other fields as properties
         * - an Array of Objects used to create multiple DOM elements
         *
         * * each argument can be: String/Object/Array content: the content to set to the element.
         *
         * ##### Examples
         *
         * ###### Setup code (required for all examples)
         * ```
         * var myContent = UWA.createElement('div');
         * ```
         *
         * ###### Insert an element using *Object* syntax
         * ```
         * myContent.setContent({
         *    tag: 'a',
         *    href: 'http://www.example.com',
         *    text: 'My Link',
         *    styles: {
         *        color: 'red'
         *    },
         *    events: {
         *       click: function (event) {
         *            // My Click Handler
         *            UWA.Event.stop(event);
         *       }
         *    }
         * });
         * ```
         *
         * Will render:
         * ```html
         * <div>
         *    <a style="color: red;" href="http://www.example.com">My Link</a>
         * </div>
         * ```
         *
         * ###### Insert elements using *Array* syntax
         *
         * ```
         * myContent.setContent([
         *    {
         *        tag: 'div',
         *        'class': 'myHeader'
         *    },
         *    {
         *        tag: 'div',
         *        'class': 'myContent',
         *        html: [
         *            {
         *                tag: 'a',
         *                text: 'My Link',
         *                styles: {
         *                    color: 'red'
         *                },
         *                events: {
         *                    click: function (event) {
         *                        // My Click Handler
         *                        UWA.Event.stop(event);
         *                   }
         *                }
         *
         *            }
         *        ]
         *    },
         *    {
         *        tag: 'div',
         *        'class': 'myFooter'
         *    },
         * ]);
         * ```
         *
         * Will render:
         * ```html
         * <div>
         *    <div class="myHeader"></div>
         *    <div class="myContent">
         *        <a>My Link</a>
         *    </div>
         *    <div class="myFooter"></div>
         * </div>
         * ```
         *
         * ###### Using *String* considered as XHTML (bad pratice)
         *
         * ```html
         * myContent.setContent('<a href="http://www.example.com">My Link</a>');
         * ```
         *
         * @return {Element} The current Element instance.
         */
        setContent: function () {

            var element = this;

            // Clear content
            Element.empty.call(element);

            return Element.addContent.apply(element, arguments);
        },

        /**
         * Add content to current Element.
         *
         * Content parameter could be:
         *
         * - a String, considered as XHTML
         * - a DOM Element
         * - an Object used to create an DOM element by using the 'tag'
         *  field as tag and other fields as properties
         * - an Array of Objects used to create multiple DOM elements
         *
         * * each argument can be: String/Object/Array content: the content to add to the element.
         *
         * @example
         * See UWA.Element.setContent method.
         *
         * @method
         * @return {Element} the current Element instance.
         */
        addContent: (function () {
            function populate(arraylike, document, fragment) {
                var i, l, htmlBuffer, contentBuffer;

                if (UWA.is(arraylike, 'nodelist')) {
                    // Turn the nodelist to an array, because when the nodes are injected
                    // in the fragment, they are removed from the nodelist
                    arraylike = [].slice.call(arraylike);
                }

                for (i = 0, l = arraylike.length; i < l; i++) {
                    contentBuffer = arraylike[i];
                    if (contentBuffer) {

                        // DOM element
                        if (contentBuffer.nodeType) {
                            fragment.appendChild(contentBuffer);

                        // XHTML string
                        } else if (typeof contentBuffer === 'string' || typeof contentBuffer === 'number') {

                            // Contain HTML tags
                            if (/<|&#?\w+;/.test(contentBuffer)) {

                                htmlBuffer = document.createElement('div');
                                Element.setHTML.call(htmlBuffer, contentBuffer);

                                while (htmlBuffer.firstChild) {
                                    fragment.appendChild(htmlBuffer.firstChild);
                                }

                            // Simple text
                            } else {
                                fragment.appendChild(document.createTextNode(contentBuffer));
                            }

                        } else if (typeof contentBuffer.inject === 'function' && !Array.isArray(contentBuffer)) {
                            contentBuffer.inject(fragment);

                        } else if (typeof contentBuffer.length === 'number') {
                            populate(contentBuffer, document, fragment);

                        // Object descriptor
                        } else if (typeof contentBuffer === 'object') {

                            // Prepare Objects
                            htmlBuffer = contentBuffer.tag || 'div';
                            delete contentBuffer.tag;

                            fragment.appendChild(UWA.createElement(htmlBuffer, contentBuffer));

                            // Restore object
                            contentBuffer.tag = htmlBuffer;

                        } else { // Numbers...
                            fragment.appendChild(document.createTextNode(contentBuffer));
                        }
                    }
                }
            }

            return function () {

                var element = this,
                    document = Element.getDocument.call(element),
                    fragment = document.createDocumentFragment();

                populate(arguments, document, fragment);

                element.appendChild(fragment);

                return element;
            };
        }()),

        /**
         * Sets the content of the element from a valid XHTML String.
         *
         * ##### Notes about HTML vs XHTML
         * In most of the UWA environments HTML have to be valid XHTML.
         *
         *  - XHTML is fundamentally different from HTML, despite looking very similar.
         *  - XHTML is XML, which means that the syntax rules are slightly different.
         *  - There are things you can do in XHTML which you cannot do in HTML.
         *  - There are things you can do in HTML which you cannot do in XHTML.
         *  - There are differences concerning CSS.
         *  - There are differences concerning client-side scripting (e.g., JavaScript).
         *
         * ###### Invalid XHTML
         * ```html
         * <img src="...">
         * <input name="" value="" >
         * <br>
         * ```
         *
         * ###### Valid XHTML
         * ```html
         * <img src="..." />
         * <input name="" value="" />
         * <br />
         * ```
         *
         * @example
         * // Your existing element
         * var myContent = UWA.createElement('div', {
         *    html: '&lt;p&gt;Loading...&lt;p/&gt;'
         * });
         *
         * myContent.setHTML('&lt;p&gt;Ready!&lt;p/&gt;');
         *
         * @param {String} html - A valid XHTML String
         * @return {Element} The current Element instance.
         * @see {@link http://www.sitepoint.com/forums/showthread.php?393445-XHTML-vs-HTML-FAQ|Frequently Asked Questions About XHTML vs HTML}
         */
        setHTML: function (html) {

            var htmlClean,
                element = this;

            if (typeof html !== 'string') {

                Element.setContent.call(element, html);

            } else {

                try {

                    // replace & by &amp to avoid JS errors
                    htmlClean = UWAString.escapeHTMLEntities(html)
                        .replace('<?xml version="1.0" encoding="UTF-8"?>', '')
                        .replace(/&(?!#?[a-z0-9]+;)/gi, '&#38;');

                    element.innerHTML = htmlClean;

                } catch (errorInnerHTML) {

                    UWA.log('UWA.Element.setHTML error cause: ' + errorInnerHTML + ' with HTML value "' + html + '"');

                    // if it fail insert escaped HTML
                    try {
                        element.innerHTML = UWAString.stripTags(String(html));
                    // if it fail insert HTML has string
                    } catch (errorStripTags) {
                        Element.setText.call(element, html);
                    }
                }
            }

            return element;
        },

        /**
         * Gets the content of the element.
         *
         * @example
         * // Your existing elements tree
         * var myContent = UWA.createElement('div', {
         *    html: {
         *        tag: 'p',
         *        text: 'Loading...'
         *    }
         * });
         *
         * myContent.getHTML();
         * // Will return "&lt;p&gt;Loading...&lt;p/&gt;"
         *
         * @return {String} The current Element innerHTML value.
         */
        getHTML: function () {

            // TODO:
            // - Ignore IE line breaks (IE)
            // - Add missing quotes on attributes (IE)
            // - Ignore empty attributes

            var innerHTML = this.innerHTML;

            // Fix IE XHTML results
            if (Client.Engine.ie) {

                innerHTML = innerHTML
                // remove upperCase tagNames (IE)
                    .replace(/< *(\/ *)?(\w+)/g, function (string) {
                        return string.toLowerCase();
                    });
            }

            return innerHTML;
        },

        /**
         * Inject, or insert, the element at a particular place relative to the
         * Element's children (specified by the second the argument, default is "bottom").
         *
         * ##### Example
         *
         * ```
         * // Your existing elements tree
         * var myFriendList = UWA.createElement('ul', {
         *    html: {
         *        tag: 'li',
         *        text: 'John Doe'
         *    }
         * });
         *
         * // Inject to the bottom (default)
         * UWA.createElement('li', {
         *    text: 'Marla Singer'
         * }).inject(myFriendList, 'bottom');
         *
         * // Inject to the top
         * UWA.createElement('li', {
         *    text: 'Brendan Eich'
         * }).inject(myFriendList, 'top');
         *
         * // Inject before
         * UWA.createElement('h1', {
         *    text: 'My Friends'
         * }).inject(myFriendList, 'before');
         * ```
         *
         * Will render:
         * ```html
         * <h1>My Friends</h1>
         * <ul>
         *    <li>Brendan Eich</li>
         *    <li>John Doe</li>
         *    <li>Marla Singer</li>
         * </ul>
         * ```
         *
         * @param {Element} injected - The element to inject
         * @param {String} where - The place to inject this Element
         *  Can be 'top', 'bottom', 'after', or 'before'.
         * @return {Element} The current Element instance.
         */
        inject: function (injected, where) {

            // TODO adoptNode support

            var parent,
                element = this,
                document = Element.getDocument.call(element);

            where = where || 'bottom';

            if (where === 'bottom') {
                injected.appendChild(element);

            } else if (where === 'top') {
                injected.insertBefore(element, injected.firstChild);

            } else {

                parent = injected.parentNode;

                // If the parent does not exist yet, we create a document
                // fragment and use it as a parent.
                // We should not doing this if the injected element is already
                // a document fragment, as it will lose its current content
                // when appended in the new parent.
                if (!parent && injected.nodeType !== 11) {
                    parent = document.createDocumentFragment();
                    parent.appendChild(injected);
                }

                if (parent) {
                    if (where === 'after') {

                        if (parent.lastChild === injected) {
                            parent.appendChild(element);
                        } else {
                            parent.insertBefore(element, injected.nextSibling);
                        }

                    } else if (where === 'before') {

                        parent.insertBefore(element, injected);
                    }
                }
            }

            return element;
        },

        /**
         * Works as {@link module:UWA/Element.Element.prototype.inject|inject}, but in reverse.
         *
         * Append the element at a particular place relative to the element's
         * children (specified by the where parameter).
         *
         * ##### Example
         *
         * ```
         * // Your existing elements tree
         * var myFriendList = UWA.createElement('ul', {
         *    html: {
         *        tag: 'li',
         *        text: 'John Doe'
         *    }
         * });
         *
         * // Insert element into myFriendList
         * myFriendList.grab(UWA.createElement('li', {
         *    text: 'Marla Singer'
         * }));
         * ```
         *
         * Will render:
         * ```html
         * <ul>
         *    <li>John Doe</li>
         *    <li>Marla Singer</li>
         * </ul>
         * ```
         *
         * @param {Element} element - The element to inject
         * @param {String} where - The place to inject this Element
         *  Can be 'top', 'bottom', 'after', or 'before'.
         * @return {Element} The current Element instance.
         */
        grab: function (element, where) {

            Element.inject.call(element, this, where);

            return this;
        },

        // TODO adopt/wraps ?

        /**
         * Check if element is injected into another element, by default the documentElement.
         *
         * @see {@link http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition}
         *
         * @example
         * // Your existing element
         * var myContent = UWA.createElement('div', {
         *    html: {
         *        tag: 'p',
         *        text: 'Loading...'
         *    }
         * });
         *
         * myContent.isInjected();
         * // Will return `false`
         *
         * myContent.inject(widget.body);
         * myContent.isInjected();
         * // Will return `true` because it's inside the DOM tree
         *
         * @method
         * @param {Element} parent - The parent element that sould containt the element,
         *  by default it's ownerDocument.documentElement.
         * @return {Boolean} `true` if has document.body into the parents tree else `false`.
         */
        isInjected: (function () {

            var isInjected;

            // Use current document for feature testings
            if (documentElement.contains) {

                isInjected = function (parent) {

                    var element = this;

                    parent = parent || element.ownerDocument.documentElement;
                    return parent !== element && (parent.contains ? parent.contains(element) : true);
                };

            // Use current document for feature testings
            } else if (documentElement.compareDocumentPosition) {

                isInjected = function (parent) {

                    var element = this;

                    parent = parent || element.ownerDocument.documentElement;
                    return Boolean(parent.compareDocumentPosition(element) & 16);
                };
            } else {

                isInjected = function (parent) {

                    var element = this;
                    parent = parent || element.ownerDocument.documentElement;

                    do {
                        element = element.parentNode;
                    } while (element && element.parentNode);

                    return element === parent;
                };
            }

            return isInjected;
        }()),

         /**
         * Empty an element of all his children.
         * Children should/could may not be used after this.
         *
         * @example
         * // Your existing element
         * var myContent = UWA.createElement('div', {
         *    html: {
         *        tag: 'p',
         *        text: 'Loading...'
         *    }
         * });
         *
         * // Remove the element children
         * myContent.empty();
         *
         * @param {Boolean} [destroyChildren=false] - `true` to remove all
         *   events from children (see {@link module:UWA/Element.Element.prototype.destroy|UWA.Element.destroy}).
         * @return {Element} The current Element instance.
         */
        empty: function (destroyChildren) {

            var firstChild,
                element = this;


            // Remove any remaining nodes and there events
            while (element.firstChild) {

                firstChild = element.firstChild;

                if (destroyChildren) {
                    Element.destroy.call(firstChild);
                } else {
                    element.removeChild(firstChild);
                }
            }

            return element;
        },

        /**
         * Detach the element from the parent and returns it.
         *
         * @return {Element} The current Element instance.
         */
        remove: function () {

            var element = this,
                parentNode = Element.getParent.call(element);

            if (parentNode) {
                parentNode.removeChild(element);
            }

            return element;
        },

        /**
         * Destroy the element and its children.
         * Remove all events from elements and children and remove them from the document.
         * Element and it's children should/could may not be used after this.
         */
        destroy: function () {

            var document, i, l,
                element = this,
                remove = Element.remove,
                destroy = Element.destroy,
                children = Element.getChildren.call(element);

            // Remove Children
            for (i = 0, l = children.length; i < l; i += 1) {
                if (children[i].destroy) {
                    destroy.call(children[i]);
                }
            }

            // Remove Events
            Element.removeEvents.call(element);

            // Do not delete Element window, document.body or document
            document = Element.getDocument.call(element);
            if (
                element !== document &&
                    element !== document.documentElement &&
                        element !== document.body &&
                            element !== Element.getWindow.call(element)
            ) {
                remove.call(element);
            }
        },

        /**
         * Return the parent node of the element.
         *
         * @param {String} [selector] - Get the first parent who matches the selector.
         * @return {Element} The parent node, null if the parent was not found.
         */
        getParent: function (selector) {

            var parent = this.parentNode;

            if (selector) {
                while (parent && parent.nodeType === 1 &&
                        !Element.match.call(parent, selector)) {
                    parent = parent.parentNode;
                }
            }

            if (parent && parent.nodeType !== 1) {
                parent = null;
            }
            return parent ? UWA.extendElement(parent) : null;
        },

        /**
         * Get the parent nodes of the element
         *
         * @param {String} [selector] - Filter parents matching this selector
         * @return {Array} the parent nodes
         */
        getParents: function (selector) {
            var result = [];
            var el = this;
            while (true) {  // eslint-disable-line no-constant-condition
                var parent = el.getParent(selector);
                if (parent) {
                    result.push(parent);
                    el = parent;
                } else {
                    return result;
                }
            }
        },

        /**
         * Get the closest element matching a selector. If the element does
         * not match the selector, get the first matching parent.
         *
         * @param {selector} String - The selector to use
         * @return {Element} The closest element, or null if it was not found.
         */
        getClosest: function (selector) {

            var that = this;

            return Element.match.call(that, selector) ?
                    that : Element.getParent.call(that, selector);
        },

        /**
         * Get collection of the element's child nodes.
         *
         * @return {Array} Collection of the element's child nodes.
         */
        getChildren: function () {
            return Array.prototype.filter.call(this.childNodes, function (el) {
                return el.nodeType === 1;
            }).map(UWA.extendElement);
        },

        /**
         * Get the document of the current element.
         *
         * @return {Document} Document element of the current element.
         */
        getDocument: function () {

            var element = this;

            return element.nodeType === 9 ? element : (element.ownerDocument || element.document);
        },

        /**
         * Get the window of the current element.
         *
         * @return {Window} window element of the current element.
         */
        getWindow: function () {

            var document = Element.getDocument.call(this);

            return document && (document.defaultView || document.parentWindow);
        },

        /**
         * Returns the parent of the element that is positioned, if there is one.
         *
         * __Notes__:
         *
         * This method fix broken offsetParent on IE < 8 using featured detection.
         *
         * @method
         * @return {Element} The first positioned element's parent node.
         */
        getOffsetParent: (function () {

            var brokenOffsetParent;

            // Detect if offsetParent return correct value
            // Use current document for feature testings
            function detectDrokenOffsetParent() {

                var element = document.createElement('div'),
                    child = document.createElement('div');

                element.style.height = '0';
                element.appendChild(child);

                brokenOffsetParent = (child.offsetParent === element);
            }

            function isBody(element) {
                return (/^(?:body|html)$/i).test(element.tagName);
            }

            function isOffset(element) {
                return element && (Element.getStyle.call(element, 'position') !== 'static' || isBody(element));
            }

            function isOffsetStatic(element) {
                return isOffset(element) || (/^(?:table|td|th)$/i).test(element.tagName);
            }
            return function () {

                var isOffsetCheck,
                    element = this,
                    document = Element.getDocument.call(element),
                    offsetParent = element.offsetParent || (document && document.body),
                    elementPosition = Element.getStyle.call(element, 'position');

                if (!isBody(element) && elementPosition !== 'fixed') {

                    // Execute test only on first call
                    if (brokenOffsetParent === undefined) {
                        detectDrokenOffsetParent();
                    }

                    if (brokenOffsetParent) {

                        isOffsetCheck = (elementPosition === 'static') ? isOffsetStatic : isOffset;

                        while ((element = element.parentNode) !== undefined) {
                            if (isOffsetCheck(element)) {
                                offsetParent = element;
                                break;
                            }
                        }

                    } else {
                        try {
                            offsetParent = element.offsetParent;
                        } catch (e) {
                            // Ignore IE possible errors
                        }
                    }
                }

                if (offsetParent) {
                    offsetParent = UWA.extendElement(offsetParent);
                }

                return offsetParent;
            };

        }()),

        /**
         * Gets all descendants elements whose match a CSS selector.
         * Behaves like the Element.querySelectorAll except for queries
         * starting with ">", "~" and "+".
         *
         * ##### Example
         *
         * * Setup code (required for all examples)
         *
         * ```
         * // Create your elements tree
         * var element = UWA.createElement('div', {
         *    html: [
         *        {
         *            tag: 'h1',
         *            html: {
         *                tag: 'a',
         *                text: 'My App Title...'
         *            }
         *        },
         *        {
         *            tag: 'div',
         *            'class': 'highlighted',
         *            html: {
         *                tag: 'ul',
         *                html: [
         *                    {
         *                        tag: 'li',
         *                        html: {
         *                            tag: 'a',
         *                            text: 'My first Nav'
         *                        }
         *                    },
         *                    {
         *                        tag: 'li',
         *                        html: {
         *                            tag: 'a',
         *                            text: 'My second Nav'
         *                        }
         *                    }
         *                ]
         *            }
         *        }
         *    ]
         * });
         * ```
         *
         * Will render:
         * ```html
         * <div>
         *    <h1>
         *        <a>My App Title...</a>
         *    </h1>
         *    <div class="highlighted">
         *        <ul>
         *            <li><a>My first Nav</a></li>
         *            <li><a>My second Nav</a></li>
         *        </ul>
         *    </div>
         * </div>
         * ```
         *
         * * Gets descendants elements whose match CSS selector
         *
         * ```
         * // Get all anchors in the element
         * element.getElements('a');
         *
         * // Get all elements with "myClass" class
         * element.getElements('.myClass');
         *
         * // Get all anchors with "myClass" class
         * element.getElements('a.myClass');
         *
         * // Get all anchors with a title attribute in the element
         * element.getElements('a[title]');
         *
         * // Get all "p" children elements under a container,
         * // whose parent is a div that contains the class 'highlighted'
         * element.getElements('div.highlighted > p');
         * ```
         *
         * @param {String} selector - The CSS selector to use (could be more than one rule)
         * @return Array of <UWA.Element> that matched.
         */
        getElements: function (selector) {
            return Array.prototype.map.call(
                queryHelper('querySelectorAll', selector, this),
                UWA.extendElement,
                UWA
            );
        },

        /**
         * Gets the first descendant element who matches a CSS selector.
         * Behaves like the Element.querySelectorAll except for queries
         * starting with ">", "~" and "+".
         *
         * ##### Example
         *
         * * Setup code (required for all examples)
         *
         * ```
         * var element = UWA.createElement('div', {
         *     html: [
         *         {
         *             tag: 'h1',
         *             html: {
         *                 tag: 'a',
         *                 text: 'My App Title...'
         *             }
         *         },
         *         {
         *             tag: 'div',
         *             'class': 'highlighted',
         *             html: {
         *                 tag: 'ul',
         *                 html: [
         *                     {
         *                         tag: 'li',
         *                         html: {
         *                             tag: 'a',
         *                             text: 'My first Nav'
         *                         }
         *                     },
         *                     {
         *                         tag: 'li',
         *                         html: {
         *                             tag: 'a',
         *                             text: 'My second Nav'
         *                         }
         *                     }
         *                 ]
         *             }
         *         }
         *     ]
         * });
         * ```
         *
         * Will render:
         * ```html
         * <div>
         *    <h1>
         *        <a>My App Title...</a>
         *    </h1>
         *    <div class="highlighted">
         *        <ul>
         *            <li><a>My first Nav</a></li>
         *            <li><a>My second Nav</a></li>
         *        </ul>
         *    </div>
         * </div>
         * ```
         *
         * * Gets first descendant element whose match CSS selector
         *
         * ```
         * // Get the first anchor in the element
         * element.getElement('a');
         *
         * // Get the first element with "myClass" class
         * element.getElement('.myClass');
         *
         * // Get the first anchor with "myClass" class
         * element.getElement('a.myClass');
         *
         * // Get the first anchor with a title attribute in the element
         * element.getElement('a[title]');
         *
         * // Get the first "p" children element under a container,
         * // whose parent is a div that contains the class 'highlighted'
         * element.getElement('div.highlighted > p');
         * ```
         *
         * @param {String} selector - The CSS selector to use (could be more than one rule)
         * @return {Element} - <UWA.Element> that matched.
         */
        getElement: function (selector) {
            return UWA.extendElement(queryHelper('querySelector', selector, this));
        },

        /**
         * Check if the element matches a CSS selector.
         *
         * Behaves like the Element.matchesSelector but also accepts queries
         * starting with ">", "~" and "+".
         *
         * @param {String} selector - The CSS selector to use (could be more than one rule)
         * @param {Element} root optional - Limit the selection to children of this element
         *
         * @returns {Boolean} - wether or not the element matches the selector
         *
         * @example
         * // Without a root, this is not very usefull
         * element.match('> *'); // the element have a parent
         * element.match('+ ul'); // the element is an UL with a previous sibling
         *
         * // With a root, everything makes sense
         * element.match('> *', root); // the element is a direct child of the root
         *
         * // .header in the container element
         * element.match('> .header', container);
         * // the element is the header of the container, and not a random element
         */
        match: function (selector, root) {
            return queryHelper('matchesSelector', selector, root, this);
        },

        /**
         * Checks whether element has the given CSS className.
         *
         * @param {String} className - the className to check.
         * @return {Bool} - true if element has className else false.
         *
         * @example
         * // Your existing element
         * var element = UWA.createElement('div', {
         *     'class': 'myCSSClassName'
         * });
         *
         * element.hasClassName('myCSSClassName');
         * // Will return true
         *
         * element.hasClassName('myMissingClassName');
         * // Will return false
         */
        hasClassName: function (className) {
            var current = getClassName(this);
            return Boolean(current && UWAString.contains(current, className, ' '));
        },

        /**
         * Adds a CSS class to element.
         *
         * @param {String} className - the className to add.
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     'class': 'myCSSClassName'
         * });
         *
         * // Add new "myCSSClassName" className
         * myElement.addClassName('myCSSClassName');
         */
        addClassName: function (className) {

            var element = this;

            if (!Element.hasClassName.call(element, className)) {
                setClassName(this, (getClassName(this).trim() + ' ' + className).trim());
            }

            return element;
        },

        /**
         * Removes element's CSS className.
         *
         * @param {String} className - the className to remove.
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     'class': 'myCSSClassName'
         * });
         *
         * // Remove existing "myCSSClassName" className
         * myElement.removeClassName('myCSSClassName');
         */
        removeClassName: function (className) {

            var element = this;

            setClassName(this, getClassName(this).replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)'), '$1').trim());

            return element;
        },

        /**
         * Add or remove the passed in class name to the element, depending on
         * whether or not it's already present.
         *
         * @param {String} className - The class to add or remove.
         * @param {Boolean} force - force add (if true) or remove the class name.
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     'class': 'myCSSClassName'
         * });
         *
         * // Remove exiting "myCSSClassName" className
         * myElement.toggleClassName('myCSSClassName');
         *
         * // Add missing "myCSSClassName" className
         * myElement.toggleClassName('myCSSClassName');
         */
        toggleClassName: function (className, force) {

            var element = this,
                add = UWA.is(force) ? force : !Element.hasClassName.call(element, className);

            return UWA.Element[add ? 'addClassName' : 'removeClassName'].call(element, className);
        },

        /**
         * Modify element's CSS style property.
         *
         * @param {String} property - style property name.
         * @param {String} value - style property value.
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     styles: {
         *         color: 'red'
         *     }
         * });
         *
         * // Update "color" style
         * myElement.setStyle('color', 'blue');
         */
        setStyle: function (property, value) {

            var styles = {};

            styles[property] = value;

            return Element.setStyles.call(this, styles);
        },

        /**
         * Modifies element's CSS style properties.
         * Styles are passed as either a hash or a name/value pair.
         *
         * @method
         * @param {Object} attributes - styles hash or a name/value pair.
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     styles: {
         *         color: 'red',
         *         padding: '5px'
         *     }
         * });
         *
         * // Update "padding" and "color" styles
         * myElement.setStyle({
         *     color, 'blue',
         *     padding: '10px'
         * );
         */
        setStyles: (function () {

            var styleValuePreffixCache = {},
                styleValuePrefixes = {
                    none: '',
                    firefox: '-moz-',
                    opera: '-o-',
                    trident: '-ms-',
                    webkit: '-webkit-'
                },
                unitLessNumericStyles = {
                    columnCount: 1,
                    flex: 1,
                    flexGrow: 1,
                    flexShrink: 1,
                    fontWeight: 1,
                    lineClamp: 1,
                    lineHeight: 1,
                    opacity: 1,
                    order: 1,
                    orphans: 1,
                    widows: 1,
                    zIndex: 1,
                    zoom: 1,

                    fillOpacity: 1,
                    strokeOpacity: 1
                };

            // This function add quote around fontFamily tyle value
            // to avoid some issue with font starting with digit.
            function getFontFamily(value) {

                // Remove quotes from value and split
                var newValue = [],
                    fonts = value.replace(/[\'\"]/g, "")
                                .split(',');

                // Add quotes and populate value again
                fonts.forEach(function (font) {
                    newValue.push('"' + font.trim() + '"');
                });

                return newValue.join(', ');
            }

            // This function is testing the support of some style
            // value by checking that the value is still the same after
            // set it to an dummy element.
            function supportsCSS(style, value) {

                var supported, engine, prefix, prefixedValue,
                    dummy, dummyStyle,
                    cacheKey = style + value;

                if (styleValuePreffixCache[cacheKey]) {
                    supported = styleValuePreffixCache[cacheKey];
                } else {

                    supported = false;
                    dummy = document.createElement('div');
                    dummyStyle = dummy.style;

                    for (engine in styleValuePrefixes) {
                        prefix = styleValuePrefixes[engine];
                        prefixedValue = prefix + value;
                        dummyStyle[style] = prefixedValue;

                        if (
                            dummyStyle[style] === prefixedValue &&
                                (prefixedValue !== '' && !Client.Engine.ie)
                        ) {
                            supported = prefixedValue;
                            break;
                        }
                    }

                    styleValuePreffixCache[cacheKey] = supported;
                }

                return supported;
            }

            function getGrabCursor(value) {

                var nativeGrabCursor = supportsCSS('cursor', value);

                if (nativeGrabCursor !== false) {
                    value = nativeGrabCursor;
                } else if (Client.Engine.opera) { // Opera do not support .cur file
                    value = 'move';
                } else { // Using .cur file
                    value = 'url(' + UWA.hosts.uwa + UWA.paths.css + '/base/cursor/' +
                        (value === 'grabbing' ? 'closedhand' : 'openhand') + '.cur)' +
                        (Client.Engine.ie ? "" : " 4 4") + ', move';
                }

                return value;
            }

            return function (styles) {

                var i, l, value, property,
                    element = this,
                    elementStyles = element.style,
                    appliedStyles = [];

                // Create appliedStyles inside a first loop
                // to handle vendors and units
                for (property in styles) {
                    if (styles.hasOwnProperty(property)) {

                        value = styles[property];
                        property = UWAString.camelCase(property);

                        // Use opacity setter if property is opacity.
                        if (property === 'opacity') {
                            Element.setOpacity.call(element, value);
                        } else {

                            // If value is a number or a string with number only,
                            // add 'px' unit to value (excluding some CSS properties).
                            if (
                                value !== '' &&                     // Not an empty string
                                    value !== null &&               // Not Null
                                            isFinite(value) &&      // Not undefined and numeric
                                                unitLessNumericStyles[property] === undefined
                            ) {
                                value += 'px';

                            // Handle -moz-none value for -moz-user-select
                            // required for Firefox < 21.
                            } else if (
                                value === 'none' &&
                                    property === 'userSelect' &&
                                        elementStyles.MozUserSelect !== undefined
                            ) {
                                value = '-moz-none';

                            // Handle possibles missing quotes for fontFamily
                            // that are ignored on some browser if missing.
                            } else if (property === 'fontFamily') {

                                value = getFontFamily(value);

                            // Handle possibles issue with cursor property
                            } else if (property === 'cursor') {

                                // Polyfill grabbing and grab cursor value
                                if ('grabbing' === value || 'grab' === value) {
                                    value = getGrabCursor(value, elementStyles);
                                }
                            }

                            appliedStyles.push({
                                name: Element.getStyleName.call(element, property),
                                value: value
                            });
                        }
                    }
                }

                // Apply styles in one loop to reduce the repaint events
                for (i = 0, l = appliedStyles.length; i < l; i++) {

                    property = appliedStyles[i].name;
                    value = appliedStyles[i].value;

                    try {
                        elementStyles[property] = value || value === 0 ? value : "";
                    } catch (e) {
                        // Ignore possible errors...
                        UWA.log('Unable to set style "' + property + '" with value "' + value + '"');
                    }
                }

                return element;
            };

        }()),

        /**
         * Get element's CSS style property value.
         * By default it will return the CSS style property value computed by the browser.
         *
         * ##### Example
         *
         * ###### Setup code
         * ```html
         * <!-- Your CSS rule -->
         * <style type="text/css">
         *     div.myClass {
         *         padding: 10px;
         *     }
         * </style>
         * ```
         *
         * ###### Get elements style value
         * ```
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     'class': 'myClass',
         *     styles: {
         *         color: 'red'
         *     }
         * });
         *
         * myElement.getStyle('color');
         * // Will return "red"
         *
         * // Using computed style
         * myElement.getStyle('padding');
         * // Will return "10px"
         *
         * // Disable computed style
         * myElement.getStyle('padding', true);
         * // Will return ""
         * ```
         *
         * @see https://developer.mozilla.org/en/DOM/window.getComputedStyle
         *
         * @param {String} property - style property name (e.g "color", "display", "top", ...).
         * @param {Boolean} computed - retrieve CSS style property value computed by the browser (e.g default is true).
         * @return {String} the style property value (e.g "none", "red", "10px", ...).
         */
        getStyle: function (property, computed) {

            var styles = Element.getStyles.call(this, [property], computed);

            return styles[property];
        },

        /**
         * Get element's CSS styles value.
         * By default it will return the CSS style value computed by the browser.
         *
         * @method
         * @param {Array} property - style properties names.
         * @param {Boolean} computed - retrieve CSS style property value computed by the browser (e.g default is true).
         *
         * @return {Object} - styles properties value indexed by property name.
         */
        getStyles: (function () {

            var getComputedStyles, badMarginPixel, opacitySemaphore,
                rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
                rmargin = /^margin/;

            // WebKit (Safari not Chrome) uses "computed value (percentage if specified)" instead of "used value" for margins
            // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            function detectBadMArginPixel() {

                var div = document.createElement('div');
                div.style.margin = '1%';
                document.body.appendChild(div);

                badMarginPixel = (window.getComputedStyle(div, null) || {marginTop: 0}).marginTop === '1%';

                document.body.removeChild(div);
            }

            // Use current document for feature testings
            if (document.defaultView && document.defaultView.getComputedStyle) {

                getComputedStyles = function (element, properties, values) {

                    var i, l, width, property, value, vendorProperty,
                        ownerDocument = element.ownerDocument,
                        defaultView = ownerDocument.defaultView,
                        computedStyle = Element.getWindow.call(element).getComputedStyle(element, null),
                        style = element.style;

                    if (defaultView && computedStyle) {

                        for (i = 0, l = properties.length; i < l; i++) {

                            property = properties[i];
                            vendorProperty = Element.getStyleName.call(element, property);
                            value = computedStyle[vendorProperty];

                            // Fallback on style value if current missing
                            if (
                                (value === '' || value === 'auto') &&
                                    !Element.isInjected.call(element, ownerDocument.documentElement)
                            ) {
                                value = style[vendorProperty];
                            }

                            // A tribute to the "awesome hack by Dean Edwards"
                            // WebKit (Safari not Chrome) uses "computed value (percentage if specified)" instead of "used value" for margins
                            // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values

                            if (badMarginPixel === undefined) {
                                detectBadMArginPixel();
                            }

                            if (badMarginPixel &&
                                    rmargin.test(vendorProperty) &&
                                        rnumnonpx.test(value)
                                    ) {
                                width = style.width;
                                style.width = value;
                                value = computedStyle.width;
                                style.width = width;
                            }

                            values[property] = value !== undefined ? value : (style[property] || '');
                        }
                    }

                    return values;
                };

            // Use current document for feature testings
            } else if (document.documentElement.currentStyle) {

                getComputedStyles = function (element, properties, values) {

                    var i, l, left, property, value, rsLeft, vendorProperty,
                        currentStyle = element.currentStyle,
                        runtimeStyle = element.runtimeStyle,
                        style = element.style;

                    // From the awesome hack by Dean Edwards
                    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

                    // If we're not dealing with a regular pixel number
                    // but a number that has a weird ending, we need to convert it to pixels
                    for (i = 0, l = properties.length; i < l; i++) {

                        property = properties[i];
                        vendorProperty = Element.getStyleName.call(element, property);
                        value = currentStyle && currentStyle[vendorProperty];

                        if (rnumnonpx.test(value)) {

                            // Remember the original values
                            left = style.left;
                            rsLeft = runtimeStyle && runtimeStyle.left;

                            // Put in the new values to get a computed value out
                            if (rsLeft) {
                                runtimeStyle.left = currentStyle.left;
                            }

                            style.left = vendorProperty === "fontSize" ? "1em" : (value || 0);
                            value = style.pixelLeft + "px";

                            // Revert the changed values
                            style.left = left;

                            if (rsLeft) {
                                runtimeStyle.left = rsLeft;
                            }
                        }

                        values[property] = value !== undefined ? value : (element.style[property] || '');
                    }

                    return values;
                };
            }

            function getStyles(element, properties, values) {

                var i, l, property,
                    style = element.style;

                for (i = 0, l = properties.length; i < l; i++) {
                    property = properties[i];
                    values[property] = style[property] || '';
                }

                return values;
            }

            return function (properties, computed) {

                var values = {},
                    element = this;

                if (
                    properties.indexOf('opacity') !== -1 &&
                        !opacitySemaphore
                ) {

                    // Add Semaphore because getOpacity use getStyle
                    // Then apply some logic.
                    opacitySemaphore = true;

                    values.opacity = Element.getOpacity.call(element, computed);

                    // Remove opacity from properties to avoid
                    // that getStyles also handle it.
                    properties.splice(properties.indexOf('opacity'), 1);

                    // Remove Semaphore
                    opacitySemaphore = false;
                }

                if (computed === false) {
                    values = getStyles(element, properties, values);
                } else {
                    values = getComputedStyles(element, properties, values);
                }

                return values;
            };
        }()),

        /**
         * Get CSS style  properties names for modern CSS3 property usage.
         * Perform feature detection on properties names, to add vendor prefix (e.g Moz, Ms, Webkit).
         *
         * Support vendor prefix for following CSS style property name:
         *    box-shadow, mask, box-shadow, mask, border-radius, user-select, box-sizing,
         *    transition, transition-timing-function, transition-duration, transition-delay,
         *    transition-property, transform, border-image, text-stroke, font-smoothing,
         *    text-fillcolor, appearance, text-shadow, transform-style, perspective, overflow-scrolling
         *
         * @method
         * @param String property: style property name.
         * @param Boolean noCamelCase: do not apply camelcase on results properties.
         * @returns {String} - the style name.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * myElement.getStyleName('border-radius');
         * // Will return "WebkitBorderRadius" on Webkit browsers
         * // Will return "OBorderRadius" on Opera browsers
         * // Will return "MozBorderRadius" on Firefox browsers
         * // Will return "MsBorderRadius"] on IE browsers
         *
         * myElement.getStyleName('float');
         * // Will return "cssFloat" on main engines
         * // Will return "styleFloat" on IE browsers
         */
        getStyleName: (function () {

            // Memoize serializer for getStyleName
            // that is faster than JSON.stringify default.
            function serializer(args) {
                return args.join('.');
            }

            var currentEngine = Client.Engine,
                currentEngineName = currentEngine.name,
                prefixedProperties = [
                    // box
                    'box-sizing', 'box-shadow',
                    // transform
                    'transform', 'transform-style',
                    'transition', 'transition-timing-function', 'transition-duration', 'transition-delay', 'transition-property',
                    // border
                    'border-image', 'border-radius',
                    // text
                    'text-stroke', 'font-smoothing', 'text-fillcolor', 'text-shadow',
                    // others
                    'perspective', 'appearance', 'touch-callout', 'overflow-scrolling', 'mask', 'user-select'
                ];

            return Utils.memoize(function (property, noCamelCase) {

                var vendorProperty, engineName, enginePreffix,
                    vendorProperties = [],
                    enginePreffixes = {
                        firefox: '-moz',
                        opera: '-o',
                        ie: (noCamelCase ? '-ms' : 'ms'), // Because "msTransform" and "-ms-transform"
                        chrome: '-webkit',
                        safari: '-webkit'
                    };

                // Only apply vendor prefix detection on string property
                if (typeof property === 'string') {

                    // Property in non camelCase
                    property = UWAString.unCamelCase(property);

                    // Handle float property
                    if (property === 'float') {

                        vendorProperty = currentEngine.ie ? 'style-float' : 'css-float';

                    // Handle prefixd properties
                    } else if (prefixedProperties.indexOf(property) !== -1) {

                        // Does not iterate on useless preffix if engine match
                        if (enginePreffixes[currentEngineName]) {

                            enginePreffix = enginePreffixes[currentEngineName];
                            vendorProperty = enginePreffix + '-' + property;

                            vendorProperties.push(vendorProperty);

                        // Else try all engines
                        } else {

                            for (engineName in enginePreffixes) {
                                if (enginePreffixes.hasOwnProperty(engineName)) {

                                    enginePreffix = enginePreffixes[engineName];
                                    vendorProperty = (enginePreffix + '-' + property);

                                    // Avoid duplicate
                                    if (vendorProperties.indexOf(vendorProperty) === -1) {
                                        vendorProperties.push(vendorProperty);
                                    }
                                }
                            }
                        }

                        // Filter property that are valid
                        vendorProperties = vendorProperties.filter(function (vp) {
                            return documentElement.style[UWAString.camelCase(vp)] !== undefined;
                        });

                        // Add standard property if empty
                        if (vendorProperties.length === 0) {
                            vendorProperty = property;
                        } else {
                            vendorProperty = vendorProperties.shift();
                        }

                    // Handle normal property
                    } else {
                        vendorProperty = property;
                    }

                    // Remove CamelCase from vendorProperties
                    if (!noCamelCase) {
                        vendorProperty = UWAString.camelCase(vendorProperty);
                    }

                // For non standard string property
                } else {
                    vendorProperty = property;
                }

                return vendorProperty;

            }, serializer);
        }()),

       /**
        * Get element's CSS style opacity value.
        *
        * @method
        * @param {Boolean} computed - retrieve opacity value computed by the browser (e.g default is true).
        * @return {Float} - the current element's CSS style opacity property value.
        */
        getOpacity: (function () {

            var getOpacityStyle = function () {},
                hasOpacity = Client.Features.opacityCSS,
                hasFilter = Client.Features.filterCSS,
                reAlpha = /alpha\(opacity=([\d.]+)\)/i;

            if (hasFilter && !hasOpacity) {

                getOpacityStyle = function (element, computed) {

                    var match,
                        opacity = 1;

                    match = Element.getStyle.call(element, 'filter', computed)
                        .replace(/ /g, '') // Support syntax with spaces
                        .match(reAlpha);   // Extract the opacity

                    if (match) {
                        opacity = match[1] / 100;
                    }

                    return opacity;
                };

            } else if (hasOpacity) {

                getOpacityStyle = function (element, computed) {

                    var opacity = 1,
                        style = element.style,
                        getStyle = Element.getStyle;

                    // Standart property
                    if (style.opacity !== undefined) {
                        opacity = getStyle.call(element, 'opacity', computed);

                    // Firefox old MozOpacity property
                    } else if (style.MozOpacity !== undefined) {
                        opacity = getStyle.call(element, 'MozOpacity', computed);
                    }

                    return parseFloat(Math.round(opacity * 100) / 100, 10);
                };
            }

            return function (computed) {
                return getOpacityStyle(this, computed);
            };
        }()),

        /**
         * Set element's CSS style opacity value.
         *
         * __Note__:
         *
         * Opacity 0 and visibily hidden have not the same behavior.
         *
         * @method
         * @param {Float} opacity - the requested element's CSS style opacity property new value.
         * @return {Element} - the current Element instance.
         */
        setOpacity: (function () {

            var setOpacityStyle = function () {},
                hasOpacity = Client.Features.opacityCSS,
                hasFilter = Client.Features.filterCSS;

            if (hasFilter && !hasOpacity) {

                setOpacityStyle = function (element, style, opacity) {

                    var originalDisplay;

                    // IE has trouble with opacity if it does not have layout
                    // Force it by setting the zoom level
                    style.zoom = 1;

                    // TODO(user): Overwriting the filter might have undesired side effects.
                    opacity = opacity === 1 ? '' : 'alpha(opacity=' + opacity * 100 + ')';

                    // see DXImageTransform.Microsoft.Alpha
                    //opacity = opacity === 1 ? '' : 'progid:DXImageTransform.Microsoft.Alpha( style=0,opacity=' + opacity * 100 + ');';

                    style.MsFilter = opacity;
                    style.filter = opacity;

                    // Redraw fix to avoid flickering
                    originalDisplay = style.display;
                    style.display = 'none';
                    // Required to trigger redraw
                    element.offsetHeight; // eslint-disable-line no-unused-expressions
                    style.display = originalDisplay; // or other value if required
                };

            } else if (hasOpacity) {

                setOpacityStyle = function (element, style, opacity) {

                    // Standart property
                    if (style.opacity !== undefined) {
                        style.opacity = opacity;

                    // Firefox old MozOpacity property
                    } else if (style.MozOpacity !== undefined) {
                        style.MozOpacity = opacity;
                    }
                };
            }

            return function (opacity) {

                var element = this,
                    style = element.style;
                if (opacity !== null) {
                    opacity = parseFloat(opacity, 10);
                    opacity = opacity > 1 ? 1 : (opacity < 0.00001 ? 0 : opacity);
                }

                setOpacityStyle(element, style, opacity);

                return element;
            };
        }()),

        /**
         * Hides and returns element, by setting "display" style property to "none".
         *
         * @return {Element} - the current Element instance.
         */
        hide: function () {
            return Element.setStyle.call(this, 'display', 'none');
        },

        /**
         * Reveal and return element, by setting "display" style property to right value.
         *
         * __Note__:
         *
         * The element will be revealed immediately, with no animation.
         * This is roughly equivalent to calling element.setStyle('display', 'block'),
         * except that the display property is restored to whatever it was initially.
         *
         * @method
         * @returns {Element} - the current Element instance.
         */
        show: (function () {

            var iframe, iframeDoc, getDefaultDisplayStyle;

            function getDisplayStyle(element) {
                return Element.getStyle.call(element, 'display');
            }

            // This function results is cached using memoize
            getDefaultDisplayStyle = Utils.memoize(function (nodeName) {

                var display,
                    doc = document,
                    body = doc.body,
                    element = doc.createElement(nodeName);

                body.appendChild(element);
                display = getDisplayStyle(element);
                body.removeChild(element);

                // If the simple way fails,
                // get element's real default display by attaching it to a temp iframe
                if (display === 'none' || display === '') {

                    // No iframe to use yet, so create it
                    if (!iframe) {
                        iframe = doc.createElement('iframe');
                        iframe.frameBorder = iframe.width = iframe.height = 0;
                    }

                    body.appendChild(iframe);

                    // Create a cacheable copy of the iframe document on first call.
                    // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                    // document to it; WebKit & Firefox won't allow reusing the iframe document.
                    if (!iframeDoc || !iframe.createElement) {
                        iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                        iframeDoc.write((doc.compatMode === 'CSS1Compat' ? '<!doctype html>' : '') + '<html><body>');
                        iframeDoc.close();
                    }

                    element = iframeDoc.createElement(nodeName);

                    iframeDoc.body.appendChild(element);
                    display = getDisplayStyle(element);
                    body.removeChild(iframe);
                }

                return display;

            });

            return function () {

                var display,
                    element = this;

                if (element.style) {

                    display = element.style.display;

                    // Reset the inline display of this element to learn if it is
                    // being hidden by cascaded rules or not
                    if (display === 'none') {
                        display = element.style.display = '';
                    }

                    // Set elements which have been overridden with display: none
                    // in a stylesheet to whatever the default browser style is
                    // for such an element
                    if (display === '') {
                        element.style.display = (getDisplayStyle(element) === 'none' && getDefaultDisplayStyle(element.nodeName)) || '';
                    }
                }

                return element;
            };
        }()),

        /**
         * Toggles the visibility of element.
         *
         * @param {Boolean} force - force show (if true) or hide the element.
         * @return {Element} - the current Element instance.
         */
        toggle: function (force) {

            var element = this,
                show = UWA.is(force) ? force : Element.isHidden.call(element);

            return UWA.Element[show ? 'show' : 'hide'].call(element);
        },

        /**
         * Check wether this element is hidden by UWA.Element.hide.
         * @return {Boolean}
         */
        isHidden: function () {
            return Element.getStyle.call(this, 'display') === 'none';
        },

        /**
         * Translate the position of element to X and Y parameters.
         *
         * __Note__:
         *
         * Translate element Using translate3d/translate or top/left depending
         * the current DOM available feature.
         *
         * @method
         * @param {Number} y - new y/top coordonate.
         * @param {Number} x - new x/left coordonate.
         * @return {Element} - the current Element instance.
         */
        setTranslate: (function () {

            var getTranslateStyles = (function () {

                var getStyles;

                // Using translate
                if (Client.Features.transitionsCSS) {

                    // TODO Required ?
                    // styles.transformOrigin = '0 0';
                    // styles.transform = 'translateZ(0)';
                    // styles.perspective = '800';
                    // styles.fontSmoothing = 'antialiased';
                    // styles.transformStyle = 'preserve-3d';

                    // Using translate3d
                    if (Client.Features.matrixCSS) {

                        getStyles = function (y, x) {
                            return {
                                transform: 'translate3d(' + x + 'px,' + y + 'px, 0)'
                            };
                        };

                    } else {

                        getStyles = function (y, x) {
                            return {
                                transform: 'translate(' + x + 'px,' + y + 'px)'
                            };
                        };
                    }

                // Default
                } else {

                    getStyles = function (y, x) {
                        return {
                            top: y,
                            left: x
                        };
                    };
                }

                return getStyles;

            }());

            return function (y, x) {

                var styles,
                    element = this;

                y = y || 0;
                x = x || 0;

                styles = getTranslateStyles(y, x);
                Element.setStyles.call(element, styles);

                return element;
            };

        }()),

        /**
         * Compute the size of a list of style properties
         *
         * @method
         * @param {String} arguments - some CSS properties.
         * @peturns {Integer} - the sum of sizes.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     styles: {
         *         border: '1px solid red',
         *         padding: '2px'
         *     }
         * });
         *
         * myElement.getComputedSize('borderLeftWidth', 'paddingLeft');
         * // Will return 3
         *
         * myElement.getComputedSize('borderWidth');
         * // Will return 2
         */
        getComputedSize: (function () {

            var alias = {
                borderWidth: ['borderLeftWidth', 'borderRightWidth'],
                borderHeight: ['borderBottomWidth', 'borderTopWidth'],
                paddingWidth: ['paddingLeft', 'paddingRight'],
                paddingHeight: ['paddingTop', 'paddingBottom'],
                marginWidth: ['marginLeft', 'marginRight'],
                marginHeight: ['marginTop', 'marginBottom'],
                innerWidth: ['borderWidth', 'paddingWidth'],
                innerHeight: ['borderHeight', 'paddingHeight'],
                outerWidth: ['marginWidth'],
                outerHeight: ['marginHeight']
            };

            return function () {

                var i, l, property, values,
                    element = this,
                    properties = Utils.toArray(arguments),
                    result = 0;

                for (i = 0; i < properties.length; i++) {

                    property = UWAString.camelCase(properties[i]);

                    // Replace by alias
                    if (alias[property]) {
                        properties.splice(i, 1);
                        properties = properties.concat(alias[property]);

                        // Recheck in case of sub alias
                        i--;

                    // Force camelCase
                    } else {
                        properties.splice(i, 1, property);
                    }
                }

                values = Element.getStyles.call(element, properties);
                for (i = 0, l = properties.length; i < l; i++) {
                    property = properties[i];
                    result += parseFloat(values[property], 10) || 0;
                }

                return result;
            };
        }()),

        /**
         * Returns either the width and height in pixels of the content of an
         * element or the width and height of the element itself, whichever is
         * greater.
         *
         * @see http://dev.w3.org/csswg/cssom-view/#element-scrolling-members
         *
         * @method
         * @return {Object} - Object with "with, "height", "top, "left" properties.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Get Scrolls values
         * var myScrolls = myElement.getScrolls();
         *
         * // myOffsets Object value (properties values depending the context)
         * {
         *     with: 417,
         *     height 53,
         *     top: 0,
         *     left 0
         * }
         */
        getScrolls: (function () {

            var badScrollWidth;

            // Use current document for feature testings
            function detectbadScrollWidth() {

                var innerEl = document.createElement('div'),
                    outerEl = document.createElement('div');

                // Style
                outerEl.style.visibility = 'hidden';
                outerEl.style.overflow = 'hidden';
                outerEl.style.width = '1px';
                innerEl.style.overflow = 'visible';

                // Content
                innerEl.innerHTML = 'x';

                // Inject
                outerEl.appendChild(innerEl);
                documentElement.appendChild(outerEl);

                // Test
                badScrollWidth = innerEl.scrollWidth === 1;

                // Clean
                documentElement.removeChild(outerEl);
            }

            return function () {

                var originalOverflow, scrolls, style,
                    element = this;

                // Use Client.getScrolls if element is window or document
                if (UWA.is(element, ['window', 'document'])) {

                    scrolls = Client.getScrolls();
                } else {

                    style = element.style;
                    scrolls = {
                        width: element.scrollWidth,
                        height: element.scrollHeight,
                        top: element.scrollTop,
                        left: element.scrollLeft
                    };

                    // Execute test only on first call
                    if (badScrollWidth === undefined) {
                        detectbadScrollWidth();
                    }

                    // Fix overflow visible bad scrollWidth value
                    if (
                        badScrollWidth &&
                            ['', 'visible'].indexOf(Element.getStyle.call(element, 'overflow')) !== -1
                    ) {

                        originalOverflow = style.overflow;
                        style.overflow = 'hidden';
                        scrolls.width = element.scrollWidth;
                        style.overflow = originalOverflow;
                    }
                }

                return scrolls;
            };
        }()),

        /**
         * Gets the cumulative offsets of the x and y positions (or the cumulative top and left) of element,
         * the position of the element will be relative to the document.
         *
         * This function is helpful if you want to position things around a certain element.
         *
         * @see http://www.w3.org/TR/cssom-view/#offset-attributes
         *
         * @method
         * @return {Object} - Object with "y" and "x" properties.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Get Offsets values
         * var myOffsets = myElement.getOffsets();
         *
         * // myOffsets Object value (properties values depending the context)
         * {
         *     x: 417,
         *     y 53
         * }
         */
        getOffsets: (function () {

            var getOffsets,
                rtable = /^t(?:able|d|h)$/i,
                doesNotAddBorder,
                doesAddBorderForTableAndCells,
                supportsFixedPosition,
                subtractsBorderForOverflowNotVisible,
                doesNotIncludeMarginInBodyOffset;

            function getComputedStyle(element) {
                var defaultView = element.ownerDocument.defaultView;
                return defaultView ? defaultView.getComputedStyle(element, null) : element.currentStyle;
            }

            function getStyle(element, style) {
                return Element.getStyle.call(element, style);
            }

            // Use current document for feature testings
            function testsOffsets() {

                var innerDiv, checkDiv, checkTd,
                    documentBody = document.body,
                    docBodyMarginTop = parseInt(getStyle(documentBody, 'marginTop'), 10),
                    outerDiv = document.createElement('div'),
                    html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div>" +
                    "<table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

                outerDiv.innerHTML = html;
                documentBody.insertBefore(outerDiv, documentBody.firstChild);
                innerDiv = outerDiv.firstChild;
                checkDiv = innerDiv.firstChild;
                checkTd = innerDiv.nextSibling.firstChild.firstChild;

                // Bugs status update
                doesNotAddBorder = (checkDiv.offsetTop !== 5);
                doesAddBorderForTableAndCells = (checkTd.offsetTop === 5);

                // Update tests elements
                checkDiv.style.position = 'fixed';
                checkDiv.style.top = '20px';

                // safari subtracts parent border width here which is 5px
                supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);

                // Update tests elements
                checkDiv.style.position = checkDiv.style.top = '';
                innerDiv.style.overflow = 'hidden';
                innerDiv.style.position = 'relative';

                subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);
                doesNotIncludeMarginInBodyOffset = (documentBody.offsetTop !== docBodyMarginTop);

                documentBody.removeChild(outerDiv);
            }

            function bodyOffsets(body) {

                var y = body.offsetTop,
                    x = body.offsetLeft;

                // Execute test only on first call
                if (doesNotAddBorder === undefined) {
                    testsOffsets();
                }

                if (doesNotIncludeMarginInBodyOffset) {
                    y += parseFloat(getStyle(body, 'marginTop')) || 0;
                    x += parseFloat(getStyle(body, 'marginLeft')) || 0;
                }

                return {
                    x: x,
                    y: y
                };
            }

            // Use current document for feature testings
            if (document.documentElement.getBoundingClientRect !== undefined) {

                getOffsets = function () {

                    // Use offsets special body
                    if (this === this.ownerDocument.body) {
                        return bodyOffsets(this);
                    }

                    var x, y, bound,
                        document, documentBody,
                        clientTop, clientLeft, docScrolls,
                        element = this,
                        window = Element.getWindow.call(element),
                        convertPoint = window.webkitConvertPointFromNodeToPage;

                    if (element.getBoundingClientRect) {

                        document = Element.getDocument.call(element);
                        documentBody = document.body;
                        clientTop = documentElement.clientTop || documentBody.clientTop || 0;
                        clientLeft = documentElement.clientLeft || documentBody.clientLeft || 0;
                        docScrolls = Client.getScrolls();

                        try {
                            bound = element.getBoundingClientRect();
                        } catch (e) {
                            // fallback to 0, 0
                        }

                        if (!bound || !Element.isInjected.call(element, documentElement)) {
                            x = bound ? bound.left : 0;
                            y = bound ? bound.top : 0;

                        } else {
                            x = bound.left + docScrolls.x - clientTop;
                            y = bound.top + docScrolls.y - clientLeft;
                        }

                    // Fallback on webkitConvertPointFromNodeToPage usage,
                    // if getBoundingClientRect is missing (iOS <=3 )
                    } else if (convertPoint) {

                        bound = convertPoint(element, new window.WebKitPoint(0, 0));

                        x = bound.x;
                        y = bound.y;
                    }

                    return {
                        x: x,
                        y: y
                    };
                };

            } else {

                getOffsets = function () {

                    // Use offsets special body
                    if (this === this.ownerDocument.body) {
                        return bodyOffsets(this);
                    }

                    var computedStyle,
                        element = this,
                        offsetParent = element.offsetParent,
                        document = Element.getDocument.call(element),
                        documentBody = document.body,
                        prevComputedStyle = getComputedStyle(element),
                        y = element.offsetTop,
                        x = element.offsetLeft;

                    // Execute test only on first call
                    if (doesNotAddBorder === undefined) {
                        testsOffsets();
                    }

                    element = element.parentNode;
                    while (
                        element &&
                            element !== documentBody &&
                                element !== documentElement &&
                                    element.nodeType !== 11
                    ) {

                        if (
                            supportsFixedPosition &&
                                prevComputedStyle.position === 'fixed'
                        ) {
                            break;
                        }

                        computedStyle = getComputedStyle(element);
                        x -= element.scrollLeft;
                        y -= element.scrollTop;

                        if (element === offsetParent) {

                            x += element.offsetLeft;
                            y += element.offsetTop;

                            if (doesNotAddBorder && !(doesAddBorderForTableAndCells && rtable.test(element.nodeName))) {
                                x += parseFloat(computedStyle.borderLeftWidth) || 0;
                                y += parseFloat(computedStyle.borderTopWidth) || 0;
                            }

                            offsetParent = element.offsetParent;
                        }

                        if (subtractsBorderForOverflowNotVisible && computedStyle.overflow !== 'visible') {
                            x += parseFloat(computedStyle.borderLeftWidth) || 0;
                            y += parseFloat(computedStyle.borderTopWidth) || 0;
                        }

                        prevComputedStyle = computedStyle;
                        element = element.parentNode;
                    }

                    if (prevComputedStyle.position === 'relative' || prevComputedStyle.position === 'static') {
                        x += documentBody.offsetLeft;
                        y += documentBody.offsetTop;
                    }

                    if (supportsFixedPosition && prevComputedStyle.position === 'fixed') {
                        x += Math.max(documentElement.scrollLeft, documentBody.scrollLeft);
                        y += Math.max(documentElement.scrollTop, documentBody.scrollTop);
                    }

                    return {
                        x: x,
                        y: y
                    };
                };
            }

            return getOffsets;
        }()),

        /**
         * Gets the cumulative offsets of the x and y positions (or the cumulative top and left) of element,
         * by default the position of the element will be relative to the offsetParent (see <getOffsetParent>).
         *
         * This function is helpful if you want to position things around a certain element.
         *
         * @param {Element} relative - (optional) the position of the element will be relative.
         *  If Element, get the position relative to this esement.
         *  If false, get the position relative to the offsetParent (see <getOffsetParent>).
         *
         * @param {String/Object} where - (optional) set the origin of the position.
         *  You can specify a corner (ex: { x: 'top', y: 'left' }), or the
         *  center of a side (ex: {x: 'center', y: 'top'} or simply
         *  'center' for the center of the box.
         *
         * @return {Object} - Object with "y" and "x" properties (e.g  {x: Number, y: Number}).
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Get Position values
         * var myPosition = myElement.getPosition();
         *
         * // myPosition Object value (properties values depending the context)
         * {
         *     x: 7,
         *     y 170
         * }
         */
        getPosition: function (relative, where) {

            var parentOffset, size, i, axis, dimension, whereType, position,
                rroot = /^(?:body|html)$/i,
                element = this,
                getOffsetParent = Element.getOffsetParent,
                getOffsets = Element.getOffsets,
                getComputedSize = Element.getComputedSize,
                getSize = Element.getSize,
                isInjected = Element.isInjected,
                emptyPosition = {
                    x: 0,
                    y: 0
                };

            relative = relative || getOffsetParent.call(element);

            // Support for non injected element
            if (!relative || !isInjected.call(element)) {
                return emptyPosition;
            }

            position = getOffsets.call(element);

            // Support old element.getPosition(document) usage
            if (relative !== Element.getDocument.call(element)) {

                parentOffset = rroot.test(relative.nodeName) ? emptyPosition : getOffsets.call(relative);

                // Subtract element margins
                // note: when an element has margin: auto the offsetLeft and marginLeft
                // are the same in Safari causing offset.left to incorrectly be 0
                position.x -= parseFloat(getComputedSize.call(element, 'marginLeft')) || 0;
                position.y -= parseFloat(getComputedSize.call(element, 'marginTop')) || 0;

                // Add offsetParent borders
                parentOffset.x += parseFloat(getComputedSize.call(relative, 'borderLeftWidth')) || 0;
                parentOffset.y += parseFloat(getComputedSize.call(relative, 'borderTopWidth')) || 0;

                // Subtract the two offsets
                position.x -= parentOffset.x;
                position.y -= parentOffset.y;

                // Add the current position where offset to position
                whereType = UWA.typeOf(where);
                if (whereType) {

                    // String where support
                    if (whereType === 'string') {
                        where = {
                            x: where,
                            y: where
                        };
                    }

                    // Get the current size of the element
                    size = getSize.call(element);

                    for (i = 0; i < 2; i += 1) {

                        axis = i ? 'x' : 'y';
                        dimension = i ? 'width' : 'height';

                        if (where[axis] === 'center') {
                            position[axis] += size[dimension] / 2;
                        } else if (
                            (i === 1 && where[axis] === 'right') ||
                                (i === 0 && where[axis] === 'bottom')
                        ) {
                            position[axis] += size[dimension];
                        }
                    }
                }
            }

            return position;
        },

        /**
         * Sets the position of an Element
         *
         * @method
         * @param {Object/Array} position - an object or a list of object with the
         *   properties 'x' and 'y' representing the coordinates of the
         *   element. If this is an array and there is a boundary specified
         *   (see options parameter), it will pick the best position to fit
         *   the element in the boundary.
         *
         * @param {Object} options - a JavaScript object containing setting/value pairs.
         * @param {Element} [options.relative] - An Element to which position values will be relative to (default to first relative parent).
         * @param {Object|Element|String} [options.boundary] - Limit the position to a given zone. It can be:
         *  - an object {x, y, width, height} with coordinates relative to the relative option,
         *  - an Element
         *  - auto' will use the first parent with a overflow hidden or auto
         * @param {Element} [options.boudaryMargin] - An Element to which position values will be relative to (default to first relative parent).
         * @param {String|Function} [options.fit] - If a boundary is used, specify the strategy to use in order
         *  to fit the element into the boundary.
         *  - 'full' (default): adjust the final position to fit the whole element in the boundary
         *  - 'none': do not try to fit the element in the boundary (only the top left corner will
         *  have to be in the boundary).
         *  - 'resize-max': adjuste the max-width and max-height styles of the element in order
         *  to fit in the element.
         *  - a function: the function will be called with two parameters: one representing the
         *  boundary with its position (x/y) and its size (width/height), the second will be the
         *  position of the element (x/y). The context (this) is the current element.
         *  Coordinates are absolute in the page. You can change those objects in order to
         *  implement a custom behaviour to fit the element inside its boundary (for example, if
         *  the element does not fit below another element, you can change its position to
         *  display it above). See example below.
         *
         * @returns {Element} - The current Element instance
         *
         * @example
         * // Simple usage
         * myElement.setPosition({x: 10, y: 20}, {
         *     relative: document.body,
         *     boundary: 'auto',
         *     boundaryMargin: 4
         * });
         *
         * // Advanced usage
         * myElement.setPosition({x: 10, y: 20}, {
         *     relative: document.body,
         *     boundary: 'auto',
         *     fit: function (boundary, position) {
         *         var elSize = Element.getSize.call(this).height,
         *
         *             // Compute the free space on each direction
         *             hasSpaceAbove = position.y - boundary.y >= elSize,
         *             hasSpaceBelow = boundary.y + boundary.height - position.y >= elSize;
         *
         *         if (!hasSpaceBelow && hasSpaceAbove) {
         *             // If there is no space below and some space above, go above
         *             position.y -= elSize;
         *         }
         *     }
         * });
         */
        setPosition: (function () {

            function getParentBoundary(el, body, relativeOffset, boundary, margin) {

                var element, result;

                switch (UWA.typeOf(boundary)) {

                case false:
                    break;

                case 'object':
                    result = {
                        x: boundary.x + relativeOffset.x,
                        y: boundary.y + relativeOffset.y,
                        width: boundary.width,
                        height: boundary.height
                    };
                    break;

                case 'element':
                    element = boundary;
                    break;

                default: // case 'string' (boundary == 'auto')
                    element = Element.getOffsetParent.call(el);

                    // The first overflown element "closest" to the first positionned parent
                    while (element && element !== body && element.nodeType === 1) {

                        if (Element.getStyle.call(element, 'overflow') !== 'visible') {
                            break;
                        }

                        element = element.parentNode;
                    }

                    if (!element || element.nodeType !== 1) {
                        element = body;
                    }
                }

                if (element) {
                    if (element === body) {
                        result = UWA.merge(Client.getScrolls(), Client.getSize());
                    } else {
                        result = Element.getOffsets.call(element);
                        result.width = element.offsetWidth;
                        result.height = element.offsetHeight;
                    }
                }

                // Handle margin
                if (result) {
                    result.x += margin;
                    result.y += margin;
                    result.width -= 2 * margin;
                    result.height -= 2 * margin;
                }

                return result;
            }

            var fitStrategies = {
                full: function (boundarySize, position) {
                    var elSize = Element.getSize.call(this);
                    var spaceLeft = boundarySize.x + boundarySize.width - position.x - elSize.width;
                    var spaceBottom = boundarySize.y + boundarySize.height - position.y - elSize.height;
                    if (spaceLeft < 0) {
                        position.x = Math.max(0, position.x + spaceLeft);
                    }
                    if (spaceBottom < 0) {
                        position.y += spaceBottom;
                    }
                },
                'resize-max': function (boundarySize, position) {
                    Element.setStyles.call(this, {
                        maxWidth: boundarySize.x + boundarySize.width - position.x,
                        maxHeight: boundarySize.y + boundarySize.height - position.y
                    });
                },
                none: function () {}
            };

            return function (position, options) {
                options = options || {};

                var boundarySize, size,
                    element = this,
                    body = Element.getDocument.call(element).body,
                    offsetParent = Element.getOffsetParent.call(element) || body,
                    offsetParentOffsets = Element.getOffsets.call(offsetParent),
                    relativeOffset = Element.getOffsets.call(options.relative || offsetParent);

                boundarySize = getParentBoundary(
                    element,
                    body,
                    relativeOffset,
                    options.boundary,
                    options.boundaryMargin || 0
                );

                if (typeof position.length === 'number') {
                    size = Element.getSize.call(element);
                    Utils.splat(position).forEach(function (p) {
                        var x = relativeOffset.x + p.x,
                            y = relativeOffset.y + p.y;
                        p.score =
                                (Math.min(boundarySize.x + boundarySize.width, x + size.width) - Math.max(boundarySize.x, x)) *
                                (Math.min(boundarySize.y + boundarySize.height, y + size.height) - Math.max(boundarySize.y, y));
                    });
                    position.sort(function (a, b) {
                        return b.score - a.score;
                    });
                    position = position[0];
                }

                position = {
                    x: position.x + relativeOffset.x,
                    y: position.y + relativeOffset.y
                };

                if (boundarySize) {

                    // fit strategy
                    if (!options.fit) {
                        // Default to full
                        options.fit = fitStrategies.full;
                    } else if (typeof options.fit === 'string' && UWA.owns(fitStrategies, options.fit)) {
                        // Named strategy
                        options.fit = fitStrategies[options.fit];
                    }

                    position.x = Math.max(
                        boundarySize.x,
                        Math.min(position.x, boundarySize.x + boundarySize.width)
                    );

                    position.y = Math.max(
                        boundarySize.y,
                        Math.min(position.y, boundarySize.y + boundarySize.height)
                    );

                    options.fit.call(this, boundarySize, position);
                }

                // set final position
                Element.setStyles.call(element, {
                    top: position.y - offsetParentOffsets.y,
                    left: position.x - offsetParentOffsets.x
                });

                return element;
            };

        }()),

        /**
         * Retreive the height and width of an element relative to the element's offsetParent.
         *
         * __Notes__:
         *
         * The width and height size is based on offset(Width|Height) that mean
         * that it include border and padding edge (W3C Content edge).
         *
         * To get the inner size (with no border and padding edge), use <getDimensions> innerWidth or innerHeight.
         * To get the outer size (with margin edge), use <getDimensions> outerWidth or outerHeight.
         *
         * @see http://www.w3.org/TR/cssom-view/#offset-attributes
         *
         * @return {Object} - Object with "with and "height" properties.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     styles: {
         *         height: '100px',
         *         width: '100px',
         *         padding: '10px',
         *         margin: '7px',
         *         border: '2px solid red'
         *     }
         * }).inject(widget.body);
         *
         * // Get Size values
         * var mySize = myElement.getSize();
         *
         * // mySize Object value
         * {
         *     height: 124, // innerHeight + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth
         *     width: 124 // innerWidth + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth
         * }
         */
        getSize: function () {

            var originalVisibility, originalDisplay, style, width, height, getStyle, size,
                element = this;

            // Use Client.getSize if window or document element
            if (UWA.is(element, ['window', 'document'])) {

                size = Client.getSize();

            } else {

                getStyle = Element.getStyle.bind(element);
                style = element.style;
                width = element.offsetWidth;
                height = element.offsetHeight;

                // All width and height properties return 0 on elements with display:none,
                // display the element temporary then restore previous state
                if (
                    getStyle('display') === 'none' &&
                        width === 0 && height === 0
                ) {

                    originalDisplay = style.display;
                    originalVisibility = style.visibility;

                    style.visibility = 'visible';
                    style.display = 'block';

                    width = element.offsetWidth;
                    height = element.offsetHeight;

                    style.display = originalDisplay;
                    style.visibility = originalVisibility;
                }

                size = {
                    width: width,
                    height: height
                };
            }

            return size;
        },

        /**
         * Finds the computed dimensions of an element and returns them as key/value pairs of an object.
         *
         * __Notes__:
         *
         * If you consider only get the with and height properties use <UWA.Element.getSize> method it's faster.
         *
         * @return {Object} - Object with "with and "height", "innerWidth" and "innerHeight",
         *   "outerWidth" and "outerHeight", "maxWidth" and "maxHeight" properties.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div', {
         *     styles: {
         *         padding: '10px',
         *         margin: '5px',
         *         height: '100px',
         *         width: '100px',
         *         border: '2px solid red'
         *     }
         * }).inject(widget.body);
         *
         * // Get Dimensions values
         * var myDimensions = myElement.getDimensions();
         *
         * // myDimensions Object value
         * {
         *     height: 124,        // based on offsetHeight
         *     width: 124          // based on offsetWidth
         *     innerHeight: 100,   // height - (paddingTop + paddingBottom + borderTopWidth + borderBottomWidth)
         *     innerWidth: 100     // width - (paddingLeft + paddingRight + borderLeftWidth + borderRightWidth)
         *     outerHeight: 134,   // height + marginTop + marginBottom
         *     outerWidth: 134     // width + marginLeft + marginRight
         * }
         */
        getDimensions: function () {

            var style,
                element = this,

                // Alias
                size = Element.getSize.call(element),
                width = size.width,
                height = size.height,

                // Dimensions
                styles = Element.getStyles.call(element, [
                    'maxWidth',
                    'maxHeight',
                    'minWidth',
                    'minHeight',
                    // borderWidth
                    'borderLeftWidth', 'borderRightWidth',
                    // paddingWidth
                    'paddingLeft', 'paddingRight',
                    // borderHeight
                    'borderBottomWidth', 'borderTopWidth',
                    // paddingHeight
                    'paddingTop', 'paddingBottom',
                    // marginWidth
                    'marginLeft', 'marginRight',
                    // marginHeight
                    'marginTop', 'marginBottom'
                ]);

            // Cast to float (e.g from 5.5px to 5.5)
            for (style in styles) {
                styles[style] = parseFloat(styles[style], 10) || 0;
            }

            return {
                width: width,
                height: height,
                maxWidth: styles.maxWidth || -1,
                maxHeight: styles.maxHeight || -1,
                minWidth: styles.minWidth || -1,
                minHeight: styles.minHeight || -1,
                innerWidth: width - (styles.borderLeftWidth + styles.borderRightWidth + styles.paddingLeft + styles.paddingRight),
                innerHeight: height - (styles.borderBottomWidth + styles.borderTopWidth + styles.paddingTop + styles.paddingBottom),
                outerWidth: width + styles.marginLeft + styles.marginRight,
                outerHeight: height + styles.marginTop + styles.marginBottom
            };
        },

        /**
         * Check if an element is visible in the current element viewport and on the screen.
         * By default it's check that the element is entirely visible.
         *
         * @param {Element} element - the element to check visibility.
         * @param {Boolean} partially - if any part of the element is visible in the
         *   viewport or only entirely visible (default: false).
         * @param {Boolean} checkForDisplay - if the element is in the screen
         *   and visible (in a human way) (default: false).
         * @param {String} axis - optionnal specific axis to check ('x' or 'y') (default: both).
         * @return {Boolean} - true if the element is in the current element viewport else false.
         *
         * @example
         * // Your existing elements
         * var myFirstElement = UWA.createElement('div', {
         *         styles: {
         *             position: 'absolute',
         *             top: '5px',
         *             left: '0px',
         *             width: '10px',
         *             height: '10px',
         *             background: 'red'
         *         }
         *     }),
         *     mySecondElement = UWA.createElement('div', {
         *         styles: {
         *             position: 'absolute',
         *             top: '5px',
         *             left: '0px',
         *             width: '10px',
         *             height: '10px',
         *             background: 'blue'
         *         }
         *     });
         *
         * // Inject elements
         * myFirstElement.inject(widget.body);
         * mySecondElement.inject(widget.body);
         *
         * // Check if myFirstElement is in the mySecondElement viewport
         * myFirstElement.isInViewport(mySecondElement);
         * // Will return true
         *
         * // Move myFirstElement element
         * myFirstElement.setStyle('top', '10px');
         *
         * // Check if myFirstElement is in the mySecondElement viewport
         * myFirstElement.isInViewport(mySecondElement);
         * // Will return false
         *
         * // Check if myFirstElement is partially in the mySecondElement viewport
         * myFirstElement.isInViewport(mySecondElement, true);
         * // Will return true
         *
         * // Check if myFirstElement is in the mySecondElement viewport, and is visible in the page
         * myFirstElement.isInViewport(mySecondElement, false, true);
         */
        isInViewport: function (viewport, partially, checkForDisplay, axis) {

            var element = this,

                // Alias
                getOffsets = Element.getOffsets,

                // Positions
                viewportPosition = getOffsets.call(viewport),
                elementPosition = getOffsets.call(element),

                // Dimensions
                viewportHeight = viewport.offsetHeight,
                viewportWidth = viewport.offsetWidth,
                width = element.offsetWidth,
                height = element.offsetHeight,
                top = elementPosition.y,
                left = elementPosition.x,
                bottom = top + element.offsetHeight,
                right = left + element.offsetWidth,
                scrolls,
                client,
                windowBoundaries,
                visibilityX,
                visibilityY,

                // tests
                isInViewport;

            if (partially) {
                visibilityX = left < (viewportPosition.x + viewportWidth) &&
                    (left + width) > viewportPosition.x;

                visibilityY = top < (viewportPosition.y + viewportHeight) &&
                    (top + height) > viewportPosition.y;
            } else {
                visibilityX = left >= viewportPosition.x &&
                    (left + width) <= (viewportPosition.x + viewportWidth);

                visibilityY = top >= viewportPosition.y &&
                    (top + height) <= (viewportPosition.y + viewportHeight);
            }

            isInViewport = (axis === 'x') ?
                    visibilityX : (axis === 'y') ?
                        visibilityY : visibilityX && visibilityY;

            if (checkForDisplay) {

                scrolls = Client.getScrolls();
                client = Client.getSize();
                windowBoundaries = {
                    top: scrolls.y,
                    bottom: scrolls.y + client.height,
                    right: scrolls.x + client.width,
                    left: scrolls.x
                };

                isInViewport = isInViewport && (
                    top < windowBoundaries.bottom &&
                    left < windowBoundaries.right &&
                    bottom > windowBoundaries.top &&
                    right > windowBoundaries.left
                );
            }

            return isInViewport;
        },

        /**
         * Store arbitrary data associated with the current element.
         * The data value will be serialized in JSON.
         *
         * ##### Example
         *
         * ```
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Store data into element
         * myElement.setData('myStringKey', 'myString');
         * myElement.setData('myObjectKey', {
         *     name: 'Bob',
         *     age: '25'
         * });
         * ```
         *
         * Will rendering
         * ```html
         * <div data-my-string-key="&quot;myString&quot;"
         *      data-my-object-key="{&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:&quot;25&quot;}">
         * </div>
         * ```
         *
         * @param {String} key - the data key name.
         * @param {String} data - the data key value.
         * @return {Element} - the current Element instance.
         */
        setData: function (key, data) {

            var subKey,
                element = this,
                dataType = UWA.typeOf(data),
                keyType = UWA.typeOf(key);

            if (keyType === 'string' && dataType) {

                data = Json.encode(data);

                if (element.dataset) {
                    element.dataset[UWAString.camelCase(key)] = data;
                } else {

                    key = 'data-' + UWAString.unCamelCase(key);

                    if (element.setAttribute) {
                        element.setAttribute(key, data);

                    // For old browser support
                    } else {
                        element[key] = data;
                    }
                }

            } else if (keyType === 'object' && !dataType) {
                for (subKey in key) {
                    if (key.hasOwnProperty(subKey)) {
                        Element.setData.call(element, subKey, key[subKey]);
                    }
                }
            }

            return element;
        },

        /**
         * Retrieve arbitrary data associated with the current element.
         *
         * @param {String} key - the data key name.
         * @return {Element} the data key value.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Store data into element
         * myElement.setData('myStringKey', 'myString');
         * myElement.setData('myObjectKey', {
         *     name: 'Bob',
         *     age: '25'
         * });
         *
         * // Retrieve data
         * myElement.getData('myStringKey');
         * // Will return "myString"
         *
         * myElement.getData('myObjectKey');
         * // Will return Object
         */
        getData: function (key) {

            var data,
                element = this;

            if (UWA.is(key, 'string')) {

                if (element.dataset) {
                    data = element.dataset[UWAString.camelCase(key)];
                } else {

                    key = 'data-' + UWAString.unCamelCase(key);

                    if (element.getAttribute) {
                        data = element.getAttribute(key, data);

                    // For old browser support
                    } else {
                        data = element[key] = data;
                    }
                }
            }

            return UWA.is(data) ? Json.decode(data) : undefined;
        },

        /**
         * Remove arbitrary data associated with the current element.
         *
         * @param {String} key - the data key name.
         * @return {Element} - the data key value.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('div');
         *
         * // Store data into element
         * myElement.setData('myStringKey', 'myString');
         *
         * // Remove data
         * myElement.removeData('myStringKey');
         *
         * // Retrieve data
         * myElement.getData('myStringKey');
         * // Will return undefined
         */
        removeData: function (key) {

            var element = this;

            if (UWA.is(key, 'string')) {

                if (element.dataset) {
                    if (element.dataset.hasOwnProperty(UWAString.camelCase(key))) {
                        delete element.dataset[UWAString.camelCase(key)];
                    }
                } else {

                    key = 'data-' + UWAString.unCamelCase(key);

                    if (element.removeAttribute) {
                        element.removeAttribute(key);

                    // For old browser support
                    } else {
                        element[key] = null;
                    }
                }
            }

            return element;
        },

        /**
         * Handle any children's external links element click events with a
         * callback function.
         *
         * __Notes__: For advanced and internal library usage only.
         *
         * @param {Function} listener: click callback function that will receive
         * url for argument.
         * @return {Element} - the current Element instance.
         */
        handleExternalLinks: function (listener) {

            var element = this;

            Element.addEvent.call(element, 'click', function (event) {

                // preventDefault has not been called
                if (!Event.isDefaultPrevented(event) && !Event.whichKey(event)) {

                    var href,
                        link = Event.getElement(event),
                        currentLocation = String(window.location).split('#')[0];

                    // Find first href in parent nodes
                    while (link && !href) {
                        href = (Element.getTagName.call(link) === 'a' &&
                                    link.getAttribute('href')) || Element.getData.call(link, 'href');

                        link = Element.getParent.call(link);
                    }

                    if (href &&
                            href.indexOf(currentLocation + '#') !== 0 &&
                            href.indexOf('#') !== 0 &&
                            href.indexOf('javascript') !== 0) {

                        listener(href);

                        Event.stop(event);
                    }
                }
            });

            return element;
        },

        /**
         * Register a single event listener on a single target.
         *
          * Event delegation:
         *   Events can be delegated by specifying a CSS selector in the first
         *   element, next to the event name. For example, to call the function
         *   only if the user clicks on links contained in the element, you
         *   could use the event name "click a". Any string accepted by
         *   Element#match is valid (selectors starting by an operator > ~ +,
         *   separated by commas, ...). See example below.
         *
         * ##### Examples
         *
         * ###### Simple example:
         * ```
         * // Your existing element
         * var myElement = UWA.createElement('a', {
         *     text: 'My Link'
         * }),
         *
         * function myClickListener(event) {
         *
         *      // Stop event propagation and prevent default.
         *      UWA.Event.stop(event);
         *
         *      // The current scope of the listener function
         *      // is the element that we have added the event listener
         *      var myElement = this;
         *
         *      // Store event position
         *      var position = UWA.Event.getPosition(event);
         * };
         *
         * // Add a "click" event
         * myElement.addEvent('click', myClickListener);
         * ```
         *
         * ###### Example using an EventListener:
         * ```
         * // Your existing element
         * var myElement = UWA.createElement('a', {
         *         text: 'My Link'
         *    }),
         *
         *    myEventListener = {
         *         myProperty : 'event listener',
         *         handleEvent : function (event) {
         *             UWA.log('"this" is scoped to this ' + this.myProperty);
         *         }
         *    };
         *
         * // Add a "click" event
         * myElement.addEvent('click', myEventListener);
         *
         * // When the event is triggered, the console display :
         * // "this" is the event listener object
         * ```
         *
         * ###### Example using event delegation:
         * ```
         * var myElement = UWA.createElement('div', {
         *     html: 'Event delegation is <strong>the best</strong>!'
         * });
         *
         * // Bind the event on strong and span tags
         * myElement.addEvent('click strong,span', function () {
         *     UWA.log('You clicked on a strong or highlighted text!');
         * });
         *
         * // You can change the element content at any time!
         * element.addContent(' and <span>this is highlighted</span>');
         *
         * // Clicking on one of those tags will trigger the event
         * ```
         *
         * ##### Events List:
         * ###### Mouse
         * - click - Mouse clicks an object.
         * - mousedown - A mouse button is pressed.
         * - mousemove - The mouse is moved.
         * - mouseup - A mouse button is released.
         *
         * ###### Keyboard
         * - keydown - A keyboard key is pressed.
         * - keypress - A keyboard key is pressed or held down.
         * - keyup - A keyboard key is released.
         *
         * ###### Frame / Window
         * - abort - Fires when an object/image is stopped from loading before completely loaded.
         * - error - An error occurs when loading a document or an image.
         * - load - Fires when the target element and all of its content has finished loading.
         * - resize - A window or frame is resized.
         * - scroll - When something is scrolled.
         * - unload - Fires when the target element or any of its content has been removed.
         *
         * ###### Forms
         * - blur - An element loses focus.
         * - change - The content of a field changes.
         * - focus - An element gets focus.
         * - select - When the user selects text in a text input field.
         * - reset - When the user resets a form.
         * - submit - When the user submits a form.
         *
         * ###### Touch
         * - touchend - Happens every time a finger is removed from the screen.
         * - touchmove - Happens as a finger already placed on the screen is moved across the screen.
         * - touchstart - Happens every time a finger is placed on the screen.
         * - touchcancel - Sent when the system cancels tracking for the touch.
         *
         * ###### Polyfill (See <UWA.Element.Event>)
         * - mouseleave - Polyfill to support element mouseleave event.
         * - mouseenter - Polyfill to support element mouseenter event.
         * - mousewheel - Polyfill to support element mousewheel event.
         * - transitionEnd - Polyfill to support element transitionEnd event.
         *
         * ###### Custom (See <UWA.Element.Event>)
         * - resize - Custom event to support element resize detection.
         * - update - Custom event to support element content update detection.
         *
         * ##### Others Event related methods:
         * - <UWA.Event.stop> - Stop an Event from propagating and also executes preventDefault.
         * - <UWA.Event.stopPropagation> - Stop the propagation of an event (this stops the event from bubbling up through the DOM).
         * - <UWA.Event.preventDefault> - Prevent the default action of the event.
         * - <UWA.Event.getElement> - Get element target to event parameter.
         * - <UWA.Event.findElement> - Find an parent element of event target using tagName.
         * - <UWA.Event.getPosition> - The "x" and "y" positions of the event, relative to the viewport.
         *
         * @method
         * @param {String} event - the event name (e.g "click").
         * @param {Function} listener - the event listener function or an object implementing the EventListener interface.
         * @param {Boolean} [noCustomEvent=false] - Disable <UWA.Element.Event> custom and
         * polyfill handler.
         * @param {Number} [priority=0] - The priority level of the callback listener.
         *   Listeners with higher priority will be executed before listeners
         *   with lower priority. Listeners with same priority level will be
         *   executed at the same order as they were added.
         * @param {Boolean} [useCapture=false] - use capture event instead of bubbling
         *
         * @return {Element} - the current Element instance.
         */
        addEvent: (function () {

            function getDescriptor(element, eventType, noCustomEvent, useCapture) {
                var handleEvent, dispatcher,
                    events = element._events || {},
                    customEvent = !noCustomEvent ? Element.Events[eventType] : false,
                    eventName = customEvent ? eventType + 'Custom' : eventType,
                    eventDispatcher = events[eventName];

                // Here is how it works:
                // If there is not dispatcher for the event we create it
                // and the DOM event dispatch the dispatcher.
                // If there is already a dispatcher for the event, we add the
                // event listener to the dispatcher binding.
                if (!eventDispatcher) {

                    dispatcher = new DelegatedDispatcher(element);

                    events[eventName] = eventDispatcher = {
                        dispatcher: dispatcher,
                        handleEvent: function (event) {

                            // TODO remove when a proper Element wrapper is implemented
                            if (UWA.driver === 'Mootools') {

                                var EventClass = window.DOMEvent || window.Event;

                                event = new EventClass(event);

                                ['offsetY', 'offsetX', 'relatedTarget', 'button',
                                    'metaKey', 'altKey', 'shiftKey', 'ctrlKey',
                                    'clientY', 'clientX', 'screenY', 'screenX',
                                    'which', 'pageY', 'pageX', 'layerY', 'layerX',
                                    'charCode', 'keyCode', 'timeStamp',
                                    'cancelable', 'bubbles', 'target',
                                    'type', 'detail', 'wheelDelta', 'touches',
                                    'changedTouches'].forEach(function (p) {
                                    if (!UWA.owns(event, p)) {
                                        event[p] = event.event[p];
                                    }
                                });
                            }

                            // Only Add timeStamp if missing
                            if (event.timeStamp === undefined) {
                                event.timeStamp = Date.now();
                            }

                            dispatcher.dispatch([event]);
                        },
                        events: {},
                        bindings: [],
                        timers: []
                    };

                    handleEvent = eventDispatcher.handleEvent;

                    // Update Element Events
                    element._events = events;

                    if (customEvent) {
                        // Use Custom Events Handler

                        customEvent(eventDispatcher, element, {
                            target: element,
                            type: eventType
                        });

                    } else if (element.addEventListener) {
                        // Use W3C Events Handler
                        element.addEventListener(eventType, handleEvent, useCapture || false);

                    } else {
                        // Use IE Events Handler

                        element.attachEvent('on' + eventType, handleEvent);

                        // Attach unload event to the window to clean up possibly IE memory leaks
                        window.attachEvent('onunload', function () {
                            element.detachEvent('on' + eventType, handleEvent);
                        });
                    }
                }

                return eventDispatcher;
            }

            return function (event, listener, noCustomEvent, priority, useCapture) {

                event = extractSelector(event);

                var element = this,
                    scope = (listener && typeof listener.handleEvent === 'function') ? listener : element,
                    descriptor = getDescriptor(this, event.name, noCustomEvent, useCapture);

                // Add listener to event dispatcher.
                descriptor.dispatcher.addDelegation(listener, event.selector, scope, priority);

                // IE fix onLoad event on images by calling listener
                // with element for context.
                if (
                    event.name === 'load' &&
                        element.tagName && element.tagName.toLowerCase() === 'img' &&
                            element.complete && element.width > 0
                ) {
                    descriptor.dispatcher.dispatch();
                }

                return element;
            };
        }()),

        /**
         * Register a multiple events listeners on a single target.
         *
         * @param {Object} events - events hash or a name/listener pair.
         * @param {Boolean} [noCustomEvent=false] - Disable Element.Event custom events.
         * @param {Number} [priority=0] - The priority level of the callback listener.
         *  Listeners with higher priority will be executed before listeners
         *  with lower priority. Listeners with same priority level will be
         *  executed at the same order as they were added.
         * @param {Boolean} [useCapture=false] - use capture events instead of bubbling
         *
         * @return {Element} the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('a', {
         *         text: 'My Link'
         *    }),
         *
         *    myEventListener = function (event) {
         *
         *         // Stop event propagation and prevent default.
         *         UWA.Event.stop(event);
         *
         *         // Get the Event type (click or touchstart into this example)
         *         var eventType = event.type;
         *    };
         *
         * // Add "click" and "touchstart" events
         * myElement.addEvents({
         *     click: myEventListener,
         *     touchstart: myEventListener
         * });
         */
        addEvents: function (events, noCustomEvent, priority, useCapture) {

            var event,
                element = this;

            for (event in events) {
                if (events.hasOwnProperty(event)) {
                    Element.addEvent.call(element, event, events[event], noCustomEvent, priority, useCapture);
                }
            }

            return element;
        },

        /**
         * Trigger an event listener on a target.
         *
         * __Notes__:
         *   It will only trigger events added using Element.add[Event|Events] methods.
         *
         * @param {String} eventName - the event name (e.g "click").
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('a', {
         *         text: 'My Link'
         *    }),
         *
         *    myEventListener = function (event) {
         *
         *         // Stop event propagation and prevent default.
         *         UWA.Event.stop(event);
         *    };
         *
         * // Add a "click" event
         * myElement.addEvent('click', myClickListener);
         *
         * // Manualy trigger "click" event listener
         * myElement.triggerEvent('click');
         */
        triggerEvent: function (eventName) {

            var element = this,
                events = element._events || {},
                handler = events[eventName],
                event = {
                    target: element,
                    timeStamp: Date.now(),
                    type: eventName
                };

            if (handler) {
                handler.handleEvent(event);
            }

            return element;
        },

        /**
         * Remove event listener(s) on a target.
         *
         * __Event delegation__:
         *
         * As normal events, to remove a target event listener, you have to
         * pass the full event name and selector, plus the listener function.
         * Passing only the event name and selector will remove all events
         * matching this event and selector.
         * Passing only the event name (without selector) will remove all
         * events matching this name regardless of its delegated state.
         *
         * @param {String} event - the event name (e.g "click"). If not specified, it
         *   will remove all events on this element.
         * @param {Function} listener - the event listener function. If not specified,
         *   it will remove all events matching the given event name.
         * @param {Boolean} [useCapture=false] - if true, removes the event added with
         * useCapture to true
         * @return {Element} - the current Element instance.
         *
         * @example
         * // Your existing element
         * var myElement = UWA.createElement('a', {
         *         text: 'My Link'
         *    }),
         *
         *    myEventListener = function (event) {
         *
         *         // Stop event propagation and prevent default.
         *         UWA.Event.stop(event);
         *     };
         *
         * // Add a "click" event
         * myElement.addEvent('click', myClickListener);
         *
         * // Remove all "click" events
         * myElement.removeEvent('click');
         *
         * // Remove only "click" events associate with "myClickListener" listener
         * myElement.removeEvent('click', myClickListener);
         */
        removeEvent: function (event, listener, useCapture) {

            if (!UWA.is(event)) {
                return Element.removeEvents.call(this);
            }

            event = extractSelector(event);

            var i, l, subEventName, dispatcher, subEvents,
                element = this,
                isCustomEvent = (element._events && element._events[event.name + 'Custom']),
                eventName = isCustomEvent ? event.name + 'Custom' : event.name,
                eventDispatcher = element._events && element._events[eventName];

            if (eventDispatcher) {

                dispatcher = eventDispatcher.dispatcher;

                if (!listener && !event.selector) {
                    dispatcher.removeAll();
                } else {
                    dispatcher.removeDelegation(listener, event.selector);
                }

                // If we have no targeted listener or there is no more listener,
                // destroy the native listeners and dispatcher instance.
                if (dispatcher.getNumListeners() === 0) {

                    // Destroy dispatcher reference to deal with Custom event
                    // that add native event with the same name (e.g mousewheel vs mousewheelCustom).
                    delete element._events[eventName];

                    // Remove Events associate to eventDispatcher
                    subEvents = eventDispatcher.events;

                    for (subEventName in subEvents) {
                        if (subEvents.hasOwnProperty(subEventName)) {
                            Element.removeEvent.call(element, subEventName, subEvents[subEventName]);
                        }
                    }

                    // Remove Timers associate to eventDispatcher
                    if (eventDispatcher.timers) {
                        for (i = 0, l = eventDispatcher.timers.length; i < l; i++) {
                            clearTimeout(eventDispatcher.timers[i]);
                        }
                    }

                    // Remove Binding associate to eventDispatcher
                    if (eventDispatcher.bindings) {
                        for (i = 0, l = eventDispatcher.bindings.length; i < l; i++) {
                            eventDispatcher.bindings[i].dispose();
                        }
                    }

                    // Custom event add event into eventDispatcher.events,
                    // do not consider Custom event to have native listeners.
                    if (!isCustomEvent) {
                        if (element.removeEventListener) {
                            element.removeEventListener(eventName, eventDispatcher.handleEvent, useCapture);
                        } else {
                            element.detachEvent('on' + eventName, eventDispatcher.handleEvent);
                        }
                    }

                    // Clear UWA Dispatcher instance
                    dispatcher.dispose();
                }
            }

            return element;
        },

        /**
         * Remove multiple events listener(s) on a target.
         *
         * ##### Examples
         *
         * You can remove all element's attached events at once by calling
         * this method without arguments.
         *
         * ```
         * var myElement = UWA.createElement('a', {
         *     text : 'My link'
         * }).addEvents({
         *     'click' : function () {},
         *     'customEvent' : function () {}
         * });
         *
         * // Shouldn't have any event handler left attached
         * myElement.removeEvents();
         * ```
         *
         * @param {Object} events - events hash or a name/listener pair.
         * @param {Boolean} [useCapture=false] - if true, removes the events added with
         * useCapture to true
         * @return {Element} - the current Element instance.
         */
        removeEvents: function (events, useCapture) {
            var event,
                element = this,
                eventsGiven = typeof events !== 'undefined',
                eventSource = eventsGiven ?
                        events :
                        element._events;

            for (event in eventSource) {
                if (eventSource.hasOwnProperty(event)) {
                    Element.removeEvent.call(
                        element,
                        event,
                        eventsGiven ? events[event] : null,
                        useCapture
                    );
                }
            }

            return element;
        },

        /**
         * Fill the parent with the current element. The element will have the
         * maximum place allowed by the parent, and the content of the parent
         * will not overflow it.
         *
         * __Notes__: For advanced and internal library usage only.
         *
         * @param {String} property - height or width, defaults to height.
         * @param {Element} reference - by default the element parent node.
         * @returns {Element} - the current Element instance.
         */
        fillParent: function (property, reference) {

            property = property || 'height';

            var element = this,
                parent = reference || Element.getParent.call(element),
                setStyle = Element.setStyle.bind(element),
                propertySuffix = UWAString.ucfirst(property),
                large = 10000;

            if (parent) {
                setStyle('height', large + 'px');
                setStyle('height', (parent['offset' + propertySuffix] - parent['scroll' + propertySuffix] + large) + 'px');
            }

            return element;
        },

        /**
         * Disable or enable the text selection on the element.
         *
         * @method
         * @param {selectable} Boolean - define if the text selection should be enabled (true) or
         *   disabled (false).
         * @return {Element} the current Element instance.
         */
        setSelectable: (function () {

            function unselectable(event) {
                Event.preventDefault(event);
            }

            return function (selectable) {

                var element = this;

                element.setAttribute('unselectable', selectable ? 'off' : 'on');

                Element.setStyles.call(element, {
                    userSelect: selectable ? '' : 'none',
                    touchCallout: selectable ? '' : 'none'
                });

                Element[selectable ? 'removeEvent' : 'addEvent'].call(element, 'selectstart', unselectable);

                return element;
            };
        }()),

        /**
         * Asynchronously requests that the element be made full-screen.
         *
         * @method
         * @return {Element} the current Element instance.
         */
        requestFullscreen: (function () {

            var method = getVendorProperty(documentElement, 'requestFullscreen') ||
                    getVendorProperty(documentElement, 'requestFullScreen');

            return method ? function () {
                // Calling the method with 1, for Safari browsers. 1 is the
                // value of the flag window.Element.ALLOW_KEYBOARD_INPUT
                // specified in the Safari documentation[1]. As
                // 'window.Element' is overriden by MooTools, we use directly
                // the flag value.
                // [1] http://developer.apple.com/library/safari/#documentation/WebKit/Reference/ElementClassRef/Element/Element.html
                return method.call(this, 1);
            } : function () {
                throw new Error('Element#requestFullscreen is not available in this platform');
            };
        }())
    });


    function eventAlias(customName, nativeName) {

        if (typeof nativeName === 'function') {
            nativeName = nativeName();
        } else if (nativeName === undefined) {
            nativeName = getVendorProperty(documentElement, 'on{}' + customName, true);
            if (nativeName) {
                // remove the 'on' prefix
                nativeName = nativeName.slice(2);
            }
        }

        // The event is already unprefixed
        if (customName === nativeName) {
            return;
        }

        Element.Events[customName] = function (eventDispatcher, element) {
            if (!nativeName) {
                throw new Error('The event ' + customName + ' is not supported on this platform');
            }

            // Add handler Event
            Element.addEvent.call(element, nativeName, eventDispatcher.handleEvent, true);

            // Register sub event to current event handler
            eventDispatcher.events[nativeName] = eventDispatcher.handleEvent;
        };
    }

    /**
     * UWA.Element polyfills and customs Events.
     * @namespace
     * @memberof module:UWA/Element
     */
    Element.Events = {

        /*
        click: function (eventDispatcher, element, event) {

            // TODO implement touchtap for touch event

            var eventName = Client.Features.touchEvents ? 'click' : 'click';

            //element.addEvent('mouseenter', handler.callback, true);
            Element.addEvent.call(element, eventName, eventDispatcher.handleEvent, true);
        },
        */

        /**
         * Polyfill to support element mouseleave event.
         * @function
         * @static
         */
        mouseleave: (function () {

            function isAChildOf(parent, child) {

                var result = false;

                if (parent !== child) {

                    while (child && child !== parent) {
                        child = child.parentNode;
                    }

                    result = parent === child;
                }

                return result;
            }

            return function (eventDispatcher, element, event) {

                var handleEvent = eventDispatcher.handleEvent;

                // Use W3C Events Handler
                if (element.addEventListener) {

                    eventDispatcher.handleEvent = function (e) {
                        var relTarget = e.relatedTarget;
                        // Call the handler only if related is outside the target
                        if (this !== relTarget && !isAChildOf(this, relTarget)) {
                            handleEvent.call(this, event);
                        }
                    };

                    Element.addEvent.call(element, 'mouseout', eventDispatcher.handleEvent);

                    // Register sub event to current event handler
                    eventDispatcher.events.mouseout = eventDispatcher.handleEvent;

                // Use IE Events Handler
                } else {

                    //element.addEvent('mouseenter', handler.callback, true);
                    Element.addEvent.call(element, 'mouseleave', handleEvent, true);

                    // Register sub event to current event handler
                    eventDispatcher.events.onmouseleave = handleEvent;
                }
            };

        }()),

        /**
         * Polyfill to support element mousenter event.
         * @function
         * @static
         */
        mouseenter: (function () {

            function isAChildOf(parent, child) {

                var result = false;

                if (parent !== child) {

                    while (child && child !== parent) {
                        child = child.parentNode;
                    }

                    result = parent === child;
                }

                return result;
            }

            return function (eventDispatcher, element, event) {

                var handleEvent = eventDispatcher.handleEvent;

                // Use W3C Events Handler
                if (element.addEventListener) {

                    eventDispatcher.handleEvent = function (e) {
                        var relTarget = e.relatedTarget;
                        // Call the handler only if related is outside the target
                        if (this !== relTarget && !isAChildOf(this, relTarget)) {
                            handleEvent.call(this, event);
                        }
                    };

                    Element.addEvent.call(element, 'mouseover', eventDispatcher.handleEvent);

                    // Register sub event to current event handler
                    eventDispatcher.events.mouseover = eventDispatcher.handleEvent;

                // Use IE Events Handler
                } else {

                    //element.addEvent('mouseenter', handler.callback, true);
                    Element.addEvent.call(element, 'mouseenter', handleEvent, true);

                    // Register sub event to current event handler
                    eventDispatcher.events.mouseenter = handleEvent;
                }
            };
        }()),

        /**
         * Polyfill to support element mousewheel event.
         * Mapping for DOMMouseScroll, onmousewheel, mousewheel.
         * @function
         * @static
         */
        mousewheel: function (eventDispatcher, element) {

            var handleEvent = eventDispatcher.handleEvent,
                eventName = Client.Engine.firefox ? 'DOMMouseScroll' : 'mousewheel';

            eventDispatcher.handleEvent = function (event) {

                event = event || window.event;
                event.wheel = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;

                handleEvent(event);
            };

            // Add handler Event
            Element.addEvent.call(element, eventName, eventDispatcher.handleEvent, true);

            // Register sub event to current event handler
            eventDispatcher.events[eventName] = eventDispatcher.handleEvent;
        },

        /**
         * Custom event to support element content update detection.
         *
         * Based on MutationObserver (or its polyfill if necessary).
         *
         * @function
         * @static
         *
         * @param  {Dispatcher} eventDispatcher
         * @param  {Node} element Node to observe
         * @param  {Object} event
         */
        update: function (eventDispatcher, element, event) {
            var observer = new MutationObserver(function (records) {
                var record = records[0];

                eventDispatcher.handleEvent(Object.assign(event, {
                    // Inject record in event for future purposes
                    record: record
                }));
            });

            observer.observe(element, {
                childList: true,
                subtree: true
            });
        },

        /**
         * Custom event to support element resize detection.
         * @function
         * @static
         */
        resize: (function () {

            // TODO http://javascriptmvc.com/jquery/dist/jquery.event.resize.js

            // Use a global timer to dispatch the check of all element
            // that have register an resize event.

            var resizeHandlerTimer,
                resizeDispatcher = new Dispatcher(),
                resizeHandlerDelay = 200;

            function getSize(element) {
                var size;

                if (UWA.is(element, ['window', 'document'])) {
                    size = Client.getSize();
                    size = [size.width, size.height];
                } else {
                    size = [
                        element.scrollWidth,
                        element.scrollHeight,
                        element.offsetWidth,
                        element.offsetHeight
                    ];
                }

                return size.join('x');
            }

            function resizeHandler() {

                clearTimeout(resizeHandlerTimer);

                resizeDispatcher.dispatch();

                // Do not add timer if their is no more events
                if (resizeDispatcher.getNumListeners() > 0) {
                    resizeHandlerTimer = setTimeout(resizeHandler, resizeHandlerDelay);
                }
            }

            return function (eventDispatcher, element, event) {

                var listenerTimer,
                    listenerDelay = 220,
                    currentSize = getSize(element),
                    orientationEvent = 'orientationchange';

                // Do not add a resizeDispatcher if there is one already for this element
                if (eventDispatcher.bindings.length > 0) {
                    return;
                }

                // Add handler Timer
                eventDispatcher.timers = [listenerTimer];

                if (window === element && UWA.is(window[orientationEvent])) {

                    // Add handler Event
                    Element.addEvent.call(element, orientationEvent, resizeHandler);

                    // Register sub event to current event handler
                    eventDispatcher.events[orientationEvent] = resizeHandler;
                }

                // Add handler binding
                eventDispatcher.bindings = [resizeDispatcher.add(function () {

                    var newSize = getSize(element),
                        wasZeroSize = currentSize === '0x0' ||
                             UWA.is(element, ['window', 'document']) ? false : !Element.isInjected.call(element),
                        isZeroSize = newSize === '0x0';

                    if (currentSize !== newSize && !isZeroSize) {

                        // Avoid Callback if document did not resize
                        currentSize = newSize;

                        // Avoid Callback if previous size was '0x0' of invisible
                        if (!wasZeroSize) {
                            // Delayed onResize to avoid multiple events
                            clearTimeout(listenerTimer);
                            listenerTimer = setTimeout(function () {
                                eventDispatcher.handleEvent(event);
                            }, listenerDelay);
                        }
                    }
                })];

                resizeHandler();
            };
        }())
    };

    /**
     * Polyfill to support element fullscreenchange event.
     * Note: Mapping for {,moz,ms,webkit,o}fullscreenchange.
     * @function
     * @static
     */
    eventAlias('fullscreenchange');

    /**
     * Polyfill to support element fullscreenerror event.
     * Note: Mapping for {,moz,ms,webkit,o}fullscreenerror.
     * @function
     * @static
     */
    eventAlias('fullscreenerror');

    /**
     * Polyfill to support element transitionEnd event.
     * Note: Mapping for webkitTransitionEnd, oTransitionEnd, transitionend, mozTransitionEnd.
     * @function
     * @static
     */
    eventAlias('transitionEnd', function () {

        // http://msdn.microsoft.com/en-us/library/ie/hh673535(v=vs.85).aspx#transitions_dom_events
        // http://www.ianlunn.co.uk/blog/articles/opera-12-otransitionend-bugs-and-workarounds/
        var transition,
            element = document.createElement('fakeelement'),
            transitions = {
                // Order matters for registering event in FF (case Sensitive issue)
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                msTransition: 'MSTransitionEnd',
                OTransition: 'oTransitionEnd',
                transition: 'transitionEnd'
            };

        for (transition in transitions) {
            if (
                transitions.hasOwnProperty(transition) &&
                    UWA.is(element.style[transition])
            ) {
                return transitions[transition];
            }
        }
    });

    /*
        Elements polyfills
    */
    (function (dom) {
        var querySelectorAll = dom.querySelectorAll,
            querySelector = dom.querySelector,
            getElementsByClassName = dom.getElementsByClassName,
            supportNot = true;

        qwery.configure({
            useNativeQSA: false
        });

        try {
            querySelectorAll.call(dom, 'a:not(.foo)');
        } catch (e) {
            supportNot = false;
        }

        if (!dom.matchesSelector) {
            Element.matchesSelector =
                getVendorProperty(dom, 'matchesSelector') ||
                function (selector, root) {
                    return qwery.is(this, selector, root && root.parentNode);
                };
        }

        if (!querySelectorAll || !supportNot) {
            Element.querySelectorAll = function (selector) {
                return qwery(selector, this);
            };
        }

        if (!querySelector || !supportNot) {
            Element.querySelector = function () {
                return Element.querySelectorAll.apply(this, arguments)[0];
            };
        }

        if (!getElementsByClassName) {
            Element.getElementsByClassName = function (selector) {
                return qwery('.' + selector, this);
            };
        }
    }(documentElement));


    document.exitFullscreen = getVendorProperty(document, 'exitFullscreen') ||
        getVendorProperty(document, 'cancelFullScreen') ||
        function () {
            throw new Error('Element#requestFullscreen is not available in this platform');
        };

    if (!('fullscreenEnabled' in document)) {
        document.fullscreenEnabled = getVendorProperty(document, 'fullscreenEnabled');
    }

    (function () {

        var realName = 'fullscreenElement',
            fullscreenElementName =
                getVendorProperty(document, realName, true) ||
                getVendorProperty(document, 'fullScreenElement', true) ||
                getVendorProperty(document, 'currentFullScreenElement', true);

        if (fullscreenElementName && fullscreenElementName !== realName) {

            try {

                Element.addEvent.call(document, 'fullscreenchange', function () {
                    document[realName] = document[fullscreenElementName];
                });

                document[realName] = document[fullscreenElementName];

            } catch (error) {
                // Ignore, the event isn't supported
            }
        }
    }());

    return UWA.namespace('Element', Element, UWA, true);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, clearTimeout, setTimeout
*/

/**
 * Classes implementing or extending this Class will have extra methods
 * to handle delayed, animated and periodical events.
 *
 * @module   UWA/Class/Timed
 *
 *
 * @example
 * define('MyProject/Class/MyAnime', [
 *     'UWA/Class',
 *     'UWA/Class/Timed',
 * ], function (Class, Timed) {
 *
 *      var MyAnime = Class.extend(Timed, {
 *
 *           init: function (element, start, stop) {
 *
 *                this.current = null;
 *                this.start = start;
 *                this.stop = stop;
 *                this.element = element;
 *            },
 *
 *            run: function () {
 *                this.setAnimate('myAnimation', this.animate);
 *            },
 *
 *            stop: function () {
 *                this.clearAnimate('myAnimation');
 *            },
 *
 *            isRuning: function () {
 *                return this.hasAnimate('myAnimation');
 *            },
 *
 *            animate: function () {
 *
 *                var element = this.element;
 *
 *                if (this.current === null) {
 *                    this.current = this.start;
 *                }
 *
 *                UWA.Element.setStyle.call(element, 'top', this.current++);
 *
 *                if (this.current <= this.stop) {
 *                    this.setAnimate('myAnimation', this.animate);
 *                }
 *           }
 *     });
 *
 *     return MyAnime;
 * });
 *
 * require(['MyProject/Class/MyAnime'], function (MyAnime) {
 *
 *     var myAnime = new MyAnime(widget.body, 1, 300);
 *
 *     myAnime.run();
 * });
 *
 */
define('UWA/Class/Timed', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Utils',
    'UWA/Utils/Client'
], function (Core, Class, Utils, Client) {
    'use strict';

    var Timed,
        timedId = 1,
        cancelRequestAnimFrame = Client.getVendorProperty(window, 'cancelAnimationFrame') || clearTimeout,
        requestAnimFrame = Client.getVendorProperty(window, 'requestAnimationFrame') || function (callback) {
            // shim layer with setTimeout fallback
            // (it caps framerate at ~30fps: https://bugzilla.mozilla.org/show_bug.cgi?id=630127)
            return setTimeout(callback, 1000 / 60);
        };

    function createSetTimed(clear, types, run, clearBeforeExecution) {

        return function (name, fn, delay, force, bind) {

            var that = this,
                result = that;

            // Support call with no name
            // TODO experimental.
            if (typeof name === 'function') {
                bind = force;
                force = delay;
                delay = fn;
                fn = name;

                result = name = timedId++;
            }

            function fail(error) {
                that[clear](name);
                throw new Error('The ' + types.slice(0, -1) + ' "' + name +
                                '" failed with error "' + error + '".');
            }

            fn = Utils.attempt.bind(null, fn, fail, bind || that);

            that[clear](name);

            that[types] = that[types] || Object.create(null);

            that[types][name] = run(function () {
                if (clearBeforeExecution) {
                    that[clear](name);
                }
                fn();
            }, delay);

            if (force) {
                fn();
            }

            return result;
        };
    }

    function createClearTimed(types, run) {

        return function (name) {

            var forName,
                that = this,
                register = that[types];

            if (register) {
                if (name === undefined) {

                    // The body of a for in is wrapped in an if statement to
                    // do not need filter unwanted properties because of Object.create(null)
                    for (forName in register) { // jshint ignore:line
                        run(register[forName]);
                        delete register[forName];
                    }

                } else if (register[name]) {
                    run(register[name]);
                    delete register[name];
                }
            }

            return that;
        };
    }

    function createHasTimed(types) {
        return function (name) {
            var register = this[types];
            return Boolean(register && register[name]);
        };
    }

    Timed = Class.extend({

        /**
         * Register a function as periodical event.
         *
         * @method
         * @param {String} name - The name of the periodical event
         * @param {Function} fn - The function to register
         * @param {Number} delay - The execution delay in milliseconds
         * @param {Boolean} force - If `true`, fire the function for the time right now
         * @param {Object} bind - The context to pass to the function, current
         *  instance by default.
         * @return {this}
         */
        setPeriodical: createSetTimed('clearPeriodical', 'periodicals', window.setInterval),

        /**
         * Unregister a periodical event previously registered with <setPeriodical>.
         * If the name is specified, it removes the associated periodical
         * event. Else, it removes all periodicals events.
         *
         * @method
         * @param {String} name - the name of the event
         * @return {this}
         */
        clearPeriodical: createClearTimed('periodicals', window.clearInterval),

        /**
         * Check if a periodical event is registered.
         *
         * @method
         * @param {String} name - The name of the periodical event
         * @return {Boolean} `true` If a periodical event is registered.
         */
        hasPeriodical: createHasTimed('periodicals'),

        /* Group: Delayeds Methods */

        /**
         * Registers a function as delayed event.
         *
         * @method
         * @param {String} name - The name of the delayed event
         * @param {Function} fn - The function to register
         * @param {Number} delay - The delay in milliseconds
         * @param {Boolean} force - If `true`, fire the function for the time right now
         * @param {Object} bind - The context to pass to the function, current
         *  instance by default.
         * @return {this}
         */
        setDelayed: createSetTimed('clearDelayed', 'delays', window.setTimeout, true),

        /**
         * Unregister a delayed event previously registered with <setDelayed>.
         * If the name is specified, it removes the associated periodical
         * event. Else, it removes all periodicals events.
         *
         * @method
         * @param {String} name - The name of the delayed event
         * @return {this}
         */
        clearDelayed: createClearTimed('delays', window.clearTimeout),

        /**
         * Check if a delayed event is registered.
         *
         * @method
         * @param {String} name - The name of the delayed event
         * @return {Boolean} `true` If a delayed event is registered.
         */
        hasDelayed: createHasTimed('delays'),

        /* Group: Animate Methods */

        /**
         * Register a function as frame animation event.
         *
         * > Use requestAnimationFrame if available else fallback on
         * > setTimeout with 16ms delay.
         *
         * @method
         * @param {String} name - The name of the animation event
         * @param {Function} fn - The function to register
         * @param {Object} bind - The context to pass to the function, current
         *  instance by default.
         * @return {this}
         */
        setAnimate: createSetTimed('clearAnimate', 'animates', requestAnimFrame, true),

        /**
         * Unregister a frame animation event previously registered with <setAnimate>.
         * If the name is specified, it removes the associated animation
         * event. Else, it removes all animation events.
         *
         * @method
         * @param {String} name - The name of the event
         * @return {this}
         */
        clearAnimate: createClearTimed('animates', cancelRequestAnimFrame),

        /**
         * Check if a animation event is registered.
         *
         * @method
         * @param {String} name - The name of the animation event
         * @return {Boolean} `true` If a animation event is registered.
         */
        hasAnimate: createHasTimed('animates'),

        /* Group: Animate Methods */

        /**
         * Register a function as immediate event.
         *
         * > Use setImmediate if available else fallback on
         * > setTimeout with ~1ms delay.
         *
         * @method
         * @param {String} name - The name of the immediate event
         * @param {Function} fn - The function to register
         * @param {Object} bind - The context to pass to the function, current
         *  instance by default.
         * @return {this}
         */
        setImmediate: createSetTimed('clearImmediate', 'immediates', Utils.setImmediate, true),

        /**
         * Unregister a immediate event previously registered with <setImmediate>.
         * If the name is specified, it removes the associated immediate
         * event. Else, it removes all immediate events.
         *
         * @method
         * @param {String} name - The name of the event
         * @return {this}
         */
        clearImmediate: createClearTimed('immediates', Utils.clearImmediate),

        /**
         * Check if a immediate event is registered.
         *
         * @method
         * @param {String} name - The name of the immediate event
         * @return {Boolean} `true` If a immediate event is registered.
         */
        hasImmediate: createHasTimed('immediates'),

        /**
         * Clear all registered 'timed' callback.
         *
         * @return {this}
         */
        clearAllTimed: function () {
            this.clearImmediate();
            this.clearAnimate();
            this.clearDelayed();
            this.clearPeriodical();
            return this;
        }
    });

    return Core.namespace('Timed', Timed, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Color utilities
 *
 * @module   UWA/Color
 */

define('UWA/Color', [
    'UWA/Core',
    'UWA/Class'
], function (UWA, Class) {
    'use strict';


    /* Group: Private methods */

    /**
     * Converting an Hexadecimal color to a RGB color
     *
     * @param  {String} hex - The hexadecimal color in form of a string. Ex: #ff0000
     * @return {Object}     - An object containing rgb values :
     *                          - [Object.r] {Int} - Red
     *                          - [Object.g] {Int} - Green
     *                          - [Object.b] {Int} - Blue
     */
    function _hexToRgb(hex) {
        // Removing the # if there is one
        if (hex.charAt(0) === '#') {
            hex = hex.substring(1);
        }

        // Changing f00 in ff0000 if needed
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        return {
            r: parseInt(hex.substr(0, 2), 16),
            g: parseInt(hex.substr(2, 2), 16),
            b: parseInt(hex.substr(4, 2), 16)
        };
    }

    /**
     * Converting an RGB color to a HSL color
     *
     * @param  {Object} rgb - An object containing r, g and b values
     * @return {Object}     - An object containing hsl values :
     *                          - [Object.h] {Int}   - Hue
     *                          - [Object.s] {Float} - Saturation
     *                          - [Object.l] {Float} - Lightness
     */
    function _rgbToHsl(rgb) {
        // Normalize
        rgb = UWA.clone(rgb);
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;

        var hsl = {};
        var min = Math.min(rgb.r, rgb.g, rgb.b);
        var max = Math.max(rgb.r, rgb.g, rgb.b);
        var diff = max - min;
        var average = (max + min) / 2;

        // Lightness
        hsl.l = average;

        if (max === min) {
            // If achromatic, set Hue and Saturation to 0
            hsl.h = 0;
            hsl.s = 0;
        } else {
            hsl.h = average;
            hsl.s = average;

            // Saturation
            hsl.s = hsl.l > 0.5 ? diff / (2 - max - min) : diff / (max + min);

            // Hue
            if (max === rgb.r) {
                hsl.h = (rgb.g - rgb.b) / diff + (rgb.g < rgb.b ? 6 : 0);
            } else if (max === rgb.g) {
                hsl.h = (rgb.b - rgb.r) / diff + 2;
            } else if (max === rgb.b) {
                hsl.h = (rgb.r - rgb.g) / diff + 4;
            }
            hsl.h /= 6;
        }

        // Denormalize
        hsl.h = Math.round(hsl.h * 360);
        hsl.s = Math.round(hsl.s * 100);
        hsl.l = Math.round(hsl.l * 100);

        return hsl;
    }

    /**
     * Converting an HSL color to a RGB color
     *
     * @param  {Object} hsl - An object containing h, s and l values
     * @return {Object}     - An object containing rgb values :
     *                          - [Object.r] {Int} - Red
     *                          - [Object.g] {Int} - Green
     *                          - [Object.b] {Int} - Blue
     */
    function _hslToRgb(hsl) {
        var result = {};

        var chroma = (1 - Math.abs(hsl.l / 50 - 1)) * hsl.s / 100,
            x = chroma * (1 - Math.abs((hsl.h / 60) % 2 - 1)),
            hueRange = Math.floor(hsl.h / 60),
            m = hsl.l / 100 - chroma / 2;

        switch (hueRange) {
            case 0:
                result.r = chroma;
                result.g = x;
                result.b = 0;
                break;
            case 1:
                result.r = x;
                result.g = chroma;
                result.b = 0;
                break;
            case 2:
                result.r = 0;
                result.g = chroma;
                result.b = x;
                break;
            case 3:
                result.r = 0;
                result.g = x;
                result.b = chroma;
                break;
            case 4:
                result.r = x;
                result.g = 0;
                result.b = chroma;
                break;
            case 5:
            case 6:
                result.r = chroma;
                result.g = 0;
                result.b = x;
                break;
        }

        result.r = Math.round((result.r + m) * 255);
        result.g = Math.round((result.g + m) * 255);
        result.b = Math.round((result.b + m) * 255);

        return result;
    }

    /**
     * Layering two colors one above the other and calculating the resulting color
     *
     * @param  {Object} background - an rgb(a) object
     * @param  {Object} foreground - an rgb(a) object
     * @return {Object}            - an rgb(a) object
     */
    function _layerColors(background, foreground) {
        background = UWA.clone(background);
        var alpha = background.alpha;

        if (alpha >= 1) {
            return background;
        }

        var rgbColors = ['r', 'g', 'b'];
        rgbColors.forEach(function (rgbColor) {
            background[rgbColor] = background[rgbColor] * alpha + foreground[rgbColor] * foreground.alpha * (1 - alpha);
        });
        background.alpha = Math.round(alpha + foreground.alpha * (1 - alpha));

        return background;
    }

    /**
     * Calculating the relative luminance of a color
     * Formula: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
     *
     * @param  {Object} color - An rgb(a) object
     * @return {Number}       - The luminance of the color
     */
    function _getLuminance(color) {
        var rgba = [color.r, color.g, color.b, color.alpha].map(function (rgb) {
            rgb /= 255;
            return rgb < .03928 ? rgb / 12.92 : Math.pow((rgb + .055) / 1.055, 2.4);
        });

		return .2126 * rgba[0] + .7152 * rgba[1] + 0.0722 * rgba[2];
    }

    /**
     * Calculating contrast ratio between two colors
     *
     * @param  {Object} foreground - an rgb(a) object
     * @param  {Object} background - an rgb(a) object
     * @return {Object}            - an object containing the contrast ratio :
     *                                  - [Object.ratio] {Int} - The ratio number
     *                                  - [Object.min]   {Int} - The minimum ratio number if background is transparent
     *                                  - [Object.max]   {Int} - The maximum ratio number if background is transparent
     */
    function _getContrast(foreground, background) {
        // If background alpha is opaque
        if (background.alpha >= 1) {
            if (foreground.alpha < 1) {
				foreground = _layerColors(foreground, background);
			}

            var backgroundLum = _getLuminance(background) + .05;
            var foregroundLum = _getLuminance(foreground) + .05;
            var ratio = backgroundLum / foregroundLum;

            if (foregroundLum > backgroundLum) {
                ratio = 1 / ratio;
            }

            return {
				ratio: Math.round(ratio),
				min: ratio,
				max: ratio
			};
        }

        // If background alpha is not opaque, we need to calculate min and max
        // possible ratio depending on the background color (black or white)
        var white = { r: 255, g: 255, b: 255, alpha: 1 };
        var black = { r: 0, g: 0, b: 0, alpha: 1 };

        var blackOverlay = _layerColors(background, black);
        var whiteOverlay = _layerColors(background, white);
        var contrastOnBlack = _getContrast(foreground, black).ratio;
        var contrastOnWhite = _getContrast(foreground, white).ratio;

        var max = Math.max(contrastOnBlack, contrastOnWhite);
        var min = 1;
		if (blackOverlay.luminance > foreground.luminance) {
			min = contrastOnBlack;
		}
		else if (whiteOverlay.luminance < foreground.luminance) {
			min = contrastOnWhite;
		}

        return {
			ratio: Math.round((min + max) / 2, 2),
			min: min,
			max: max
		};
    }

    var Color = Class.extend({

        _color: null,

        init: function (color) {
            this._color = UWA.clone(color);
        },

        /**
         * Returning an hexadecimal color string
         *
         * @return {String} - An hexadecimal string
         */
        toHexString: function () {
            var rgb = [this._color.r, this._color.g, this._color.b];
            var hex = rgb.map(function (hue) {
                hue = parseInt(hue, 10);
                hue = hue.toString(16);
                return hue.length === 1 ? '0' + hue : hue;
            });

            return '#' + hex.join('');
        },

        /**
         * Returning an rgba color string
         *
         * @return {String} - An rgba string
         */
        toRGBString: function () {
            var color = this._color;
            var isAlpha = color.alpha < 1;

            return 'rgb' + (isAlpha ? 'a' : '') + '(' + color.r + ', ' + color.g + ', ' + color.b + (isAlpha ? (', ' + color.alpha) : '') + ')';
        },

        /**
         * Returning an hsla color string
         *
         * @return {String} - An hsla string
         */
         toHSLString: function () {
            var color = this._color;
            var isAlpha = color.alpha < 1;

            return 'hsl' + (isAlpha ? 'a' : '') + '(' + color.h + ', ' + color.s + '%, ' + color.l + (isAlpha ? ('%, ' + color.alpha) : '%') + ')';
        },

        /**
         * Returning an rgb, hsl and alpha object
         *
         * @return {Object} - An object containing rgba values:
         *                      - [Object.r]     {Int} - Red
         *                      - [Object.g]     {Int} - Green
         *                      - [Object.b]     {Int} - Blue
         *                      - [Object.h]     {Int} - Hue
         *                      - [Object.s]     {Int} - Saturation
         *                      - [Object.l]     {Int} - Lightness
         *                      - [Object.alpha] {Int} - Alpha
         */
        toObject: function () {
            return UWA.clone(this._color);
        },

        /**
         * Returns a new Color replacing this color components with the ones passed as
         * argument.
         *
         * @param {Object} components an object with optionaly any properties returned by
         * the toObject method.
         * @return {Color} the resulting UWA/Color
         * @example
         *
         * // Get a new color by setting its "green" component
         * var newColor = color.cloneWith({ g: 255 });
         *
         * // Get a new color by setting its "green" and "alpha" components
         * var newColor = color.cloneWith({ g: 255, alpha: 50 });
         */
        cloneWith: function (components) {
            var newComponents = Object.assign(this.toObject(), components);
            if (UWA.owns(components, "h") || UWA.owns(components, "s") || UWA.owns(components, "l")) {
                return Color.fromHSL(newComponents.h, newComponents.s, newComponents.l, newComponents.alpha);
            }

            if (UWA.owns(components, "r") || UWA.owns(components, "g") || UWA.owns(components, "b")) {
                return Color.fromRGB(newComponents.r, newComponents.g, newComponents.b, newComponents.alpha);
            }

            return new Color(newComponents);
        }
    });

    /**
     * Creating an UWA.Color object from RGB(a) values
     *
     * @param  {Int}   r - Red   : an integer between 0 and 255
     * @param  {Int}   g - Green : an integer between 0 and 255
     * @param  {Int}   b - Blue  : an integer between 0 and 255
     * @param  {Float} a - Alpha [optional] : a number between 0 and 1
     * @return {Object}  - An UWA.Color object
     *
     * @example
     * Color.fromRGB(255, 255, 255, .4);
     */
    Color.fromRGB = function (r, g, b, a) {
        var colorObj = {
            r: parseInt(r, 10),
            g: parseInt(g, 10),
            b: parseInt(b, 10),
            alpha: (a === undefined) ? 1 : parseFloat(a, 10)
        };

        Object.assign(colorObj, _rgbToHsl(colorObj));
        return new Color(colorObj);
    };

    /**
     * Creating an UWA.Color object from HSL(a) values
     *
     * @param  {Int}   h - Hue        : an integer between 0 and 360
     * @param  {Float} s - Saturation : a number between 0 and 100
     * @param  {Float} l - Lightness  : a number between 0 and 100
     * @param  {Float} a - Alpha [optional] : a number between 0 and 1
     * @return {Object}  - An UWA.Color object
     *
     * @example
     * Color.fromHSL(360, 100, 100, .4);
     */
    Color.fromHSL = function (h, s, l, a) {
        var colorObj = {
            h: parseInt(h, 10),
            s: parseFloat(s, 10),
            l: parseFloat(l, 10),
            alpha: (a === undefined) ? 1 : parseFloat(a, 10)
        };

        Object.assign(colorObj, _hslToRgb(colorObj));
        return new Color(colorObj);
    };

    /**
     * Parsing a Color string into an UWA.Color object
     *
     * @param  {String} colorString - The RVB, Hex or HSL string to parse
     * @return {Object}             - An UWA.Color object
     *
     * @example
     * Color.parse('rgb(0, 0, 0)');
     * Color.parse('rgba(0, 0, 0, .5)');
     * Color.parse('#ff0000');
     * Color.parse('ff0000');
     * Color.parse('hsl(0, 0%, 0%)');
     * Color.parse('hsla(0, 0%, 0%, .5)');
     */
    Color.parse = function (colorString) {
        // Supporting transparent colors
        if (colorString === 'transparent') {
            colorString = 'rgba(0, 0, 0, 0)';
        }

        var colorObj = {};
        var hexaReg = /^(#?)((?:[A-Fa-f0-9]{3}){1,2})$/m;
        var rgbaOrHslaReg = /^(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/m;
        var isHex = colorString.test(hexaReg);
        var matchRgbaOrHsla = colorString.match(rgbaOrHslaReg);

        // If color is an hexadecimal string
        if (isHex) {
            colorObj = _hexToRgb(colorString);
            colorObj.alpha = 1;
            Object.assign(colorObj, _rgbToHsl(colorObj));

            return new Color(colorObj);
        }

        // If color is an RGB(a) or HSL(a) string
        if (matchRgbaOrHsla && matchRgbaOrHsla.length > 0) {
            matchRgbaOrHsla.shift();
            var parse;
            var type = matchRgbaOrHsla[0];
            var alpha = matchRgbaOrHsla[5] ? parseFloat(matchRgbaOrHsla[5], 10) : 1;

            if (type === 'rgb') { // If color is an RGB color
                parse = Color.fromRGB;
            } else if (type === 'hsl') { // If color is an HSL color
                parse = Color.fromHSL;
            }

            return parse(matchRgbaOrHsla[2], matchRgbaOrHsla[3], matchRgbaOrHsla[4], alpha);
        }
    };

    /**
     * A WCAG 2.0 contrast ratio checker
     * More on a WCAG : https://www.w3.org/WAI/intro/wcag
     *
     * @param  {Object} foreground - An UWA.Color object for the front layer color
     * @param  {Object} background - An UWA.Color object for the background layer color
     * @return {Object}            - An object containing the contrast results :
     *                                  - [Object.ratio] {Int}     - The ratio of the contrast (between 0 and 22)
     *                                  - [Object.status] {String} - The status of the contrast
     *                                    "fail" "aa-large" "aa" or "aaa"
     *
     * @example
     * var foreground = Color.parse('#ffffff');
     * var background = Color.parse('#000000');
     * var contrast = Color.checkContrast(foreground, background);
     *
     * // contrast = { ratio: 21, status: 'aaa' }
     */
    Color.checkContrast = function (foreground, background) {
        var contrast = _getContrast(foreground.toObject(), background.toObject());
        var status;

        if (contrast.max >= 0 && contrast.min < 3) {
            status = 'fail';
        } else if (contrast.max >= 3 && contrast.min < 4.5) {
            status = 'aa-large';
        } else if (contrast.max >= 4.5 && contrast.min < 7) {
            status = 'aa';
        } else if (contrast.max >= 7 && contrast.min < 22) {
            status = 'aaa';
        }

        return {
            ratio: contrast.ratio,
            status: status
        };
    };

    /**
     * Enabling private methods to be unit tested
     */
    Color.__test__ = {
        hexToRgb: _hexToRgb,
        rgbToHsl: _rgbToHsl,
        hslToRgb: _hslToRgb,
        layerColors: _layerColors,
        getLuminance: _getLuminance,
        getContrast: _getContrast
    };

    return UWA.namespace('Color', Color, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Provides simple cross-platform API for DOM elements animation/effects.
 *
 * @module   UWA/Fx
 *
 */
define('UWA/Fx', [
    'UWA/Core',
    'UWA/String',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Class/Events',
    'UWA/Class/Timed',
    'UWA/Element',
    'UWA/Color'
], function (UWA, UWAString, Class, Options, Events, Timed, Element, Color) { // jshint ignore:line
    'use strict';

    // Check if property is one of the following: borderColor, backgroundColor color
    function isColorProperty(property) {
        return ['borderColor', 'backgroundColor', 'color'].indexOf(UWAString.camelCase(property)) !== -1;
    }

    function toNumber(value) {
        var result = Number(value);

        if (isNaN(result)) {
            result = parseInt(value, 10);
        }

        return isNaN(result) ? 0 : result;
    }

    var Fx = Class.extend(Options, Timed, Events, /** @lends module:UWA/Fx.UWA.Fx# */{ // bypass

        /**
         * The default options values.
         */
        defaultOptions: {
            transition: 'linear',
            duration: 500,
            unit: 'px',
            wait: false
        },

        /**
         * The current element affected by animation.
         */
        element: null,

        /**
         * The animation initial values.
         */
        from: null,

        /**
         * The animation final values.
         */
        to: null,

        /**
         * The animation current values.
         */
        current: null,

        /**
         * Simple cross-platform API for DOM elements animation/effects.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onStart`        | Triggered when the animation starts    |
         * | `onAnimate`      | Triggered on each animation frame      |
         * | `onComplete`     | Triggered when the animation ends      |
         *
         * @example
         *
         * // Create the element to animate
         * var myElement = UWA.createElement('div');
         *
         * // Initialize FX with myElement and some options
         * var fx = new UWA.Fx(myElement, {
         *    duration: 250,
         *    transition: 'bounceIn',
         *    events: {
         *        onStart: function () {
         *            // Callback trigered when the animation starts
         *        },
         *        onAnimate: function () {
         *            // Callback trigered on each animation frame
         *        },
         *        onComplete: function () {
         *            // Callback trigered when the animation ends
         *        }
         *    }
         * });
         *
         * // Run Fx from a range to another
         * fx.start({
         *    backgroundColor: ['#FF0000', '#0000FF'],
         *    padding: [10, 20],
         *    height: [10, 200],
         *    width: [10, 200],
         *    opacity: [0, 1]
         * });
         *
         * // Run Fx from current values to new one
         * fx.start({
         *    backgroundColor: '#FF0000',
         *    padding: 10,
         *    height: 10,
         *    width: 10,
         *    opacity: 0
         * });
         *
         * // OR
         * fx.fade();
         *
         * // OR
         * fx.tween('color', '#0000FF', '#FF0000');
         *
         * @param {Element} element - A valid DOM element
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.transition='linear'] - The equation name to use for the effect
         * @param {Number} [options.duration=500] - The duration of the effect in ms
         * @param {String} [options.unit='px'] - The unit, e.g. 'px', 'em', or '%'
         * @param {Boolean} [options.wait=false] - Wait that the current animation complete before start new one
         *
         * @constructs UWA.Fx
         * @mixes UWA.Class.Options
         * @mixes UWA.Class.Timed
         * @mixes UWA.Class.Events
         *
         * @memberOf module:UWA/Fx
         */
        init: function (element, options) {

            var that = this;

            // Store Animated Element
            that.element = element;

            // Set steps default values
            that.from = {};
            that.to = {};
            that.queue = [];

            // Set Instance Options
            that.setOptions(options);
        },

        /**
         * Start the animation of one CSS property.
         *
         * @param {String} property - The css property to set the value to
         * @param {String} from - The css property value to set at start
         * @param {String} to - The css property value to set at the end
         * @return {this}
         */
        tween: function (property, from, to) {

            var obj = {};
            obj[property] = [from, to];

            return this.start(obj);
        },

        /**
         * Element shortcut method for tween with opacity.
         * Useful for fading an Element in and out or to a certain opacity level.
         *
         * @param {String} how - The opacity level as a number or string representation.
         * Possible values include:
         *
         * - `in`       Fade the element to 100% opacity.
         * - `out`      Fade the element to 0% opacity.
         * - `show`     Immediately set the element's opacity to 100%.
         * - `hide`     Immediately set the element's opacity to 0%.
         * - `toggle`   If visible, fade the element out, otherwise, fade it in.
         * - `(float)`  A float value between 0 and 1. Will fade the element to this opacity.
         *
         * @return {this}
         */
        fade: function (how) {

            how = how !== undefined ? how : 'toggle';

            var property = 'opacity',
                current = Element.getOpacity.call(this.element),
                obj = {};

            obj[property] = [];

            switch (how) {
            case 'in':
                obj[property] = [current, 1];
                break;
            case 'out':
                obj[property] = [current, 0];
                break;
            case 'show':
                obj[property] = [1, 1];
                break;
            case 'hide':
                obj[property] = [0, 0];
                break;
            case 'toggle':
                if (current < 1) {
                    obj[property] = [current, 1];
                } else {
                    obj[property] = [current, 0];
                }
                break;
            default:
                obj[property] = [current, how];
            }

            return this.start(obj);
        },

        /**
         * Start the animation of multiple CSS properties at once.
         *
         * @param {Object} properties - An object of key/value pairs of CSS attributes to
         * change or a string representing a CSS selector which can be found within
         * the CSS of the page.
         *
         * If only one value is given for any CSS property, the transition will
         * be from the current value of that property to the value given.
         * @return {this}
         */
        start: function (properties) {

            var that = this;

            if (!that.options.wait || !that.hasAnimate('fx')) {

                // Clear previous timer
                // Does not cancel if not exist cause it's cancel
                // all animation in some browsers (e.g chrome, opera)
                that.stop();

                that.setSteps(properties);

                // Trigger onStart
                that.dispatchEvent('onStart');

                // Launch Animation
                that.startTime = Date.now();
                that.current = {};

                // Trigger animate loop
                that.animate();

            } else {
                that.queue.push(properties);
            }

            return that;
        },

        /**
         * Pause the current animation.
         *
         * @return {this}
         */
        pause: function () {

            var that = this;

            that.clearAnimate('fx');

            return that;
        },

        /**
         * Stop the current animation and clear next steps.
         *
         * @return {this}
         */
        stop: function () {

            var that = this;

            that.pause();

            that.from = {};
            that.to = {};

            return that;
        },

        /**
         * Populate `to` and `from` based on the properties parameter.
         *
         * @param {Object} properties - An object of key/value pairs of CSS attributes to
         * change or a string representing a CSS selector which can be found within
         * the CSS of the page.
         *
         * If only one value is given for any CSS property, the transition will
         * be from the current value of that property to the value given.
         */
        setSteps: function (properties) {

            var property,
                that = this,
                from = {},
                to = {};

            for (property in properties) {
                if (properties.hasOwnProperty(property)) {

                    // Set property name to camelCase
                    property = UWAString.camelCase(property);

                    if (Array.isArray(properties[property])) {
                        from[property] = properties[property][0];
                        to[property] = properties[property][1];
                    } else {
                        from[property] = Element.getStyle.call(that.element, property);
                        to[property] = properties[property];
                    }

                    // Convert Color properties to Rgb Array
                    if (isColorProperty(property)) {
                        var fromColorObj = Color.parse(from[property]).toObject();
                        var toColorObj = Color.parse(to[property]).toObject();
                        from[property] = [ fromColorObj.r, fromColorObj.g, fromColorObj.b, fromColorObj.alpha ];
                        to[property] = [ toColorObj.r, toColorObj.g, toColorObj.b, toColorObj.alpha ];

                    // Convert Other properties to Number
                    } else {
                        from[property] = toNumber(from[property]);
                        to[property] = toNumber(to[property]);
                    }
                }
            }

            that.from = from;
            that.to = to;
        },

        /**
         * Compute the step value using from, to parameters,
         * transition options, currentTime and duration.
         *
         * @param {Number} from - The start value
         * @param {Number} to - The end value
         * @return {Number} Computed value result.
         */
        compute: function (from, to) {

            var value,
                options = this.options,
                transition = options.transition,
                duration = options.duration,
                transitionType = UWA.typeOf(transition);

            // By name using string
            if (transitionType === 'string') {

                // Check valid name
                if (!UWA.is(Fx.Transitions[transition], 'function')) {
                    throw new Error('Invalid UWA.FX transition option value.');
                } else {
                    transition = Fx.Transitions[transition];
                }

            // By bezier control points using array
            } else if (transitionType === 'array') {
                transition = Fx.Transitions.cubicBezier.apply(null, transition);

            // Else invalid if not a function
            } else if (transitionType !== 'function') {
                throw new Error('Invalid UWA.FX transition option value.');
            }

            if (duration > 0 && from !== to) {
                value = transition(this.currentTime, from, to - from, duration);
            } else {
                value = to;
            }

            if (isNaN(value)) {
                throw new Error(UWAString.format('Invalid UWA.FX transition computation value with from "{0}" to "{1}".', from, to));
            }

            return value;
        },

        /**
         * Run the animation steps loop.
         */
        animate: function () {

            var isLastFrame,
                that = this,
                time = Date.now(),
                duration = that.options.duration,
                startTime = that.startTime;

            if (time < startTime + duration) {
                that.currentTime = time - startTime;
            } else {
                that.currentTime = duration;
                isLastFrame = true;
            }

            // Trigger onAnimate
            that.dispatchEvent('onAnimate', [that.element, that.from, that.to]);

            // Detect last frame
            if (isLastFrame) {

                // Clear previous timer
                that.stop();

                // Trigger onComplete
                that.dispatchEvent('onComplete');

                // Run next animation on queue
                if (that.queue.length > 0) {
                    that.start(that.queue.shift());
                }

                that.lastTime = null;

            // Request another animation frame
            } else {

                that.setAnimate('fx', that.animate);
            }

            that.fps = 1000 / (time - (that.lastTime || time));
            that.lastTime = time;
        },

        /* Group: Events Methods */

        /**
         * Called on each step of the animation in order to perform the
         * animation step on the element using <compute> on the to and from
         * parameters properties value pair to get the current value of the
         * properties to animate.
         *
         * @param {Element} element - The element attached
         * @param {Number} from - The start value
         * @param {Number} to - The end value
         */
        onAnimate: function (element, from, to) {

            var style, value,
                that = this,
                styles = {};

            for (style in from) {
                if (from.hasOwnProperty(style)) {
                    if (isColorProperty(style)) {
                        value = 'rgba(' +
                            Math.round(that.compute(from[style][0], to[style][0])) + ',' +
                            Math.round(that.compute(from[style][1], to[style][1])) + ',' +
                            Math.round(that.compute(from[style][2], to[style][2])) + ',' +
                            that.compute(from[style][3], to[style][3]) + ')';

                    } else {
                        value = that.compute(from[style], to[style]);
                    }

                    // Skip style if it have already the same value
                    // to reduce styles recalculation and repaint.
                    if (that.current[style] !== value) {
                        styles[style] = value;
                    }
                }
            }

            that.current = styles;

            Element.setStyles.call(element, styles);
        }
    });

    /**
     * A collection of tweening transitions for use with the UWA.Fx classes.
     *
     * @property {Function} linear - Displays a linear transition
     * @property {Function} quadIn - Displays a quadratic transition in
     * @property {Function} quadOut - Displays a quadratic transition out
     * @property {Function} quadInOut - Displays a quadratic transition in and out
     * @property {Function} cubicIn - Displays a cubicular transition in
     * @property {Function} cubicOut - Displays a cubicular transition out
     * @property {Function} cubicInOut - Displays a cubicular transition in and out
     * @property {Function} quartIn - Displays a quartetic transition in
     * @property {Function} quartOut - Displays a quartetic transition out
     * @property {Function} quartInOut - Displays a quartetic transition in and out
     * @property {Function} quintIn - Displays a quintic transition in
     * @property {Function} quintOut - Displays a quintic transition out
     * @property {Function} quintInOut - Displays a quintic transition in and out
     * @property {Function} sineIn - Displays a sineousidal transition in
     * @property {Function} sineOut - Displays a sineousidal transition out
     * @property {Function} sineInOut - Displays a sineousidal transition in and out
     * @property {Function} expoIn - Displays a exponential transition in
     * @property {Function} expoOut - Displays a exponential transition out
     * @property {Function} expoInOut - Displays a exponential transition in and out
     * @property {Function} circIn - Displays a circular transition in
     * @property {Function} circOut - Displays a circular transition out
     * @property {Function} circInOut - Displays a circular transition in and out
     * @property {Function} backIn - Makes the transition go back in
     * @property {Function} backOut - Makes the transition go back out
     * @property {Function} backInOut - Makes the transition go back, then all forth
     * @property {Function} elasticIn - Makes the transition as elastic curve in
     * @property {Function} elasticOut - Makes the transition as elastic curve out
     * @property {Function} elasticInOut - Makes the transition as elastic curve in and out
     * @property {Function} bounceIn - Makes the transition bouncy in
     * @property {Function} bounceOut - Makes the transition bouncy out
     * @property {Function} bounceInOut - Makes the transition bouncy in and out
     *
     * @see {@link http://sol.gfxile.net/interpolation/}
     * @see {@link http://gizma.com/easing/#cub2}
     * @see {@link http://timotheegroleau.com/Flash/experiments/easing_function_generator.htm}
     *
     * @todo http://greweb.me/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/
     * @todo http://www.greensock.com/customease/
     *
     * @alias Transitions
     * @type {Object}
     * @memberOf module:UWA/Fx.UWA.Fx
     * @static
     */
    Fx.Transitions = {

        /**
         * Displays a linear transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > No easing, no acceleration.
         */
        linear: function (t, b, c, d) {
            return c * t / d + b;
        },

        /**
         * Displays a quadratic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        quadIn: function (t, b, c, d) {
            return c * (t /= d) * t + b;
        },

        /**
         * Displays a quadratic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        quadOut: function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },

        /**
         * Displays a quadratic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        quadInOut: function (t, b, c, d) {
            return ((t /= d / 2) < 1) ?
                    (c / 2 * t * t + b) :
                    (-c / 2 * ((--t) * (t - 2) - 1) + b);
        },

        /**
         * Displays a cubicular transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        cubicIn: function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },

        /**
         * Displays a cubicular transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        cubicOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },

        /**
         * Displays a cubicular transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        cubicInOut: function (t, b, c, d) {
            return ((t /= d / 2) < 1) ?
                    (c / 2 * t * t * t + b) :
                    (c / 2 * ((t -= 2) * t * t + 2) + b);
        },

        /**
         * Displays a quartetic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        quartIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },

        /**
         * Displays a quartetic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        quartOut: function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },

        /**
         * Displays a quartetic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        quartInOut: function (t, b, c, d) {
            return ((t /= d / 2) < 1) ?
                    (c / 2 * t * t * t * t + b) :
                    (-c / 2 * ((t -= 2) * t * t * t - 2) + b);
        },

        /**
         * Displays a quintic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * Note:
         * * Accelerating from zero velocity.
         */
        quintIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },

        /**
         * Displays a quintic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        quintOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },

        /**
         * Displays a quintic transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * Note:
         * * Acceleration until halfway, then deceleration.
         */
        quintInOut: function (t, b, c, d) {
            return ((t /= d / 2) < 1) ? (c / 2 * t * t * t * t * t + b) : (c / 2 * ((t -= 2) * t * t * t * t + 2) + b);
        },

        /**
         * Displays a sineousidal transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        sineIn: function (t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },

        /**
         * Displays a sineousidal transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * Note:
         * * Decelerating to zero velocity.
         */
        sineOut: function (t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },

        /**
         * Displays a sineousidal transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        sineInOut: function (t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },

        /**
         * Displays a exponential transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        expoIn: function (t, b, c, d) {
            return (t === 0) ? b : (c * Math.pow(2, 10 * (t / d - 1)) + b);
        },

        /**
         * Displays a exponential transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        expoOut: function (t, b, c, d) {
            return (t === d) ? (b + c) : (c * (-Math.pow(2, -10 * t / d) + 1) + b);
        },

        /**
         * Displays a exponential transition.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        expoInOut: function (t, b, c, d) {
            if (t === 0) {
                return b;
            }

            if (t === d) {
                return b + c;
            }

            return ((t /= d / 2) < 1) ?
                    (c / 2 * Math.pow(2, 10 * (t - 1)) + b) :
                    (c / 2 * (-Math.pow(2, -10 * --t) + 2) + b);
        },

        /**
         * Displays a circular transition in.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        circIn: function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },

        /**
         * Displays a circular transition out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        circOut: function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },

        /**
         * Displays a circular transition in and out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        circInOut: function (t, b, c, d) {
            return ((t /= d / 2) < 1) ?
                    (-c / 2 * (Math.sqrt(1 - t * t) - 1) + b) :
                    (c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b);
        },

        /**
         * Makes the transition go back in.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        backIn: function (t, b, c, d, s) {
            s = (!s ? 1.70158 : s);
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },

        /**
         * Makes the transition go back out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        backOut: function (t, b, c, d, s) {
            s = (!s ? 1.70158 : s);
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },

        /**
         * Makes the transition go back, then all forth.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        backInOut: function (t, b, c, d, s) {
            s = (!s ? 1.70158 : s);

            return ((t /= d / 2) < 1) ?
                    (c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b) :
                    (c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b);
        },

        /**
         * Makes the transition as elastic curve in.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        elasticIn: function (t, b, c, d, a, p) {

            var s;

            if (t === 0) {
                return b;
            }

            if ((t /= d) === 1) {
                return b + c;
            }

            p = (!p ? d * 0.3 : p);
            a = (!a ? 1 : a);

            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }

            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },

        /**
         * Makes the transition as elastic curve out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        elasticOut: function (t, b, c, d, a, p) {

            var s;

            if (t === 0) {
                return b;
            }

            if ((t /= d) === 1) {
                return b + c;
            }

            p = (!p ? d * 0.3 : p);
            a = (!a ? 1 : a);

            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }

            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
        },

        /**
         * Makes the transition as elastic curve in and out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        elasticInOut: function (t, b, c, d, a, p) {

            var s, e;

            if (t === 0) {
                e = b;
            } else if ((t /= d / 2) === 2) {
                e = b + c;
            } else {

                p = (!p ? d * (0.3 * 1.5) : p);
                a = (!a ? 1 : a);

                if (a < Math.abs(c)) {
                    a = c;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(c / a);
                }

                if (t < 1) {
                    e = (-0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b);
                } else {
                    e = (a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b);
                }
            }

            return e;
        },

        /**
         * Makes the transition bouncy in.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Accelerating from zero velocity.
         */
        bounceIn: function (t, b, c, d) {
            return c - Fx.Transitions.bounceOut(d - t, 0, c, d) + b;
        },

        /**
         * Makes the transition bouncy out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Decelerating to zero velocity.
         */
        bounceOut: function (t, b, c, d) {
            var e;

            if ((t /= d) < (1 / 2.75)) {
                e = c * (7.5625 * t * t) + b;
            } else if (t < (2 / 2.75)) {
                e = c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            } else if (t < (2.5 / 2.75)) {
                e = c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            } else {
                e = c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
            }

            return e;
        },

        /**
         * Makes the transition bouncy int and out.
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         *
         * > Acceleration until halfway, then deceleration.
         */
        bounceInOut: function (t, b, c, d) {
            var Transitions = Fx.Transitions;

            return (t < d / 2) ?
                    (Transitions.bounceIn(t * 2, 0, c, d) * 0.5 + b) :
                    (Transitions.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b);
        },

        /**
         * Create a transition function based on quintic bezier control points.
         *
         * - Number p0: First control point value.
         * - Number p1: Second control point value.
         * - Number p2: Third control point value.
         * - Number p3: Fouth control point value.
         * - Number p4: Fift control point value.
         * - Number p5: Last control point value.
         *
         * > The result animation function parameters are following:
         *
         * @example
         *
         * // Create the element to animate
         * var myElement = UWA.createElement('div');
         *
         * // UWA quinticBezier Transitions (cubicOut)
         * new UWA.Fx(box5, {
         *    duration: 1000,
         *    transition: UWA.Fx.Transitions.quinticBezier(0, 0.6, 0.9, 1, 1, 1)
         * }).start({
         *    left: [0, 100]
         * });
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @return {Function} Ready to use animation function with t, b, c, d parameters.
         */
        quinticBezier: (function () {

            // Inspired from Flash implementation of Easing Function Generator
            // by Timothie Groleau - 20 September 2003.

            // caluclate bezier polynomials based on control points' location
            function getPolynomials(c0, c1, c2, c3, c4, c5) {

                var e = 5 * (c1 - c0),
                    d = 10 * (c2 - c0) - 4 * e,
                    c = 10 * (c3 - c0) + 30 * (c1 - c2),
                    b = 5 * (c4 + c0) - 20 * (c3 + c1) + 30 * c2,
                    a = c5 - c0 - b - c - d - e;

                return {
                    a: a,
                    b: b,
                    c: c,
                    d: d,
                    e: e
                };
            }

            return function (p0, p1, p2, p3, p4, p5) {

                var offset = p0,
                    scale = p5 - p0,
                    x1 = (p1 - offset) / scale,
                    x2 = (p2 - offset) / scale,
                    x3 = (p3 - offset) / scale,
                    x4 = (p4 - offset) / scale,
                    f = getPolynomials(offset, x1, x2, x3, x4, scale);

                // Number t: Current time.
                // Number b: Start value.
                // Number c: Change in value.
                // Number d: Duration.
                return function (t, b, c, d) {

                    var ts,
                        tc,
                        curT = (t / d),
                        curTx = curT * curT,
                        curTy = curTx * t;

                    if (f.a || f.c) {
                        if (f.b || f.d) {
                            ts = curTx;
                            tc = curTx * curT;
                        } else {
                            tc = curTy;
                        }
                    } else if (f.b || f.d) {
                        ts = curTy;
                    }

                    return b + c * (
                        (f.a * curTx) +
                        (f.b * curTx) +
                        (f.c * tc) +
                        (f.d * ts) +
                        (f.e * curT)
                    );
                };
            };
        }()),

        /**
         * Create a transition function based on cubic bezier control points.
         *
         * - Number p1x: First control point x axis value.
         * - Number p1y: First control point y axis value.
         * - Number p2x: Second control point x axis value.
         * - Number p2y: Second control point y axis value.
         *
         * > The result animation function parameters are following:
         *
         * @example
         *
         * // Create the element to animate
         * var myElement = UWA.createElement('div');
         *
         * // UWA cubicBezier Transitions (cubicOut)
         * new UWA.Fx(box5, {
         *    duration: 1000,
         *    transition: UWA.Fx.Transitions.cubicBezier(0.215, 0.61, 0.355, 1)
         * }).start({
         *    left: [0, 100]
         * });
         *
         * // UWA cubicBezier array notation (cubicOut)
         * new UWA.Fx(box5, {
         *    duration: 1000,
         *    transition: [0.215, 0.61, 0.355, 1]
         * }).start({
         *    left: [0, 100]
         * });
         *
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @return {Function} Ready to use animation function with t, b, c, d parameters.
         */
        cubicBezier: (function () {

            // caluclate bezier polynomials based on control points' location
            function getPolynomials(c0, c1, c2, c3) {

                var cx = 3.0 * c0,
                    bx = 3.0 * (c2 - c0) - cx,
                    ax = 1.0 - cx - bx,
                    cy = 3.0 * c1,
                    by = 3.0 * (c3 - c1) - cy,
                    ay = 1.0 - cy - by;

                return {
                    ax: ax,
                    bx: bx,
                    cx: cx,
                    ay: ay,
                    by: by,
                    cy: cy
                };
            }

            function getEpsilon(d) {
                return (1000 / 60 / d) / 4;
            }

            function sampleCurveX(t, f) {
                return ((f.ax * t + f.bx) * t + f.cx) * t;
            }

            function sampleCurveY(t, f) {
                return ((f.ay * t + f.by) * t + f.cy) * t;
            }

            function sampleCurveDerivativeX(t, f) {
                return (3.0 * f.ax * t + 2.0 * f.bx) * t + f.cx;
            }

            function solveCurveX(x, f, epsilon) {

                var i, t0, t1, t2, x2, d2, result;

                // First try a few iterations of Newton's method -- normally very fast.
                for (t2 = x, i = 0; i < 8; i++) {

                    x2 = sampleCurveX(t2, f) - x;

                    if (Math.abs(x2) < epsilon) {
                        return t2;
                    }

                    d2 = sampleCurveDerivativeX(t2, f);
                    if (Math.abs(d2) < epsilon) {
                        break;
                    }

                    t2 = t2 - x2 / d2;
                }

                // No solution found - use bi-section
                t0 = 0.0;
                t1 = 1.0;
                t2 = x;

                if (t2 < t0) {
                    result = t0;
                } else if (t2 > t1) {
                    result = t1;
                } else {

                    while (t0 < t1) {

                        x2 = sampleCurveX(t2, f);

                        if (Math.abs(x2 - x) < epsilon) {
                            return t2;
                        }

                        if (x > x2) {
                            t0 = t2;
                        } else {
                            t1 = t2;
                        }

                        t2 = (t1 - t0) * 0.5 + t0;
                    }

                    // Give up
                    result = t2;
                }

                return result;
            }

            function solve(x, f, epsilon) {
                return sampleCurveY(solveCurveX(x, f, epsilon), f);
            }

            return function (p1x, p1y, p2x, p2y) {

                // pre-calculate the polynomial coefficients
                // First and last control points are implied to be (0,0) and (1.0, 1.0)
                var f = getPolynomials(p1x, p1y, p2x, p2y);

                // Number t: Current time.
                // Number b: Start value.
                // Number c: Change in value.
                // Number d: Duration.
                return function (t, b, c, d) {

                    var curT = (t / d),
                        epsilon = getEpsilon(d),
                        t1 = solve(curT, f, epsilon),
                        s1 = 1.0 - t1;

                    return (b * s1) + ((b + c) * t1);
                };
            };
        }())
    };

    return UWA.namespace('Fx', Fx, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Plugins/Abstract
 *
 */
define('UWA/Plugins/Abstract', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options'
], function (UWA, Class, Options) {
    'use strict';

    /**
     * @class UWA.Plugins.Abstract
     * @extends UWA.Class.Options
     */
    var Abstract = Class.extend(Options, /** @lends module:UWA/Plugins/Abstract.UWA.Plugins.Abstract# */{ // bypass

        /**
         * This object is made to implement widget custom plugins over widget events
         * and widget content handling.
         *
         * Examples of Plugins:
         *
         * - Auth Service with Form
         * - Search Results Highlite into Widget body
         * - Google Analitycs tracker
         * - Google Ads
         * - Resize Corner
         * - Must be Online else widget is not availble
         *
         * ##### Examples
         *
         * Using plugin in Widget Javascript:
         *
         * ```html
         * <script type="text/javascript" src="http://cdn.uwa.preview.netvibes.com/lib/c/UWA/js/UWA_Plugins_GoogleAnalytics.js"></script>
         * <script type="text/javascript">
         *    var MyPlugin = new UWA.Plugins.MyPlugin(widget, {
         *        'myName': 'John'
         *    });
         * </script>
         * ```
         *
         * Using plugin in Widget Manifest:
         *
         * ```html
         * <widget:plugins>
         *    <widget:plugin name="MyPluginClass">
         *        <widget:option name="myName" value="John">
         *    </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Or:
         *
         * ```html
         * <widget:plugins>
         *    <widget:plugin name="MyPluginClass">
         *        <widget:options name="myData">
         *              <widget:option name="myName" value="John" />
         *              <widget:option name="mySex" value="male" />
         *              <widget:option name="myAge" value="18" />
         *        </widget:options>
         *    </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Plugin onLoad example:
         *
         * ```
         * this.addEvent('onLoad', function onLoad() {
         *    this.removeEvent('onLoad', onLoad);
         *    this.dispatchEvent('onLoad');
         *    return `false`;
         * });
         * ```
         *
         * @param {Object} widget
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Plugins.Abstract
         * @memberof module:UWA/Plugins/Abstract
         */
        init: function (widget, options) {
            this.widget = widget;
            this.environment = widget.environment;

            // Set options
            this.setOptions(options);
        },

        /**
         * Executes the listeners method associated with the given event name.
         *
         * > Internal or advanced use only.
         *
         * @param {String} name - The event name (e.g. "onUpdateTitle");
         * @param {Array} args - Array of parameters that should be passed to each listener
         * @param {Object} bind - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         *
         * @return {Void} Nothing but calls the listeners associated with the given event name.
         */
        dispatchEvent: function (name, args, bind) {
            this.environment.dispatchEvent(name, args, bind);
        },

        /**
         * Add an listener method associated with the given event name.
         *
         * > Internal or advanced use only.
         *
         * @param {String} name - The event name (e.g. "onUpdateTitle")
         * @param {Function} listener - Listener function that will be executed when event is triggered
         * @param {Object} bind - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         * @param {Number} priority - The priority level of the listener. Listeners with higher priority will be executed before listeners with lower priority
         * Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         */
        addEvent: function (name, listener, bind, priority) {
            this.environment.addEvent(name, listener, bind || this, priority);
        },

        /**
         * Add listeners methods associated with the given event name.
         *
         * > Internal or advanced use only.
         *
         * @param {Object} events - The listeners methods indexed by name (e.g. {"onUpdateTitle", function() {}})
         * @param {Object} bind - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         * @param {Number} priority - The priority level of the listener. Listeners with higher priority will be executed before listeners with lower priority
         */
        addEvents: function (events, bind, priority) {
            var event;
            for (event in events) {
                if (events.hasOwnProperty(event)) {
                    this.addEvent(event, events[event], bind, priority);
                }
            }
        },

        /**
         * Specified name ONLY: Remove ALL events of given name.
         * Specified name AND listener function: Remove that given listener from
         * this event name's stack.
         *
         * > Internal or advanced use only.
         *
         * @param {String} name - event name (optional)
         * @param {Function} listener - function to remove (optional)
         */
        removeEvent: function (name, listener) {
            this.environment.removeEvent(name, listener);
        }
    });

    return UWA.namespace('Plugins/Abstract', Abstract, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, WeakMap
*/

/**
 * This module provides the abstract base class for all controls.
 *
 * @module   UWA/Controls/Abstract
 *
 */
define('UWA/Controls/Abstract', [
    'vendors/webcomponents/MutationObserver',
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Class/Events',
    'UWA/Utils'
], function (MutationObserver, UWA, Class, Options, Events, Utils) {
    'use strict';

    var forEach = [].forEach;
    var controlMap = new WeakMap();
    var observers = new WeakMap();

    function recursiveForEach(nodeList, fn) {
        var i, l;
        for (i = 0, l = nodeList.length; i < l; i++) {
            var node = nodeList[i];
            if (node.nodeType === 1) {
                fn(node);

                var j, k;
                var children = node.getElementsByTagName('*');
                for (j = 0, k = children.length; j < k; j++) {
                    fn(children[j]);
                }
            }
        }
    }

    function makeObserver(el) {
        var document, html;
        try {
            document = el && (el.ownerDocument || el.document || el);
            html = document && document.documentElement;
        } catch (e) {
            // Probably a cross origin iframe
        }
        if (!html || observers.has(html)) {
            return;
        }

        var observer = new MutationObserver(function (events) {
            function dispatchEvent(node, add, event) {
                var control = controlMap.get(node);
                if (!control) {
                    if (node.tagName === 'IFRAME') {
                        makeObserver(node.contentWindow);
                    }
                    return;
                }

                control.dispatchEvent(add ? 'onInjected' : 'onRemoved', event);
            }

            forEach.call(events, function (event) {
                var controlEvent = {
                    nextSibling: event.nextSibling || null,
                    previousSibling: event.previousSibling || null,
                    parentNode: event.target
                };

                recursiveForEach(event.addedNodes, function (node) {
                    dispatchEvent(node, true, controlEvent);
                });

                recursiveForEach(event.removedNodes, function (node) {
                    dispatchEvent(node, false, controlEvent);
                });
            });
        });

        observers.set(html, observer);

        observer.observe(html, { childList: true, subtree: true });
    }

    makeObserver(UWA.getGlobal());

    var Abstract = Class.extend(Options, Events, /** @lends module:UWA/Controls/Abstract.UWA.Controls.Abstract# */{ // bypass

        /**
         * The current control elements.
         *
         * @protected
         * @type {Object}
         */
        elements: null,


        /**
         * This Class provides the foundation for all custom Controls Classes.
         * All of the other Controls Classes inherit from this one.
         *
         * > This abstract class *CANNOT* be instanciate.
         *
         * ##### Available Events
         *
         * | Event             | Description                                                         |
         * | ----------------- | ------------------------------------------------------------------- |
         * | `onPreInject`     | Triggered before inject                                             |
         * | `onPostInject`    | Triggered after inject                                              |
         * | `onResize`        | Invoked when control needs to resize                                |
         * | `onInjected`      | Triggered asynchronously when the content gets injected in the DOM  |
         * | `onRemoved`       | Triggered asynchronously when the content gets removed from the DOM |
         *
         * The `onInjected` and `onRemoved` events are debounced (if the content gets
         * injected then removed then injected, only `onInjected` will be triggered) and
         * will be triggered with an object as argument. This object will hold three
         * properties informing on the position of the content in the DOM before it was
         * removed (in the `onRemoved` case) or after it has been injected (in the
         * `onInjected` case):
         *
         *  * `previousSibling`: the previous sibling of the content or `null` if it was
         * the first child
         *  * `nextSibling`: the next sibling of the content or `null` if it was the last
         * child
         *  * `parentNode`: the parent node of the content.
         *
         * *Warning*: the `onRemoved` event may be triggered because someone did destroy
         * the elements recursively in a parent node. Elements of the control may be
         * destroyed: detached from the DOM recursively and events removed.
         *
         * @example
         * var newcontrol = UWA.Controls.Abstract.extend({
         *     // Your Control Implementation
         * });
         *
         * @param {Object} options - options hash or a option/value pair
         *
         * @constructs UWA.Controls.Abstract
         * @mixes module:UWA/Class/Options.UWA.Class.Options
         * @mixes module:UWA/Class/Events.UWA.Class.Events
         * @memberof module:UWA/Controls/Abstract
         */
        init: function (options) {

            // Init Instance properties
            this.elements = {};

            // Set options
            this.setOptions(options);
        },

        /**
         * Inject control in the dom.
         *
         * @param {HTMLelement} element - Dom target
         * @param {String} [where] - Where to inject
         * @return {this}
         */
        inject: function (element, where) {
            var content = this.getContent();
            if (content) {
                var previous = controlMap.get(content);
                if (previous && previous !== this) {
                    throw new Error('This control container element is already owned by another control!');
                }
                controlMap.set(content, this);
                makeObserver(element);
                this.dispatchEvent('onPreInject', [element]);
                content.inject(element, where);
                this.dispatchEvent('onPostInject', [element]);
                this.dispatchEvent('onResize', [element]);
            }
            return this;
        },

        /**
         * Remove the control from the dom
         *
         * @return {this}
         */
        remove: function () {
            var content = this.getContent();
            if (content) {
                content.remove();
            }
            return this;
        },

        /**
         * Returns control content.
         *
         * @return {HTMLelement} Control container.
         */
        getContent: function () {

            if (!this.elements.container && !this.container) {
                throw new Error("You don't have an elements.container or container.");
            }

            return this.elements.container || this.container;
        },

        /**
         * Generate a CSS class name based on the class `name` property, its
         * parent classes, and the options "className". It should be used
         * internally (in the control).
         *
         * @example
         * var Input = UWA.Controls.Abstract.extend({
         *    name: 'uwa-input',
         *
         *    options: {
         *        className: '',
         *    },
         *
         *    buildSkeleton: function () {
         *        this.elements.container = UWA.createElement('div', { 'class': this.getClassNames() });
         *        this.elements.content = UWA.createElement('div', { 'class': this.getClassNames('-content') });
         *    }
         * });
         *
         * var Radio = Input.extend({
         *    name: 'uwa-inputradio'
         * });
         *
         * new Radio({
         *     className: 'toto black'
         * });
         * // container will have the class 'toto black uwa-inputradio uwa-input'
         * // content will have the class 'toto black uwa-inputradio-content uwa-input-content'
         *
         * @param {String} suffixes - All parameters should be strings, used as
         *  suffix to append to the UWA.Class names of the inheritance chain.
         * @return {String} The generated CSS class name.
         */
        getClassNames: function () {
            var constructor = this.constructor,
                suffixes = Utils.toArray(arguments),
                className = this.options.className || '',
                // className could be an array of classes.
                result = Utils.splat(className).join(' ');

            // If called without argument, default to "no suffix"
            if (!suffixes.length) {
                suffixes = [''];
            }

            if (suffixes.indexOf('') >= 0 && this.options._root !== false) {
                suffixes.push('-root');
            }

            // Iterate over the inheritance chain and use UWA.Class names as css classes, with the given suffixes
            while (constructor) {
                if (constructor.prototype.name) {
                    result += ' ' + constructor.prototype.name + suffixes.join(' ' + constructor.prototype.name);
                }
                constructor = constructor.parent;
            }

            return result;
        },

        /**
         * Hide control content.
         */
        hide: function () {
            this.getContent().hide();
            return this.dispatchEvent('onHide');
        },

        /**
         * Show control content.
         */
        show: function () {
            this.getContent().show();
            return this.dispatchEvent('onShow');
        },

        /**
         * Destroy the control elements and its children.
         * Remove all events and remove the element from the dom.
         * This control and its children should not be used
         * after this.
         */
        destroy: function () {

            var element,
                elements = this.elements || {};

            // Deal with container out of elements
            if (this.container) {
                elements.container = this.container;
            }

            if (this.elements.container) {
                controlMap['delete'](this.elements.container);
            }

            // Remove Elements
            for (element in elements) {
                if (elements.hasOwnProperty(element)) {
                    elements[element].destroy();

                    // Remove reference
                    delete elements[element];
                }
            }

            this.removeEvents();

            // If this control inherits from Timed, clear it.
            if (this.clearAllTimed) {
                this.clearAllTimed();
            }
        }
    });


    var controlLink = new WeakMap();

    Abstract._getClosestControlFromElement = function (element) {
        while (element) {
            var control = controlLink.get(element);
            if (control) {
                return control;
            }
            element = element.parentNode;
        }
        return null;
    };

    Abstract._getClosestControlsFromElement = function (element) {
        var result = [];
        while (element) {
            var control = controlLink.get(element);
            if (control && result.indexOf(control) < 0) {
                result.push(control);
            }
            element = element.parentNode;
        }
        return result;
    };

    Abstract._linkElementToControl = function (control, element) {
        var current = controlLink.get(element);
        if (current) {
            if (current !== control) {
                throw new Error('This element is already linked to another control');
            }
            return;
        }
        controlLink.set(element, control);
    };

    return UWA.namespace('Controls/Abstract', Abstract, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout
*/

/**
 * @module   UWA/Controls/Pager
 *
 */
define('UWA/Controls/Pager', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Controls/Abstract'
], function (UWA, Event, Abstract) {
    'use strict';

    var Pager = Abstract.extend(/** @lends module:UWA/Controls/Pager.UWA.Controls.Pager# */{ // bypass



        offset: 0,

        limit: 0,

        max: 0,

        length: 0,

        loadingData: false,

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: 'uwa-pager nv-pager',

            // Display
            type: 0,
            showPageLinks: false,
            showMoreLink: false,
            pageLinks: 5,

            // Data
            length: 0,
            offset: 0,
            limit: 10,
            max: 0,
            loadNext: null,

            // Labels
            prevLabel: 'prev',
            nextLabel: 'next',
            moreLabel: 'more'
        },



        /**
         * Display a Pager with next and previous links.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onOffsetChange` | Triggered on Offset Change             |
         * | `onPageClick`    | Triggered on page link clicked         |
         * | `onPrevClick`    | Triggered on prev link clicked         |
         * | `onNextClick`    | Triggered on next link clicked         |
         * | `onMoreClick`    | Triggered on more link clicked         |
         * | `onLoadingStart` | Triggered on data load start           |
         * | `onLoadingEnd`   | ITriggered on data load end            |
         *
         *
         * __loadNext option__:
         *
         * When the pager get to the end of the data (offset == length), it will
         * call the loadNext function to retrieve more data. The function is
         * called with two arguments:
         *
         * - The current length
         * - A function to call with the new data length, to allow asynchronous
         * data retrieval. Make sure to call it exactly one time, no matter what.
         *
         * See example below:
         *
         * ```
         * var data = [];
         * var pager = new UWA.Controls.Pager({
         *     limit: 5,
         *     offset: 0,
         *     length: data.length,
         *     events: {
         *         onOffsetChange: onPagerOffsetChange.bind(this),
         *         onMoreClick: onPagerMoreClick.bind(this)
         *     }
         * });
         *
         * var data = [];
         * function loadNext(index, next) {
         *     UWA.Data.request('http://example.org/api.php?json', {
         *         type: 'json',
         *         data: {
         *             from: index
         *         },
         *         onComplete: function (result) {
         *             data = data.concat(result);
         *             next(data.length);
         *         }
         *     });
         * }
         * var pager = new UWA.Controls.Pager({
         *     limit: 5,
         *     offset: 0,
         *     max: 100,
         *     length: data.length,
         *     loadNext: loadNext
         * });
         * ```
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className='uwa-pager'] - Customized container classname
         * @param {Number} [options.type=2] - Pager display type
         * @param {Boolean} [options.showPageLinks=false] - Display pages links
         * @param {Boolean} [options.showMoreLink=true] - Display more link
         * @param {Number} [options.pageLinks=5] - Max number of displayed links
         * @param {Number} [options.length=0] - Number of entry
         * @param {Number} [options.limit=10] - Limit data entry per page
         * @param {Number} [options.offset=0] - Current offset data entry
         * @param {Number} [options.max=50] - Max number of  page
         * @param {Function} [options.loadNext=null] - Callback to retrieve next data
         * @param {String} [options.prevLabel='prev'] - Prev link text label
         * @param {String} [options.nextLabel='next'] - Next link text label
         * @param {String} [options.moreLabel='more'] - More link text label
         *
         * @constructs UWA.Controls.Pager
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Pager
         */
        init: function (options) {

            this._parent(options);

            options = this.options;

            // Update Properties
            this.offset = parseInt(options.offset, 10);
            this.limit = parseInt(options.limit, 10);
            this.max = parseInt(options.max, 10);
            this.length = parseInt(options.length, 10);

            this.buildSkeleton();
        },

        setOptions: function (options) {

            this._parent(options);

            options = this.options;

            // Deprecated options support

            if (options.dataLength) {
                options.length = options.dataLength;
            } else if (options.dataArray) {
                options.length = options.dataArray.length;
            }

            if (options.onChange) {
                this.addEvent('onOffsetChange', options.onChange);
            }

            if (options.onMoreClick) {
                this.addEvent('onMoreClick', options.onMoreClick);
            }

            // if type is not specified but showPageLinks was declared
            // (deprecated usage) force type 1
            if (options.showPageLinks || (options.pageLinks && !options.type)) {
                this.type = 1;
            }

            return this;
        },

        /**
         * Update the pager length.
         *
         * @param {Object} length - The new pager length
         * @return {Object} The current UWA.Controls.Pager instance.
         */
        setLength: function (length) {

            this.length = parseInt(length, 10);

            this.setOffset(this.offset);
        },

        /**
         * Update the pager offset.
         *
         * @param {Object} length - The new pager offset
         * @return {Object} The current UWA.Controls.Pager instance.
         */
        setOffset: function (offset) {

            var that = this,
                prevOffset = that.offset;

            // Avoid negative offset
            offset = offset < 0 ? 0 : offset;

            that.offset = Math.min(parseInt(offset, 10), (that.max || that.length));

            if (prevOffset !== that.offset) {
                that.dispatchEvent('onOffsetChange', [that.offset]);
            }

            return that;
        },

        /**
         * Update the pager limit.
         *
         * @param {Object} length - The new pager limit
         * @return {Object} The current UWA.Controls.Pager instance.
         */
        setLimit: function (limit) {
            this.limit = parseInt(limit, 10);

            return this;
        },

        /**
         * Get the current page offset.
         *
         * @return {Number} The current page offset.
         */
        getPageOffset: function (offset) {
            return Math.ceil((parseInt(offset, 10) || this.offset) / this.limit);
        },

        /**
         * Get the current number of pages of the pager.
         *
         * @return {Number} The current number of pages.
         */
        getPages: function () {
            return Math.ceil((this.max || this.length || 1) / this.limit);
        },

        /**
         * Check is the current page is the last one.
         *
         * @return {Boolean} `true` if the current page is the last one.
         */
        isLastPage: function () {

            var that = this,
                exceedMax = !that.max || that.length >= that.max,
                exceedLength = that.offset + that.limit >= that.length;

            return exceedMax && exceedLength;
        },

        /**
         * Build main pager elements
         */
        buildSkeleton: function () {

            var elements = this.elements;

            elements.container = UWA.createElement('div', {
                'class': this.options.className
            });

            this.dispatchEvent('onRefresh');
        },

        buildPageInfos: function () {
            var elements = this.elements;

            elements.pageInfos = UWA.createElement('span', {
                'class': 'pageInfos',
                html: UWA.createElement('span', {
                    text: (this.getPageOffset() + 1) + ' / ' + this.getPages()
                })
            }).inject(elements.subContainer);
        },

        buildPageLinks: function () {

            var i, pageLink,
                elements = this.elements,
                options = this.options,
                injectPageLink = this.injectPageLink.bind(this),
                injectPageSeparator = this.injectPageSeparator.bind(this),
                pageLinks = options.pageLinks,
                totalPage = this.getPages(),
                currentPage = this.getPageOffset(),
                pageCounter = 0,
                offsetPage = Math.round(pageLinks / 2),
                firstPage = (currentPage >= offsetPage && (totalPage >= pageLinks)) ? (currentPage - offsetPage + 1) : 0;

            elements.pageContainer = UWA.createElement('span', {
                'class': 'pageLinks'
            });

            if (firstPage < totalPage) {

                for (i = firstPage; i < totalPage && pageCounter < pageLinks; i++) {

                    // page one, display when needed
                    if (firstPage >= 1 && pageCounter === 0) {
                        injectPageLink(pageCounter);
                        if (i > 1) {
                            injectPageSeparator();
                        }
                    }

                    pageLink = injectPageLink(i);
                    if (i === currentPage) {
                        pageLink.addClassName('selected');
                    }

                    // last page, display when needed
                    if (i < totalPage - 1 && (pageCounter === pageLinks - 1)) {
                        if (i < totalPage - 2) {
                            injectPageSeparator();
                        }
                        injectPageLink(totalPage - 1);
                    }

                    pageCounter++;
                }
            }

            elements.pageContainer.inject(elements.subContainer);
        },

        injectPageLink: function (pageNumber) {

            var currentPage = parseInt(pageNumber + 1, 10);

            return UWA.createElement('a', {
                'class': 'pageLink',
                href: '#page_' + currentPage,
                text: currentPage,
                events: {
                    click: this.dispatchAsEventListener('onPageClick', pageNumber)
                }
            }).inject(this.elements.pageContainer);
        },

        injectPageSeparator: function () {

            return UWA.createElement('span', {
                'class': 'comas',
                text: ' ... '
            }).inject(this.elements.pageContainer);
        },



        /**
         * Update main pager elements
         */
        onRefresh: function () {

            var elements = this.elements,
                options = this.options,
                isLastPage = this.isLastPage();

            // Clear Content
            elements.container.empty();

            elements.subContainer = UWA.createElement('div');

            elements.prev = UWA.createElement('a', {
                'class': 'prev' + (this.offset === 0 ? ' disabled' : ''),
                href: '#prev',
                html: UWA.createElement('span', {
                    text: UWA.i18n(options.prevLabel)
                }),
                events: {
                    click: this.dispatchAsEventListener('onPrevClick')
                }
            }).inject(elements.subContainer);

            if (isLastPage && (options.showMoreLink || options.moreLink)) {

                elements.next = UWA.createElement('a', {
                    'class': 'more',
                    href: options.moreLink || '#more',
                    html: UWA.createElement('span', {
                        text: UWA.i18n(options.moreLabel)
                    }),
                    events: {
                        click: this.dispatchAsEventListener('onMoreClick')
                    }
                }).inject(elements.subContainer);

            } else {

                elements.next = UWA.createElement('a', {
                    'class': 'next' + (isLastPage ? ' disabled' : ''),
                    href: '#next',
                    html: UWA.createElement('span', {
                        text: UWA.i18n(options.nextLabel)
                    }),
                    events: {
                        click: this.dispatchAsEventListener('onNextClick')
                    }
                }).inject(elements.subContainer);
            }

            if (options.type === 1) {
                this.buildPageLinks();
            } else if (options.type === 2) {
                this.buildPageInfos();
            }

            elements.subContainer.inject(elements.container);
        },

        onOffsetChange: function (newOffset) {

            this.offset = newOffset;

            this.dispatchEvent('onRefresh');

            // Handle Deprecated events "onChange"
            this.dispatchEvent('onChange', [newOffset]);

        },

        onPageClick: function (event, page) {

            UWA.Event.preventDefault(event);

            if (!this.loadingData) {
                this.setOffset(this.limit * page);
            }
        },

        onPrevClick: function (event) {

            Event.preventDefault(event);

            var eventElement = Event.findElement(event, 'a');

            if (
                !this.loadingData &&
                    !eventElement.hasClassName('disabled')
            ) {
                this.setOffset(this.offset - this.limit);
            }
        },

        onNextClick: function (event) {

            Event.preventDefault(event);

            var that = this,
                loadNext = that.options.loadNext,
                eventElement = Event.findElement(event, 'a'),
                offset = that.offset + that.limit,
                haveEnoughData = offset + that.limit <= that.length;

            function goToNextPage() {
                that.setOffset(offset);
            }

            if (!that.loadingData &&
                    !that.isLastPage() &&
                    !eventElement.hasClassName('disabled')) {

                // Deprecated method to retrieve more data
                if (!loadNext && that.onNeedMoreData) {
                    loadNext = function (index, next) {
                        that.onNeedMoreData(index);
                        setTimeout(next.bind(null, null), 60000);
                    };
                }

                if (!haveEnoughData && loadNext) {
                    // If we don't have enough data, retrieve more asynchronously

                    that.dispatchEvent('onLoadingStart');

                    loadNext(that.length, function (newLength) {
                        if (newLength) {
                            that.length = newLength;
                        }
                        goToNextPage();
                        that.dispatchEvent('onLoadingEnd');
                    });
                } else {
                    // Else simply go to next page
                    goToNextPage();
                }
            }
        },

        onMoreClick: function () {

            // Nothing to do by default...
        },

        onLoadingStart: function () {
            this.loadingData = true;
            this.elements.subContainer.addClassName('loading');
        },

        onLoadingEnd: function () {
            this.loadingData = false;
            this.elements.subContainer.removeClassName('loading');
        }
    });

    return UWA.namespace('Controls/Pager', Pager, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Img
 *
 *
 * @example
 * var myControl = new UWA.Controls.Img({
 *     url: 'http://example.com/hello.jpg',
 * });
 *
 * myControl.inject(myControlContainer);
 */
define('UWA/Controls/Img', [
    'UWA/Core',
    'UWA/Controls/Abstract'
], function (UWA, Abstract) {
    'use strict';

    var Img = Abstract.extend(/** @lends module:UWA/Controls/Img.UWA.Controls.Img# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: 'uwa-img',
            url: null,
            height: null,
            width: null
        },

        /**
         * Display and img tags and handle resize and various options.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onResize`       | Invoked when control need to resize    |
         * | `onLoad`         | Invoked when the image load.           |
         * | `onError`        | Invoked when the image load fail       |
         *
         * @example
         * var myControl = new UWA.Controls.Img({
         *     url: 'http://example.com/hello.jpg',
         * });
         *
         * myControl.inject(myControlContainer);
         * // OR
         * myControlContainer.appendChild(myControl.getContent());
         *
         * TODO:
         * - Implement "resize" and "preload" options.
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className='uwa-img'] - Control maincontainer className
         * @param {String} [options.url=undefined] - The image ressource url
         * @param {Number} [options.width=undefined] - Control main container width
         * @param {Number} [options.height=undefined] - Control main container height
         *
         * @constructs UWA.Controls.Img
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Img
         */
        init: function (options) {

            this._parent(options);

            this.buildSkeleton();
        },

        /**
         * Build main dom elements
         */
        buildSkeleton: function () {

            var img,
                options = this.options,
                elements = this.elements;

            elements.container = UWA.createElement('div', {
                'class': options.className,
                styles:  {
                    width: options.width + 'px',
                    height: options.height + 'px'
                }
            });

            // See http://www.thefutureoftheweb.com/blog/image-onload-isnt-being-called
            img = elements.image = UWA.createElement('img', {
                src: options.url,
                width: '100%',
                height: '100%',
                events: {
                    error: this.dispatchAsEventListener('onError'),
                    load: this.dispatchAsEventListener('onLoad'),
                    resize: this.dispatchAsEventListener('onResize')
                }
            });

            img.inject(elements.container);
        }
    });

    return UWA.namespace('Controls/Img', Img, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define*/


/**
 * @module   UWA/Utils/Scroll
 *
 */

define('UWA/Utils/Scroll', [
    'vendors/webcomponents/WeakMap',
    'UWA/Core',
    'UWA/Element',
    'UWA/Fx',
    'UWA/Event'
], function (WeakMap, UWA, Element, Fx, Event) {
    'use strict';

    function isScrollable(element, dir) {
        var overflow = Element.getStyle.call(element, dir ? 'overflow-' + dir : 'overflow');
        return isBody(element) || overflow === 'scroll' || overflow === 'auto';
    }

    /**
     * Get the closest element that is scrollable
     *
     * @param {Element} element the base element
     * @param {string} [dir=false] the direction "x" or "y". If not provided, test if it
     * can scroll in any direction.
     * @returns {Element} the overflow parent
     */
    function getClosestScrollable(element, dir) {

        // The first overflown element "closest" to the first positionned parent
        while (element && element.nodeType === 1) {

            if (isScrollable(element, dir)) {
                break;
            }

            element = element.parentNode;
        }

        return element;
    }

    /**
     * Get the closest parent element that is scrollable
     *
     * @param {Element} element the base element
     * @param {string} [dir=false] the direction "x" or "y". If not provided, test if it
     * can scroll in any direction.
     * @returns {Element} the overflow parent
     */
    function getParentScrollable(element, dir) {
        return getClosestScrollable(element && element.parentNode, dir);
    }

    /**
     * Test if the element is a body
     * @private
     *
     * @param {Element} element the element to test
     * @returns {Boolean} true if the element is a body element
     */
    function isBody(element) {
        return Element.getTagName.call(element) === 'body';
    }

    /**
     * Get the scroll value of an element
     *
     * @param {Element} element the scrollable element
     * @returns {Object} an object with keys top and left, representing the
     * scroll top and scroll left of the element. (and possible other keys but
     * don't use it)
     */
    function getScroll(element) {
        if (isBody(element)) {
            element = Element.getWindow.call(element);
        }
        var result = Element.getScrolls.call(element);
        if (UWA.owns(result, 'x')) {
            result.left = result.x;
            result.top = result.y;
        }
        return result;
    }

    /**
     * Set the scroll value of an element
     * @private
     *
     * @param {Element} element the scrollable element
     * @param {Object} scroll the scroll position
     * @param {Number|null} [scroll.left=current scroll left] the scroll left value
     * @param {Number|null} [scroll.top=current scroll top] the scroll top value
     *
     * @alias UWA.Utils.Scroll.setScroll
     * @memberOf module:UWA/Utils/Scroll
     */
    function setScroll(element, scroll) {
        if (isBody(element)) {
            element = Element.getWindow.call(element);
        }

        var currentScroll = getScroll(element);
        if (!UWA.is(scroll.left)) {
            scroll.left = currentScroll.left;
        }
        if (!UWA.is(scroll.top)) {
            scroll.top = currentScroll.top;
        }

        if (UWA.is(element, 'window')) {
            element.scrollTo(scroll.left, scroll.top);
        } else {
            element.scrollTop = scroll.top;
            element.scrollLeft = scroll.left;
        }
    }

    /**
     * @class
     * @extends UWA.Fx
     *
     * Use this class to animate the scroll
     * @private
     */
    var ScrollFX = Fx.extend({

        setSteps: function (properties) {

            var property,
                from = {},
                to = {};

            var scrolls = getScroll(this.element);

            for (property in properties) {

                if (Array.isArray(properties[property])) {
                    from[property] = properties[property][0];
                    to[property] = properties[property][1];
                } else {
                    from[property] = scrolls[property];
                    to[property] = properties[property];
                }
            }

            this.from = from;
            this.to = to;
        },

        onAnimate: function (element, from, to) {
            var scroll = {};
            var key;
            for (key in from) {
                scroll[key] = this.compute(from[key], to[key]);
            }
            setScroll(element, scroll);
        }
    });


    var smoothScrollStorage = new WeakMap();

    /**
     * Animate the scroll of an element
     *
     * @param {Element} element the scrollable element
     * @param {Object} end scroll destination
     * @param {Number} end.top scroll top destination
     * @param {Number} end.left scroll left destination
     * @param {Object} options option hash
     * @param {Function} options.onComplete callback called when the scroll is finished
     *
     * @example
     * var button = UWA.createElement('button', {
     *     type: 'button',
     *     text: 'Scroll to top',
     *     events: {
     *         click: function () {
     *             UWA.Utils.Scroll.smoothScroll(scrollableElement, {top: 0}, {
     *                 onComplete: function () {
     *                     // Hide the button when we are at the top
     *                     button.hide();
     *                 }
     *             });
     *         }
     *     }
     * });
     *
     * @alias UWA.Utils.Scroll.smoothScroll
     * @memberOf module:UWA/Utils/Scroll
     */
    function smoothScroll(element, end, options) {
        options = UWA.extend({
            onComplete: null
        }, options);

        var currentScroll = smoothScrollStorage.get(element);
        if (currentScroll) {
            currentScroll.stop();
            currentScroll.dispatchEvent('onComplete');
        }

        currentScroll = new ScrollFX(element, {
            transition: 'sineOut',
            duration: currentScroll ? 100 : 200,
            events: {
                onComplete: function () {
                    smoothScrollStorage['delete'](element);
                    if (options.onComplete) {
                        options.onComplete();
                    }
                }
            }
        });

        smoothScrollStorage.set(element, currentScroll);

        currentScroll.start(end);
    }

    /**
     * Scroll until an element is visible
     *
     * @param {Element} element the element to show
     * @param {Object} options option hash
     * @param {Boolean} [options.top=false] if the element should be on top
     * even if it is bellow the scrollable zone
     * @param {Boolean} [options.bottom=false] if the element should be at the
     * bottom even if it is on top of the scrollable zone
     * @param {Number} [options.margin=0] add a space around the element
     * @param {Element} [options.scrollable=first overflowing parent] the
     * scrollable element to scroll
     * @param {Boolean} [options.smooth=false] be smooth
     * @param {Function} [options.onComplete] callback called when the scroll is finished
     *
     * @example
     * UWA.Utils.Scroll.scrollToElement(element, {
     *     smooth: true,
     *     onComplete: function () {
     *         console.log('Scroll animation complete!');
     *     }
     * });
     *
     * @alias UWA.Utils.Scroll.scrollToElement
     * @memberOf module:UWA/Utils/Scroll
     */
    function scrollToElement(element, options) {
        options = UWA.extend({
            top: false,
            bottom: false,
            margin: 0,
            scrollable: null,
            smooth: false,
            onComplete: null
        }, options);

        var scrollable = options.scrollable || getParentScrollable(element);

        if (!scrollable) {
            return;
        }

        var body = isBody(scrollable);

        var scrollableSize = Element.getSize.call(body ? Element.getWindow.call(element) : scrollable);
        var elementSize = Element.getSize.call(element);
        var elementOffsets = Element.getOffsets.call(element);
        var space = {
            top: elementOffsets.y,
            left: elementOffsets.x,
            bottom: 0,
            right: 0
        };

        var scroll = getScroll(scrollable);

        [0, 1].forEach(function (top) {
            var pos = top ? 'top' : 'left';
            var otherPos = top ? 'bottom' : 'right';
            var size = top ? 'height' : 'width';

            if (body) {
                space[pos] -= scroll[pos];
            } else {
                space[pos] -= Element.getOffsets.call(scrollable)[top ? 'y' : 'x'];
            }

            space[pos] -= options.margin;
            space[otherPos] = scrollableSize[size] - space[pos] - elementSize[size] - 2 * options.margin;
            var shouldScrollPos = space[pos] < 0 || (space[otherPos] < 0 && space[otherPos] < -space[pos]);
            var shouldScrollOtherPos = space[otherPos] < 0;

            if (!options[otherPos] && (shouldScrollPos || options[pos])) {
                scroll[pos] += space[pos];
            } else if (options[otherPos] || shouldScrollOtherPos) {
                scroll[pos] -= space[otherPos];
            }
        });

        if (options.smooth) {
            smoothScroll(scrollable, scroll, { onComplete: options.onComplete });
        } else {
            setScroll(scrollable, scroll);
            if (options.onComplete) {
                options.onComplete();
            }
        }
    }

     function preventParentScrollListener(options, e) {
         /*jshint validthis: true*/
         var scrollable = getClosestScrollable(Event.getElement(e));
         var prevent = false;

         if (!this.isInjected(scrollable)) {
             var scrollHeight = scrollable.scrollHeight;
             var height = scrollable.clientHeight;
             var scroll = scrollable.scrollTop;
             var delta = Event.wheelDelta(e);

             var canScroll = height !== scrollHeight || (options && options.onlyScrollable === false);
             var canScrollTop = scroll > 0;
             var canScrollBottom = scroll + height < scrollHeight;

             if (canScroll && ((delta < 0 && !canScrollBottom) || (delta > 0 && !canScrollTop))) {
                 prevent = true;
             }
         } else {
             prevent = true;
         }

         if (prevent) {
             Event.stop(e);
         }
     }

    /**
     * Prevent the scroll of any element containing the passed element. This is usefull
     * when you want a small zone the user can scroll without scrolling the whole page
     * body.
     *
     * @param {DOMElement} element the element (scrollable or containing scrollable
     * elements) that should not impact the parent scroll.
     * @param {Object} [options] a object containing options
     * @param {Boolean} [options.onlyScrollable=true] by default, the scroll will be
     * prevented only if the scroll occurs in a scrollable element. Set this option to
     * false to prevent scroll on non-scrollable elements.
     *
     * @returns {Function} to remove the scroll prevention
     *
     * @example
     * var scroller = UWA.createElement('div', { styles: { overflow: 'auto' } });
     * UWA.Utils.Scroll.preventParentScroll(scroller);
     * scroller.inject(parent);
     *
     * @alias UWA.Utils.Scroll.preventParentScroll
     * @memberOf module:UWA/Utils/Scroll
     */
    function preventParentScroll(element, options) {
        var cb = preventParentScrollListener.bind(element, options);
        Element.addEvent.call(element, 'mousewheel', cb);
        return function remove() {
            Element.removeEvent.call(element, 'mousewheel', cb);
        };
    }

    return UWA.namespace('Utils/Scroll', {
        scrollToElement: scrollToElement,
        smoothScroll: smoothScroll,
        preventParentScroll: preventParentScroll,
        getClosestScrollable: getClosestScrollable,
        getParentScrollable: getParentScrollable
    }, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * Provides a simple positionned dropdown that points a given element.
 *
 * @module   UWA/Controls/DropDown
 *
 *
 * @example
 * var dropdown = new UWA.Control.DropDown.Pointy({
 *     target: myElement
 * }).inject(myElement, 'after');
 *
 * dropdown.getInnerElement().setContent('In case the curse does not succeed, this is my lucky stake.');
 *
 * myElement.addEvent('click', dropdown.show.bind(dropdown));
 */
define('UWA/Controls/DropDown', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Utils/Client',
    'UWA/Utils/Scroll'
], function (UWA, Event, Element, Abstract, Client, Scroll) {
    'use strict';

    var DropDown,
        browserCanCapture = Client.Features.eventCapture;

    /**
     * Base class for a positionned dropdown.
     *
     * ##### Available Events
     *
     * | Event            |  Description                                                      |
     * | ---------------- | ----------------------------------------------------------------- |
     * | `onClick`        | When the user clicks on the dropdown (default: hide the dropdown) |
     * | `onClickOutside` | When the user clicks outside the dropdown (default: nothing)      |
     * | `onMouseLeave`   | When the mouse leaves the dropdown (default: nothing)             |
     * | `onShow`         | When the dropdown is shown                                        |
     * | `onHide`         | When the dropdown is hidden                                       |
     *
     * @example
     * var dropdown = new UWA.Controls.DropDown({
     *     position: myElement.getPosition(null, {x: 'left', y: 'bottom'})
     * }).inject(myElement, 'after');
     * myElement.addEvent('click', dropdown.show.bind(dropdown));
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {Object|Function} [options.position=null] - The position to pass to UWA.Element#setPosition.
     * If this is a function, it will be called just before setting the position and should return the position
     * to use.
     *
     * @param {Object|Function} [options.positionOptions=null] - The position options to pass to UWA.Element#setPosition.
     * If this is a function, it will be called just before setting the position and should return the position
     * options to use.
     *
     * @constructs UWA.Controls.DropDown
     * @extends UWA.Control.Abstract
     * @memberOf module:UWA/Controls/DropDown
     */
    DropDown = Abstract.extend(/** @lends module:UWA/Controls/DropDown.UWA.Controls.DropDown# */{ // bypass

        /**
         * The control name
         *
         * @type {String}
         */
        name: 'uwa-dropdown',

        /**
         * The default controls options.
         *
         * @type {Object}
         * @private
         */
        defaultOptions: {
            position: {},
            positionOptions: {
                boundary: 'auto'
            },
            global: false
        },

        init: function (options) {
            this._parent(options);
            this.clickOutsideEvent = function (event) {
                var element = event && Event.getElement(event);
                var container = this.elements.container;

                var elementIsInjected = element.isInjected(container);
                var controlIsInjected = Abstract._getClosestControlsFromElement(element).some(function (control) {
                    return control.getContent().isInjected(container);
                });
                if (!elementIsInjected && !controlIsInjected) {
                    this.dispatchEvent('onClickOutside', [event]);
                }
            }.bind(this);
        },

        /**
         * Destroy the control elements and its children.
         * Remove all events and remove the element from the dom.
         * This control and its children should not be used
         * after this.
         */
        destroy: function () {
            this.hide();
            this._parent();
        },

        /**
         * Build and return input wrapper Element.
         *
         * @return {HTMLElement}
         */
        getContent: function () {
            var elements = this.elements;

            if (!elements.container) {

                elements.container = UWA.createElement('div', {
                    'class': this.getClassNames() + (this.options.global ? ' global' : ''),
                    events: {
                        click: this.dispatchEvent.bind(this, 'onClick'),
                        mouseleave: this.dispatchEvent.bind(this, 'onMouseLeave')
                    }
                });

                if (this.options.global) {
                    elements.bacon = UWA.createElement('div', {
                        'class': this.getClassNames('-bacon')
                    }).hide();

                    this._scrollPrevention = function (event) {
                        var element = Event.getElement(event);
                        var inner = this.getInnerElement();
                        if (inner !== element && !element.isInjected(inner)) {
                            Event.preventDefault(event);
                        }
                    }.bind(this);

                    Scroll.preventParentScroll(elements.container, {
                        onlyScrollable: false
                    });

                } else {
                    elements.container.hide();
                }

                Abstract._linkElementToControl(this, elements.container);

                if (!browserCanCapture) {
                    elements.capture = UWA.createElement('div', {
                        styles: {
                            width: '100%',
                            height: '100%',
                            position: 'absolute',
                            zIndex: 1000,
                            top: 0,
                            left: 0
                        },
                        events: {
                            click: this.clickOutsideEvent
                        }
                    });
                }
            }
            return elements.bacon || elements.container;
        },

        /**
         * Default onClick handler. When an event gets here, the dropdown is hidden.
         *
         * @param {Event} e - The click event
         */
        onClick: function (e) {
            Event.stopPropagation(e);
            this.hide();
        },

        /**
         * Default onPostInject event handler. When the dropdown is injected, update its position.
         */
        onPostInject: function () {
            this.updatePosition();
        },

        /**
         * Default onShow event handler. Initialize the "onClickOutside" event mechanism.
         */
        onShow: function () {
            if (this.options.global) {
                this.elements.container.inject(document.body);
                Element.addEvent.call(document.body, 'mousewheel', this._scrollPrevention, null, true);
            }

            this.updatePosition();

            if (this.hasEvent('onClickOutside')) {
                if (browserCanCapture) {
                    Element.addEvent.call(document, 'click', this.clickOutsideEvent, null, 0, true); // use capture \o/
                } else {
                    this.elements.capture.inject(document.body);
                }
            }
        },

        /**
         * Default onShow event handler. Remove the "onClickOutside" event mechanism.
         */
        onHide: function () {
            if (this.options.global) {
                this.elements.container.remove();
                Element.removeEvent.call(document.body, 'mousewheel', this._scrollPrevention, true);
            }

            if (browserCanCapture) {
                Element.removeEvent.call(document, 'click', this.clickOutsideEvent, true);
            } else {
                this.elements.capture.remove();
            }
        },

        onRemoved: function () {
            var elements = this.elements;
            var content = elements.bacon || elements.container;
            if (content) {
                content.hide();
            }
            if (this.options.global && elements.container) {
                elements.container.remove();
            }
            if (this._scrollPrevention) {
                Element.removeEvent.call(document.body, 'mousewheel', this._scrollPrevention, true);
            }
        },

        /**
         * Whether or not the dropdown is visible.
         *
         * @return {Boolean}
         */
        isOpen: function () {
            return !!this.elements.container &&
                this.getContent().getStyle('display') !== 'none';
        },

        /**
         * Toggles the visibility of the dropdown.
         *
         * @param {Boolean} [force=false] - Force show (if `true`) or hide the element
         * @return {this}
         */
        toggle: function (force) {
            if (!UWA.is(force)) {
                force = !this.isOpen();
            }
            this[force ? 'show' : 'hide']();
            return this;
        },

        /**
         * Set the "position" and "positionOptions" options and update the
         * position of the dropdown. Arguments are merged with the current options instead
         * of replacing them.
         *
         * @param {Object} position equivalent to the `position` option
         * @param {Object} [positionOptions=] equivalent to the `positionOptions` option
         * @return {this}
         */
        setPosition: function (position, options) {
            UWA.extend(this.options, {
                position: position,
                positionOptions: options || {}
            }, true);
            return this.updatePosition();
        },

        /**
         * Update the position of the dropdown, using the "position" and
         * "positionOptions" options. See UWA.Element#setPosition.
         *
         * @return {this}
         */
        updatePosition: (function () {
            function get(value) {
                return UWA.is(value, 'function') ? value() : value;
            }
            return function () {
                if (this.isOpen()) {
                    this.dispatchEvent('onPreUpdatePosition');
                    this.elements.container.setPosition(
                        get(this.options.position),
                        get(this.options.positionOptions)
                    );
                }
                return this;
            };
        }()),

        /**
         * Get the inner element of the dropdown. Use it to set its content.
         *
         * > This function is the equivalent of getContent, but a class
         * > extending this control could change this.
         *
         * @example
         * var myControl = new UWA.Controls.DropDown();
         * myControl.getInnerElement().empty(true).addContent('foo');
         * myControl.show();
         *
         * @return {HTMLElement} A DOM element.
         */
        getInnerElement: function () {
            this.getContent(); // build content if needed
            return this.elements.container;
        }
    });

    /**
     * A simple positionned dropdown that points a given element or coordinates.
     *
     * ##### Available Events
     *
     * All events inherited from UWA.Controls.DropDown.
     *
     * @example
     * var dropdown = new UWA.Control.DropDown.Pointy({
     *     target: myElement
     * }).inject(myElement, 'after');
     *
     * dropdown.getInnerElement().setContent('In case the curse does not succeed, this is my lucky stake.');
     *
     * myElement.addEvent('click', dropdown.show.bind(dropdown));
     *
     * @example
     * var dropdown = new UWA.Control.DropDown.Pointy();
     * dropdown.inject(myElement, 'after');
     *
     * dropdown.getInnerElement().setContent('In case the curse does not succeed, this is my lucky stake.');
     *
     * myElement.addEvent('click', function (e) {
     *     dropdown.setPosition(UWA.Event.getPosition(e), {
     *         relative: document.body // event position is absolute, so set the position relative
     *                                 // to the body
     *     });
     *     dropdown.show();
     * });
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {HTMLElement} [options.target=undefined] - Points toward this element.
     *
     * @param {Object|Function} [options.autoPosition] - An array of preferred position relative
     * to the target element. Each value of this array should be a string of the form '<side>-<alignment>'
     * where <side> is either 'below', 'right', 'left' or 'above' and <alignment> is either 'start',
     * 'center' or 'end'. Default: ['below-center', 'right-start', 'left-start', 'above-center']
     *
     * @param {Number} [options.margin=12] - Space between the dropdown and the element.
     *
     * @constructs UWA.Controls.DropDown.Pointy
     * @extends UWA.Controls.DropDown
     * @memberOf module:UWA/Controls/DropDown
     */
    DropDown.Pointy = DropDown.extend(/** @lends module:UWA/Controls/DropDown.UWA.Controls.DropDown.Pointy# */{ // bypass

        /**
         * The control name. Defaults to 'uwa-pointydropdown'.
         *
         * @type {String}
         */
        name: 'uwa-pointydropdown',

        /**
         * The default control options.
         *
         * @type {Object}
         * @private
         */
        defaultOptions: {
            autoPosition: ['below-center', 'right-center', 'left-center', 'above-center'],
            margin: 12
        },

        /**
         * Overrides UWA.Controls.DropDown.updatePosition.
         */
        updatePosition: function () {
            this.dispatchEvent('onPreUpdatePosition');
            var targetDimensions, contentDimensions, position,
                options = this.options,
                margin = options.margin,
                container;

            var minDimension = 30;
            if (options.target) {
                targetDimensions = options.target.getDimensions();
            } else {
                targetDimensions = { width: 0, height: 0 };
            }

            contentDimensions = this.elements.container.getDimensions();

            position = options.autoPosition.map(function (autoPosition) {
                autoPosition = autoPosition.split('-');
                var place = autoPosition[0],
                    align = autoPosition[1] || 'center',
                    position = {x: 0, y: 0};

                position.place = place;
                position.align = align;

                if (place === 'below') {
                    position.y = targetDimensions.height + margin;
                } else if (place === 'above') {
                    position.y = -contentDimensions.outerHeight - margin;
                } else if (align === 'center') {
                    position.y = targetDimensions.height / 2 - contentDimensions.outerHeight / 2;
                } else if (align === 'end') {
                    position.y = Math.max(targetDimensions.height, minDimension) - contentDimensions.outerHeight;
                }

                if (place === 'left') {
                    position.x = -contentDimensions.outerWidth - margin;
                } else if (place === 'right') {
                    position.x = targetDimensions.width + margin;
                } else if (align === 'center') {
                    position.x = targetDimensions.width / 2 - contentDimensions.outerWidth / 2;
                } else if (align === 'end') {
                    position.x = Math.max(targetDimensions.width, minDimension) - contentDimensions.outerWidth;
                }

                if (!options.target) {
                    position.x += options.position.x || 0;
                    position.y += options.position.y || 0;
                    if (align !== 'center') {
                        if (place === 'right' || place === 'left') {
                            position.y -= minDimension / 2;
                        }
                        if (place === 'above' || place === 'below') {
                            position.x -= minDimension / 2;
                        }
                    }
                }

                return position;
            });

            if (this.isOpen()) {
                container = this.elements.container;
                container.setPosition(
                    position,
                    UWA.merge({
                        relative: options.target
                    }, this.options.positionOptions)
                );
                position = position[0];
                if (this._containerClassName) {
                    container.removeClassName(this._containerClassName);
                }
                this._containerClassName = position.place + ' ' + position.align;
                container.addClassName(this._containerClassName);

                this.updatePointPosition(position.place);
            }

            return this;
        },

        /**
         * Move the point toward the target.
         *
         * @param {String} place - Where to place the point ('below', 'above', 'left' or 'right')
         */
        updatePointPosition: function (place) {
            var target = this.options.target,
                content = this.elements.container,
                pointMargin = 10,
                contentDimensions = content.getSize(),
                contentOffsets = content.getOffsets(),
                targetDimensions = target ? target.getSize() : {height: 0, width: 0},
                targetOffsets = target ? target.getOffsets() : this.options.position,
                pointPosition = {bottom: null, left: null, right: null, top: null};

            targetOffsets.x -= contentOffsets.x;
            targetOffsets.y -= contentOffsets.y;

            if (place === 'below' || place === 'above') {
                pointPosition.left = targetOffsets.x + targetDimensions.width / 2;
                if (pointPosition.left < pointMargin || pointPosition.left > contentDimensions.width - pointMargin) {
                    pointPosition.left = contentDimensions.width / 2;
                }
                if (place === 'below') {
                    pointPosition.top = 0;
                } else {
                    pointPosition.bottom = 0;
                }
            } else {
                pointPosition.top = targetOffsets.y + targetDimensions.height / 2;
                if (pointPosition.top < pointMargin || pointPosition.top > contentDimensions.height - pointMargin) {
                    pointPosition.top = contentDimensions.height / 2;
                }
                if (place === 'right') {
                    pointPosition.left = 0;
                } else {
                    pointPosition.right = 0;
                }
            }

            this.elements.point
                .setStyles(pointPosition)
                .setText({ above: 'j', below: 'k', left: 'm', right: 'l' }[place] || ' ')
                .toggleClassName('side', place === 'left' || place === 'right');
        },

        /**
         * Overrides UWA.Controls.DropDown.getInnerElement.
         */
        getInnerElement: function () {
            this.getContent(); // build content
            return this.elements.inner;
        },

        /**
         * Overrides UWA.Controls.DropDown.getContent.
         */
        getContent: function () {
            var elements = this.elements;
            var result = this._parent();
            if (!elements.inner) {
                elements.container.setContent(
                    elements.inner = UWA.createElement('div', {
                        'class': this.getClassNames('-inner')
                    }),
                    elements.point = UWA.createElement('div', {
                        'class': this.getClassNames('-point')
                    })
                );
            }
            return result;
        }
    });

    return UWA.namespace('Controls/DropDown', DropDown, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, setTimeout, clearTimeout
*/

/**
 * @module   UWA/Controls/Drag
 *
 */
define('UWA/Controls/Drag', [
    'UWA/Internal/Deprecate',
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Element',
    'UWA/Event'
], function (
    Deprecate,
    UWA,
    Class,
    Options,
    Utils,
    Client,
    Element,
    Event
) {
    'use strict';

    var Drag,
        browserCanCapture = Client.Features.eventCapture,
        nop = function () {};

    function isTouchEvent(event) {
        return event.type.startsWith("touch");
    }

    /*
        setPosition

        Set the absolute position of an element on the page. It takes into
        account the position of the first relative parent of the element.

        Parameters:
            * element Element: the element to position
            * posotion {x: Number, y: Number}: the absolute coordinates (relative to the page)
    */
    function setPosition(element, position) {
        var parent = element.offsetParent,
            parentPosition;

        if (parent && parent.nodeType === 1) {
            parentPosition = Element.getOffsets.call(parent);
            parentPosition.y += parseInt(Element.getStyle.call(parent, 'border-top-width'), 10) || 0;
            parentPosition.x += parseInt(Element.getStyle.call(parent, 'border-left-width'), 10) || 0;
        } else {
            parentPosition = {x: 0, y: 0};
        }

        element.setStyles({
            top: (position.y - parentPosition.y) + 'px',
            left: (position.x - parentPosition.x) + 'px'
        });
    }

    /*
        getZoneLimit

        Get an element inner absolute coordinates. If the element is displayed
        inline, it uses the first non-inline parent, so it supports edge cases
        like:

        (start code)
            <div>
                <span id="el">
                    <span>foo</span>
                    <span>foo</span>
                    <span>foo</span>
                    <span>foo</span>
                </span>
                <span>another inline element</span>
            </div>
            <!-- getZoneLimit(el) will use the div coordinates -->
        (end code)

        Parameters:
            * element Element: the element to use

        Returns:
            * {x: Number, y: Number, maxX: Number, maxY: Number}: the four
                coordinates of the inner zone of the element.
    */
    function getZoneLimit(element) {
        var position,
            getComputedSize = Element.getComputedSize;
        while (element && Element.getStyle.call(element, 'display') === 'inline') {
            element = element.getParent();
        }

        if (element) {
            position = Element.getOffsets.call(element);
            position.maxX = position.x + element.offsetWidth -
                getComputedSize.call(element, 'border-right-width', 'padding-right');
            position.maxY = position.y + element.offsetHeight -
                getComputedSize.call(element, 'border-bottom-width', 'padding-bottom');
            position.x += getComputedSize.call(element, 'border-left-width', 'padding-left');
            position.y += getComputedSize.call(element, 'border-top-width', 'padding-top');

        } else {
            position = { x: 0, y: 0, maxX: 0, maxY: 0 };
        }

        return position;
    }

    /*
     * Todo:
     * - UnitTests
     * - Check W3C recomandation for polyfill (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html)
     */

    /**
     * Low level cross-Platform API for DOM Elements Drag and Drop.
     *
     * Features:
     * - Support touch and mouse platform
     *
     * __Dragging process__:
     *
     * ```
     *          o
     *          v
     *        start
     *       __| |__
     *      |       |
     *      v       v
     *     snap    cancel
     *      |       |
     *      v       |
     *     move <-- |
     *      | |___| |
     *      v       |
     *     stop     |
     *      |__   __|
     *         | |
     *         v v
     *        reset
     *          v
     *          o
     * ```
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @param {String} [options.mouseSnap=10] - Amount of pixels before the dragging actually
     * starts. If mouseDelay is greater than 0, this is the amount of pixels before the drag is
     * cancelled if dragged before the delay is finished.
     *
     * @param {String} [options.touchSnap=20] - Same as mouseSnap but for touch events.
     *
     * @param {Number} [options.mouseDelay=0] - Delay, in ms, before the dragging actually start
     *
     * @param {Number} [options.touchDelay=300] - Same as mouseDelay but for touch events.
     *
     * @param {String} [options.delegate='*'] - CSS selector run against
     * the target of the event target, to determine if it is a draggable
     * element or not.
     *
     * @param {Element} [options.document=document] - The higher element
     * where we can put events. Used to attach the move and stop events,
     * and to prevent the click on capture capable browsers.
     *
     * @param {Element} [options.root=document.body] - Root element of CSS queries,
     * and used to store temporary DOM on IE on browser who can't capture events (IE).
     *
     * @param {Element} [options.element=root] - Where to attach the start event.
     *
     * @class UWA.Controls.Drag
     * @mixes UWA.Class.Options
     * @memberof module:UWA/Controls/Drag
     */
    Drag = Class.extend(Options, /** @lends module:UWA/Controls/Drag.UWA.Controls.Drag# */{ // bypass

        defaultOptions: {
            mouseSnap: 10,
            mouseDelay: 0,

            touchSnap: 20,
            touchDelay: 300,

            delegate: '*',

            document: document
            /*
            root: document.body,

            element: root,
            */
        },

        init: function (options) {
            this.setOptions(options);

            if (this.options.snap !== undefined) {
                Deprecate.warn("Controls/Drag snap option", "Use the mouseSnap and touchSnap options instead.");
                this.options.mouseSnap = this.options.touchSnap = this.options.snap;
            }

            if (this.options.delay !== undefined) {
                Deprecate.warn("Controls/Drag delay option", "Use the mouseDelay and touchDelay options instead.");
                this.options.mouseDelay = this.options.touchDelay = this.options.delay;
            }

            // Events binding
            var onMove = this.onMove.bind(this);
            var onStop = this.onStop.bind(this);
            var onStart = this.onStart.bind(this);

            this.documentEvents = {
                touchmove: onMove,
                mousemove: onMove,
                touchend: onStop,
                mouseup: onStop,
                touchcancel: onStop
            };

            this.elementEvents = {
                touchstart: onStart,
                mousedown: onStart
            };

            this.attach();
        },

        /**
         * Set the options.
         *
         * @param {options} Object - The options to use
         * @return {this}
         */
        setOptions: function (options) {
            this._parent(options);

            options = this.options;

            this.root = UWA.extendElement(options.root || document.body);
            this.element = UWA.extendElement(options.element || this.root);

            this.document = options.document;

            if (!browserCanCapture) {
                if (!this.clickDiscarder) {
                    this.clickDiscarder = UWA.createElement('div', {
                        styles: {
                            position: 'absolute',
                            height: '1px',
                            width: '1px'
                        }
                    });
                }
                this.clickDiscarder.inject(this.root);
            }

            return this;
        },

        /**
         * Destroy this instance. Do not use it afterward.
         */
        destroy: function () {
            this.detach();
            if (!browserCanCapture) {
                this.clickDiscarder.destroy();
            }
        },

        /**
         * Attach the event to start dragging the element.
         *
         * @return {this}
         */
        attach: function () {
            Element.addEvents.call(this.element, this.elementEvents);
            return this;
        },

        /**
         * Detach all events. The element won't be draggable anymore.
         *
         * @return {this}
         */
        detach: function () {
            this.reset();
            Element.removeEvents.call(this.element, this.elementEvents);
            return this;
        },

        /**
         * Called when the drag starts.
         *
         * @param {Object} position - {x: Number, y: Number}: the starting position
         */
        start: nop,

        /**
         * Called when the drag moves.
         *
         * @param {Object} position - {x: Number, y: Number}: the current position
         * @param {Object} delta - {x: Number, y: Number}: the difference between starting
         * position and the current position
         */
        move: browserCanCapture ? nop : function (position) {
            setPosition(this.clickDiscarder, position);
        },

        /**
         * Called when the drag is snapping (the user exceeded the drag threshold).
         *
         * @param {Object} position - {x: Number, y: Number}: the current position
         * @param {Object} delta - {x: Number, y: Number}: the difference between starting
         * position and the current position
         */
        snap: function (position) {
            if (!browserCanCapture) {
                setPosition(this.clickDiscarder, position);
                this.clickDiscarder.show();
            }
            var scroller = UWA.Controls && UWA.Controls.Scroller;
            scroller = scroller && scroller.activeScroller;
            if (scroller) {
                scroller.onScrollStop(this.currentEvent);
            }
        },

        /**
         * Called when the drag stops.
         */
        stop: nop,

        /**
         * Called when the drag is cancelled (stoped before it snapped).
         */
        cancel: nop,

        /**
         * Called after each drag process to re-initialize the instance.
         */
        reset: function () {
            clearTimeout(this.startTimeout);
            if (!browserCanCapture) {
                this.clickDiscarder.hide();
            } else if (this.snapped) {
                // Stop propagation of all clicks for 300ms after the
                // drag is finished. This will prevent unwanted clicks
                // to be fired.  On iOS / iPad2, 200ms is not enough to
                // prevent clicks, so we will stay with 300ms. We may
                // change this delay for some plateforms.
                this.document.addEventListener('click', Event.stopPropagation, true);
                setTimeout(function () {
                    this.document.removeEventListener('click', Event.stopPropagation, true);
                }.bind(this), 300);
            }
            this.snapped = false;
            this.startOrigin = this.currentDelta = this.currentEvent = this.target = null;
            Element.removeEvents.call(this.document, this.documentEvents);
        },

        /**
         * Called in the "mousedown" event. It essentially binds the "mouseup"
         * and "mousemove" events.
         *
         * @param {Event} e - DOM event
         */
        onStart: function (e) {
            var target = Event.getElement(e),
                // This cover left click and touch
                leftClick = (e.which || e.button || 0) < 2;

            if (leftClick && !this.target &&
                    Element.match.call(target, this.options.delegate, this.root)) {
                this.currentEvent = e;
                this.target = target;
                this.startOrigin = Event.getPosition(e);
                this.start(this.startOrigin);
                if (this.target) {  // Drag has not been reseted
                    Element.addEvents.call(this.document, this.documentEvents);
                    var delay = isTouchEvent(e) ? this.options.touchDelay : this.options.mouseDelay;
                    if (delay) {
                        this.startTimeout = setTimeout(this.onMove.bind(this, false), delay);
                    }

                    // preventDefault prevents the text to be selected, or
                    // context menus to be opened.
                    // stopPropagation allow drag and drop usage in a scroller
                    // (start dragging will cancel the scroll)
                    // BUT:
                    // preventDefault prevents scrolling in native (overflow:
                    // auto) container.
                    // stopPropagation prevents scrolling in a scroller by
                    // starting in a draggable element. If all elements in the
                    // scroller are draggable, the scroller won't be
                    // scrollable.
                    //
                    // Disabled for now on touch devices, until we find a
                    // better solution for dragging in scrollers
                    if (!isTouchEvent(e)) {
                        Event.preventDefault(e);
                    }
                }
            }
        },

        /**
         * Called in the "mousemove" event. Checks the snap threshold and call
         * the right methods.
         *
         * @param {Evente} e - DOM event
         */
        onMove: function (e) {

            var delta, forceSnap;

            if (!e) {
                e = this.currentEvent;
                forceSnap = true;

            } else {
                this.currentEvent = e;
                if (this.snapped) {
                    Event.preventDefault(e);
                }
            }

            var position = Event.getPosition(e);
            this.currentDelta = delta = {
                x: position.x - this.startOrigin.x,
                y: position.y - this.startOrigin.y,
                distance: 0
            };

            delta.distance = Math.sqrt(delta.x * delta.x + delta.y * delta.y);

            if (!this.snapped) {
                var snap = isTouchEvent(e) ? this.options.touchSnap : this.options.mouseSnap;
                var delay = isTouchEvent(e) ? this.options.touchDelay : this.options.mouseDelay;
                if (delay ? forceSnap && delta.distance <= snap : !snap || delta.distance > snap) {
                    this.snapped = true;
                    this.snap(position, delta);
                } else if (delay) {
                    this.cancel();
                    this.reset();
                }
            }

            if (this.snapped) {
                this.move(position, delta);
            }
        },

        /**
         * Called in the "mouseup" event. Stops the process.
         *
         * @param {Evente} e - DOM event
         */
        onStop: function (e) {
            this.currentEvent = e;
            if (this.snapped) {
                this.stop();
                Event.stop(e);
            } else {
                this.cancel();
                /*
                    On touch browsers, calling preventDefault on a touchstart
                    event will cancel the click event.
                    In this case, we should dispatch it artificially.
                    See http://www.w3.org/TR/touch-events/#the-touchstart---------event

                    Note that some browser (Android Browser on 4.1) will fire
                    the click event anyway, so we should not dispatch the event
                    a second time.
                */
                /* Disabled, as we don't call preventDefault for now (see onStart)
                if (browserIsTouch && browserCanCapture && this.options.delay &&
                        // If the target stay the same
                        this.target && this.target === target &&
                        // and the user did not move more than 30 pixels
                        (!this.currentDelta || this.currentDelta.distance < 30)) {

                    // Generate click in 300ms
                    timeout = setTimeout(Event.dispatchEvent.bind(null, target, 'click', e), 300);

                    // Capture click event in order to prevent click generation
                    // if the click is fired within 300ms
                    target.addEventListener('click', function callback() {
                        target.removeEventListener('click', callback, true);
                        clearTimeout(timeout);
                    }, true);
                }
                */
            }
            this.reset();
        }
    });

    /**
     * Drag and drop DOM elements in zones. Inherits from Drag.
     *
     * Drag.Move steps (excludes the 'move' step for simplification):
     *
     * ```
     *             o
     *             v
     *           start ---> o
     *             |
     *             v
     *           handles
     *             |
     *             v
     *    -----> enter
     *    |     __| |__
     *    |    |       |
     *    |    v       v
     *    --- leave   drop
     *         |__   __| |
     *            | |    |
     *            v v    |
     *           cancel  |
     *             |  ___|
     *             | |
     *             v v
     *            stop
     *             v
     *             o
     * ```
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @param {Element} [options.container=undefined] - An Element instance
     * to get the limits of the draggable zone. If the 'root' option is not defined,
     * 'container' is used as 'root'.
     *
     * @param {String} [options.zones=[root]] - Either: a CSS selector
     * who will be called against the 'root', a list of Elements or a function
     * returning a list of Elements. The zones are elements where the handled
     * element could be dropped, or moved on it.
     *
     * @param {Boolean} [options.centerHandles=undefined] - If `true`, centers
     * the handled element around the cursor.
     *
     * @param {Boolean} [options.overlay=undefined] - If `true`, but an overlay
     * in the 'document' to prevent frames or flash to steal drag events.
     * This is only available on non-touch devices as touch events do not have this problem.
     *
     * @param {Function} [options.start=undefined] - Callback. If defined,
     * will be called before the drag snaps. If it returns `false`, it cancels
     * the whole process.
     *
     * @param {Function} [options.handles=undefined] - Callback.
     * If defined, will be called as soon as the drag snaps.
     * If it returns a DOM element, the element is used to set the drag
     * position. If it returns undefined, the event target will be used instead.
     *
     * @param {Function} [options.enter=undefined] - Callback.
     * If defined, called when the cursor enters in a zone.
     * If it returns a DOM element, it will be used as placeholder in this zone.
     *
     * @param {Function} [options.leave=undefined] - Callback.
     * If defined, called when the cursor leaves a zone.
     *
     * @param {Function} [options.drop=undefined] - Callback.
     * If defined, called when the handled element is droped on a zone.
     * If it returns `false`, the next step is 'cancel'.
     *
     * @param {Function} [options.move=undefined] - Callback.
     * If defined, called when the handled element moves.
     *
     * @param {Function} [options.cancel=undefined] - Callback.
     * If defined, called when the handled element is dropped outside
     * a zone or if 'drop' returned `false`.
     *
     * @param {Function} [options.stop=undefined] - Callback.
     * If defined, called when the drag stops. Not called
     * if 'start' returned `false`.
     *
     * @param {Function} [options.fixed=undefined] - Callback.
     * If defined, called to determine if a node (passed second argument)
     * should be fixed. This can cancel a drag and influences the palceholder
     * placement
     *
     * @param {Boolean} [options.allowBesidePlaceholder=false] - If `true` the
     * placeholder could be placed next to the dragged target.
     *
     * @class UWA.Controls.Drag.Move
     * @extends UWA.Controls.Drag
     * @memberof module:UWA/Controls/Drag
     */
    Drag.Move = Drag.extend( /** @lends module:UWA/Controls/Drag.UWA.Controls.Drag.Move# */{ // bypass

        init: function (options) {
            this._parent(options);
            this.refreshCache = this.refreshCache.bind(this);
        },

        /**
         * Set the options.
         *
         * @param {options} Object - The options to use
         * @return {this}
         */
        setOptions: function (options) {
            if (options && !options.root) {
                options.root = options.container;
            }
            return this._parent(options);
        },

        /**
         * Overrides Drag.start. Call callbacks 'start' and 'fixed' to
         * check if we have to start the move process.
         */
        start: function (position) {
            this._parent(position);

            this.context = Object.create(this);
            if (this.call('start') === false ||
                    this.call('fixed', this.target) === true) {
                this.reset();
            }
        },

        /**
         * Overrides Drag.snap. Call the 'handles' callback and
         * initialises the zone and limit caches.
         */
        snap: function (position, delta) {
            this._parent(position, delta);

            var body,
                options = this.options;

            this.handles = this.call('handles') || this.target;
            if (options.centerHandles) {
                setPosition(this.handles, {
                    x: position.x - this.handles.offsetWidth / 2 - delta.x,
                    y: position.y - this.handles.offsetHeight / 2 - delta.y
                });
            }
            this.startPosition = Element.getOffsets.call(this.handles);

            if (this.options.overlay) {
                body = this.document.body || this.document;
                this.overlay = UWA.createElement('div', {
                    styles: {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: body.offsetWidth + 'px',
                        height: body.offsetHeight + 'px'
                    }
                }).inject(body);
            }

            this.refreshCache();
        },

        /**
         * Context proof (this method can be called as context.refreshCache).
         * Refresh the zones cache.
         */
        refreshCache: function () {
            var options = this.options;

            this.zones = options.zones ?
                    this.getList(options.zones) :
                        [this.root];

            this.positions = this.zones.map(function (zone) {
                var position = getZoneLimit(zone);
                position.element = zone;
                return position;
            });

            if (options.container && this.handles) {
                var size = getZoneLimit(options.container);
                var dimension = Element.getDimensions.call(this.handles);
                this.limit = {
                    x: [size.x, size.maxX - dimension.outerWidth],
                    y: [size.y, size.maxY - dimension.outerHeight]
                };
            } else {
                this.limit = {
                    x: [-Infinity, Infinity],
                    y: [-Infinity, Infinity]
                };
            }
        },

        /**
         * Overrides the Drag.reset method.
         */
        reset: function () {
            this._parent();
            this.zone = null;
            this.startPosition = null;
            if (this.overlay) {
                this.overlay.destroy();
                this.overlay = null;
            }
        },

        /**
         * Overrides the Drag.stop method. Call the 'drop', 'cancel' and
         * 'stop' callbacks.
         */
        stop: function () {
            this._parent();
            if (!this.zone || this.call('drop') === false) {
                this.setPosition(this.startOrigin, {x: 0, y: 0});
                this.call('cancel');
            }
            this.call('stop');
        },

        /**
         * Overrides the Drag.move method. Computes the position of the
         * element, and call the 'leave', 'enter' and 'move' callbacks.
         */
        move: function (position, delta) {
            this._parent(position, delta);
            this.setPosition(position, delta);
            var i, l, zone, pos;

            for (i = 0, l = this.positions.length; i < l; i += 1) {
                pos = this.positions[i];
                if (pos.x <= position.x && position.x <= pos.maxX &&
                        pos.y <= position.y && position.y <= pos.maxY) {
                    zone = pos.element;
                }
            }

            if (this.zone !== zone) {
                if (this.zone) {
                    this.call('leave');
                    if (this.placeholder) {
                        this.placeholder.remove();
                        this.placeholder = null;
                        this.refreshCache();
                    }
                }
                this.zone = zone;
                if (zone) {
                    this.placeholder = this.call('enter');
                    this.refreshPlaceholderCache();
                }
            }
            if (this.zone && this.placeholder) {
                this.placePlaceholder();
            }
            this.call('move');
        },

        /**
         * Set the position of the element, after limiting it with the limits.
         * Populates the 'limit' property.
         */
        setPosition: function (position, delta) {

            var limit, i, coordinate, shift,
                limited = this.limited = {},
                handlesPosition = {};

            for (i = 0; i < 2; i += 1) {
                coordinate = i ? 'x' : 'y';
                limit = this.limit[coordinate];
                handlesPosition[coordinate] =
                    this.startPosition[coordinate] + delta[coordinate];

                shift = 0;
                if (limit[1] < handlesPosition[coordinate]) {
                    shift = limit[1] - handlesPosition[coordinate];
                    limited[i ? 'right' : 'bottom'] = shift;
                } else if (limit[0] > handlesPosition[coordinate]) {
                    shift = limit[0] - handlesPosition[coordinate];
                    limited[i ? 'left' : 'top'] = shift;
                }

                if (shift) {
                    position[coordinate] += shift;
                    handlesPosition[coordinate] += shift;
                    delta[coordinate] += shift;
                }
            }

            setPosition(this.handles, handlesPosition);
        },

        /**
         * Get a list of elements based on the type of the parameter. If it is
         * an array, it returns it. If it is a function, calls it and return the
         * results. If it is a string, consider it as a CSS selector to be run
         * within the 'root' element.
         *
         * @param {Array|Function|String} definition - Some elements to consider.
         * @return {Array.<DOMElement>} A list of dom elements.
         */
        getList: function (definition) {

            var list,
                type = UWA.typeOf(definition);

            if (type === 'array') {
                list = definition;
            } else if (type === 'function') {
                list = definition.apply(this, Array.prototype.slice.call(arguments, 1));
            } else {
                list = this.root.getElements(definition);
            }

            return list;
        },

        /**
         * Invoke a callback if it is defined
         *
         * @param {String} name - The name of the callback
         * @param {Array} arg - The parameters to pass to the callback
         * @return The result of the callback
         */
        call: function (name, arg) {
            var fct = this.options[name];
            if (fct) {
                return Utils.attempt(fct, 0, null, this.context, arg);
            }
        },

        /**
         * Refreshes the placeholder cache
         */
        refreshPlaceholderCache: function () {
            var child, i, l,
                children = (this.zone || this.root).childNodes,
                cache = [];

            for (i = 0, l = children.length; i < l; i += 1) {
                child = children[i];
                if (child.nodeType === 1 &&
                        child !== this.handles &&
                        child !== this.placeholder &&
                        (child.offsetHeight || child.offsetWidth) &&
                        this.clickDiscarder !== child &&
                        this.call('fixed', child) !== true) {
                    cache[cache.length] = {
                        element: child,
                        position: Element.getOffsets.call(child)
                    };
                }
            }

            this.placeholderCache = cache;
        },

        /**
         * Put the placeholder between the elements contained in the current
         * zone.
         */
        placePlaceholder: function () {

            var position, i, l, child, closest,
                next,
                nextChild, previousChild,
                handlesPosition,
                horizontal,
                firstLine, newLine,
                lastEnd,
                width = 'offsetWidth',
                height = 'offsetHeight',
                handles = this.context.handles,
                placeholder = this.context.placeholder,
                limited = this.context.limited,
                zone = this.zone || this.root,
                target = this.target,
                children = this.placeholderCache;

            while (target && target.parentNode !== zone) {
                target = target.parentNode;
            }

            position = Element.getOffsets.call(handles);
            // Center of the handled element
            handlesPosition = {
                x: limited.left ? -Infinity : limited.right ? Infinity :
                        position.x + handles[width] / 2,
                y: limited.top ? -Infinity : limited.bottom ? Infinity :
                        position.y + handles[height] / 2
            };

            // Find the closest element
            for (i = 0, l = children.length; i < l; i += 1) {
                child = children[i];
                position = child.position;

                // Is it the first element of the line?
                newLine = lastEnd === undefined || lastEnd > position.x;

                if (newLine) {
                    // Is it the first line?
                    firstLine = lastEnd === undefined;

                } else {
                    // Have we more than one element on the line?
                    horizontal = true;
                }

                lastEnd = position.x + child.element[width];

                if (
                    (newLine || position.x <= handlesPosition.x) &&
                        (firstLine || position.y <= handlesPosition.y)
                ) {
                    closest = i;
                }
            }

            // Compute the final index
            next = 0;
            if (closest !== undefined) {
                // Go before or after the closest
                child = children[closest];
                position = child.position;

                // TODO: WOW weird if in an if, not clear
                if (
                    horizontal ?
                            position.x + child.element[width] / 2 > handlesPosition.x :
                                    position.y + child.element[height] / 2 > handlesPosition.y
                ) {
                    next = closest;
                } else {
                    next = closest + 1;
                }
            }

            nextChild = children[next] && children[next].element;
            previousChild = children[next - 1] && children[next - 1].element;

            // Insert the placeholder at the given position
            if (
                target === handles || !target ||
                    (this.options.allowBesidePlaceholder || previousChild !== target && nextChild !== target)
            ) {
                // If the target is moving, or the target is not already at this
                // position
                // TODO: WOW weird if in an if, not clear
                if (
                    nextChild ?
                            nextChild !== placeholder && nextChild.previousSibling !== placeholder :
                            previousChild ?
                                    previousChild !== placeholder && previousChild.nextSibling !== placeholder :
                                            zone.lastChild !== placeholder
                ) {
                    if (nextChild || previousChild) {
                        // Insert before the next element
                        placeholder.inject(nextChild || previousChild, nextChild ? 'before' : 'after');
                    } else {
                        // Insert at the end
                        placeholder.inject(zone);
                    }
                    this.refreshPlaceholderCache();
                    this.refreshCache();
                }

            } else if (Element.isInjected.call(placeholder)) {
                // If the placeholder is next to the target (same place targeted)
                placeholder.remove();
                this.refreshPlaceholderCache();
                this.refreshCache();
            }
        }

    });

    return UWA.namespace('Controls/Drag', Drag, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/ThemedScroller
 *
 */

define('UWA/Controls/ThemedScroller', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Controls/Abstract',
    'UWA/Controls/Drag',
    'UWA/Class/Timed'
], function (UWA, Utils, Client, ControlsAbstract, Drag, Timed) {
    'use strict';

    /**
     * Gets the event position relative to the client screen.
     *
     * @param {DOMEvent} event
     * @return {Object} a hash with coordinates stored in x/y properties
     */
    function domEventPosition(event) {
        if (event.event) {
            event = event.event;
        }
        var positions = event.changedTouches || event.touches || [event];
        var result = {x: 0, y: 0};
        var l = positions.length;
        var i;
        for (i = 0; i < l; i++) {
            result.x += positions[i].clientX / l;
            result.y += positions[i].clientY / l;
        }
        return result;
    }

    /* Base informations for each scroll direction */
    var baseInfos = {
        delta: 0,
        coef: 1,
        active: false,
        visible: false,
        scrollSize: 0,
        scrollPosition: 0,
        offsetSize: 0
    };

    /* Internal drag handler for scrollbars */
    var DragScrollBar = Drag.extend({

        defaultOptions: {
            touchSnap: 0,
            touchDelay: 0
        },

        init: function (scroller, options) {
            this._parent(options);
            this.scroller = scroller;
            this.direction = this.element.className.contains('scrollbar-y') ? 'y' : 'x';
        },

        _getInfos: function () {
            return this.scroller._infos[this.direction];
        },

        /* Gets the position of the mouse relative to the scrollbar */
        _getPosition: function () {
            var scrollbarPosition = this.element.getBoundingClientRect()[this.direction === 'y' ? 'top' : 'left'];
            return domEventPosition(this.currentEvent)[this.direction] - scrollbarPosition;
        },

        start: function (position) {
            this._parent(position);
            this._getInfos().active = true;
            this.scroller.update();
            // Store the initial position
            this.position = this._getPosition();
        },

        move: function (position, delta) {
            this._parent(position, delta);
            // Update the scroll
            var infos = this._getInfos();
            infos.delta = (this._getPosition() - this.position) * infos.coef;
            infos.active = true;
            this.scroller.updateVisible();
        },

        stop: function () {
            this._parent();
            this.scroller.updateActive(this.currentEvent);
        }
    });

    var ThemedScroller = ControlsAbstract.extend(Timed, {
        name: 'uwa-themed-scroller',

        options: {
            element: null,
            scrollbars: 'auto',
            scrollbarsMargin: 4,
            scrollbarsMinSize: 50,
            shadows: false
        },

        /**
         * Constructor
         *
         * @param {Object} [options=] a hash reprenting options to use for this instance
         *
         * @param {DOMElement} [options.element=] an existing element to use
         * instead of creating a new one
         *
         * @param {String} [options.scrollbars=auto] which scrollbars to display:
         * 'none', 'virtual', 'native' or 'auto'. Virtual scrollbars will be
         * fully customisable DOM scrollbars, with a nice look by default.
         * Native scrollbars will be the native OS scrollbars. The 'auto' style
         * will chose between the two other values, depending of the current OS
         * and browser. The 'none' style won't display scrollbars.
         *
         * @param {Number} [options.scrollbarsMargin=4] space (in px) to leave before and after scrollbars
         *
         * @param {Number} [options.scrollbarsMinSize=50] minimum size (in px) of scrollbars
         *
         * @param {Boolean} [options.shadows=false] if it should display shadows or not
         *
         * @constructs UWA.Controls.ThemedScroller
         */
        init: function (options) {
            if (UWA.is(options) && UWA.is(options.element)) {
                UWA.extendElement(options.element);
            }

            this._parent(options);

            this._elementEvents = {
                mousemove: this.updateActive.bind(this),
                mouseout: this.updateActive.bind(this)
            };

            this.build();
            this.initInfos();
        },

        initInfos: function () {
            this._infos = {
                x: Object.create(baseInfos),
                y: Object.create(baseInfos)
            };
            this.setPeriodical('update', this.update, 1000);
            this.updateShift();
            this.update();
        },

        destroy: function () {
            if (this.options.element) {
                var container = this.elements.container;
                container
                    .removeEvents(this._elementEvents)
                    .removeClassName(this.getClassNames())
                    .setContent(this.elements.content.childNodes);
                var oldDestroy = container.destroy;
                container.destroy = function () {}; // don't destroy the container
                this._parent();
                container.destroy = oldDestroy;
            } else {
                this._parent();
            }
        },

        onInjected: function () {
            this.initInfos();
        },

        /**
         * Initialize the wrapper, bind the events
         */
        build: function () {
            var container = this.options.element || UWA.createElement('div');
            container
                .addClassName(this.getClassNames())
                .addEvents(this._elementEvents);

            var extraClass = this.options.scrollbars === 'native' ? 'native-scrollbars ' : 'no-native-scrollbars ';

            var content = UWA.createElement('div', {
                'class': extraClass + this.getClassNames('-content'),
                events: {
                    scroll: this.updateVisible.bind(this)
                },
                html: container.childNodes
            }).inject(container);

            this.setDelayed('hide-overflow', function () {
                /* We have to set the overflow to hidden asynchorously, because
                 * of a nasty bug in Firefox. To reproduce, try to remove this
                 * setTimeout and load the smartreader with a lot of feeds. The
                 * tab panel should have a weird scrollbar below the scroller.
                 */
                container.setStyle('overflow', 'hidden');
            }, 0);

            this.elements.container = container;
            this.elements.content = content;
        },

        /**
         * Get the inner element. Use this if you want to access the content of
         * the scroller.
         *
         * @return {DOMElement} the inner element
         */
        getInnerElement: function () {
            return this.elements.content;
        },

        /**
         * Get the scrollbar for one direction. Optionally, the scrollbar is
         * built if it does not exist yet.
         *
         * @param {String} dir 'x' or 'y'
         * @param {Boolean} [create=false] create the scrollbar if it does not
         * exist
         *
         * @returns {DOMElement|undefined} the scrollbar element or undefined
         * if it does not exist yet.
         */
        getScrollbar: function (dir, create) {
            var scrollbar = this.elements[dir + 'Scrollbar'];
            if (!scrollbar && create) {
                scrollbar = this.elements[dir + 'Scrollbar'] = UWA.createElement('div', {
                    'class': this.getClassNames('-scrollbar', '-scrollbar-' + dir)
                }).inject(this.elements.container);
                new DragScrollBar(this, {
                    element: scrollbar,
                    root: this.elements.container
                });
                // force redraw layout, needed for css transition
                scrollbar.clientHeight; // eslint-disable-line no-unused-expressions
            }
            return scrollbar;
        },

        /**
         * Get the shadow for one direction. Optionally, the shadow is
         * built if it does not exist yet.
         *
         * @param {String} dir 'x-start', 'x-end', 'y-start' or 'y-end'
         * @param {Boolean} [create=false] create the shadow if it does not
         * exist
         *
         * @returns {DOMElement|undefined} the shadow element or undefined
         * if it does not exist yet.
         */
        getShadow: function (dir, create) {
            var shadow = this.elements[dir + 'Shadow'];
            if (!shadow && create) {
                shadow = this.elements[dir + 'Shadow'] = UWA.createElement('div', {
                    'class': this.getClassNames('-shadow', '-shadow-' + dir)
                }).inject(this.elements.container);
            }
            return shadow;
        },

        /**
         * Show or hide a shadow.
         *
         * @param {String} dir 'x-start', 'x-end', 'y-start' or 'y-end'
         * @param {Number} value number of pixels available to scroll. Used to
         * change the intensity of the shadow.
         */
        showShadow: function (dir, value) {
            var shadow = this.getShadow(dir, value);
            var maxValue = 100;
            if (value) {
                if (value > maxValue) {
                    value = maxValue;
                }
                shadow.setStyle('opacity', value / maxValue).addClassName('active');
            } else if (shadow) {
                shadow.removeClassName('active');
            }
        },

        /**
         * Update the active scrollbars according to the current pointer
         * position. This will call `updateVisible` in order to update the
         * rendering.
         *
         * @param {DOMEvent} event the mouse or touch event to use to know
         * the position of the pointer.
         */
        updateActive: function (event) {
            this.updateShift();
            if (this.options.scrollbars !== 'virtual') {
                return;
            }

            function between(a, b, c) {
                return a < b && b < c;
            }
            if (event.type === 'mouseout' || event.type === 'touchend') {
                this._infos.x.active = this._infos.y.active = false;
            } else {
                var rect = this.elements.container.getBoundingClientRect();
                var zoneWidth = 12;
                var position = domEventPosition(event);
                ['x', 'y'].forEach(function (dir, y) {
                    var limit = rect[y ? 'right' : 'bottom'];
                    this._infos[dir].active = between(limit - zoneWidth, position[y ? 'x' : 'y'], limit) &&
                        between(rect[y ? 'top' : 'left'], position[dir], rect[y ? 'bottom' : 'right']);
                }, this);
            }
            this.updateVisible();
        },

        /**
         * Set the scrollbars visible for one second. This will call `update`
         * in order to update the rendering.
         */
        updateVisible: function () {
            this._infos.x.visible = this._infos.y.visible = true;
            this.setDelayed('scrollbars-visible', function () {
                this._infos.x.visible = this._infos.y.visible = false;
                this.update();
            }, 1000);
            this.update();
        },

        updateShift: function () {
            var content = this.elements.content;
            if (this._shift === undefined && content.isInjected()) {
                var scrollbars = this.options.scrollbars;
                if (scrollbars === 'auto') {
                    /* Disable virtual scrollbars in iOS by default, because when
                     * used with `-webkit-overflow-scrolling: touch;` in order to
                     * use momentum and bouncing, the 'scroll' event is not
                     * triggered until the scroll stops, so the rendering of the
                     * scrollbars is laggy.
                     *
                     * Disable virtual scrollbars on Firefox if the scrollbar
                     * width is zero (mostly on MacOS for now), because we
                     * can't hide scrollbars on Firefox.
                     *
                     * Warning: chrome/MacOS with hidden native scrollbars does
                     * not apply the ::--webkit-scrollbar styles if the
                     * scrollbars were already displayed. Make sure scrollbars
                     * are hidden before determining the type of auto
                     * scrollbars.
                     */
                    if (Client.Platform.ios || (content.offsetWidth - content.clientWidth === 0 && Client.Engine.firefox)) {
                        scrollbars = 'native';
                        content.removeClassName('no-native-scrollbars').addClassName('native-scrollbars');
                    } else {
                        scrollbars = 'virtual';
                    }
                    this.options.scrollbars = scrollbars;
                }
                if (scrollbars === 'virtual') {
                    var shift = content.offsetWidth - content.clientWidth;
                    if (shift >= 0 && shift < 30) { // quick and dirty way to check if the shift has an reasonable value
                        this._shift = shift;
                        content.setStyles({
                            right: -this._shift,
                            bottom: -this._shift
                        });
                    }
                } else {
                    this._shift = 0;
                }
            }
        },

        /**
         * Access to the DOM to read the sizes needed for the `_write` method.
         *
         * @param {Boolean} y true if this is the 'y' direction
         * @protected
         */
        _read: function (y) {
            var infos = this._infos[y ? 'y' : 'x'];
            var content = this.elements.content;
            infos.scrollSize = content[y ? 'scrollHeight' : 'scrollWidth'];
            infos.scrollPosition = content[y ? 'scrollTop' : 'scrollLeft'] + infos.delta;
            infos.offsetSize = content[y ? 'offsetHeight' : 'offsetWidth'] - (this._shift || 0);

            if (infos.scrollPosition < 0) {
                infos.scrollPosition = 0;
            } else if (infos.scrollPosition > infos.scrollSize - infos.offsetSize) {
                infos.scrollPosition = infos.scrollSize - infos.offsetSize;
            }
        },

        /**
         * Update the DOM according to the current scroller state (informations
         * gathered by `_write` and other methods).
         *
         * @param {Boolean} y true if this is the 'y' direction
         * @protected
         */
        _write: function (y) {
            var dir = y ? 'y' : 'x';
            var infos = this._infos[dir];
            var options = this.options;

            if (infos.delta) {
                this.elements.content[y ? 'scrollTop' : 'scrollLeft'] = infos.scrollPosition;
                infos.delta = 0;
            }

            if (this.options.scrollbars === 'virtual') {
                var scroll = infos.scrollSize > infos.offsetSize;
                var scrollbar = this.getScrollbar(dir, scroll);

                if (scroll && infos.scrollSize) {
                    var totalSize = infos.offsetSize - 2 * options.scrollbarsMargin;
                    var size = (totalSize * (infos.offsetSize / infos.scrollSize));
                    if (size < options.scrollbarsMinSize) {
                        size = options.scrollbarsMinSize;
                    }
                    infos.coef = (infos.scrollSize - infos.offsetSize) / (totalSize - size);
                    scrollbar.style[y ? 'top' : 'left'] = (options.scrollbarsMargin + infos.scrollPosition / infos.coef) + 'px';
                    scrollbar.style[y ? 'height' : 'width'] = size + 'px';
                    scrollbar
                        .toggleClassName('active', infos.active)
                        .toggleClassName('visible', infos.visible);
                } else if (scrollbar) {
                    scrollbar.removeClassName('active').removeClassName('visible');
                }
            }

            if (options.shadows) {
                this.showShadow(dir + '-start', infos.scrollPosition);
                this.showShadow(dir + '-end', infos.scrollSize - infos.scrollPosition - infos.offsetSize);
            }
        },

        /**
         * Update the scroller rendering. This method is debounced using a
         * requestAnimationFrame and won't change anything if the direction
         * informations did not change since the last call.
         */
        update: function () {
            this.setAnimate('update', function () {
                this.updateShift();
                this._read(false);
                this._read(true);
                if (!UWA.equals(this._previousInfos, this._infos)) {
                    // Separate reads from writes to avoid unnecessary repaint
                    this._write(false);
                    this._write(true);
                    this._previousInfos = UWA.clone(this._infos);
                }
            });
        }
    });

    return UWA.namespace('Controls/ThemedScroller', ThemedScroller, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * This module provides a set of custom input and buttons.
 *
 * @module   UWA/Controls/Input
 *
 *
 * @see http://uwa.netvibes.com/apps/Samples/Controls/Input/index.xhtml
 */
define('UWA/Controls/Input', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Element',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Utils/Scroll',
    'UWA/Controls/Abstract',
    'UWA/Controls/DropDown',
    'UWA/Controls/ThemedScroller',
    'UWA/Class/Timed'
], function (UWA, Event, Element, Utils, Client, Scroll, Abstract, DropDown, ThemedScroller, Timed) { // jshint ignore:line
    'use strict';

    // {{{ Input

    /**
     * Abstract class to build an input.
     *
     * ##### Available Events
     *
     * | Event            |  Description                                        |
     * | ---------------- | --------------------------------------------------- |
     * | `onChange`       | When the value changes                              |
     * | `onKeyDown`      | When the user press a key                           |
     * | `onClick`        | When the user click on the control                  |
     * | `onMouseDown`    | When the user press the mouse button on the control |
     *
     * @example
     * var button = new UWA.Controls.Input.Button({
     *     value: "Camion?",
     *     events: {
     *         onClick: function () { alert("Pouet pouet"); }
     *     }
     * }).inject(widget.body);
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {String} [options.className=''] - Class names to apply on dom elements built by this control
     * @param {String} [options.element=''] - Element to use in order to render this control
     * (ex: a `button` for a Input.Button, an `input` for a Input.Text...)
     * @param {String} [options.attributes={}] - A set of attributes to set on the input element (see UWA.Element.set)
     * @param {String} [options.value=''] - Set the input value immediatly
     *
     * @abstract
     * @constructs UWA.Controls.Input
     * @extends module:UWA/Controls/Abstract.UWA.Controls.Abstract
     * @memberof module:UWA/Controls/Input
     */
    var Input = Abstract.extend(/** @lends module:UWA/Controls/Input.UWA.Controls.Input# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        options: {
            className: '',
            element: null,
            attributes: {},
            value: ''
        },

        /**
         * @property {String} name - The input name. Default: 'uwa-input'
         * @protected
         */
        name: 'uwa-input',

        /**
         * @property {Boolean} _hiddenInput - If the input element should be displayed or
         * emulated with some generated DOM. Default: false.
         * @protected
         */
        _hiddenInput: true,

        init: function (options) {
            if (this.constructor === Input) {
                throw new Error('Use a subclass of Input');
            }
            this._parent(options);

            var element = options && options.element,
                parentElement = element && element.parentNode,
                afterElement = element && element.nextSibling;

            if (parentElement) {
                parentElement.removeChild(element);
            }

            this.events = null;

            this.getContent(); // build dom
            if (UWA.owns(options, 'value')) {
                this.setValue(options.value);
            }

            // TODO maybe put this in a Controls.Abstract helper
            if (parentElement) {
                this.inject(afterElement || parentElement, afterElement && 'before');
            }
        },

        /**
         * Build main dom elements.
         * @protected
         */
        buildSkeleton: function () {

            var elements = this.elements;

            elements.input = (this.options.element || this.buildInput()).set(this.options.attributes);

            if (this._hiddenInput) {
                elements.content = UWA.createElement('div', {
                    'class': this.getClassNames('-content')
                });

                elements.input.addClassName(this.getClassNames('-input') + ' hidden-input');

                elements.container = UWA.createElement('div', {
                    html: [
                        elements.input,
                        elements.content
                    ]
                });
            } else {
                elements.content = elements.container = elements.input;
            }

            elements.container.addClassName(this.getClassNames());

            // This will call syncEvents
            this.setDisabled(this.isDisabled());
        },

        _syncEvents: function (inputOnly) {
            var that = this,
                elements = this.elements;

            function dispatch(event) {
                return that.dispatchEvent.bind(that, event);
            }

            if (!that.events) {
                that.events = {
                    container: {
                        mouseenter: function () { this.addClassName('hover'); },
                        mouseleave: function () { this.removeClassName('hover'); },
                        mousedown: function (e) {
                            this.addClassName('active');
                            that.dispatchEvent('onMouseDown', [e]);
                        },
                        mouseup: function () { this.removeClassName('active'); },
                        click: dispatch('onClick')
                    },
                    input: {
                        change: dispatch('onChange'),
                        keydown: dispatch('onKeyDown'),
                        focus: that.focus.bind(that, true, false),
                        blur: that.focus.bind(that, false, false)
                    }
                };
            }

            if (that.isDisabled()) {
                elements.container.removeEvents(that.events.container);
                elements.input.removeEvents(that.events.input);
            } else {
                if (!that._hiddenInput || !inputOnly) {
                    elements.container.addEvents(that.events.container);
                }
                elements.input.addEvents(that.events.input);
            }

        },

        /**
         * Build the native input element. To override.
         *
         * @return {DOMElement} The native input element
         */
        buildInput: function () {
            return UWA.createElement('input', {type: 'text'});
        },

        /**
         * Synchronize the control display with the native input state. To override.
         */
        syncInput: function () {
            if (this._hiddenInput && this.elements.content) {
                this.elements.content.setText(this.getValue());
            }
        },

        /**
         * Set the focus on this input.
         *
         * @param {Boolean} [y=true] If `false`, removes the focus.
         * @param {Boolean} [changeInputFocus=true] change the input focus (you should not change that)
         * @return {this} instance
         */
        focus: function (y, changeInputFocus) {
            if (y === undefined) {
                y = true;
            }
            Element.toggleClassName.call(this.elements.container, 'focus', y);
            if (changeInputFocus !== false) {
                this.elements.input[y ? 'focus' : 'blur']();
            }
            return this;
        },

        /**
         * Get if this input is disabled
         *
         * @return {Boolean}
         */
        isDisabled: function () {
            return Boolean(this.elements.input.disabled);
        },

        /**
         * Set the input as disabled
         *
         * @param {Boolean} [y=true] If `false`, enable the input.
         * @return {this}
         */
        setDisabled: function (y) {
            if (y === undefined) {
                y = true;
            }
            this.elements.input.disabled = y;
            this.elements.container.toggleClassName('disabled', y);
            this._syncEvents();
            return this;
        },

        /**
         * Get the input value. To override if needed.
         *
         * @return {String} The input value
         */
        getValue: function () {
            var input = this.elements.input,
                tag = input.getTagName();
            return tag === 'input' || tag === 'textarea' ? input.value : input.getText();
        },

        /**
         * Set the input value. To override if needed.
         *
         * @param {String} value - The new value
         * @return {this}
         */
        setValue: function (value) {
            var input = this.elements.input,
                tag = input.getTagName();
            if (tag === 'input' || tag === 'textarea') {
                input.value = value;
            } else {
                input.setText(value);
            }
            this.syncInput();
            return this;
        },

        /**
         * Returns control content.
         *
         * @return {HTMLelement} Control container.
         */
        getContent: function () {
            if (!this.elements.container) {
                this.buildSkeleton();
                this.syncInput();
            }
            return this.elements.container;
        },

        /**
         * Returns the native input element
         *
         * @return {HTMLelement}
         */
        getInputElement: function () {
            return this.elements.input;
        },

        /**
         * Dispatch the 'change' event in the input. Used internally to fire
         * the event when the native input is driven by the control.
         * @private
         */
        _dispatchOnChange: function () {
            if (this.isDisabled()) {
                this.syncInput();
            } else {
                Event.dispatchEvent(this.elements.input, 'change');
            }
        },

        onMouseDown: function (e) {
            if (this._hiddenInput && !Client.Features.touchEvents) {
                Event.preventDefault(e);
                this.focus();
            }
        },

        onChange: function (e) {
            this.syncInput();
            this._bubbleOnChange(e);
        },

        _bubbleOnChange: (function () {
            var bubbleOnChange;

            function getBubbleOnChange() {
                if (bubbleOnChange === undefined) {
                    bubbleOnChange = false;

                    var container = document.createElement('div'),
                        input = document.createElement('input');

                    input.type = 'text';
                    container.appendChild(input);

                    // In order to dispatch an event, the input has to be in
                    // the dom (IE8)
                    container.style.display = 'none';
                    document.body.appendChild(container);

                    Element.addEvent.call(container, 'change', function (e) {
                        bubbleOnChange = true;
                        Event.stop(e);
                    });
                    Event.dispatchEvent(input, 'change');

                    Element.remove.call(container);
                    Element.removeEvents.call(container);
                }
                return bubbleOnChange;
            }

            return function (e) {
                var eventHandler,
                    element = this.elements.input.parentNode;
                if (!getBubbleOnChange()) {
                    // While we have a parent and the propagation has not been stopped
                    while (element && element.nodeType === 1 && (e.event || e).returnValue !== false) {
                        eventHandler = element._events && element._events.change;
                        if (eventHandler) {
                            eventHandler.handleEvent(e);
                        }
                        element = element.parentNode;
                    }
                }
            };
        }()),

        onKeyDown: function () {
            this.syncInput();
        }

    });

    // }}}

    // {{{ ToggleInput

    /**
     * Protected. Inherits from Input.
     * Abstract class to build a toggleable input.
     *
     * @constructs UWA.Controls.Input._ToggleInput
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @memberof module:UWA/Controls/Input
     */
    Input._ToggleInput = Input.extend(/** @lends module:UWA/Controls/Input.UWA.Controls.Input._ToggleInput# */{

        /**
         * @property {String} name - The input name. Default: 'uwa-toggle'
         * @protected
         */
        name: 'uwa-toggle',

        buildSkeleton: function () {
            this._parent();
            this.elements.content.addClassName('uwa-icon');
        },

        /**
         * Get if this input is checked
         * @returns {Boolean}
         */
        isChecked: function () {
            return this.elements.input.checked;
        },

        /**
         * Set the focus of this input
         * @param {Boolean} [y=true] if false, blurs the focus
         * @returns {Object} this
         */
        focus: function (y) {
            this._parent(y);
            // When clicking on a <label> handling this input, the input state
            // can change. On IE8 (and maybe other browsers), the onChange and
            // onClick events are not fired by clicking on the <label>, but the
            // onBlur and onFocus are. So we sync the input here.
            // This should not harm other browsers
            this.syncInput();
            return this;
        },

        /**
         * Check or uncheck the input.
         *
         * @param {Boolean} [y=true] - If `false`, uncheck the input
         * @return {this}
         */
        check: function (y) {
            this.elements.input.checked = y !== false;
            this.syncInput();
            return this;
        }
    });

    // }}}

    // {{{ Radio

    /**
     * Radio input.
     * Inherits from Input._ToggleInput.
     *
     * ##### Available CSS Classes
     *
     * The className option can be composed of one or more of those CSS classes:
     *
     * | Class name       |  Description                                      |
     * | ---------------- | ------------------------------------------------- |
     * | `light`          | Use this class if it will be on a dark background |
     *
     * @constructs UWA.Controls.Input.Radio
     * @extends module:UWA/Controls/Input.UWA.Controls.Input._ToggleInput
     * @memberof module:UWA/Controls/Input
     */
    Input.Radio = Input._ToggleInput.extend(/** @lends module:UWA/Controls/Input.UWA.Controls.Input.Radio# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-radio'.
         */
        name: 'uwa-radio',

        buildInput: function () {
            return UWA.createElement('input', {type: 'radio'});
        },

        onClick: function (e) {
            this._parent(e);
            var input = this.elements.input;
            if (!input.checked) {
                input.checked = true;
                this._dispatchOnChange();
            }
        },

        syncInput: function () {
            var myinput = this.elements.input,
                name = myinput.name,
                done = false;

            function sync(input) {
                var content = input.parentNode;
                if (content && Element.hasClassName.call(content, 'uwa-radio')) {
                    Element.toggleClassName.call(content, 'checked', input.checked);
                }
                done |= myinput === input;
            }

            if (name) {
                Array.prototype.forEach.call(document.getElementsByName(name), sync);
            }

            if (!done) {
                sync(myinput);
            }
        }
    });

    // }}}

    // {{{ Checkbox

    /**
     * Checkbox input.
     * Inherits from Input._ToggleInput.
     *
     * ##### Available CSS Classes
     *
     * The className option can be composed of one or more of those CSS classes:
     *
     * | Class name       |  Description                                      |
     * | ---------------- | ------------------------------------------------- |
     * | `light`          | Use this class if it will be on a dark background |
     * | `switch`         | Alternative design                                |
     * | `small`          | To be used with `switch`, a smaller switch        |
     *
     * @constructs UWA.Controls.Input.Checkbox
     * @extends module:UWA/Controls/Input.UWA.Controls.Input._ToggleInput
     * @mixes UWA.Classes.Timed
     * @memberof module:UWA/Controls/Input
     */
    Input.Checkbox = Input._ToggleInput.extend(Timed, /** @lends module:UWA/Controls/Input.UWA.Controls.Input.Checkbox# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-checkbox',
         * @protected
         */
        name: 'uwa-checkbox',

        buildInput: function () {
            return UWA.createElement('input', {type: 'checkbox'});
        },

        onClick: function (e) {
            this._parent(e);

            /*
             * We have to toggle the input artificially when clicking on the content. But
             * there is a trap: when the input is inside a label or associated with a
             * label by an id, the input may be checked by the browser, so it will go back
             * to its initial state.
             *
             * The delayed 'extern-change-prevention' is here to prevent the input to be
             * changed twice within one millisecond.
             *
             * We have to prevent the articial toggle if the event 'onchange' has been
             * dispatched immediately before or after the onclick event.
             */
            if (!this.hasDelayed('extern-change-prevention')) {
                this.setDelayed('extern-change-prevention', function () {
                    this.elements.input.checked = !this.elements.input.checked;
                    this.syncInput();
                    this._dispatchOnChange();
                }, 1);
            }
        },

        onChange: function (e) {
            this._parent(e);
            // Both cancel the current delayed and prevent a future delayed
            this.setDelayed('extern-change-prevention', function () { }, 1);
        },

        syncInput: function () {
            this.elements.container.toggleClassName('checked', this.elements.input.checked);
        }
    });

    // }}}

    // {{{ Select

    /**
     * Represents a select input.
     * Inherits from Input.
     *
     * Known issue: there is a bug on WebKit with subpixel rendering of
     * display: table CSS. Thus, a strange one pixel column may appear if the
     * input has a subpixel width (for example, 150.5px or a size in em). In
     * order to prevent this, specify the width with a rounded pixel value.
     * See http://jsfiddle.net/DBkfF/
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {String} [options.options={}] - Directly add some options to this instance.
     * See Input.Select#putOptions.
     *
     * @constructs UWA.Controls.Input.Select
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @memberof module:UWA/Controls/Input
     */
    Input.Select = Input.extend(Timed, /** @lends module:UWA/Controls/Input.UWA.Controls.Input.Select# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-select'.
         * @protected
         */
        name: 'uwa-select',

        /**
         * @property {Object} options - The default controls options
         * @protected
         */
        options: {
            options: []
        },

        init: function (options) {
            this._parent(options);
            if (UWA.owns(options, 'options')) {
                this.putOptions(options.options);
            }
            // set the value here because when it is done in the parent init method, the
            // options are not yet created, so the value can't be set
            if (UWA.owns(options, 'value')) {
                this.setValue(options.value);
            }
        },

        focus: function (y) {
            this._parent(y);
            if (y === false) {
                this.elements.dropdown.hide();
            }
            return this;
        },

        buildInput: function () {
            return UWA.createElement('select');
        },

        buildSkeleton: function () {
            var split,
                elements = this.elements;
            this._parent();

            var body = elements.container.getDocument().body;

            elements.content.addContent([
                split = UWA.createElement('div', {
                    'class': this.getClassNames('-split'),
                    html: [{
                        tag: 'div',
                        'class': this.getClassNames('-text')
                    }, {
                        tag: 'div',
                        'class': this.getClassNames('-button'),
                        html: { tag: 'div', 'class': 'uwa-icon uwa-icon-only' }
                    }]
                })

            ]);

            elements.dropdown = new DropDown({
                className: this.options.className,

                global: true,
                _root: false,

                position: function () {
                    var dropdownContent = elements.dropdown.getInnerElement();

                    var boundingClientRect = elements.container.getBoundingClientRect();
                    var spaceAbove = boundingClientRect.top;
                    var spaceBelow = Client.getSize().height - boundingClientRect.top - boundingClientRect.height;

                    // if the input is nearest the bottom than the top, display on top.
                    var isOnTop = spaceAbove > spaceBelow;

                    dropdownContent.toggleClassName('uwa-select-dropdown-top', isOnTop);
                    dropdownContent.getElement('> .uwa-select-split').inject(dropdownContent, isOnTop ? 'bottom' : 'top');
                    dropdownContent.setStyle('width', boundingClientRect.width);

                    elements.scroller.getContent().setStyle('height', Math.min(
                        elements.options.offsetHeight,
                        isOnTop ? spaceAbove : spaceBelow
                    ));
                    elements.scroller.update();

                    return {
                        x: boundingClientRect.left,
                        y: elements.container.getOffsets().y - (
                            isOnTop ? Math.min(boundingClientRect.top, elements.options.offsetHeight) : 0)
                    };
                },

                positionOptions: { fit: 'resize-max', relative: body },

                events: {
                    onShow: function () {
                        if (elements.container) {
                            elements.container.addClassName('dropdown-visible');
                            this._scrollToSelected();
                        }
                    }.bind(this),
                    onHide: function () {
                        if (elements.container) {
                            elements.container.removeClassName('dropdown-visible');
                        }
                    },
                    onRemoved: function () {
                        if (elements.container) {
                            elements.container.removeClassName('dropdown-visible');
                        }
                    }
                }
            });

            elements.dropdown.getInnerElement().addClassName('uwa-select-dropdown');
            elements.dropdown.inject(elements.content);

            elements.options = UWA.createElement('div', {
                'class': this.getClassNames('-options'),
                events: { mousedown: this._selectionHandler.bind(this) }
            });

            elements.scroller = new ThemedScroller({
                shadows: false
            });
            elements.scroller.getInnerElement().addContent(elements.options);

            elements.dropdown.getInnerElement().setContent([
                split.cloneNode(true),
                elements.scroller
            ]);
        },

        getValue: function () {
            return this._getSelectedOptions().map(function (option) { return option.value; });
        },

        /**
         * Select some options based on their value.
         * @param {Array} values values to select
         * @returns {this}
         */
        setValue: function (values) {
            var indexes = [];
            values = Utils.splat(values);
            this._getOptions().forEach(function (option, index) {
                if (values.indexOf(option.value) !== -1) {
                    indexes.push(index);
                }
            });
            return this.setSelection(indexes);
        },

        /**
         * Select some options based on their indexes.
         *
         * @param {Array} indexes - Indexes to select
         * @return {this}
         */
        setSelection: function (indexes) {
            if (!this._isMultiple()) {
                indexes = indexes.slice(0, 1);
            }
            this._getOptions().forEach(function (option, index) {
                option.selected = indexes.indexOf(index) !== -1;
            });
            this._dispatchOnChange();
            return this;
        },

        /**
         * Get the selected options indexes.
         *
         * @return {Array} of integers.
         */
        getSelection: function () {
            var result = [];
            this._getOptions().forEach(function (option, index) {
                if (option.selected) {
                    result.push(index);
                }
            });
            return result;
        },

        /**
         * Get if this select box is multiple.
         * @protected
         * @returns {Boolean}
         */
        _isMultiple: function () {
            return this.elements.input.multiple;
        },

        /**
         * Get the <option> elements
         * @protected
         * @returns {Array} DOM elements
         */
        _getOptions: function () {
            return this.elements.input.getElements('option');
        },

        /**
         * Get the selected <option> elements
         * @protected
         * @returns {Array} DOM elements
         */
        _getSelectedOptions: function () {
            return this._getOptions().filter(function (option) { return option.selected; });
        },

        _dispatchOnChange: function () {
            this.clearDelayed('on-change-debounce');
            this._parent();
        },

        /**
         * Handle the select event by clicking on an option.
         * @protected
         * @param {DOMEvent} event the click event
         */
        _selectionHandler: function (event) {
            Event.stop(event);
            if (!this._isMultiple()) {
                this.elements.dropdown.hide();
                // When the dropdown gets closed, the 'mouseout' event is not triggered.
                // Remove the hover class manually
                this.elements.container.removeClassName('hover');
            }
            var selection, iIndex,
                element = Event.findElement(event, '.option,.optgroup'),
                index = 0,
                indexes = [],
                isOption = element.hasClassName('option'),
                inGroup = false;

            // Get the indexes of the user selection. If the user clicked on a
            // group, the result will contain all indexes of the group.
            element.getParent().getChildren().some(function (child) {
                if (isOption) {
                    if (element === child) {
                        indexes.push(index);
                        return true;
                    }
                } else if (inGroup) {
                    if (child.hasClassName('option')) {
                        indexes.push(index);
                    } else {
                        return true;
                    }
                } else if (element === child) {
                    inGroup = true;
                }

                if (child.hasClassName('option')) {
                    index += 1;
                }
            });

            // If the input is multiple, we have to toggle the user
            // selection instead of replacing it
            if (this._isMultiple()) {

                selection = this.getSelection();
                if (isOption) {
                    // Toggle the index
                    iIndex = selection.indexOf(indexes[0]);
                    if (iIndex === -1) {
                        selection.push(indexes[0]);
                    } else {
                        selection.splice(iIndex, 1);
                    }
                } else if (indexes.some(function (_index) { return selection.indexOf(_index) < 0; })) {
                    // If some indexes are not already selected, complete the group
                    indexes.forEach(function (_index) {
                        if (selection.indexOf(_index) < 0) {
                            selection.push(_index);
                        }
                    });

                // else clean the group
                } else {
                    selection = selection.filter(function (_index) {
                        return indexes.indexOf(_index) < 0;
                    });
                }
                indexes = selection;
            }

            this.setSelection(indexes);
        },

        syncInput: function () {
            var input = this.elements.input,
                elements = this.elements;

            function buildOptionList() {
                var group, result;
                result = Array.prototype.map.call(input.getElementsByTagName('*'), function (child) {
                    var name = Element.getTagName.call(child),
                        element = UWA.createElement('div', {
                            'class': name + (child.selected ? ' selected' : ''),
                            text: child.label || Element.getText.call(child) || '\u00A0'
                        });

                    if (name === 'optgroup') {
                        if (group) {
                            group.addClassName('selected');
                        }
                        group = element;
                    } else if (!child.selected) {
                        group = null;
                    }
                    return element;
                });

                if (group) {
                    group.addClassName('selected');
                }

                return result;
            }

            var text = this._getSelectedOptions().map(Element.getText.call, Element.getText).join(', ') || '\u00A0';
            elements.content.getElement('.uwa-select-text').setText(text);
            elements.dropdown.getInnerElement().getElement('.uwa-select-text').setText(text);
            elements.options.empty(true).setContent(buildOptionList());
        },

        _scrollToSelected: function () {
            var selected = this.elements.dropdown && this.elements.dropdown.getInnerElement().getElement('.option.selected');
            if (selected) {
                Scroll.scrollToElement(selected);
            }
        },

        onClick: function (event) {
            this._parent(event);
            this.elements.dropdown.show();
        },

        onKeyDown: function (event) {
            var key = Event.whichKey(event),
                retain = true;

            if (key === 'space') {
                this.elements.dropdown.show();
            } else if (key === 'return') {
                this.elements.dropdown.toggle();
            } else if (key === 'esc') {
                this.elements.dropdown.hide();
            } else {
                retain = false;
            }

            if (retain) {
                Event.preventDefault(event);
            } else {
                this._parent(event);
                this.setDelayed('scroll-to-selected', this._scrollToSelected, 1);
            }
        },

        /**
         * Change options of the input.
         *
         * @example
         * var select = new UWA.Controls.Input.Select();
         *
         * // Add two normal options
         * select.putOptions([{
         *    label: UWA.i18n('Foo'),
         *    value: 'foo'
         * }, {
         *    label: UWA.i18n('Bar'),
         *    value: 'bar'
         * }]);
         *
         * // Remove the option with the value "foo"
         * select.putOptions([{
         *    value: 'foo'
         * }]);
         *
         * // Add two new grouped options
         * select.putOptions([{
         *    label: UWA.i18n('Foo 1'),
         *    value: 'foo1',
         *    group: UWA.i18n('Foo')
         * }, {
         *    label: UWA.i18n('Foo 2'),
         *    value: 'foo2',
         *    group: UWA.i18n('Foo'),
         *    selected: `true`
         * }]);
         *
         * select.inject(widget.body);
         *
         * @param {Array|Object} options - An array of objects or a single object
         * describing options to put in this select. Each object should have those fields:
         *
         * - String label - Text displayed on the option
         * - String value - Value of the option
         * - Boolean selected - Wether the option should be selected
         * - String optional group - A group label. All options with the
         * same group label will be grouped under this label.
         *
         * @param {Boolean} [replace] - Remove the existing options before
         * adding the new ones.
         * @return {this}
         */
        putOptions: function (options, replace) {
            var input = this.elements.input;
            function getElement(selector, value) {
                var i,
                    elements = input.getElementsByTagName('*');

                for (i = 0; i < elements.length; i += 1) {
                    if (elements[i][selector] === value) {
                        return elements[i];
                    }
                }
            }

            if (replace) {
                Element.empty.call(input, true);
            }

            Utils.splat(options).forEach(function (option) {
                var dom = getElement('value', option.value),
                    parent,
                    groupDom;

                if (option.label !== undefined) {
                    if (!dom) {
                        // Create new option
                        dom = UWA.createElement('option');
                    }

                    // Update option attributes
                    Element.set.call(dom, {
                        text: option.label,
                        value: option.value,
                        selected: option.selected
                    });

                    if (option.group) {
                        groupDom = getElement('label', option.group);
                        if (!groupDom) {
                            // Create new group
                            groupDom = input.appendChild(UWA.createElement('optgroup', {
                                label: option.group
                            }));
                        }
                        groupDom.appendChild(dom);
                    } else {
                        input.appendChild(dom);
                    }
                } else if (dom) {
                    parent = dom.parentNode;

                    // Remove option
                    Element.remove.call(dom);

                    // Remove empty groups
                    if (parent && Element.getTagName.call(parent) === 'optgroup' && parent.childNodes.length === 0) {
                        Element.remove.call(parent);
                    }
                }
            });
            this.syncInput();
            return this;
        },

        /**
         * Remove options from the input
         *
         * @param {Array|Object|String} options An array or a single entry
         * describing options to remove. The entry can be either an object with a `value`
         * field, or a string representing the value option itself.
         *
         * @example
         * // Add two normal options
         * select.putOptions([{
         *    label: UWA.i18n('Foo'),
         *    value: 'foo'
         * }, {
         *    label: UWA.i18n('Bar'),
         *    value: 'bar'
         * }]);
         *
         * // Remove the option 'foo'
         * select.removeOptions('foo');
         * // or
         * select.removeOptions({value: 'foo'});
         * // or
         * select.removeOptions([{value: 'foo'}]);
         */
        removeOptions: function (options) {
            this.putOptions(UWA.splat(options).map(function (option) {
                return {
                    value: typeof option === 'string' ? option : option.value
                };
            }));
        }

    });

    // }}}

    // {{{ File

    /**
     * Represents a file input.
     * Inherits from Input.
     *
     * @constructs UWA.Controls.Input.File
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @memberof module:UWA/Controls/Input
     */
    Input.File = Input.extend(/** @lends module:UWA/Controls/Input.UWA.Controls.Input.File# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-file'
         * @protected
         */
        name: 'uwa-file',

        buildInput: function () {
            return UWA.createElement('input', {
                type: 'file'
            });
        },

        buildSkeleton: function () {
            this._parent();

            if (!this.options.buttonOnly) {
                this.elements.text = UWA.createElement('div', {
                    'class': this.getClassNames('-text')
                });
            } else {
                this.elements.content.addClassName('button-only');
            }

            this.elements.content.addClassName(this.getClassNames('-split')).setContent([
                this.elements.text,
                UWA.createElement('div', {
                    'class': this.getClassNames('-button'),
                    text: UWA.i18n('Browse...')
                })
            ]);
        },

        setValue: function (value) {
            if (value) {
                throw new Error('You can\'t set a value to a file input');
            }
            var input = this.elements.input,
                clone;

            input.value = '';

            // On IE, we can't reset the value like this.
            if (input.value) {
                clone = UWA.extendElement(UWA.clone(input));
                clone.inject(input, 'before');
                input.destroy();
                this.elements.input = clone;
                this._syncEvents(true);
            }
            this.syncInput();
        },

        syncInput: function () {
            if (this.elements.text) {
                this.elements.text.setText(this.elements.input.value.replace(/^c:\\fakepath\\/i, '') || '\u00A0');
            }
        }
    });

    // }}}

    // {{{ Text

    /**
     * Represents a text input, either one line or multiline.
     * Inherits from Input.
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {Boolean} [options.multiline=false] - If `true`, this instance input will be multiline
     * (only if no element options is given).
     *
     * @constructs UWA.Controls.Input.Text
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @mixes module:UWA/Controls/Timed.UWA.Controls.Timed
     * @memberof module:UWA/Controls/Input
     */
    Input.Text = Input.extend(Timed, /** @lends module:UWA/Controls/Input.UWA.Controls.Input.Text# */{ // bypass

        /**
         * @property {String} name - The input name.
         * @private
         */
        name: 'uwa-text',

        _hiddenInput: false,

        /**
         * @property {Object} options - The default controls options.
         * @private
         */
        options: {
            multiline: false
        },

        buildInput: function () {
            return this.options.multiline ?
                    UWA.createElement('textarea') :
                    UWA.createElement('input', { type: 'text'});
        },

        buildSkeleton: function () {
            this._parent();
            this.elements.input.addClassName(this.getClassNames('-text'));
        },

        onKeyDown: function (e) {
            this._parent(e);
            // This will hide the placeholder when the user press the first key
            this.setDelayed('placeholder-sync', this.syncInput, 1);
        },

        onHide: function () {
            this._parent();
            this.setDelayed('placeholder-sync', this.syncInput, 1);
        },

        onShow: function () {
            this._parent();
            this.setDelayed('placeholder-sync', this.syncInput, 1);
        },

        onPostInject: function () {
            // Wait a little and then sync the placeholder when the input gets injected
            this.setDelayed('placeholder-sync', this.syncInput, 50);
        },

        getInputElement: function () {
            // This is the simplest way to sync the placeholder once the developer change the input
            // element directly
            this.setDelayed('placeholder-sync', this.syncInput, 1);
            return this._parent();
        },

        syncInput: function () {
            var input = this.elements.input;

            if (!Client.Features.inputPlaceholder) {
                if (!input.parentNode ||
                    this.getValue() ||
                    !input.getAttribute('placeholder') ||
                    !input.offsetHeight) {

                    this._hidePlaceholder();
                } else {
                    this._showPlaceholder();
                }
            }
        },

        _showPlaceholder: function () {
            var position, styles,
                elements = this.elements,
                input = elements.input,
                dimensions = input.getDimensions();

            if (!elements.placeholder) {
                // Better safe than sorry. Update the placeholder position periodically, so it fixes
                // all unexpected issues we can encounter (ex: the input moves, is removed from the
                // dom, the placeholder text changes, etc..)
                this.setPeriodical('placeholder-sync', this.syncInput, 1000);
                elements.placeholder = UWA.createElement('div', {
                    'class': this.getClassNames('-placeholder'),
                    events: {
                        click: this.focus.bind(this, true)
                    }
                });
            }

            if (!dimensions.width || !dimensions.height) {
                this._hidePlaceholder();
                return;
            }

            styles = input.getStyles(['font']);
            styles.height = dimensions.innerHeight;
            styles.width = dimensions.innerWidth;
            if (input.getTagName() !== 'textarea') {
                styles.lineHeight = dimensions.innerHeight + 'px';
                styles.whiteSpace = 'nowrap';
            }
            position = input.getPosition();
            position.x += input.getComputedSize('marginLeft', 'paddingLeft', 'borderLeftWidth');
            position.y += input.getComputedSize('marginTop', 'paddingTop', 'borderTopWidth');


            elements.placeholder.set({
                text: input.getAttribute('placeholder'),
                styles: styles
            })
            .setPosition(position);

            if (elements.placeholder.previousSibling !== input) {
                elements.placeholder.inject(input, 'after');
            }
        },

        _hidePlaceholder: function () {
            var placeholder = this.elements.placeholder;
            if (placeholder) {
                placeholder.remove();
            }
        }
    });

    // }}}

    // {{{ Password

    /**
     * Represents a password input.
     * Inherits from Input.
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @constructs UWA.Controls.Input.Text
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @mixes module:UWA/Controls/Timed.UWA.Controls.Timed
     * @memberof module:UWA/Controls/Input
     */
    Input.Password = Input.Text.extend({
        options: {
            multiline: false,
            attributes: {
                type: 'password'
            }
        }
    });
    // }}}

    // {{{ Button

    /**
     * Represents a button.
     * Inherits from Input.
     *
     * ##### Available CSS Classes
     *
     * The className option can be composed of one or more of those CSS classes:
     *
     * __Themes__:
     *
     * | Class name          |  Description                                                                            |
     * | ------------------- | --------------------------------------------------------------------------------------- |
     * | `green`             | Green button                                                                            |
     * | `black`             | Black button                                                                            |
     * | `light-grey`        | Light grey button                                                                       |
     * | `dark-grey`         | Dark grey flat button                                                                   |
     * | `extra-dark-grey`   | Very dark grey flat button                                                              |
     * | `border-only`       | Border only button with a transparent background                                        |
     * | `light-border-only` | Border only button with a transparent background, suited displaying on dark backgrounds |
     *
     * __Sizes__:
     *
     * | Class name        |  Description                                      |
     * | ----------------- | ------------------------------------------------- |
     * | `small`           | Height 24px                                       |
     * | `medium`          | Height 32px                                       |
     * | `large`           | Height 54px                                       |
     *
     * __Icon orientation__:
     *
     * | Class name        |  Description                                      |
     * | ----------------- | ------------------------------------------------- |
     * | `iconr`           | Add an icon to the right                          |
     * | `iconl`           | Add an icon to the left                           |
     * | `icon-only`       | Icon only. Button without text                    |
     * | `icon-separated`  | The icon will be displayed over a dark background |
     *
     * __Icons__:
     *
     * | Class name        |  Description                                      |
     * | ----------------- | ------------------------------------------------- |
     * | `refresh`         | Refresh icon                                      |
     * | `delete`          | Delete icon                                       |
     * | `plus`            | Plus icon                                         |
     * | `next`            | Next arrow icon                                   |
     * | `previous`        | Previous arrow icon                               |
     * | `cogwheel`        | cogwheel icon                                     |
     * | `play`            | Play icon                                         |
     * | `download`        | Download icon                                     |
     *
     * @constructs UWA.Controls.Input.Button
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @memberof module:UWA/Controls/Input
     */
    Input.Button = Input.extend(/** @lends module:UWA/Controls/Input.UWA.Controls.Input.Button# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-text'.
         * @protected
         */
        name: 'uwa-button',

        /**
         * @property {Object} options - The default controls options.
         * @protected
         */
        options: {
            className: 'dark-grey'
        },

        _hiddenInput: false,

        init: function (options) {
            if (UWA.owns(options, 'className')) {
                // 'black' class name is an alias for dark grey
                options.className = options.className.replace(/\bblack\b/, 'dark-grey');

                // Shortcut to allow CSS factorization
                if (/\b(?:iconl|iconr|icon-only)\b/.test(options.className)) {
                    options.className += ' uwa-icon';
                }

                if (/\b(?:dark-grey)\b/.test(options.className)) {
                    options.className += ' icon-separated';
                }
            }


            this._parent(options);
            // IE8 fix: if there is absolutely no content in the button, the
            // icon will have a strange vertical alignment
            if (/\b(?:icon-only)\b/.test(this.options.className)) {
                this.setValue('\u00A0');
            }

        },

        buildInput: function () {
            return UWA.createElement('button', { type: 'button' });
        }
    });

    // }}}

    return UWA.namespace('Controls/Input', Input, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Form
 *
 */
define('UWA/Controls/Form', [
    'UWA/Core',
    'UWA/String',
    'UWA/Utils',
    'UWA/Event',
    'UWA/Json',
    'UWA/Controls/Abstract',
    'UWA/Controls/Input'
], function (UWA, UWAString, Utils, Event, Json, Abstract, Input) {
    'use strict';

    var Form = Abstract.extend(/** @lends module:UWA/Controls/Form.UWA.Controls.Form# */{ // bypass

        /**
         * Current Form instance unique identifier.
         *
         * @type {Number}
         */
        id: null,

        /**
         * The default controls options.
         * @private
         */
        defaultOptions: {
            className: 'uwa-form',
            fields: [],
            labelPreffix: ':',
            nativeInputs: false,
            darkBackground: false
        },

        /**
         * The form control is designed to create HTML form using simple API.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onPreInject`    | Triggered before inject                |
         * | `onPostInject`   | Triggered after inject                 |
         * | `onResize`       | Invoked when control needs to resize   |
         * | `onSubmit`       | Invoked when an form submited          |
         * | `onChange`       | Invoked when an field state change     |
         *
         * ##### Example
         *
         * ```
         * var prefs = new UWA.Controls.Form({
         * fields: [
         *  {
         *      type: "text",
         *      name: "my_text",
         *      label: "My text pref",
         *      value: ""
         *  },
         *  {
         *      type: "password",
         *      name: "my_password",
         *      label: "My password pref",
         *      value: ""
         *  },
         *  {
         *      type: "boolean",
         *      name: "my_checkbox",
         *      label: "My checkbox pref",
         *      value: "false"
         *  },
         *  {
         *      type: "hidden",
         *      name: "my_hidden",
         *      value: ""
         *  },
         *  {
         *      type: "range",
         *      name: "my_range",
         *      label: "My range pref",
         *      value: "10",
         *      step: "5",
         *      min: "5",
         *      max: "15",
         *      value: "10"
         *  },
         *  {
         *      type: "list",
         *      name: "my_list",
         *      label: "My list",
         *      value: "Value1",
         *      options: [
         *          {
         *              label: "Label1",
         *              value: "Value1"
         *          },
         *          {
         *              label: "Label2",
         *              value: "Value2"
         *          },
         *          {
         *              label: "Label3",
         *              value: "Value3"
         *          }
         *      ],
         *      value: "Value1"
         *  }
         * ],
         * events: {
         *     onChange: function(callback, name, value) {
         *
         *     },
         *
         *     onSubmit: function(event, values) {
         *
         *     }
         * }
         * });
         * ```
         *
         * __XHTML skeleton__:
         *
         * ```html
         * <form class="uwa-form" id="10">
         * <fieldset>
         *    <div class="field fieldText">
         *        <label for="m_10_my_text">My text pref:</label><span><input type="text" id="m_10_my_text" class="text" name="my_text" value=""/></span>
         *    </div>
         *    <div class="field fieldPassword">
         *        <label for="m_10_my_password">My password pref:</label><span><input type="password" id="m_10_my_password" class="password" name="my_password" value=""/></span>
         *    </div>
         *    <div class="field fieldBoolean">
         *        <label for="m_10_my_checkbox">My checkbox pref:</label><span><input type="checkbox" id="m_10_my_checkbox" class="boolean unchecked" name="my_checkbox"/></span>
         *    </div>
         *    <div class="field fieldRange">
         *        <label for="m_10_my_range">My range pref:</label><span>
         *        <select id="m_10_my_range" class="range" name="my_range">
         *            <option value="5">5</option>
         *            <option value="10" selected="selected">10</option>
         *            <option value="15">15</option>
         *        </select>
         *        </span>
         *    </div>
         *    <div class="field fieldList">
         *        <label for="m_10_my_list">My list:</label><span>
         *        <select id="m_10_my_list" class="list" name="my_list">
         *            <option value="Value1" selected="selected">Label1</option>
         *            <option value="Value2">Label2</option>
         *            <option value="Value3">Label3</option>
         *        </select>
         *        </span>
         *    </div>
         *    <div class="field fieldText">
         *        <label for="m_10_json_endpoint">JSON Endpoint:</label><span><input type="text" id="m_10_json_endpoint" class="text" name="json_endpoint" value=""/></span>
         *    </div>
         *    <div class="field fieldText">
         *        <label for="m_10_ajax_endpoint">Ajax Endpoint:</label><span><input type="text" id="m_10_ajax_endpoint" class="text" name="ajax_endpoint" value=""/></span>
         *    </div>
         *    <div class="field fieldSubmit">
         *        <span><input type="submit" id="m_10_done" class="submit" name="done" value="Done"/></span>
         *    </div>
         * </fieldset>
         * </form>
         * ```
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.id=*random*] - Form unique id
         * @param {String} [options.className='uwa-form'] - Form class name
         * @param {Object} [options.fields={}] - Form field
         * @param {String} [options.labelPreffix=':'] - Default Label preffix
         *
         *
         * @constructs UWA.Controls.Form
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Form
         */
        init: function (options) {

            this._parent(options);

            this.id = Utils.random(10);

            this.buildSkeleton();
        },

        /**
         * Gets the content of the preference form, for display.
         * @private
         */
        buildSkeleton: function () {

            var i, l, field,
                that = this,
                options = that.options,
                fields = that.options.fields,
                fieldBuilders = that.fields,
                fieldElements = [],

                form = UWA.createElement('form', {
                    'class': options.className,
                    id: this.id,
                    events: {
                        submit: function (event) {

                            Event.stop(event);

                            this.dispatchEvent('onSubmit', [event, this.getFormValues()]);

                        }.bind(this)
                    }
                });

            if (!options.nativeInputs) {
                form.addClassName('uwa-form-uikit');
            }

            for (i = 0, l = fields.length; i < l; i++) {
                field = fields[i];

                if (field.type !== 'hidden') {

                    if (fieldBuilders[field.type] === undefined) {
                        field.type = 'text';
                    }

                    // Set id
                    field.id = 'm_' + that.id + '_' + field.name;

                    // Add Field element container to fieldset
                    fieldElements.push(fieldBuilders[field.type](field, options, this));
                }
            }

            // Add Elemenst into a fieldset
            UWA.createElement('fieldset', {
                html: fieldElements
            }).inject(form);

            // Set form has control container
            that.elements.container = form;
        },

        /**
         * Get field elements containers.
         *
         * @return Array of Elements.
         */
        getFields: function () {

            var container = this.elements.container,
                textareaArray = Utils.toArray(container.getElementsByTagName('textarea')),
                inputArray = Utils.toArray(container.getElementsByTagName('input')),
                selectArray = Utils.toArray(container.getElementsByTagName('select'));

            return inputArray.concat(selectArray).concat(textareaArray);
        },

        /**
         * Get field element container by name.
         *
         * @return {Element}
         */
        getField: function (name) {

            var i, l, element,
                elements = this.getFields();

            for (i = 0, l = elements.length; i < l; i++) {

                element = elements[i];

                if (element.name === name) {
                    return element;
                }
            }
        },

        /**
         * Get current form fields values using key/value pairs of an object.
         *
         * @return {Object} Value hash or a name/value pair.
         */
        getFormValues: function () {

            var i, l,
                values = {},
                elements = this.getFields();

            function getSelectOptions(element) { //eslint-disable-line no-shadow
                return element.getElements('option')
                    .filter(function (option) { return option.selected; })
                    .map(function (option) { return option.value; });
            }

            for (i = 0, l = elements.length; i < l; i++) {

                var element = elements[i];

                switch (element.type) {
                case 'button':
                case 'submit':
                    // Skip submit && button
                    break;

                case 'password':
                    // Do not save empty password
                    if (element.value !== '') {
                        values[element.name] = element.value;
                    }
                    break;

                case 'checkbox':
                    values[element.name] = Boolean(element.checked);

                    // Keep string value like string
                    if (typeof element.value === 'string') {
                        values[element.name] = String(values[element.name]);
                    }
                    break;

                case 'radio':
                    if (element.checked) {
                        values[element.name] = element.value;
                    }
                    break;

                default:
                    if (element.getTagName() === 'select' && element.multiple) {
                        values[element.name] = getSelectOptions(element);
                    }
                    else {
                        values[element.name] = element.value;
                    }
                    break;

                }
            }

            return values;
        },

        /**
         * Get current form field value by name.
         *
         * @param {String} name - Field name
         * @return {Object}
         */
        getFormValue: function (name) {
            return this.getFormValues()[name];
        },

        /**
         * Set current form fields values using key/value pairs of an object.
         *
         * @param {Object} values - Value hash or a name/value pair
         */
        setFormValues: function (values) {

            var i, l, element, value,
                elements = this.getFields();

            for (i = 0, l = elements.length; i < l; i++) {

                element = elements[i];

                if (values.hasOwnProperty(element.name)) {
                    value = values[element.name];

                    switch (element.type) {
                    case 'password':
                    case 'button':
                    case 'submit':
                        // Skip submit && button && password
                        break;

                    case 'checkbox':
                        element.checked = Boolean(value);
                        break;

                    case 'radio':
                        if (element.checked && String(element.value) === value) {
                            element.checked = Boolean(value);
                        }
                        break;

                    default:
                        element.value = value;
                        break;
                    }
                }
            }
        },

        /**
         * Set current form field value.
         *
         * @param {String} name - Field name
         * @param {String} value - Field new value
         */
        setFormValue: function (name, value) {

            var values = {};
            values[name] = value;

            this.setFormValues(values);
        },

        fields: {

            /**
             * Create a new Element input type text.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type text.
             *
             * @alias fields.text
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            text: function (field, options, form) {

                var input = UWA.createElement('input', {
                    type: 'text',
                    id: field.id,
                    'class': field.type + ' small',
                    name: field.name,
                    value: field.value || '',
                    autocomplete: 'off',
                    autocorrect: 'off',
                    autocapitalize: 'off'
                });

                // Manage onchange preference attribute
                if (field.onchange) {
                    input.addEvent('keyup', function () {
                        this.dispatchEvent('onChange', [field.onchange, field.name, input.value]);
                    }.bind(form));
                }

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: [
                        {
                            tag: 'label',
                            'for': field.id,
                            text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                        },
                        {
                            tag: 'span',
                            content: options.nativeInputs ? input : new Input.Text({
                                _root: false,
                                element: input,
                                className: 'small'
                            })
                        }
                    ]
                });
            },

            /**
             * Create a new Element input type password.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type password.
             *
             * @alias fields.password
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            password: function (field, options, form) {

                var input = UWA.createElement('input', {
                    type: 'password',
                    id: field.id,
                    'class': field.type,
                    name: field.name,
                    value: field.value || ''
                });

                // Manage onchange preference attribute
                if (field.onchange) {
                    input.addEvent('keyup', function () {
                        this.dispatchEvent('onChange', [field.onchange, field.name, input.value]);
                    }.bind(form));
                }

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: [
                        {
                            tag: 'label',
                            'for': field.id,
                            text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                        },
                        {
                            tag: 'span',
                            content: options.nativeInputs ? input : new Input.Text({
                                _root: false,
                                element: input,
                                className: 'small'
                            })
                        }

                    ]
                });
            },

            /**
             * Create a new Element input type submit.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type button.
             *
             * @alias fields.submit
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            submit: function (field, options) {

                var input = UWA.createElement('input', {
                    id: field.id,
                    'class': field.type,
                    type: 'submit',
                    name: field.name,
                    value: field.value || UWA.i18n('Done')
                });

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: {
                        tag: 'span',
                        content: options.nativeInputs ? input : new Input.Button({
                            _root: false,
                            element: input,
                            className: 'light-grey small'
                        })
                    }
                });
            },

            /**
             * Create a new Element input type button.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type button.
             *
             * @alias fields.submit
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            button: function (field, options) {

                var input = UWA.createElement('button', {
                    id: field.id,
                    'class': field.type,
                    name: field.name,
                    text: field.value || UWA.i18n('Done')
                });

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: {
                        tag: 'span',
                        content: options.nativeInputs ? input : new Input.Button({
                            _root: false,
                            element: input,
                            className: 'light-grey small'
                        })
                    }
                });
            },

            /**
             * Create a new Element input type reset.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type button.
             *
             * @alias fields.reset
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            reset: function (field, options) {

                var input = UWA.createElement('button', {
                    id: field.id,
                    type: 'reset',
                    'class': field.type,
                    name: field.name,
                    value: field.value || UWA.i18n('Done')
                });

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: {
                        tag: 'span',
                        content: options.nativeInputs ? input : new Input.Button({
                            _root: false,
                            element: input,
                            className: 'light-grey small'
                        })
                    }
                });
            },

            /**
             * Create a new Element input type checkbox.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `input` type checkbox.
             *
             * @alias fields.boolean
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            'boolean': function (field, options, form) {

                var input,
                    id = field.id,
                    row = UWA.createElement('div', {
                        'class': 'field field' + UWAString.ucfirst(field.type)
                    }),

                    checkedValue = typeof field.value === 'string' ? 'true' : true,
                    isChecked = (field.value && (field.value === true || field.value === 'true'));

                // Add Label element
                UWA.createElement('label', {
                    'for': id,
                    text: UWA.i18n((field.label || field.name))
                }).inject(row);

                // Add Input
                input = UWA.createElement('input', {
                    id: id,
                    value: checkedValue,
                    type: 'checkbox',
                    'class': field.type + ' ' + (isChecked ? 'checked' : 'unchecked'),
                    name: field.name
                });

                if (isChecked) {
                    input.setAttribute('checked', 'checked');
                    input.defaultChecked = true; // for IE
                }

                // Manage onchange preference attribute
                input.addEvent('change', function () {

                    var isInputChecked = input.checked;

                    input.addClassName(isInputChecked ? 'checked' : 'unchecked');
                    input.removeClassName(isInputChecked ? 'unchecked' : 'checked');

                    if (field.onchange) {
                        this.dispatchEvent('onChange', [field.onchange, field.name, isInputChecked ? 'true' : 'false']);
                    }

                }.bind(form));

                // Add Input element container
                UWA.createElement('span', {
                    html: options.nativeInputs ? input : new Input.Checkbox({
                        _root: false,
                        element: input,
                        className: options.darkBackground ? "light" : ""
                    })
                }).inject(row);

                return row;
            },

            /**
             * Create a new Element textarea.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `textarea`.
             *
             * @alias fields.textarea
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            textarea: function (field, options, form) {

                var textarea = UWA.createElement('textarea', {
                    id: field.id,
                    'class': field.type + ' small',
                    name: field.name,
                    text: field.value || ''
                });

                // Manage onchange preference attribute
                if (field.onchange) {
                    textarea.addEvent('keyup', function () {
                        this.dispatchEvent('onChange', [field.onchange, field.name, textarea.value]);
                    }.bind(form));
                }

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: [
                        {
                            tag: 'label',
                            'for': field.id,
                            text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                        },
                        options.nativeInputs ? textarea : new Input.Text({
                            _root: false,
                            element: textarea
                        })
                    ]
                });
            },

            /**
             * Create a new Element select has range selector.
             *
             * @param {Object} field - field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} new Element `select`.
             *
             * @alias fields.range
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            range: function (field, options, form) {

                var i, option, container, select,

                    id = field.id,

                    row = UWA.createElement('div', {
                        'class': 'field field' + UWAString.ucfirst(field.type)
                    });

                // Add Label element
                UWA.createElement('label', {
                    'for': id,
                    text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                }).inject(row);

                container = UWA.createElement('span').inject(row);

                select = UWA.createElement('select', {
                    id: 'm_' + form.id + '_' + field.name,
                    'class': 'range',
                    name: field.name
                }).inject(container);

                // Cast has Integer
                field.step = parseInt(field.step, 10);
                field.max = parseInt(field.max, 10);
                field.min = parseInt(field.min, 10);

                if (field.step > 0) {

                    for (i = field.min; i <= field.max; i += field.step) {

                        option = UWA.createElement('option', {
                            value: i,
                            text: String(i)
                        });

                        if (field.value && parseInt(field.value, 10) === i) {
                            option.setAttribute('selected', 'selected');
                            option.selected = true; // For RIM and IE
                        }

                        select.appendChild(option);
                    }
                }

                // Manage onchange preference attribute
                if (field.onchange) {
                    select.addEvent('change', function () {
                        this.dispatchEvent('onChange', [field.onchange, field.name, select.value]);
                    }.bind(form));
                }

                if (!options.nativeInputs) {
                    new Input.Select({
                        _root: false,
                        element: select,
                        className: 'small'
                    });
                }

                return row;
            },

            /**
             * Create a new Element select has list selector.
             *
             * @param {Object} field - field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} new Element `select`.
             *
             * @alias fields.list
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            list: function (field, options, form) {

                var i, l, option, optionElement, container, select,

                    id = 'm_' + form.id + '_' + field.name,

                    row = UWA.createElement('div', {
                        'class': 'field field' + UWAString.ucfirst(field.type)
                    });

                // Add Label element
                UWA.createElement('label', {
                    'for': id,
                    text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                }).inject(row);

                container = UWA.createElement('span').inject(row);

                select = UWA.createElement('select', {
                    id: 'm_' + form.id + '_' + field.name,
                    'class': 'list',
                    name: field.name,
                    multiple: Boolean(field.multiple)
                }).inject(container);

                if (
                    UWA.is(field.options, 'array') &&
                        field.options.length > 0
                ) {

                    var values = Utils.splat(field.value).map(function (v) { return String(v); });

                    for (i = 0, l = field.options.length; i < l; i++) {

                        option = field.options[i];
                        option.label = option.label || option.value;

                        optionElement = UWA.createElement('option', {
                            text: UWA.i18n(option.label),
                            value: option.value
                        }).inject(select);

                        if (values.indexOf(String(option.value)) >= 0) {
                            optionElement.setAttribute('selected', 'selected');
                            optionElement.selected = true; // For RIM and IE
                        }
                    }

                    // Manage onchange preference attribute
                    if (field.onchange) {
                        select.addEvent('change', function () {
                            this.dispatchEvent('onChange', [field.onchange, field.name, select.value]);
                        }.bind(form));
                    }

                // Disable if no options
                } else {
                    row.hide();
                }

                if (!options.nativeInputs) {
                    new Input.Select({
                        _root: false,
                        element: select,
                        className: 'small'
                    });
                }

                return row;
            },

            /**
             * Create a new Element with multiple checkbox.
             *
             * @param {Object} field - field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} new Element
             *
             * @alias fields.checklist
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            checklist: function (field, options, form) {

                var i, l, option, container, hiddenInput,

                    inputs = [],

                    id = 'm_' + form.id + '_' + field.name,

                    row = UWA.createElement('div', {
                        'class': 'field field' + UWAString.ucfirst(field.type)
                    });

                // Add Label element
                UWA.createElement('label', {
                    'for': id,
                    text: UWA.i18n((field.label || field.name) + options.labelPreffix)
                }).inject(row);

                container = UWA.createElement('span', {
                    'class': field.type
                }).inject(row);

                hiddenInput = UWA.createElement('input', {
                    id: 'm_' + form.id + '_' + field.name,
                    name: field.name,
                    type: 'hidden',
                    value: UWA.is(field.value, 'array') ? Json.encode(field.value) : field.value
                }).inject(container);

                if (UWA.is(field.options, 'array') &&
                    field.options.length > 0) {

                    var fieldValue = UWA.is(field.value, 'array') ? field.value : Json.decode(field.value);

                    var values = Utils.splat(fieldValue).map(function (v) { return String(v); });

                    for (i = 0, l = field.options.length; i < l; i++) {

                        option = field.options[i];
                        option.label = option.label || option.value;

                        var isChecked = values.indexOf(String(option.value)) >= 0;

                        var p = UWA.createElement('p').inject(container);

                        // Add Input
                        var input = UWA.createElement('input', {
                            value: option.value,
                            type: 'checkbox',
                            name: option.value,
                            checked: isChecked
                        });
                        inputs.push(input);

                        // Manage onchange preference attribute
                        input.addEvent('change', function () {

                            var inputValues = [];

                            inputs.forEach(function (elm) {
                                if (elm.checked) {
                                    inputValues.push(elm.value);
                                }
                            });

                            hiddenInput.value = Json.encode(inputValues);

                            if (field.onchange) {
                                this.dispatchEvent('onChange', [field.onchange, field.name, hiddenInput.value]);
                            }

                        }.bind(form));

                        // Add Input element container
                        UWA.createElement('span', {
                            html: options.nativeInputs ? input : new Input.Checkbox({
                                _root: false,
                                element: input
                            })
                        }).inject(p);

                        // Add Label element
                        UWA.createElement('label', {
                            text: UWA.i18n(option.label)
                        }).inject(p);

                    }

                // Disable if no options
                } else {
                    row.hide();
                }

                return row;
            },

            /**
             * Create a new Element div with html.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} new Element `div`.
             *
             * @alias fields.html
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            html: function (field) {
                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: {
                        tag: 'div',
                        html: field.html
                    }
                });
            },

            /**
             * Create a new Element img.
             *
             * @param {Object} field - Field description
             * @param {Object} options - UWA.Controls.Form <options>
             * @param {Object} form - UWA.Controls.Form instance
             * @return {Object} New Element `img`.
             *
             * @alias fields.img
             * @memberof module:UWA/Controls/Form.UWA.Controls.Form
             */
            img: function (field) {

                var label = UWA.i18n(field.label || field.name) || "";

                return UWA.createElement('div', {
                    'class': 'field field' + UWAString.ucfirst(field.type),
                    html: {
                        tag: 'img',
                        src: field.src,
                        height: field.height || 'auto',
                        width: field.width || '100%',
                        alt: label,
                        title: label
                    }
                });
            }
        }
    });

    return UWA.namespace('Controls/Form', Form, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, JSON
*/

/**
 * @module   UWA/Widget
 *
 */
define('UWA/Widget', [
    'UWA/Core',
    'UWA/String',
    'UWA/Array',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Class/Timed',
    'UWA/Class/Events',
    'UWA/Class/Debug',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Data',
    'UWA/Element'
], function (UWA, UWAString, UWAArray, Class, Options, Timed, Events, Debug, Utils, Client, Data, Element) { // jshint ignore:line
    'use strict';

    function assertAllStrings(value) {
        if (!Array.isArray(value)) {
            throw new Error(value + ' should be an array');
        }
        value.forEach(function (v) {
            if (typeof v !== 'string') {
                throw new Error(v + ' should be a string');
            }
        });
    }

    function parseStringArray(value) {
        if (!value) { return []; }
        var result;
        if (Array.isArray(value)) {
            result = value;
        } else {
            try {
                result = JSON.parse(value);
            } catch (e) {
                throw new Error('While parsing JSON value `' + value + '`: ' + e);
            }
        }
        assertAllStrings(result);
        return result;
    }

    function decodeValueForPreference(preference, value) {
        if (preference) {
            if (preference.multiple || preference.type === 'checklist') {
                try {
                    value = parseStringArray(value);
                }
                catch (e) {
                    throw new Error('While decoding value for preference ' + preference.name + ': ' + e);
                }
            }
            if (preference.type === 'boolean' && value === '') {
                value = false;
            }
        }

        return value;
    }

    function encodeValueForPreference(preference, value) {
        if (preference) {
            if (preference.multiple || preference.type === 'checklist') {
                assertAllStrings(value);
                value = JSON.stringify(value);
            }
        }
        return value;
    }

    var Widget = Class.extend(Options, Timed, Events, Debug, /** @lends module:UWA/Widget.UWA.Widget# */ {

        /**
         * The Widget object provides abstract methods to create and manipulate UWA application instances,
         * this object is typically instanciated by {@link module:UWA/Environment.UWA.Environment|UWA.Environment} as the widget variable in a widget execution scope.
         *
         * > Note on events dispatching:
         * > Events will start to be dispatched to the widget only after the "onLoad" event has being
         * > dispatched first.
         *
         * ##### Available Events
         *
         * | Event                  | Description                                                             |
         * | ---------------------- | ----------------------------------------------------------------------- |
         * | `onLoad`               | Triggered when the widget is launched.                                  |
         * | `onRefresh`            | Triggered when the widget is refreshed (manually or programmatically).  |
         * | `onResize`             | Triggered when the widget is resized (manually or programmatically).    |
         * | `onKeyboardAction`     | Triggered when a key is pressed within the widget's area.               |
         * | `onSearch`             | Triggered when a search is performed from within the platform.          |
         * | `onResetSearch`        | Triggered when a search is reseted from within the platform.            |
         * | `onUpdateIcon`         | Triggered when the widget's icon is modified.                           |
         * | `onUpdateTitle`        | Triggered when the widget's title is modified.                          |
         * | `onUpdateCounter`      | Triggered when the widget's counter is modified.                        |
         * | `onUpdatePreferences`  | Triggered when a widget's preference is added.                          |
         * | `onEdit`               | Triggered when edition of preferences begin.                            |
         * | `endEdit`              | Triggered when edition of preferences ending.                           |
         * | `onOpenURL`            | Open an url into a new environment browser window.                      |
         *
         * @property {String} id - Unique identifier of the widget.
         * The value depends on the execution environment: the Environment registration handler sets this property.
         *
         * @property {UWA.Environment} environment - Reference to the execution environment.
         * The Environment registration handler sets this property. Instance of the Environment class.
         *
         * @property {String} title - Widget's title.
         * The title of the widget. It is set by the <setTitle> method.
         *
         * @property {String} icon - Widget's icon url.
         * The icon of the widget. It is set by the <setIcon> method.
         *
         * @property {UWA.Element} body - Widget's body.
         * The main HTML element of the widget.
         * Value is null until the <widget> is fully registered in the Environment.
         * Should not be used before <launch> or <onLoad> are fired.
         *
         * @property {Object} data - Stores widget's data.
         * This property can be modified by the <setValue> method, and accessed by the <getValue> method.
         *
         * @property {Object} events - Stores widget's events.
         * @property {Array} plugins - Stores widget's plugins.
         * The array is initially empty. It is initialised by the <setPlugins> method.
         *
         * @property  {Array<Object>} preferences - widget's preferences.
         * The array is initially empty. It is initialised by the <setPreferences> method.
         *
         * @property {Object} metas - Stores widget's metas.
         * The object is initially empty. It is initialised by the <setMetas> method.
         *
         * @property {Object} elements - Instances of UI <UWA.Element> of the widget.
         * @property {String} lang - The preferred language as defined by the Environment (e.g "en" or "en_US").
         * @property {String} locale - The preferred locale as defined by the Environment (e.g "us" or "fr").
         * @property {String} dir - The preferred language direction as defined by the Environment.
         * This property is set by the <setDir> method.
         *
         * @property {Boolean} readOnly - `true` if the widget is currently read only for the viewer. Default to `false`.
         * @property {Boolean} isEdit - `true` if the widget is currently display the preference form.
         * @property {Number|Boolean} counter - The count of unread items in the widget.
         * This property is set by the <setCounter> method.
         *
         * @property {String} counterType - The count type of unread items in the widget.
         * This property is set by the <setCounter> method.
         *
         * @constructs UWA.Widget
         * @mixes UWA.Class.Options
         * @mixes UWA.Class.Timed
         * @mixes UWA.Class.Events
         * @mixes UWA.Class.Debug
         * @memberof module:UWA/Widget
         */
        init: function () {

            var that = this,
                locale = Client.Locale;

            that.id = null;
            that.environment = null;
            that.launched = false;

            that.title = null;
            that.icon = null;
            that.counter = 0;
            that.counterType = null;
            that.metas = {};

            that.preferences = [];
            that.defaultData = Object.create(null);
            that.data = {};

            that.menus = [];
            that.plugins = [];
            that.events = {};

            that.elements = {};
            that.body = null;

            that.lang = locale.lang;
            that.locale = locale.locale;
            that.dir = locale.dir;

            that.readOnly = false;
            that.isEdit = false;
        },

        /**
         * Launch the widget : call <initPlugins> and <initPreferences> then
         * dispatch <event> "beforeLoad", "onLoad" and "afterLoad".
         *
         * > Internal or advanced use only.
         *
         * @method
         * @param {Object} data - Widget's data values
         * @param {Boolean} readOnly - Default to `false`. True if the widget is currently read only for the viewer
         * @return {Boolean} `true` if launch succeed else `false`.
         */
        launch: function (data, readOnly) {

            var that = this;

            // Set launched state
            that.launched = false;
            if (readOnly !== undefined) {
                that.readOnly = Boolean(readOnly);
            }

            // Init Widget components
            that.initPreferences();
            that.initPlugins();

            // Update Data
            that.setValues(data);

            that.dispatchEvent('onInitConfig', {
                metas: that.metas,
                plugins: that.plugins,
                preferences: that.getPreferences()
            });

            // Trigger "beforeLoad"
            that.dispatchEvent('beforeLoad');

            // This function will be called only if the event is not cancelled
            that.addEventOnce('onLoad', function () {
                that.launched = true;
            }, that, 1);

            // Trigger main "onLoad"
            that.dispatchEvent('onLoad');

            // Trigger "afterLoad" only if <launched> is true
            if (that.launched) {
                that.dispatchEvent('afterLoad');
            }

            return that.launched;
        },

        /**
         * Destroy the elements and its children of widget.
         * Remove all events and remove the elements from the dom.
         * Clear all Delayeds and Periodicals timers.
         *
         * @method
         */
        destroy: function () {

            var element,
                that = this,
                elements = that.elements;

            // Remove Delayed
            that.clearDelayed();

            // Remove Periodical
            that.clearPeriodical();

            // Destroy Elements
            for (element in elements) {
                if (elements.hasOwnProperty(element)) {
                    elements[element].destroy();
                }
            }

            // Remove Events
            that.removeEvent();

            // Reset Environment
            that.launched = false;
        },

        /**
         * Set options of this instance. Passing an 'events' field will
         * automatically add those events.
         *
         * @method
         * @param {Object} options - Options hash
         */
        setOptions: function (options) {

            var option, optionSetter,
                that = this;

            for (option in options) {
                optionSetter = 'set' + UWAString.capitalize(option);
                if (UWA.is(that[optionSetter], 'function')) {
                    that[optionSetter](options[option]);
                }
            }

            return that._parent(options);
        },

        /* Group: Widget Options Getter/Setter */

        /**
         * Sets the auto-refresh interval for the widget.
         * The widget must have a "onRefresh" method to work properly.
         *
         * @method
         * @param {Number} delay - The refresh delay, in *minutes*
         *
         * @example
         * widget.setAutoRefresh(20); // Set the auto-refresh interval to 20 minutes
         */
        setAutoRefresh: function (delay) {

            delay = parseInt(delay, 10);

            var that = this;

            if (delay && delay > 0) {
                that.setPeriodical(
                    'autoRefresh',
                    that.dispatchEvent.bind(that, 'onRefresh'),
                    delay * 1000 * 60
                );
            } else {
                that.clearPeriodical('autoRefresh');
            }

            that.metas.autoRefresh = delay;
        },

        /**
         * Sets  the number of results or status for the current search/unread items.
         *
         * @method
         * @param {Integer|Boolean|String} count - The number of results or status for the current search/unread items
         * @param {String} [type] - The number of results type (e.g 'search').
         * @return Nothing, but updates the title with the result count, if greater or equal to zero.
         */
        setCounter: function (count, type) {

            var that = this;

            if (
                that.counter !== count ||
                    (UWA.is(type) && that.counterType !== type)
            ) {

                that.counter = count;
                that.counterType = type;

                that.dispatchEvent('onUpdateCounter', [count, type]);
            }
        },

        /**
         * Get the title of the Widget.
         *
         * @method
         * @return {String} The title of the widget. HTML tags are stripped.
         */
        getTitle: function () {
            return UWA.is(this.title, 'string') ? UWAString.stripTags(this.title) : '';
        },

        /**
         * Sets the title of the Widget.
         *
         * > Implementation can differ between environments.
         *
         * @method
         * @param {String} title - The title of the widget. Can contain HTML code
         * @param {String} url   - The link of the title.
         * @return {String} New <title> property value.
         *
         * ##### Example
         *
         * ```
         * widget.setTitle('Netvibes Blog');
         * // OR
         * widget.setTitle('<a href="http://blog.netvibes.com/">Netvibes Blog</a>');
         * ```
         */
        setTitle: function (title, url) {

            var that = this;

            // Set title only support String
            // and we avoid to change it if the same.
            if (
                UWA.is(title, 'string') &&
                    that.title !== title || (url && that._titleUrl !== url)
            ) {
                // Update property
                that.title = title;
                that._titleUrl = url;

                that.dispatchEvent('onUpdateTitle', [title, url]);
            }

            return that.title;
        },

        /**
         * Sets the icon for the Widget.
         *
         * > Implementation can differ between environments.
         *
         * @method
         * @param {String} url - The url of the icon. The URL should include the protocol (http://)
         * @param {Boolean} search - If `true`, try to autodiscover the icon for the given url.
         * @return {String} New <icon> property value.
         *
         * @example
         * widget.setIcon("http://www.example.com/favicon.ico");
         * // OR
         * widget.setIcon("http://www.example.com", `true`);
         */
        setIcon: function (icon, search) {

            var that = this;

            if (icon && UWA.is(icon, 'string')) {

                // Add proxy on search or missing img file extention
                if (search) {
                    icon = Data.proxifyUrl(icon, {
                        proxy: 'icon'
                    });
                }

                if (that.icon !== icon) {

                    // Update property
                    that.icon = icon;

                    that.dispatchEvent('onUpdateIcon', [icon]);
                }
            }

            return that.icon;
        },

        /**
         * Add or update a menu item to widget's chrome.
         *
         * @example <caption>Add a settings menu item</caption>
         * widget.setMenu(
         *     name: 'edit/settings',
         *     icon: 'settings',
         *     label: 'Settings',
         *     onExecute: 'onMenuSettings'
         * );
         * widget.addEvent('onMenuSettings', function () {
         *     // Menu item clicked
         * });
         *
         * @example <caption>Asynchronous submenu creation</caption>
         * widget.setMenu({
         *     name: 'edit',
         *     onShow: 'onShowMenu'
         * });
         *
         * widget.setMenu({
         *     name: 'edit/date',
         *     label: 'Loading...'
         * });
         *
         * widget.addEvent('onShowMenu', function (menu) {
         *     widget.setMenu({
         *         name: 'edit/date',
         *         label: UWADate.strftime(new Date(), '%x')
         *     });
         * });
         *
         * @method
         * @param {Object} item - Menu item descriptor
         * @param {String} item.name - The identifier of the menu item.
         *                             It can contains a slash to be in a submenu (example: 'edit/preferences').
         * @param {String} item.icon - An icon name, a character (unicode...) or an image URL
         * @param {String} item.label - The text displayed on the menu item
         * @param {String} item.className - A class name to be added to the menu item
         */
        setMenu: function (item) {

            var environment = this.environment,
                parts = item.name.split('/'),
                name = parts[0],
                parent,
                menus,
                oldItem;

            if (parts.length > 2) {
                throw new Error('Adding more than one submenu level is not supported by setMenu');
            }

            // If a menu is added twice with the same, merge
            // the given menu descriptor with the existing one
            oldItem = this.getMenu(item.name);
            if (oldItem) {
                UWA.extend(oldItem, item);
            } else {

                if (parts.length > 1) {
                    // If root menu does not exists, create a default one
                    parent = this.getMenu(name);
                    if (!parent) {
                        parent = {label: name};
                        this.menus.push(parent);
                    }
                    if (!parent.items) {
                        parent.items = [];
                    }
                    menus = parent.items;
                } else {
                    menus = this.menus;
                }
                menus.push(item);
            }

            this.setDelayed('onUpdateMenu', function () {
                environment.dispatchEvent('onUpdateMenu', [this.menus]);
            }, 20);
        },

        /**
         * Get a menu item by its name.
         *
         * @method
         * @param {String} name - Menu identifier
         * @return {Object} Menu item descriptor.
         *
         * @example
         * var menu = widget.getMenu('options/share');
         */
        getMenu: function (name) {

            var menu, parts;

            if (UWA.is(name, 'string')) {
                parts = name.split('/');

                menu = UWAArray.detect(this.menus, function (item) {
                    return item.name === parts[0];
                });
                if (menu && parts.length > 1) {
                    menu = menu.items && UWAArray.detect(menu.items, function (item) {
                        return item.name === name;
                    });
                }
            }
            return menu;
        },

        /**
         * Remove a menu item by its name.
         *
         * @method
         * @param {String} name - Menu identifier
         *
         * @example
         * var menu = widget.removeMenu('options/share');
         */
        removeMenu: function (name) {

            var i, l, menu, filter;

            filter = function (menuItem) {
                return menuItem.name !== name;
            };

            for (i = 0, l = this.menus.length; i < l; i++) {
                menu = this.menus[i];
                if (menu.name === name) {
                    this.menus.remove(menu);
                    break;
                }
                if (menu.items) {
                    menu.items = menu.items.filter(filter);
                }
            }
        },

        /**
         * The preferred language direction.
         *
         * @method
         * @param {String} dir - Language direction ('rtl' or 'ltr')
         * @return {String} New <dir> property value.
         *
         * @see {@link http://www.w3.org/TR/html4/struct/dirlang.html}
         */
        setDir: function (dir) {

            var that = this,
                previousDir = that.dir,
                wrapper = that.elements.wrapper;

            dir = (dir === 'rtl' ? 'rtl' : 'ltr');

            if (wrapper && previousDir !== dir) {
                wrapper.setAttribute('dir', dir);
                wrapper.addClassName(dir);
                wrapper.removeClassName(previousDir);
            }

            that.dir = dir;

            return dir;
        },

        /**
         * Set the metas of the widget.
         *
         * > Internal or advanced use only.
         *
         * @method
         * @param {Object} metas - Metas hash or a name/value pair
         * @return {Object} New <metas> property value.
         */
        setMetas: function (metas) {

            var that = this;

            UWA.merge(that.metas, metas);

            if (UWA.is(metas.debugMode)) {

                that.setDebugMode(metas.debugMode);

                if (that.environment) {
                    that.environment.setDebugMode(metas.debugMode);
                }
            }

            if (UWA.is(metas.autoRefresh)) {
                that.setAutoRefresh(metas.autoRefresh);
            }

            return that.metas;
        },

        /* Group: Widget content manipulation methods */

        /**
         * Replace the content of the widget body by another.
         *
         * Content parameter could be:
         *
         *  - a String, considered as XHTML
         *  - a DOM Element
         *  - an Object used to create an DOM element by using the 'tag'
         *    field as tag and other fields as properties
         *  - an Array of Objects used to create multiple DOM elements
         *
         * ##### Examples
         *
         * - Insert an element using *Object* syntax
         *
         * ```
         * widget.setBody({
         *    tag: 'a',
         *    href: 'http://www.example.com',
         *    text: 'My Link',
         *    styles: {
         *        color: 'red'
         *    },
         *    event: {
         *       click: function (event) {
         *            // My Click Handler
         *            UWA.Event.stop(event);
         *       }
         *    }
         * });
         * ```
         *
         * Will rendering:
         *
         * ```html
         * <a style="color: red;" href="http://www.example.com">My Link</a>
         * ```
         *
         * - Insert elements using *Array* syntax
         *
         * ```
         * widget.setBody([
         *    {
         *        tag: 'div',
         *        'class': 'myHeader'
         *    },
         *    {
         *        tag: 'div',
         *        'class': 'myContent',
         *        html: [
         *            {
         *                tag: 'a',
         *                text: 'My Link',
         *                styles: {
         *                    color: 'red'
         *                },
         *                event: {
         *                    click: function (event) {
         *                        // My Click Handler
         *                        UWA.Event.stop(event);
         *                   }
         *                }
         *
         *            }
         *        ]
         *    },
         *    {
         *        tag: 'div',
         *        'class': 'myFooter'
         *    },
         * ]);
         * ```
         *
         * Will rendering:
         *
         * ```html
         * <div class="myHeader"></div>
         * <div class="myContent">
         *    <a>My Link</a>
         * </div>
         * <div class="myFooter"></div>
         * ```
         *
         * - Using *String* considered as XHTML (bad practice)
         * ```html
         * widget.setBody('<a href="http://www.example.com">My Link</a>');
         * ```
         *
         * @method
         * @param {String|Object|Array} content - The content to set to the widget body
         * @return  Nothing.
         */
        setBody: function (content) {

            if (!this.body) {
                throw new Error('Widget.body is not yet available');
            }

            this.body.setContent(content);
        },

        /**
         * Add content to current widget body.
         *
         * @method
         * @param {String|Object|Array} content - The content to add to the widget body.
         * Content parameter could be:
         *
         * - a String, considered as XHTML
         * - a DOM Element
         * - an Object used to create an DOM element by using the 'tag'
         *    field as tag and other fields as properties
         * - an Array of Objects used to create multiple DOM elements
         *
         * @return Nothing.
         *
         * @example
         * See <UWA.Widget.setBody> method.
         */
        addBody: function (content) {
            this.body.addContent(content);
        },

        /**
         * Alias to UWA.Element.getElements on Widget body.
         *
         * @method
         * @param {String} selector - TODO
         * @return {Array} Elements into an Array or an empty Array.
         */
        getElements: function (selector) {
            return this.body.getElements(selector);
        },

        /**
         * Alias to <UWA.Element.getElement> on Widget <body>.
         *
         * @method
         * @param {String} selector - TODO
         * @return {Element} Matched Element or undefined if not found.
         */
        getElement: function (selector) {
            return this.body.getElement(selector);
        },

        /**
         * Creates a new element according to the provided "tagName":
         *
         * - if options is not defined, works like document.createElement(tagName)
         * - if options is defined, works like JS frameworks DOM builders (mootools/prototype) - new Element(tagName, options)
         *
         * @method
         * @param {String} tagName - The HTML tag name of the element to create
         * @param {Object} options - Will be set on the newly-created element using Element#setAttributes
         * @return {Element} The created element.
         *
         * @example
         * var div = widget.createElement('div');
         * // OR
         * var input = widget.createElement('input', {
         *    "type": "submit",
         *    "value": "Update"
         * });
         */
        createElement: function (tagName, options) {

            /*
            // TODO Enable it but it break some widgets
            // Preffix element id with 'm_' + widgetId + '_'
            if (options && options.id) {
                options.id = 'm_' + this.id + '_' + options.id;
            }
            */

            return UWA.createElement(tagName, options);
        },

        /**
         * Set the stylesheet of the widget with the given CSS rules.
         *
         * > Internal or advanced use only.
         *
         * @method
         * @param {String} style - The style rule to apply to the widget elements
         */
        setStyle: function (style) {

            var that = this,
                widgetNamespace = that.id ? '#m_' + that.id : '.moduleWrapper',
                styleNamespace = widgetNamespace;

            // Set id to the wrapper if available
            if (that.id) {
                that.elements.wrapper.setAttribute('id', 'm_' + that.id);
            }

            // Sandbox widget css to <namespace> .moduleContent
            Utils.setCss(false, style, styleNamespace, that.getUrl());
        },

        /* Group: Environment manipulation methods */

        /**
         * Mutate a widget into another widget.
         *
         * @method
         * @param {String} url - Widget new url
         * @param {Object} preferences - Widget preferences
         *
         * @note
         * Internal or advanced use only.
         */
        mutate: function (url, preferences) {

            var environment = this.environment;

            if (!url) {
                throw new Error('Missing or empty first param on widget.mutate');
            }

            if (environment && environment.mutate) {
                environment.mutate(url, preferences);
            } else {
                throw new Error('Current Environment do not support widget.mutate');
            }
        },

        /**
         * Get current Widget UWA url.
         *
         * @method
         * @return {String} UWA url of the current widget.
         */
        getUrl: function () {

            var url,
                that = this,
                location = window.location.href;

            if (that.uwaUrl) { // via Exposition
                url = that.uwaUrl;
            } else { // Environment specific, if needed
                url = Utils.getQueryString(location, 'uwaUrl', location);
            }

            return url;
        },

        /**
         * Star Widget into Environment if available.
         *
         * @method
         *
         * @note
         * Implementation can differ between environments.
         */
        addStar: function (data) {
            var environment = this.environment;
            if (environment && environment.addStar) {
                environment.addStar(data);
            }
        },

        /**
         * Finds the computed width and height of widget possible max height
         * and width and returns them as key/value pairs of an object.
         *
         * @method
         * @return {Object} Object with "with, "height" properties.
         *
         * @example
         * var viewport = widget.getViewportDimensions();
         * widget.body.setStyles({
         *    height: viewport.height + 'px',
         *    width: viewport.width + 'px'
         * });
         */
        getViewportDimensions: function () {

            var element, last,
                that = this,
                elements = that.elements,
                body = elements.body,

                // Alias
                getDimensions = Element.getDimensions,
                isInjected = Element.isInjected,
                getComputedSize = Element.getComputedSize,

                // Dimensions
                screenDimensions = Client.getSize(),
                wrapperDimensions = getDimensions.call(elements.wrapper),
                bodyDimensions = getDimensions.call(body),
                height = screenDimensions.height,
                width = wrapperDimensions.width;

            // Remove Heights from header and footer from global height
            ['header', 'footer'].forEach(function (name) {
                element = elements[name];
                if (element && isInjected.call(element)) {
                    height -= getDimensions.call(element).outerHeight;
                }
            });

            // Remove padding+margin+border height from body to wrapper parent
            element = body;
            last = elements.wrapper.parentNode;
            do {

                // Avoid to substract outerWidth from wrapper because we use
                // wrapperDimensions has reference for width
                if (element !== elements.wrapper) {
                    width -= getComputedSize.call(element, 'innerWidth', 'outerWidth');
                } else {
                    width -= getComputedSize.call(element, 'innerWidth');
                }

                // Also substract wrapper outerHeight from wrapper because we use
                // screenDimensions has reference for height
                height -= getComputedSize.call(element, 'innerHeight', 'outerHeight');

                element = element.parentNode;
            } while (element && element !== last);

            // Use maxHeight and minHeight from body if required
            if (bodyDimensions.maxHeight > 0 && height > bodyDimensions.maxHeight) {
                height = bodyDimensions.maxHeight;
            } else if (bodyDimensions.minHeight > 0 && height < bodyDimensions.minHeight) {
                height = bodyDimensions.minHeight;
            }

            // Avoid negative dimensions
            return {
                height: height < 0 ? 240 + height : height,
                width: width < 0 ? 320 + width : width
            };
        },

        /* Group: Plugins management methods */

        /**
         * Sets plugins schema of the widget. Replaces previous plugins.
         *
         * @method
         * @param {Array} schema - An Array of plugins in their JSON serialization
         *
         * @example
         * widget.setPlugins([
         *    {"name":"Auth", params: [{"name": "paramName", "value": "paramValue"}]},
         *    {"name":"GoogleAnalytics", params: [{"name": "paramName", "value": "paramValue"}]},
         * ]);
         */
        setPlugins: function (plugins) {
            this.plugins = plugins;
        },

        /**
         * Initializes plugins of the widget.
         *
         * @method
         */
        initPlugins: function () {

            var i, l, plugin,
                that = this,
                plugins = UWA.clone(that.plugins);

            for (i = 0, l = plugins.length; i < l; i++) {
                plugin = plugins[i];
                if (UWA.Plugins[plugin.name]) {
                    plugin.instance = new UWA.Plugins[plugin.name](that, plugin.options);
                }
            }
        },

        /*
          Group: Preferences management methods

            This methods are mostly for internal use or advanced scripting.
            Behavior can differ between differents execution environments.
        */

        /**
         * Initializes preferences of the widget. The method gets values from the environment.
         * If values do not exist in the environment, it sets them to their default values.
         * This method is likely internaly fired by the <launch> method of the Widget.
         *
         * @method
         */
        initPreferences: function () {

            var that = this;

            that.setPreferences(that.preferences);
        },

        /**
         * Check if Widget has visible preferences and not in <readOnly> mode.
         *
         * @method
         * @return {Boolean} `true` if has visible preferences.
         */
        hasPreferences: function () {

            var that = this,
                preferences = that.preferences;

            return !that.readOnly && preferences.length > 0 &&
                preferences.some(function (preference) {
                    return preference.type !== 'hidden';
                });
        },

        /*
         * Get a preference without cloning it or setting its value property
         * Internal use only
         * @protected
         *
         * @method
         * @param {String} name the preference name
         * @return {Object} the preference descriptior
         */
        _getRawPreference: function (name) {
            return UWAArray.detect(this.preferences, function (preference) { return preference.name === name; });
        },

        /**
         * Get a preference with its name.
         *
         * @method
         * @param {String} name - The name of the preference
         * @return {Object} A preference in its JSON serialization with it's current value.
         *
         * ##### Example
         *
         * If you have this preference defined in XML
         *
         * ```html
         * <widget:preference name="limit" type="range" label="Number of items to display" defaultValue="5" step="1" min="1" max="25" />
         * ```
         *
         * You can get its javascript representation with the following code
         * widget.getPreference("limit")
         *
         * That will return the following JSON Object:
         *
         * ```
         * {
         *    name: "limit",
         *    type: "range",
         *    label: "Number of items to display",
         *    defaultValue: "",
         *    step: "1",
         *    min: "1",
         *    max: "25",
         *    value: "5"
         * }
         * ```
         */
        getPreference: function (name) {

            var preference = this._getRawPreference(name);
            if (preference) {
                preference = UWA.clone(preference);
                preference.value = this.getValue(name);
            }

            return preference;
        },

        /**
         * Check if Widget has preferences its name.
         *
         * @return {Boolean} `true` if has preferences that match the given name.
         */
        hasPreference: function (name) {
            return this.preferences.some(function (preference) {
                return preference.name === name;
            });
        },

        /**
         * Adds a single preference to the existing preferences of the widget.
         * Replace the previous preference if preference of the same name is already defined.
         *
         * @method
         * @param {Object} - A preference in its JSON serialization.
         *
         * @example
         * widget.addPreference({
         *    name: "paging",
         *    type: "boolean",
         *    label: "Enable pagination",
         *    defaultValue: "`false`"
         * });
         */
        addPreference: (function () {

            var validPreferencesTypes = [
                'hidden',
                'text',
                'list',
                'checklist',
                'range',
                'password',
                'boolean'
            ];

            function validPreference(preference) {
                return preference.name && preference.type &&
                    validPreferencesTypes.indexOf(preference.type) !== -1;
            }

            return function (preference) {

                var hasDefaultValue,
                    index = -1,
                    that = this,
                    preferences = that.preferences;

                if (validPreference(preference)) {

                    // Clone to avoid external reference
                    preference = UWA.clone(preference);

                    hasDefaultValue = preference.defaultValue !== undefined;

                    if (preference.multiple && typeof preference.multiple !== 'boolean') {
                        preference.multiple = preference.multiple === 'true';
                    }

                    // If defaultValue of boolean is empty string,
                    // convert to bollean and set default to false.
                    if (hasDefaultValue) {
                        preference.defaultValue = decodeValueForPreference(preference, preference.defaultValue);
                    }

                    // Search for existing preference
                    preferences.forEach(function (pref, prefIndex) {
                        if (preference.name === pref.name) {
                            index = prefIndex;
                        }
                    });

                    // Use name if label is missing
                    if (!preference.label) {
                        preference.label = preference.name;
                    }

                    // Replace preference if exist
                    if (index !== -1) {
                        preferences[index] = preference;

                    // Else insert a new preference
                    } else {
                        preferences.push(preference);
                    }

                    that.defaultData[preference.name] = preference.defaultValue;

                    if (that.launched) {
                        that.dispatchEvent('onUpdatePreferences', [that.getPreferences()]);
                    }
                }
            };
        }()),

        /**
         * Sets preferences schema, replaces previous preferences schema.
         *
         * @method
         * @param {Array} schema - An Array of preferences in their JSON serialization
         *
         * @example
         * widget.setPreferences([
         *    {name: "paging", type: "boolean", label: "Enable pagination", defaultValue: "`false`"},
         *    {name: "offset", type: "hidden", defaultValue: "0"}
         * ]);
         */
        setPreferences: function (schema) {

            var i, l,
                that = this;

            // Clear reference
            that.preferences = [];
            that.defaultData = {};

            // Add Preference
            for (i = 0, l = schema.length; i < l; i++) {
                that.addPreference(schema[i]);
            }
        },

        /**
         * Add preferences to the widget if preferences of the same name are not already defined.
         *
         * @method
         * @param {Array} schema - An Array of preferences in their JSON serialization
         */
        mergePreferences: function (schema) {

            var i, l,
                that = this;

            for (i = 0, l = schema.length; i < l; i++) {
                if (!that.hasPreference(schema[i].name)) {
                    that.addPreference(schema[i]);
                }
            }
        },

        /**
         * Gets preferences schema of the widget.
         *
         * @method
         * @return {Object} Preferences schema with current values for each preference.
         */
        getPreferences: function () {

            var i, l, k, m,
                preference, option,
                that = this,
                preferences = UWA.clone(that.preferences);

            for (i = 0, l = preferences.length; i < l; i++) {
                preference = preferences[i];
                preference.value = that.getValue(preference.name);

                // Translate preference label
                preference.label = UWA.i18n(preference.label);

                // Translate options label
                if (UWA.is(preference.options, 'array')) {
                    for (k = 0, m = preference.options.length; k < m; k++) {
                        option = preference.options[k];
                        option.label = UWA.i18n(option.label);
                    }
                }
            }

            return preferences;
        },

        /**
         * Gets the value of the given preference.
         *
         * Notes about the returned value:
         *
         * - If no default value is provided by the corresponding widget:preference XML tag
         * then this method will return undefined.
         *
         * - The type depends on what you have stored inside it.
         *
         * @method
         * @param {String} name - The name of the preference we want the value of
         * @return {Void} The current value of the given preference.
         */
        getValue: function (name) {

            var that = this;
            var environment = that.environment;

            var currentValue = that.data[name];

            if (!UWA.is(currentValue) && environment && environment.getData) {
                currentValue = decodeValueForPreference(that._getRawPreference(name), environment.getData(name));
            }

            if (!UWA.is(currentValue)) {
                currentValue = that.defaultData[name];
            }

            if (UWA.is(currentValue)) {
                that.data[name] = currentValue;
            } else {
                currentValue = undefined;
                delete that.data[name];
            }

            return currentValue;
        },

        /**
         * Gets the Integer value of the given preference.
         *
         * It is particularly advised to use getInt when a preference is of type range.
         *
         * @method
         * @param {String} name - The name of the preference we want the value of
         * @return {Number} The current value of the preference, converted as integer.
         */
        getInt: function (name) {

            var value = this.getValue(name);

            // Convert some boolean cases
            if (value === 'true' || value === true) {
                value = 1;
            } else {
                value = parseInt(value, 10);
            }

            return isNaN(value) ? 0 : value;
        },

        /**
         * Gets the Boolean value of the given preference.
         *
         * It is particularly advised to use getBool when a preference is of type boolean.
         *
         * @method
         * @param {String} name - The name of the preference we want the value of.
         * @return {Boolean} The current value of the preference, converted as boolean.
         */
        getBool: (function () {

            var trueCases = [1, '1', 'true', true];

            return function (name) {
                return (trueCases.indexOf(this.getValue(name)) !== -1);
            };
        }()),

        /**
         * Sets the value of the given preference.
         *
         * @method
         * @param {String} name - The name of the preference we want to set.
         * @param {String} value - The value of the preference.
         * @return {String} The value of the preference we set.
         *
         * @example
         * widget.setValue("nbItems", 5);
         */
        setValue: function (name, value) {

            var that = this,
                environment = that.environment,
                preference = that._getRawPreference(name),
                dispatchEvent = true;

            value = decodeValueForPreference(preference, value);

            if (!UWA.equals(that.data[name], value)) {

                if (!UWA.is(value)) {

                    // Delete current value
                    if (that.data.hasOwnProperty(name)) {
                        delete that.data[name];
                    } else {
                        // setValue has been invoked with a null/undefined value
                        // which was already removed Event should not be dispatched.
                        dispatchEvent = false;
                    }

                    // Handle environment
                    if (environment && environment.deleteData) {
                        environment.deleteData(name);
                    } else if (environment && environment.setData) {
                        environment.setData(name, undefined);
                    }

                } else {

                    value = UWA.clone(value);

                    // Update current value
                    that.data[name] = value;

                    // Handle environment
                    if (environment && environment.setData) {
                        environment.setData(
                            name,
                            encodeValueForPreference(preference, value),
                            preference ? UWA.equals(preference.defaultValue, value) : false
                        );
                    }
                }

                if (dispatchEvent) {
                    that.dispatchEvent('onUpdateValue', [name, value]);
                }
            }

            return value;
        },

        /**
         * Sets the values of the given preferences.
         *
         * @method
         * @param {Object} values - The preferences indexed by name value we want to set.
         *
         * @example
         * widget.setValues({
         *    'nbItems': 5,
         *    'title', "MyTitle"
         * });
         */
        setValues: function (values) {
            var name;
            for (name in values) {
                if (values.hasOwnProperty(name)) {
                    this.setValue(name, values[name]);
                }
            }
        },

        /**
         * Delete value of the given preference.
         *
         * @method
         * @param {String} name - The name of the preference we want the value of
         */
        deleteValue: function (name) {
            return this.setValue(name);
        },

        /**
         * Trigger "endEdit" or "onEdit" depending the isEdit state.
         */
        toggleEdit: function () {
            var menuOptions;
            var that = this,
                eventName = that.isEdit ? 'endEdit' : 'onEdit';

            that.dispatchEvent(eventName);

            // If an 'options/preferences' menu exists, make its parent active/inactive
            if (that.environment && that.environment.html.menus && that.getMenu('options/preferences')) {
                menuOptions = that.environment.html.menus.getElement('[data-name="options"]');
                if (menuOptions) {
                    menuOptions.toggleClassName('active', !that.isEdit);
                }
            }
        },

        /* Group: Events Methods */

        /**
         * Executes the listeners method associated with the given event name.
         *
         * > Internal or advanced use only.
         *
         * @method
         * @param {String} name - The event name (e.g. "onUpdateTitle");
         * @param {Array} args - Array of parameters that should be passed to each listener
         * @param {Object} bind - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         * @param {Object} dispatched - Indicate that the environment has dispatched the event already
         * @return {Object} Current <UWA.Widget> instance for more fluent interface and
         * calls the listeners associated with the given event name.
         */
        dispatchEvent: function (name, args, bind, dispatched) {

            // Copy bind value for environment
            var widget = this,
                environment = widget.environment,
                canDispatch = (!dispatched && environment) || name === 'onLoad' || widget.launched;

            // Dispatch Event to Environment
            if (!dispatched && environment) {
                environment.dispatchEvent(name, args, bind);

            // Dispatch Event to Widget only
            // Note: canDispatch is important, 'onLoad' need to be the first event
            // dispatched to avoid for example an 'onResize' dispatch before 'onLoad'.
            // That does not mean that 'onLoad' cannot dispatch 'onResize', it could
            // because launched is updated just before onLoad is triggered.
            } else if (canDispatch) {
                widget._parent(name, args, bind);
            }

            return widget;
        },

        /**
         * Add a listener associated with the given event name.
         *
         * @method
         * @param {String} name - The event name (e.g. "onUpdateTitle");
         * @param {Function} listener - listener function that will be executed when event is triggered.
         * @param {Object} bind - (optional) Context on which listener will be executed
         *       (object that should represent the `this` variable inside listener
         *       function). If left undefined, the context on which listener will
         *       be executed will be the one passed to <dispatchEvent>, which
         *       defaults to this widget.
         * @param {Number} priority - (optional) The priority level of the listener.
         *       Listeners with higher priority will be executed before listeners with lower priority.
         *       Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {Object} Current <UWA.Widget> instance for more fluent interface
         *
         * @example
         * // Example to add a listener on the onLoad event:
         *  widget.addEvent("onLoad", function (eventName) {
         *       widget.setBody("Widget loaded !");
         *  });
         *
         * @note
         * If the widget is already loaded, adding a listener for the onLoad event
         * will execute the listener right away.
         */
        addEvent: function (name, listener, bind, priority) {

            var widget = this,
                shouldExecute = name === 'onLoad' && widget.launched;

            widget._parent(name, listener, bind, priority);

            if (shouldExecute) {
                widget.addEventOnce('_onLoadImmediate', listener, bind, priority);
                this.setImmediate('_onLoadImmediate', function () {
                    widget.dispatchEvent('_onLoadImmediate');
                });
            }

            return widget;
        },

        /**
         * Add a listener associated with the given event name.
         * Once the event is fired, the listener will be removed.
         * This is handy for saying "the next time that X happens, do this".
         *
         * @method
         * @param {String} name - The event name (e.g. "onUpdateTitle");
         * @param {Function} listener - listener function that will be executed when event is triggered.
         * @param {Object} bind - (optional) Context on which listener will be executed
         *       (object that should represent the `this` variable inside listener
         *       function). If left undefined, the context on which listener will
         *       be executed will be the one passed to <dispatchEvent>, which
         *       defaults to this widget.
         * @param {Number} priority - (optional) The priority level of the listener.
         *       Listeners with higher priority will be executed before listeners with lower priority.
         *       Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {Object} Current <UWA.Widget> instance for more fluent interface
         *
         * @example
         * // Example to add a listener on the onLoad event:
         *  widget.addEvent("onLoad", function (eventName) {
         *       widget.setBody("Widget loaded !");
         *  });
         *
         * @note
         * If the widget is already loaded, adding a listener for the onLoad event
         * will execute the listener right away.
         */
        addEventOnce: function (name, listener, bind, priority) {
            var widget = this,
                shouldExecute = name === 'onLoad' && widget.launched;

            if (shouldExecute) {
                widget.addEventOnce('_onLoadImmediate', listener, bind, priority);
                this.setImmediate('_onLoadImmediate', function () {
                    widget.dispatchEvent('_onLoadImmediate');
                });
            } else {
                widget._parent(name, listener, bind, priority);
            }

            return widget;
        },

        /* Group: View Methods */

        /*
         * Try to change the current view. It will trigger an event
         * onViewRequest and the environment is in charge to send back an
         * event onViewChange or onViewError if an error occured.
         *
         * @method
         * @param {String|Object} descriptor - Descriptor of the view. It has to have at least the
         * field "type" with a view type. Other fields are optional and relative to the view. See
         * environments documentation for available view types. If descriptor is a string, it is the
         * equivalent of an object with the type property filled with this value.
         * @return {this}
         *
         * @example
         * widget.onViewChange = function (event) {
         *    if (event.type === 'maximized') {
         *        buildLargeWidgetView();
         *    } else {
         *        buildNormalWidgetView();
         *    }
         * };
         *
         * widget.onViewError = function (event) {
         *    widget.log('Failed to change the view: ' + event.error);
         * };
         *
         * widget.requestView({
         *    type: 'maximized',
         *    minWidth: 100
         * });
         */
        requestView: function (descriptor) {
            if (UWA.is(descriptor, 'string')) {
                descriptor = { type: descriptor };
            }
            this.dispatchEvent('onViewRequest', [descriptor]);
            return this;
        },

        /**
         * Get the current view parameters.
         *
         * @example
         * widget.onResize = function () {
         *  if (widget.getView().type === 'maximized') {
         *    resizeLargeLayout();
         *  } else {
         *    resizeNormalLayout();
         *  }
         * };
         *
         * @return {Object} The current view. This is an object with at least the
         *  'type' property indicating the view type. Other properties are
         *  the view options.
         */
        getView: function () {
            return this._view || {
                type: 'windowed'
            };
        },

        /**
         * Parses and return the `availableViews` meta data. This value
         * indicates which views this widget is handling, so the environment
         * can safely change the widget view to another available view at any
         * time.
         *
         * ##### Example
         *
         * Declaring availableViews meta in the widget code
         *
         * ```html
         * <meta name="availableViews" content='maximized {"chrome": `false`}; fullscreen' />
         * ```
         *
         * Implementing a 'maximize' button in the widget header (enviroment side)
         *
         * ```
         * var maximizeView = UWA.Array.detect(widget.getAvailableViews(), function (view) {
         *  return view.type === 'maximized';
         * });
         *
         * if (maximizeView) {
         *  widgetHeader.addContent({
         *    tag: 'span',
         *    text: 'maximize',
         *    events: {
         *      click: function () {
         *        environment.dispatchEvent('onViewRequest', maximizeView);
         *      }
         *    }
         *  });
         * }
         * ```
         */
        getAvailableViews: function () {
            var str = this.metas.availableViews || '';
            return UWAArray.invoke(str.split(';'), 'trim').filter(function (e) {
                return e;
            }).map(function (chunkStr) {
                var type = chunkStr.match(/\S*/)[0],
                    options = chunkStr.slice(type.length).trim(),
                    result;

                if (options) {
                    try {
                        result = JSON.parse(options);
                    } catch (e) {
                        this.log('Failed to parse availableViews options');
                    }
                }
                if (!result) {
                    result = {};
                }
                result.type = type;
                return result;
            }, this);
        },

        /* Group: Events */

        /**
         * Triggered when the widget is launched.
         * This event MUST be declared in any widget, in order for any of the widget's JavaScript code to be executed.
         * Implementations MUST trigger this event once the application is done loading.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onLoad
         * @inner
         */

        /**
         * Triggered when the widget is refreshed (manually or programmatically).
         * Implementations SHOULD trigger this event when preferences values are updated.
         * If this event is not declared, the <UWA.Widget.onLoad> event will be triggered instead.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onRefresh
         * @inner
         */

        /**
         * Triggered when the widget is resized (manually or programmatically).
         * Implementations SHOULD trigger this event when the size of the application container is resized
         * (for instance, when the user resizes the containing column, or changes the number of columns on the page).
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onResize
         * @inner
         */

        /**
         * Triggered when a key is pressed within the widget's area.
         * Implementations may first require the user to click within the widget's area in order to limit the interaction to that widget only.
         * Implementations SHOULD pass the key-code as first argument of the event.
         *
         * @param {String} key - The pressed key's code
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onKeyboardAction
         * @inner
         */

        /**
         * Triggered when a search is performed from within the platform.
         *
         * Implementing platforms that feature a search form MAY trigger this event, with the search query as first argument,
         * so that the widget may use it to further perform a search with its own data, if such a thing is possible.
         *
         * @param {String} query - The search query
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onSearch
         * @inner
         */

        /**
         * Triggered when a search is reseted from within the platform.
         *
         * Implementing platforms that feature a search form MAY trigger this event,
         * so that the widget may use it to further reset the last search, if such a thing is possible.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onResetSearch
         * @inner
         */

        /**
         * Triggered when the widget's icon is modified.
         * Implementations MUST trigger it when widget.setIcon() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} url - The url of the icon. The URL should include the protocol (http://)
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onUpdateIcon
         * @inner
         */

        /**
         * Triggered when the widget's title is modified.
         * Implementations MUST trigger it when widget.setTitle() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} title - The title of the widget. Can contain HTML code
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onUpdateTitle
         * @inner
         */

        /**
         * Triggered when the widget's counter is modified.
         * Implementations MUST trigger it when widget.setCounter() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {Number|Boolean|String} count - The number of results or status for the current search/unread items
         * @param {String} [type] - The number of results type (e.g 'search').
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onUpdateCounter
         * @inner
         */

        /**
         * Triggered when a widget's preference is added.
         * Implementations SHOULD trigger this event when a preferences is added (manually or programmatically).
         *
         * @param {Array} preferences - An Array of preferences in their JSON serialization
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onUpdatePreferences
         * @inner
         */

        /**
         * Triggered when edition of preferences begin.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onEdit
         * @inner
         */
        onEdit: function () {
            this.isEdit = true;
        },

        /**
         * Triggered when edition of preferences ending.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method endEdit
         * @inner
         */
        endEdit: function () {
            this.isEdit = false;
        }

        /**
         * Open an url into a new environment browser window.
         *
         * Behavior differ between execution environments:
         *  - open the page in an iframe on the same screen
         *  - open the page in a new window/tab
         *  - open the page in a new browser window (desktop widgets)
         *
         * @param {String} url - The url to open in a new window
         * @return {Boolean} `true` if it successfully opens the url (according to the subprotocol)
         *
         * Notes:
         * Implementation can differ between environments.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onOpenURL
         * @inner
         */

        /**
         * Try to change the widget view. This event can be triggered from the
         * widget by <UWA.Widget.requestView>.
         *
         * @param {Object} view - view parameters. It needs to have at least one
         *  field 'type' indicating the view name. Other properties are
         *  optional and passed to the view.
         *
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onViewRequest
         * @inner
         */

        /**
         * Triggered when the view changed.
         *
         * @param {Object} view - view parameters, like for <onViewRequest>
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onViewChange
         * @inner
         */

        /**
         * Triggered when the view fails to change.
         *
         * @param {Object} view - view parameters, like for <onViewRequest>, with one
         *  additional parameter 'error' representing the error message.
         *
         * @memberof module:UWA/Widget.UWA.Widget#
         * @method onViewError
         * @inner
         */
    });

    return UWA.namespace('Widget', Widget, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/WidgetPopupMenu
 *
 */
define('UWA/Controls/WidgetPopupMenu', [
    'UWA/Core',
    'UWA/Element',
    'UWA/Event',
    'UWA/Utils',
    'UWA/Controls/DropDown'
], function (UWA, Element, Event, Utils, DropDown) {
    'use strict';

    /**
     * Internal control class to display dropdown menu
     * in some widget environments such as `standalone`
     * or `netvibes`.
     *
     * @example
     * if (!env.popupMenu) {
     *     env.popupMenu = new WidgetPopupMenu(env);
     * }
     *
     * // Set the target DOM element used to position menu
     * env.popupMenu.setTarget(event.target);
     *
     * // Build and show popup menu
     * env.show(menu.items);
     *
     * @private
     */
    var WidgetPopupMenu = DropDown.extend({

        /**
         * The control name.
         *
         * @type {String}
         */
        name: 'uwa-widget-popup-menu',

        /**
         * WidgetPopupMenu constructor.
         *
         * @param {UWA.Environment.Netvibes} env
         */
        init: function (env) {
            this._parent();
            this.env = env;
            this.items = null;
        },

        /**
         * Set the HTML element that triggered the display
         * of the popup menu.
         *
         * @param {Element} element - HTML element.
         */
        setTarget: function (element) {
            this.target = element;
            return this;
        },

        /**
         * Overrides UWA.Controls.DropDown#onClick.
         */
        onClick: function (e) {
            this._parent(e);

            var target = Event.findElement(e, 'li'),
                menu = this.env.widget.getMenu(target.getAttribute('data-name'));

            if (menu) {
                this.env.dispatchEvent('onMenuExecute', [menu]);
            }
        },

        onClickOutside: function (e) {
            if (Event.getElement(e) !== this.target) {
                this.hide();
            }
        },

        /**
         * Menu position is constrained by the widget body area.
         *
         * Overrides UWA.Controls.DropDown#setPosition.
         */
        setPosition: function () {
            var position, positionOptions,
                container = this.env.html.moduleFrame || this.env.html.wrapper,
                containerOffsets = Element.getOffsets.call(container),
                containerSize = Element.getSize.call(container),
                targetOffsets = Element.getOffsets.call(this.target),
                targetSize = Element.getSize.call(this.target);

            position = {
                x: targetOffsets.x,
                y: targetOffsets.y + targetSize.height
            };

            positionOptions = {
                boundary: {
                    x: 0,
                    y: targetOffsets.y + targetSize.height,
                    width: containerOffsets.x + containerSize.width,
                    height: Infinity
                }
            };

            return this._parent(targetOffsets, positionOptions);
        },

        /**
         * Overrides UWA.Controls.DropDown#getInnerElement.
         */
        getInnerElement: function () {
            this.getContent(); // build content
            return this.elements.inner;
        },

        /**
         * Overrides UWA.Controls.DropDown#getContent.
         */
        getContent: function () {
            var elements = this.elements;
            if (!elements.inner) {
                this._parent().setContent(
                    elements.inner = UWA.createElement('menu', {
                        'type': 'popup'
                    })
                );
            }
            return elements.container;
        },

        /**
         * Assign menu items to render.
         *
         * @param {Array<Object>} items - List of menu item descriptors
         * @return {this}
         */
        setItems: function (items) {
            this.items = items;
            return this;
        },

        /**
         * Overrides UWA.Controls.DropDown#show.
         */
        toggle: function () {
            this.getInnerElement().empty();
            this.items.forEach(this.addItem, this);
            this.setPosition();
            this._parent();
        },

        /**
         * Overrides UWA.Controls.DropDown#onShow.
         */
        onShow: function () {
            this.target.addClassName('active');
            this._parent();
        },

        /**
         * Overrides UWA.Controls.DropDown#onHide.
         */
        onHide: function () {
            this.target.removeClassName('active');
            this._parent();
        },

        /**
         * Build a menu item and inject it in the menus container.
         *
         * @example
         * popupMenu.addItem({
         *     label: 'Item 1',
         *     icon: 'star',
         *     visible: true
         * });
         *
         * @param {Object} item - Menu item descriptor
         * @return {HTMLElement} Built element.
         */
        addItem: function (item) {
            var visible, element, icon, disabled;

            // Item visibility
            if (UWA.is(item.visible, 'function')) {
                visible = item.visible();
            } else {
                visible = (item.visible !== false);
            }

            if (visible === false) {
                // If item is not visible, skip it
                return;
            }

            // Item container
            element = UWA.createElement('li', {
                'class': this.getClassNames('-item'),
                'data-name': item.name
            });

            // Icon element
            if (item.icon) {
                icon = UWA.createElement('span', {
                    'class': 'uwa-icon uwa-icon-only'
                });
                if (this._getUtf8StringLength(item.icon) === 1) {
                    icon.set('data-icon', item.icon);
                    icon.addClassName('uwa-icon-unicode');

                } else if (Utils.isAbsoluteUrl(item.icon)) {
                    icon.adopt(UWA.createElement('img', {
                        src: item.icon,
                        width: 16,
                        height: 16
                    }));

                } else {
                    icon.addClassName(item.icon);
                }
                icon.inject(element);
            }

            // Title element
            if (item.label) {
                UWA.createElement('span', {
                    text: item.label
                }).inject(element);
            }

            // Set disabled flag
            if (UWA.is(item.disabled, 'function')) {
                disabled = item.disabled();
            } else {
                disabled = !!item.disabled;
            }
            if (disabled) {
                element.addClassName('disabled');
            }

            return element.inject(this.getInnerElement());
        },

        _getUtf8StringLength: function (str) {
            var m = encodeURIComponent(str).match(/%[89ABab]/g);
            return str.length + (m ? m.length : 0);
        }
    });

    return UWA.namespace('Controls/WidgetPopupMenu', WidgetPopupMenu, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout
*/

/**
 * Cross-Platform API for cross document data exchange.
 *
 * This set of Classes is used for example to dispatch events and messages
 * accross widgets instances through an interface using events names and JSON data.
 *
 * @module   UWA/Utils/InterCom
 *
 *
 * @example
 * // Make an alias to API, it's not required, but help for compression and shortcut.
 * var InterCom = UWA.Utils.InterCom;
 *
 * //
 * // Create a new Server Instance into main page
 * //
 *
 * var serverId = 'MyServer1';
 * var server = new InterCom.Server(serverId, {
 *     isPublic: true // Allow Socket looking for Server to connect
 * });
 *
 * //
 * // SocketA
 * //
 *
 * // Init "socketA" into an iframe or main page
 * var socketA = new InterCom.Socket('socketA');
 *
 * // Request a Server for socketA
 * socketA.subscribeServer(serverId, window, 'http://...'); // no server name means that the first server with isPublic option will be matched
 *
 *  // Handle "SocketAEvent" event
 *  socketA.addListener('SocketAEvent', function (json, info) {
 *      alert(json.msg); // display message from socketBData
 * });
 *
 * //
 * // SocketB
 * //
 *
 * // Init socketB into an iframe or main page
 * var socketB = new InterCom.Socket(); // Anonymous Socket, no body can direct dispatch on him
 * socketB.subscribeServer(serverId, window.parent, 'http://...');   // Specific Server
 *
 * // Data will pass througt Server to other sockets
 * var socketBData = {msg: 'Hello from SocketB'};
 *
 * //
 * // A. Send data to other sockets using "SocketAEvent" event and dispatchEvent function
 * //
 *
 * // 1. Only for socketA
 * socketB.dispatchEvent('SocketAEvent', socketBData, 'socketA');
 *
 * // 2. Only for sockets of socketB Servers
 * socketB.dispatchEvent('SocketAEvent', socketBData);
 *
 * // 3. Only for specifics Sockets or/and Server
 * socketB.dispatchEvent('SocketAEvent', socketBData, ['socketA', ...], ['MyServer1',...]);
 *
 * //
 * // B. Handle response with hooks
 * //
 *
 * // Handle "SocketBHook" event
 * socketA.addListener('SocketBHook', function (json, info) {
 *     alert(json.responseName); // dispatch step (beforeDispatch, onDispatchLoop, afterDispatch)
 *     alert(json.time);         // time
 * });
 *
 * // Then send event "SocketAEvent" and call "SocketBHook" event during server dispatch steps
 * socketB.dispatchEvent('SocketAEvent', socketBData, [], [], {
 *     beforeDispatch: 'SocketBHook',
 *     onDispatchLoop: 'SocketBHook',
 *     afterDispatch: 'SocketBHook'
 * });
 */
define('UWA/Utils/InterCom', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Class',
    'UWA/Dispatcher',
    'UWA/Class/Events',
    'UWA/Class/Options',
    'UWA/Class/Timed',
    'UWA/Class/Debug',
    'UWA/Json'
], function (UWA, Utils, Class, Dispatcher, Events, Options, Timed, Debug, Json) { // jshint ignore:line
    'use strict';

    // Check if at least there is one match between 2 array of sockets.
    function socketsMatch(serverSockets, sockets) {

        var o, lo, i, li;

        for (o = 0, lo = serverSockets.length; o < lo; o++) {
            for (i = 0, li = sockets.length; i < li; i++) {
                if (sockets[i] === serverSockets[o]) {
                    return true;
                }
            }
        }

        return false;
    }

    // Create an Event Class instance on UWA.Utils.InterCom._listener
    // Require by some adapter implementation.
    function createMainListeners(root) {

        // The parent can be acceded and have InterCom
        var hasUWA = Boolean(root.UWA && root.UWA.Utils && root.UWA.Utils.InterCom);

        // Has UWA but no Utils.InterCom._listener, then create it.
        if (hasUWA && !root.UWA.Utils.InterCom._listener) {
            root.UWA.Utils.InterCom._listener = new Events();
        }

        return root.UWA.Utils.InterCom._listener;
    }

    var InterCom,

        // Events subscribe name
        eventSubscribe = 'subscribe',
        eventUnSubscribe = 'unSubscribe',

        // Global alias
        global = UWA.getGlobal();

    InterCom = {
        /**
         * Get InterCom Adapater instance.
         *
         * @type {Function}
         * @alias getAdapter
         * @memberof module:UWA/Utils/InterCom
         */
        getAdapter: function (adapterName) {

            var i, l, adapter,
                adapters = InterCom.Adapters,
                adapterNames = adapterName ? Utils.splat(adapterName) : Object.keys(adapters);

            for (i = 0, l = adapterNames.length; i < l && !adapter; i++) {

                adapterName = adapterNames[i];

                if (adapters.hasOwnProperty(adapterName)) {
                    if (adapters[adapterName].isAvailable(adapter)) {
                        adapter = adapters[adapterName];
                        break;
                    }
                } else {
                    throw new Error('Unable to get InterCom Adapter with name "' + adapterName + '"');
                }
            }

            if (!adapter) {
                throw new Error('Unable to get InterCom Adapter');
            }

            return adapter;
        }
    };

    InterCom.Adapters = {

        /**
         * Adapter for browsers that support native messaging (various implementations
         * of the HTML5 postMessage method).
         *
         * Officially defined at http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.
         *
         * postMessage is a native implementation of XDC. A page registers that
         * it would like to receive messages by listening the the "message" event
         * on the window object. In turn, another page can
         * raise that event by calling window.postMessage  with a string representing
         * the message and a string indicating on which domain the receiving page must
         * be to receive  the message. The target page will then have its "message"
         * event raised if the domain matches and can, in turn, check the origin of the
         * message and process the data contained within.
         *
         * PostMessage: postMessage on the window object.
         *
         *  + Internet Explorer 8+
         *  + Safari 4+
         *  + Chrome 2+
         *  + Webkit nightlies
         *  + Firefox 3+
         *  + Opera 9+
         *
         * @type {Object}
         * @property {Function} isAvailable - Check if adapter is available.
         * @property {Function} removeListener - Remove event listener.
         * @property {Function} addListener - Add event listener.
         * @property {Function} dispatchEvent - Dispatch event.
         *
         * @alias Adapters.PostMessage
         * @memberof module:UWA/Utils/InterCom
         */
        PostMessage: (function () {

            var messageTypeIdentifier = 'uwa-intercom';
            var dispatcher;

            function eventHandler(event) {
                var eventData;

                try {
                    eventData = (typeof event.data === "string") && event.data[0] === '{' && JSON.parse(event.data);
                } catch (e) { /* invalid json */ }

                if (eventData && eventData.type === messageTypeIdentifier) {
                    // Provide real origin and source
                    // via postmessage event properties.
                    dispatcher.dispatch([
                        eventData.payload,
                        {
                            origin: event.origin,
                            source: event.source
                        }
                    ]);
                }
            }

            return {

                isAvailable: function () {
                    return global.postMessage &&
                                global.location &&
                                    global.location.protocol &&
                                        global.location.protocol.contains('http');
                },

                removeListener: function (listener) {

                    if (dispatcher) {

                        dispatcher.remove(listener);

                        if (dispatcher.getNumListeners() === 0) {

                            // Dispose dispatcher
                            dispatcher.dispose();
                            dispatcher = undefined;

                            // Firefox, Opera and Safari
                            if (global.addEventListener) {
                                global.removeEventListener('message', eventHandler, false);

                            // Internet Explorer
                            } else if (global.attachEvent) {
                                global.detachEvent('onmessage', eventHandler);
                            }
                        }
                    }
                },

                addListener: function (listener) {

                    if (!dispatcher) {

                        dispatcher = dispatcher || new Dispatcher();

                        // Firefox, Opera and Safari
                        if (global.addEventListener) {
                            global.addEventListener('message', eventHandler, false);

                        // Internet Explorer
                        } else if (global.attachEvent) {
                            global.attachEvent('onmessage', eventHandler);
                        }
                    }

                    dispatcher.add(listener);
                },

                dispatchEvent: function (data, targetSource, targetOrigin) {

                    var parent;

                    // Default to parent if unspecified.
                    if (!targetSource) {
                        parent = global.parent;

                        targetSource = parent.postMessage ?
                                parent : (parent.document.postMessage ? parent.document : undefined);
                    }

                    // Fix possible bad target
                    targetOrigin = (targetOrigin && targetOrigin !== '*') ? Utils.buildUrl(global.location, targetOrigin) : '*';

                    if (targetSource && targetSource.postMessage) {
                        var wrappedData = {
                            type: messageTypeIdentifier,
                            payload: data
                        };
                        targetSource.postMessage(JSON.stringify(wrappedData), targetOrigin);
                    }
                }
            };

        }()),

        /**
         * Adapter using IFrame URL Technique Officially defined at http://msdn.microsoft.com/en-us/library/bb735305.aspx.
         *
         * For all others, we have a fallback mechanism known as "FrameCallback".
         * FrameCallback exploits the fact that while same-origin policy prohibits a
         * frame from accessing members on a window not in the same domain, that frame
         * can, however, navigate the window heirarchy (via parent). This is exploited
         * by having a page on domain A that wants to talk to domain B create an iframe
         * on domain B pointing to a special relay file and with a message encoded
         * after the hash (#). This relay, in turn, finds the page on domain B, and
         * can call a receipt function with the message given to it. The relay URL
         * used by each caller is http://example.com/intercom.html and  *must* be
         * present before the call method is used.
         *
         * FrameCallback: Iframe-based method, utilizing a relay page, to send a message.
         *
         * + No known major browsers still use this method, but it remains useful as a catch-all fallback for the time being.
         * + Internet Explorer 5+
         * + Safari 1+
         * + Chrome 1+
         * + Webkit nightlies
         * + Firefox 1+
         * + Opera 5+
         *
         * @type {Object}
         * @property {Function} isAvailable - Check if adapter is available.
         * @property {Function} removeListener - Remove event listener.
         * @property {Function} addListener - Add event listener.
         * @property {Function} dispatchEvent - Dispatch event.
         *
         * @alias Adapters.FrameCallback
         * @memberof module:UWA/Utils/InterCom
         */
        FrameCallback: (function () {

            var cacheBust = 0, listeners,
                frameQueue = [],
                frameState = true,
                document = global.document;

            function insertFrame() {

                if (frameState && document.body && frameQueue.length > 0) {
                    document.body.appendChild(frameQueue.shift());
                }

                if (frameQueue.length > 0) {
                    setTimeout(insertFrame, 10);
                }
            }

            function dispatchFrame(data, targetSource, targetOrigin) {

                var newHash, frame,
                    originUrl = global.location.toString(),
                    targetUri = Utils.parseUrl(targetOrigin),
                    frameUrl = targetUri.protocol + '://' + targetUri.domain + '/intercom.html',
                    // Provide real origin via global, intercom.html is
                    // providing source from parent.
                    info = {
                        info: data,
                        origin: originUrl
                    };

                newHash = '#' + Date.now() + (cacheBust++) + '&' + Json.encode(info);
                frame = document.createElement('iframe');
                frame.setAttribute('src', frameUrl + newHash);
                frame.style.position = 'absolute';
                frame.style.top = '-2000px';
                frame.style.left = '0px';
                frame.onload = function () {
                    frameState = true;
                    frame.parentNode.removeChild(frame);
                };

                frameQueue.push(frame);

                setTimeout(insertFrame, 10);
            }

            function dispatchEvent(data, targetSource) {

                var targetListeners = createMainListeners(targetSource);

                setTimeout(function () {
                    // Provide real origin and source via global.
                    targetListeners.dispatchEvent('message', [data, {
                        origin: global.location.toString(),
                        source: global
                    }]);
                });
            }

            function isCrossFrame(targetSource) {

                try {

                    return (
                        targetSource === global || (
                            targetSource.location.host === global.location.host &&
                                targetSource.location.protocol === global.location.protocol
                        )
                    );

                } catch (frameError) {
                    // Ignore and consider invalid
                }
            }

            return {

                isAvailable: function () {

                    listeners = createMainListeners(global);

                    return Boolean(listeners);
                },

                removeListener: function (listener) {
                    listeners.removeEvent('message', listener);
                },

                addListener: function (listener) {
                    listeners.addEvent('message', listener);
                },

                dispatchEvent: function (data, targetSource, targetOrigin) {
                    if (isCrossFrame(targetSource)) {
                        dispatchEvent(data, targetSource, targetOrigin);
                    } else {
                        dispatchFrame(data, targetSource, targetOrigin);
                    }
                }
            };
        }())
    };

    InterCom.Server = Class.extend(Options, Debug, /** @lends module:UWA/Utils/InterCom.Server# */ {
        /**
         * Current Server id.
         * @type {String}
         */
        id: null,

        /**
         * Current Server generated uuid.
         * @type {String}
         */
        uuid: null,

        /**
         * Current Current server's sockets.
         * @type {Object}
         */
        sockets: null,

        /**
         * Current server's listeners.
         * @type {Object}
         */
        listeners: null,

        /**
         * Current Server default options.
         * @type {String}
         */
        defaultOptions: {
            adapter: null,
            autoconnect: true
        },

        /**
         * Create a new Server instance to dispatch events between sockets that have registered
         * to this server using subscribeServer.
         *
         * @param {String} serverId the server Id.
         * @param {Object} options server options.
         *
         * @constructs Server
         * @mixes UWA.Class.Debug
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Utils/InterCom
         *
         * @example
         * var MyServer = new UWA.Utils.InterCom.Server('MyServer');
         */
        init: function (serverId, options) {

            var that = this;

            // Set default serverId
            that.setServerId(serverId);

            // Init peroperties
            that.sockets = {};
            that.listeners = new Events();

            // Set socket options
            that.setOptions(options);

            // Connect if server autoconnect options is enable
            if (that.options.autoconnect) {
                that.connect();
            }
        },

        /**
         * Set server id
         * @param {String} serverId the server Id.
         */
        setServerId: function (serverId) {

            var that = this,
                Instances = InterCom.Server.Instances = InterCom.Server.Instances || {};

            // Set uuid
            that.uuid = that.uuid || Utils.getUUID();

            // Get serverId
            serverId = serverId || that.uuid;

            if (Instances[serverId]) {
                Instances[serverId].disconnect();
                delete Instances[serverId];
            }

            that.id = serverId;
            Instances[serverId] = that;

            return that;
        },

        /**
         * Add mainListener
         */
        connect: function () {

            var that = this;

            // Bind handleEvent to local scope
            that.handleEvent = that.handleEvent.bind(that);

            that.adapter = InterCom.getAdapter(that.options.adapter);
            that.adapter.addListener(that.handleEvent);

            return that;
        },

        /**
         * Disconnect Server instance from its Sockets and remove mainListener.
         */
        disconnect: function () {

            var that = this;

            if (that.adapter) {

                Object.keys(that.sockets).forEach(function (socketId) {
                    that.unsubscribeSocket(socketId);
                });

                that.adapter.removeListener(that.handleEvent);
            }

            // TODO more

            return that;
        },

        /**
         * Handle socket events dispaching.
         */
        handleEvent: function (info, event) {

            var isValidEvent, isValidUUID, isTarget,
                that = this,
                serverId = that.id,
                sockets = that.sockets,
                socketIds = Object.keys(sockets);

            // Simple event property validation
            isValidEvent = (
                event && event.source && event.origin &&
                    info.event && info.target && info.origin &&
                        info.target.servers && Array.isArray(info.target.servers) &&
                            info.target.sockets && Array.isArray(info.target.sockets)
            );

            // Simple UUID validation
            isValidUUID = isValidEvent && (
                sockets[info.origin.socket] &&
                    sockets[info.origin.socket].uuid === info.uuid
            );

            isTarget = isValidEvent && (
                info.target.sockets.length === 0 &&
                    info.target.servers.indexOf(serverId) !== -1
            );

            // Should we handle this event to current server or sockets ?
            if (isValidEvent) {

                // For current server only
                if (isTarget) {

                    that.log('SERVER: server "' + serverId + '" accept message for event "' + info.event + '"');

                    // It's an eventSubscribe event,
                    if (info.event === eventSubscribe) {

                        // Then answer with the same event to give it server id,
                        // if no UUID match
                        if (!isValidUUID) {
                            that.subscribeSocket(info.origin.socket, event.source, event.origin, info.uuid);
                        }

                    // Check isValidUUID
                    } else if (isValidUUID) {

                        // It's a eventUnSubscribe event, answer with the same event to give it server id
                        if (info.event === eventUnSubscribe) {
                            that.unsubscribeSocket(info.origin.socket);

                        // Then else redispatch to current server's sockets
                        } else {
                            that.dispatchEvent(info.event, info.data, info.origin.socket, info.target.sockets);
                        }
                    }

                // For server's sockets
                } else if (
                    isValidUUID &&
                        socketsMatch(info.target.sockets, socketIds) &&
                            socketsMatch([info.origin.socket], socketIds)
                ) {

                    that.log('SERVER PREDISPATCH: server "' + serverId + '" dispatch event "' + info.event + '" from "' + info.origin.socket + '"');

                    that.dispatchEvent(info.event, info.data, info.origin.socket, info.target.sockets);

                // Ignored msg for debugging only
                } else {
                    that.log('SERVER: server "' + serverId + '" refuse message for event "' + info.event + '"');
                }

            // Ignored msg for debugging only
            } else {
                that.log('SERVER: server "' + serverId + '" refuse invalid message for event "' + info.event + '"');
            }
        },

        /**
         * Subscribe socket instance to this server
         *
         * @param {String} socketId Id of socket to subscribe.
         * @param {Object} source Source of socket to subscribe (e.g window reference).
         * @param {String} origin Origin of socket to subscribe (e.g url of window reference).
         */
        subscribeSocket: function (socketId, source, origin, uuid) {

            var that = this,
                serverId = that.id;

            that.log('SERVER: server "' + serverId + '" register new socket "' + socketId + '"');

            that.sockets[socketId] = {
                source: source,
                origin: origin,
                uuid: uuid
            };

            that.dispatchEvent(eventSubscribe, {}, undefined, socketId);

            return that;
        },

        /**
         * Unsubscribe socket from this server.
         *
         * @param {String} socketId Id of socket to unsubscribe.
         */
        unsubscribeSocket: function (socketId) {

            var that = this,
                serverId = that.id;

            if (that.sockets[socketId]) {

                that.log('SERVER: server "' + serverId + '" unregister socket "' + socketId + '"');

                that.dispatchEvent(eventUnSubscribe, {}, undefined, socketId);

                delete that.sockets[socketId];
            }

            return that;
        },

        /**
         * Handle a new Event with data over the current Server.
         *
         * @param {String} event Name of listened event.
         * @param {Function} listener Callback function call when new even incoming.
         *
         * @example
         * myServer.addListener('MyEvent', function (json, info) {
         *     alert(json); // event data
         *     alert(info); // origin sockets and servers data for filtering
         * });
         */
        addListener: function (event, listener) {

            this.listeners.addEvent(event, listener);

            return this;
        },

        /**
         * Remove an event listener.
         *
         * @param {String} event Name of listened event.
         * @param {Function} listener Callback function call when new even incoming.
         */
        removeListener: function (event, listener) {

            this.listeners.removeEvent(event, listener);

            return this;
        },

        /**
         * Dispatch event with data to current Server's Sockets.
         *
         * @param {String} event Name of listened event.
         * @param {Object} data Data associate to this event dispatch request.
         * @param {String} originSocket Socket who dispatch the Event first.
         * @param {Array|String} targetSockets List or Name of targeted Sockets
         *
         * @example
         * myServer.dispatchEvent('MyEvent', {
         *     data: 'Hello other Sockets'
         * });
         */
        dispatchEvent: function (event, data, originSocket, targetSockets) {

            var that = this,
                serverId = that.id,
                sockets = that.sockets,
                adapter = that.adapter,
                serverInfo = {
                    event: event,
                    data: data,

                    target: {
                        sockets: targetSockets
                    },

                    origin: {
                        socket: originSocket,
                        server: serverId
                    },

                    uuid: that.uuid
                };

            // Get targetServers if missing
            if (!targetSockets || !targetSockets.length) {
                targetSockets = Object.keys(that.sockets);

                // Remove originSocket from the list if it exists
                if (targetSockets.indexOf(originSocket) !== -1) {
                    targetSockets.splice(targetSockets.indexOf(originSocket), 1);
                }

            // Add support for targetServers string
            } else {
                targetSockets = Utils.splat(targetSockets);
            }

            // Init adapter if required
            if (!adapter) {
                that.connect();
                adapter = that.adapter;
            }

            if (targetSockets.length === 0) {

                that.log('SERVER: server "' + serverId + '" has no target socket for dispatchEvent "' + event + '"');

            } else {

                // Dispatch on servers one by one
                targetSockets.forEach(function (socketId) {

                    var socket = sockets[socketId],
                        socketInfo = {
                            event: event,
                            data: data,

                            target: {
                                sockets: [socketId]
                            },

                            origin: {
                                socket: originSocket,
                                server: serverId
                            },

                            uuid: that.uuid
                        };

                    that.log('SERVER: server "' + serverId + '" dispatchEvent "' + socketInfo.event + '" to "' + socketId + '"');

                    try {
                        adapter.dispatchEvent(socketInfo, socket.source, socket.origin);
                    } catch (e) {
                        if (global.console) {
                            global.console.error('InterCom server "' + serverId + '": error while dispatching to socket ' + socketId + ': ' + e + '\nDeleting socket');
                        }
                        delete sockets[socketId];
                    }
                });
            }

            // Then else redispatch to current server
            that.listeners.dispatchEvent(event, [data, serverInfo]);

            return that;
        }
    });

    InterCom.Socket = Class.extend(Options, Debug, /** @lends module:UWA/Utils/InterCom.Socket# */ {
        /**
         * Current Socket id.
         * @type {String}
         */
        id: null,

        /**
         * Current Socket generated uuid.
         * @type {String}
         */
        uuid: null,

        /**
         * Current Current socket's servers.
         * @type {Object}
         */
        servers: null,

        /**
         * Current socket's listeners.
         * @type {Object}
         */
        listeners: null,

        /**
         * Current Server default options.
         * @type {String}
         */
        defaultOptions: {
            adapter: null,
            autoconnect: false
        },

        /**
         * Create a new Socket instance to dispatch events between sockets that have registered
         * to this server using subscribeServer.
         *
         * @param {String} socketId the socket Id.
         * @param {Object} options socket options.
         *
         * @constructs Socket
         * @mixes UWA.Class.Timed
         * @mixes UWA.Class.Debug
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Utils/InterCom
         *
         * @example
         * var MySocket = new UWA.Utils.InterCom.Socket('MySocket');
         * MySocket.subscribeServer('MyServer');
         */
        init: function (socketId, options) {

            var that = this;

            // Set default socketId
            that.setSocketId(socketId);

            // Init peroperties
            that.servers = {};
            that.listeners = new Events();

            // Set socket options
            that.setOptions(options);
        },

        setSocketId: function (socketId) {

            var that = this,
                Instances = InterCom.Socket.Instances = InterCom.Socket.Instances || {};

             // Set uuid
            that.uuid = that.uuid || Utils.getUUID();

            // Get socketId
            socketId = socketId || that.uuid;

            if (Instances[socketId]) {
                Instances[socketId].disconnect();
                delete Instances[socketId];
            }

            that.id = socketId;
            Instances[socketId] = this;

            return that;
        },

        /**
         * Add mainListener
         */
        connect: function () {

            var that = this;

            // Bind handleEvent to local scope
            that.handleEvent = that.handleEvent.bind(that);

            that.adapter = InterCom.getAdapter(that.options.adapter);
            that.adapter.addListener(that.handleEvent);

            return that;
        },

        /**
         * Disconnect Socket instance from his Servers and remove mainListener.
         */
        disconnect: function () {

            var that = this;

            if (that.adapter) {

                Object.keys(that.servers).forEach(function (serverId) {
                    that.unsubscribeServer(serverId);
                });

                that.adapter.removeListener(that.handleEvent);
            }

            return that;
        },

        /**
         * Handle socket events dispaching.
         */
        handleEvent: function (info, event) {

            var server, isValidUUID, isValidEvent, isTarget,
                that = this,
                socketId = that.id,
                servers = that.servers;

            // Simple event property validation
            isValidEvent = (
                event && event.source && event.origin &&
                    info && info.event && info.target && info.origin &&
                        info.origin.server && servers[info.origin.server] &&
                            info.target.sockets && Array.isArray(info.target.sockets)
            );

            // Simple UUID validation
            isValidUUID = isValidEvent && (
                servers[info.origin.server] &&
                    servers[info.origin.server].uuid === info.uuid
            );

            // Simple target validation
            isTarget = isValidEvent && (
                info.target.sockets.length !== 0 &&
                    info.target.sockets.indexOf(socketId) !== -1
            );

            // Should we handle this event to current server or sockets ?
            if (isValidEvent) {

                // For current socket only
                if (isTarget) {

                    // Alias Server
                    server = that.servers[info.origin.server];

                    that.log('SOCKET: socket "' + socketId + '" accept message for event "' + info.event + '"');

                    // It's an eventSubscribe event
                    if (info.event === eventSubscribe) {

                        // then store if no UUID match
                        if (!isValidUUID) {
                            server.waiting = false;
                            server.uuid = info.uuid;

                            // If there is event to dispatch in the queue
                            if (server.queue.length) {
                                // Dispatch them right now since server is no more waiting
                                server.queue.forEach(function (queueInfo) {
                                    that.adapter.dispatchEvent(queueInfo, server.source, server.origin);
                                });

                                that.log('SOCKET: socket dispatch "' + server.queue.length + '" events in the queue for serverId "' + info.origin.server + '".');

                                // Clear queue
                                server.queue = [];
                            }
                        }

                        that.listeners.dispatchEvent(info.event, [info.data, info]);

                    // Check isValidUUID
                    } else if (isValidUUID) {

                        // It's a eventUnSubscribe event, answer with the same event to give it server id
                        if (info.event === eventUnSubscribe) {

                            delete that.servers[info.origin.server];

                        // Then else redispatch to current socket
                        } else {
                            that.listeners.dispatchEvent(info.event, [info.data, info]);
                        }

                    } else {
                        that.log('SOCKET: socket "' + socketId + '" refuse invalid uuid for event "' + info.event + '"');
                    }

                // Ignored msg for debugging only
                } else {
                    that.log('SOCKET: socket "' + socketId + '" refuse message for event "' + info.event + '"');
                }

            // Ignored msg for debugging only
            } else {
                that.log('SOCKET: socket "' + socketId + '" refuse invalid message for event "' + info.event + '"');
            }
        },

        /**
         * Request a Server, and buffer request during waiting server response.
         *
         * @param {String} serverId Id of server to subscribe.
         * @param {Object} source Source of server to subscribe (e.g window reference).
         * @param {String} origin Origin of server to subscribe (e.g url of window reference).
         */
        subscribeServer: function (serverId, source, origin) {

            var that = this;

            // Defaut is parent and same location
            source = source || global.parent;
            origin = origin || global.location.toString();

            that.servers[serverId] = {
                waiting: true,
                queue: [],
                source: source,
                origin: origin
            };

            that.dispatchEvent(eventSubscribe, undefined, undefined, serverId);

            return that;
        },

        /**
         * Unsubscribe server from this socket.
         *
         * @param {String} serverId Id of server to unsubscribe.
         */
        unsubscribeServer: function (serverId) {

            var that = this,
                socketId = that.id;

            if (that.servers[serverId]) {

                that.log('SOCKET: socket "' + socketId + '" unregister server "' + serverId + '"');

                that.dispatchEvent(eventUnSubscribe, {}, undefined, serverId);

                delete that.servers[serverId];
            }

            return that;
        },

        /**
         * Handle a new Event with data over the current Server.
         *
         * @param {String} event Name of listened event.
         * @param {Function} listener Callback function call when new even incoming.
         *
         * @example
         * mySocket.addListener('MyEvent', function (json, info) {
         *    alert(json); // event data
         *    alert(info); // origin sockets and servers data for filtering
         * });
         */
        addListener: function (event, listener) {

            this.listeners.addEvent(event, listener);

            return this;
        },

        /**
         * Remove an event listener.
         *
         * @param {String} event Name of listened event.
         * @param {Function} listener Callback function call when new even incoming.
         */
        removeListener: function (event, listener) {

            this.listeners.removeEvent(event, listener);

            return this;
        },

        /**
         * Dispatch Event with data over Server to others Sockets.
         *
         * @param {String} event Name of listened event.
         * @param {Object} data Data associate to this event dispatch request.
         * @param {String} targetSockets List or Name of targeted Sockets.
         * @param {Array|String} targetServers List or Name of targeted Servers.
         */
        dispatchEvent: function (event, data, targetSockets, targetServers) {

            var that = this,
                socketId = that.id,
                servers = that.servers,
                adapter = that.adapter;

            // Get targetServers if missing
            if (!targetServers || !targetServers.length) {
                targetServers = Object.keys(that.servers);

            // Add support for targetServers string
            } else {
                targetServers = Utils.splat(targetServers);
            }

            // Add support for targetSockets string
            targetSockets = Utils.splat(targetSockets);

            // Init adapter if required
            if (!adapter) {
                that.connect();
                adapter = that.adapter;
            }

            data = Json.prune(data);

            // Dispatch on servers one by one
            targetServers.forEach(function (serverId) {

                var server = servers[serverId],
                    info = {
                        event: event,
                        data: data,

                        target: {
                            servers: [serverId],
                            sockets: targetSockets
                        },

                        origin: {
                            socket: socketId
                        },

                        uuid: that.uuid
                    };

                // If the queue is empty and the server ready, then dispatchEvent
                if (
                    (server.queue.length === 0 && !server.waiting) ||
                        (event === eventSubscribe || event === eventUnSubscribe)
                ) {

                    that.log('SOCKET: socket "' + socketId + '" dispatch event "' + event + '"');

                    adapter.dispatchEvent(info, server.source, server.origin);

                // If server not ready or queue not empty then push to the queue
                // try until fail and retry on next dispatchEvent.
                } else {

                    that.log('SOCKET: socket "' + socketId + '" queue event "' + event + '" for serverId "' + serverId + '"');

                    // Add info to the queue
                    server.queue.push(info);
                }
            });

            return that;
        }
    });

    return UWA.namespace('Utils/InterCom', InterCom, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, window, navigator
*/

/**
 * This module allow to render an UWA appplication into a frame
 * without requiring full UWA Js Runtime loaded into main document.
 *
 * ##### Examples
 *
 * Simple Example:
 *
 * ```
 * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html');
 * ```
 *
 * Example with offline capabilitie:
 *
 * ```
 * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html', {
 *     useAppCache: true,
 *     offlineMode: true
 * });
 * ```
 *
 * Example to handle title and preference update:
 *
 * ```
 * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html');
 * MyWidget.addCallback('setTitle', function(title) {
 * // setTitle called with value <title>
 * });
 *
 * MyWidget.addCallback('setValue', function(name, value) {
 * // setValue called for key <name> with value <value>
 * });
 * ```
 *
 * @module   UWA/Embedded
 *
 */
define('UWA/Embedded', [
    'UWA/Core',
    'UWA/String',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Class/Debug',
    'UWA/Class/Events',
    'UWA/Utils',
    'UWA/Utils/InterCom'
], function (UWA, UWAString, Class, Options, Debug, Events, Utils, InterCom) { // jshint ignore:line
    'use strict';

    // Following function are helper to avoid UWA.Element dependency.

    // Simple element helper to set styles
    function setElementStyles(element, styles) {
        var name;
        for (name in styles) {
            if (styles.hasOwnProperty(name)) {
                element.style[name] = styles[name];
            }
        }
    }

    // Simple element helper to set attributes
    function setElementAttributes(element, attributes) {

        var value, attribute;

        for (attribute in attributes) {
            if (attributes.hasOwnProperty(attribute)) {

                value = attributes[attribute];

                if (attribute === 'styles') {
                    setElementStyles(element, value);
                } else if (attribute === 'html') {
                    element.innerHTML = value;
                } else if (attribute === 'text') {
                    element.innerHTML = "";
                    element.appendChild(document.createTextNode(value));
                } else {
                    element.setAttribute(attribute, value);
                }
            }
        }
    }

    // Simple element helper to create element
    function createElement(tagName, attributes, parent) {

        var element = document.createElement(tagName);

        if (attributes) {
            setElementAttributes(element, attributes);
        }

        if (parent) {
            parent.appendChild(element);
        }

        return element;
    }

    function isEmpty(object) {

        var prop;

        if (typeof object !== 'object') {
            return false;
        }

        for (prop in object) {
            if (object.hasOwnProperty(prop)) {
                return false;
            }
        }

        return true;
    }

    function encodeUrl(str) {
        return typeof str === 'boolean' ? (str === false ? '0' : '1') : Utils.encodeUrl(str);
    }

    var Embedded = Class.extend(Options, Debug, Events, /** @lends module:UWA/Embedded.UWA.Embedded# */ {

        /**
         * Current UWA Widget Url used by current Embedded instance.
         *
         * @type {String}
         */
        url: '',

        /**
         * Current Embedded instance unique identifier.
         *
         * @type {String}
         */
        id: null,

        /**
         * Stores widget's data.
         *
         * > This property can be modified by the <setValue> method.
         * > This property may automatically updated by widget using <publicInterface>.
         *
         * @type {Object}
         */
        data: null,

        /**
         * Identifier of UWA assets version.
         *
         * @type {String}
         */
        version: UWA.version,

        /**
         * Embedded Elements (container, header, footer, frame, ...).
         */
        elements: null,

        /**
         * Stores widget's preferences.
         * The array is initially empty. It is initialised by the <onRegisterWidget> method.
         * This property may automatically updated by widget using <publicInterface>.
         *
         * @type {Array}
         */
        preferences: null,

        /**
         * Activates or desactivates the remote message for the widget.
         * The default value is TRUE. When TRUE, messages written with <sendRemote> method will sent to the widget.
         *
         * @type {Boolean}
         */
        disableRemote: true,

        /**
         * UWA.Embedded default rendering Options.
         * @private
         */
        defaultOptions: {

            // Container options
            container: null,
            className: 'module',

            // Customize
            title: null,
            themeUrl: null,
            color: 'white',
            height: 'auto',
            width: '100%',
            maxHeight: false,
            bookmarklet: false,
            lang: null,

            // Data
            id: null,
            readOnly: false,
            data: {},

            // Header, Footer and Scroller
            buildHeader: false,
            displayHeader: true,
            displayFooter: true,
            displayScroller: false,
            displayEdit: true,

            // Performances
            cache: null,
            useAsyncFrame: false,
            useAppCache: false,
            offlineMode: false,
            autoLaunch: true,

            // Security
            subDomain: false,
            subDomainPattern: '{id}.widget.',
            remoteName: 'uwa.embedded',
            sandbox: false,

            // Hosts
            exposition: UWA.hosts.exposition,
            uwa: UWA.hosts.uwa
        },

        /**
         * @property {Object} socket - Stores Embedded's socket for UWA.InterCom usage.
         * @protected
         */
        socket: null,

        /**
         * Render an UWA appplication into a frame without requiring full UWA Js Runtime loaded into main document.
         *
         * ##### Features
         *
         * - Provide widget callbacks mapping.
         * - UWA application soft or hard sandboxing.
         * - Remote UWA application communication and events controls.
         * - Remote UWA application preferences manipulation.
         * - Async Script Snipets for loading UWA application into third party website.
         *
         * ##### Examples
         *
         * Simple Example:
         *
         * ```
         * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html');
         * ```
         *
         * Example with offline capabilitie:
         *
         * ```
         * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html', {
         *     useAppCache: true,
         *     offlineMode: true
         * });
         * ```
         *
         * Example to handle title and preference update:
         *
         * ```
         * var MyWidget = new UWA.Embedded('http://example.com/apps/mywidget.html');
         * MyWidget.addCallback('setTitle', function(title) {
         * // setTitle called with value <title>
         * });
         *
         * MyWidget.addCallback('setValue', function(name, value) {
         * // setValue called for key <name> with value <value>
         * });
         * ```
         *
         * @param {String} url - a valid UWA widget url
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Element} [options.container=null] - Element that contain the injected widget
         * @param {String} [options.className='module'] - ClassName of the container Element
         * @param {String} [options.maxHeight='auto'] - Define the max height
         * @param {String} [options.color='white'] - Define header color
         * @param {String} [options.readOnly=false] - Disable widget preferences
         * @param {String} [options.data={}] - Define widget preferences values
         * @param {String} [options.buildHeader=false] - Build header outside of the frame
         * @param {String} [options.displayHeader=true] - Display header into frame
         * @param {String} [options.displayFooter=true] - Display footer into frame
         * @param {String} [options.displayScroller=false] - Display scroller into frame
         * @param {String} [options.useAsyncFrame=false] - Enable async frame mode (experimental)
         * @param {String} [options.useAppCache=false] - Enable HTML5 offline capabilities
         * @param {String} [options.offlineMode=false] - Enable AJAX cache offline capabilities
         * @param {String} [options.autoLaunch=true] - Launch the widget when frame is ready
         * @param {String} [options.subDomain=false] - Enable subDomain sandbox
         * @param {String} [options.subDomainPattern='{id}.widget.'] - SubDomain sandbox pattern
         * @param {String} [options.remoteName='uwa.embedded'] - UWA.Utils.InterCom server name
         * @param {String} [options.uwa=UWA.hosts.uwa] - Set a specific UWA JS Runtime host
         * @param {String} [options.exposition=UWA.hosts.exposition] - Set a specific Exposition Server host
         *
         * @constructs UWA.Embedded
         * @mixes UWA.Class.Options
         * @mixes UWA.Class.Debug
         * @mixes UWA.Class.Events
         * @memberof module:UWA/Embedded
         */
        init: function (url, options) {

            // Init values
            this.url = url;
            this.data = {};
            this.elements = {};
            this.preferences = [];
            this._remoteQueue = [];
            this.startTime = new Date().getTime();

            // Init options
            this.setOptions(options);

            // Alias
            options = this.options;

            // Use Container name has Widget Id
            var scripts, script, asyncContainer,
                containerType = typeof options.container;

            // Handle Container Id
            if (containerType === 'string') {

                this.container = document.getElementById(options.container);

            // Handle Container Object
            } else if (containerType === 'object' && this.options.container !== null) {

                this.container = options.container;

            // Handle Export Code Async/NonAsync
            } else {

                asyncContainer = document.getElementById('UWA_ASYNC');
                this.container = createElement('div', {
                    id: this.id,
                    'class': options.className
                });

                if (asyncContainer) {
                    asyncContainer.parentNode.insertBefore(this.container, asyncContainer.nextSibling);
                } else {
                    scripts = document.getElementsByTagName('script');
                    script = scripts[scripts.length - 1];
                    script.parentNode.insertBefore(this.container, script);
                }
            }

            // Save Instance
            Embedded.Instances[this.id] = this;

            if (!this.container) {
                throw new Error('UWA.Embedded is unable to get container element with container ' + this.container + '.');
            } else if (typeof this.url !== 'string') {
                throw new Error('UWA.Embedded expect url defined has first param');
            } else {
                this.log('Init new instance with container id "' + this.id + '" and widget url "' + this.url + '"');
                this.render();
            }
        },

        destroy: function () {
            // TODO
        },

        /**
         * Set options values of current instance.
         *
         * @param {Object} options - The options to add
         * @return {Object} The current UWA.Embedded instance.
         */
        setOptions: function (options) {

            this._parent(options);

            options = this.options;

            // Has title options let's build header
            if (options.title) {
                options.buildHeader = true;
            }

            // Display header and build Headder are not compatible
            if (options.buildHeader) {
                options.displayHeader = false;
            }

            // Set default Data
            this.data = options.data || {};

            // Set Id from options of generate if missing
            if (options.id || !this.id) {
                this.id = options.id || this.generateId();
            }

            return this;
        },

        /**
         * Generate a new uniq embbedded Id based on <url>.
         *
         * @return {String} new uniq embbedded Id.
         */
        generateId: function () {

            var id;
            do {
                id = 'uwa-' + Utils.getCheckSum(this.url) + '-' + Utils.random(1, 100000);
            } while (document.getElementById(id) && Embedded.Instances[id] !== null);

            return id;
        },



        /**
         * Render Iframe and Iframe Container.
         */
        render: function () {

            var iframeOptions,
                elements = {},
                options = this.options,
                container = this.container,
                iOS = navigator.userAgent.toLowerCase().match(/ip(?:ad|od|hone)/);

            elements.wrapper = createElement('div', {
                'class': 'moduleWrapper'
            });

            // Build Header title
            if (options.buildHeader) {

                // Build Header
                elements.header = createElement('div', {
                    'class': 'moduleHeader',
                    styles: {
                        position: 'relative',
                        overflow: 'hidden',
                        height: '23px',
                        padding: '5px 5px 0 5px'
                    }
                }, elements.wrapper);

                elements.iconContainer = createElement('span', {
                    styles: {
                        padding: '0 5px 0 0'
                    }
                }, elements.header);

                elements.icon = createElement('img', {
                    src: options.uwa + UWA.paths.img + 'icon.png',
                    'class': 'moduleIcon',
                    height: 16,
                    width: 16,
                    styles: {
                        border: 'none',
                        height: 16,
                        width: 16
                    }
                }, elements.iconContainer);

                elements.title = createElement('span', {
                    text: options.title || 'Loading...',
                    'class': 'moduleTitle',
                    styles: {
                        font: 'bold 11px/20px "Lucida Grande",Tahoma,Helvetica,Arial,sans-serif',
                        verticalAlign: 'top'
                    }
                }, elements.header);
            }

            // Build body
            elements.body = createElement('div', {
                'class': 'moduleContent'
            }, elements.wrapper);

            // Build Iframe
            iframeOptions = {
                id: 'frame-' + this.id,
                //src: 'about:blank',
                frameBorder: 0,
                //allowTransparency: 'false',
                width: '100%',
                scrolling: options.maxHeight || options.height !== 'auto' ? 'auto' : 'no'
            };

            if (options.sandbox) {
                iframeOptions.sandbox = 'allow-same-origin allow-forms allow-scripts allow-popups';
            }

            elements.iframe = createElement('iframe', iframeOptions, elements.body);

            // Avoid possible whitespace after iframe
            setElementStyles(elements.iframe, {
                display: 'block'
            });

            // Set container has a bookmarklet
            if (options.bookmarklet) {

                options.displayScroller = true;
                options.height = '100%';
                options.width = '320px';

                setElementStyles(elements.wrapper, {
                    position: 'fixed',
                    top: 0,
                    right: 0,
                    height: options.height,
                    width: options.width,
                    'z-index': 99999998
                });
            }

            // Set the current iframe height
            if (options.height !== 'auto') {
                elements.iframe.height = options.height;
            }

            // Note that starting in version 4.2.1 of Safari iOS, the entire content
            // of an iFrame is forcibly shown when scrolling attribute is 'auto'.
            // To keep iFrame inside the window boundaries, iFrame width
            // must be set in 'px' and 'scrolling' attribute to 'no'.
            if (iOS && options.displayScroller) {
                elements.iframe.scrolling = 'no';
            }

            this.elements = elements;

            // Clean container and add wrapper to container
            container.innerHTML = '';
            container.appendChild(elements.wrapper);

            if (options.useAsyncFrame) {
                this.renderIframeAsync();
            } else {
                this.renderIframe();
            }

            // Set Color
            this.setChromeColor(options.color);

            // Init Remote
            this.initRemote();
        },

        renderIframe: function () {

            var iframe = this.elements.iframe,
                iframeUrl = this.getIframeUrl();

            // Update only if it change
            if (!iframe.previousIframeUrl || iframe.previousIframeUrl !== iframeUrl) {
                iframe.previousIframeUrl = iframeUrl;
                iframe.src = iframeUrl;
            }
        },

        renderIframeAsync: function () {

            var code,
                that = this,
                jsonEncode = JSON.stringify,
                options = that.options,
                iframeDoc = that.elements.iframe.contentWindow.document,
                moduleUrl = options.exposition + '/widget/amd/js?uwaUrl=' + encodeUrl(that.url),
                widgetObject = {
                    id: that.id,
                    widgetDomain: window.location.toString().replace(/#.*$/, '')
                };

            // Handle cache options
            if (options.cache) {
                moduleUrl += '&cache=' + encodeUrl(options.cache);
            }

            code = [
                '<!DOCTYPE html>',
                '<html>',
                '<head>',

                // UTF8 love
                '<meta charset="UTF-8" />',

                // Configure UWA
                '<script type="text/javascript">',
                '   var UWA = {hosts:' + jsonEncode(UWA.hosts) + '},',
                '       curl = {apiName: "require"};',
                '</script>',

                // Load Curl
                '<script type="text/javascript" src="' + options.uwa + '/lib/vendors/curl.js?v=' + that.version + '"></script>',

                // Load Widget Module
                '<script type="text/javascript" src="' + moduleUrl + '&v=' + that.version + '"></script>',

                '</head>',
                '<body>',

                // Extend Widget with options
                '<script type="text/javascript">',
                '   define("' + that.id + '", ["' + that.url + '"], function (widget) {',
                '       UWA.extend(widget, ' + jsonEncode(widgetObject) + ');',
                '   });',
                '</script>',
                '</body>',
                '</html>'
            ];

            iframeDoc.open();
            iframeDoc.write(code.join("\n"));
            iframeDoc.close(); // iframe onload event happens
        },

        /**
         * Get current iframe Url with rights parameters.
         */
        getIframeUrl: function () {

            var key, url,
                that = this,
                paramsQuery = [],
                options = that.options,
                data = that.data,
                params = {
                    uwaUrl: that.url,
                    id: that.id,
                    cache: options.cache,
                    header: options.displayHeader,
                    footer: options.displayFooter,
                    scroller: options.displayScroller,
                    displayEdit: options.displayEdit,
                    autoLaunch: options.autoLaunch && !options.offlineMode,
                    useAppCache: options.useAppCache,
                    offlineMode: options.offlineMode,
                    chromeColor: options.color,
                    widgetDomain: window.location.toString().replace(/#.*$/, ''),
                    themeUrl: options.themeUrl,
                    lang: options.lang
                };

            // Add ReadOnly and Data into Params only if offlineMode is false
            if (!options.offlineMode) {

                params.readOnly = options.readOnly;

                for (key in data) {
                    if (data.hasOwnProperty(key) && !params.hasOwnProperty(key)) {
                        params[key] = data[key];
                    }
                }
            }

            // Build paramsQuery
            for (key in params) {
                if (params.hasOwnProperty(key) && params[key] !== null) {
                    paramsQuery.push(key + '=' + encodeUrl(params[key]));
                }
            }

            // Store full url
            url = that.getIframeDomain() + '?' + paramsQuery.join('&');

            // Avoid Url limit overflow
            if (url.length > 2048) {
                throw new Error('UWA.Embedded iframe url is more than 2048 characters please implement UWA.Embedded using offlineMode=true.');
            }

            return url;
        },

        /**
         * Get current module domain for iframe mode.
         *
         * @return {String} Module Domain related to <UWA.hosts.exposition> value.
         */
        getIframeDomain: function () {

            var subdomainId,
                options = this.options,
                iframeDomain = options.exposition;

            if (options.subDomain) {
                subdomainId = Utils.getCheckSum(this.url);
                iframeDomain = iframeDomain.replace('://', '://' + options.subDomainPattern.replace('{id}', subdomainId));
            }

            iframeDomain += '/widget/frame';

            return iframeDomain;
        },



        /**
         * Init Remote controls system to exchange data between module frame and current document.
         *
         * > Internal or advanced use only.
         */
        initRemote: function () {

            var socket,
                that = this,
                options = that.options;

            if (!that.socket) {

                // Init one uwa Embedded server per pages
                if (!Embedded.Servers[options.remoteName]) {
                    Embedded.Servers[options.remoteName] = new InterCom.Server(options.remoteName);
                }

                socket = new InterCom.Socket(that.id + '-master');
                socket.subscribeServer(options.remoteName, window, window.location.toString());
                socket.addListener('widgetMessage', function (message) {

                    var args = message.args,
                        event = args.shift();

                    // Avoid that last received event is also sendRemote
                    that.disableRemote = event;

                    that.dispatchEvent(event, args);

                    // Restore sendRemote
                    that.disableRemote = false;
                });

                // Store socket
                that.socket = socket;

                // Send remote queue
                that._runRemoteQueue();
            }
        },

        /*
         * Send the next message from the queue, if any, then call itself recursively
         */
        _runRemoteQueue: function () {
            var message, args,
                that = this;

            if (!that.socket || that._remoteQueue.length === 0) {
                return;
            }

            args = that._remoteQueue.shift();

            // Disable to avoid dispatch loop
            if (
                that.disableRemote === true ||
                    that.disableRemote === args[0]
            ) {
                that.log('sendRemote message ignored: ' + args);

            } else {
                // Encode the message into JSON
                message = {
                    id: that.id,
                    args: args
                };

                that.log('sendRemote message: ' + args);
                that.socket.dispatchEvent('environmentMessage', message, [message.id + '-slave']);
            }

            that._runRemoteQueue();
        },

        /**
         * Send message throught remote controls to the widget.
         *
         * @example
         * embedded.sendRemote('onUpdateTitle', ["My new Title"])
         *
         * @param {String} event - A event name for remote interface
         * @param {Array} args - Event data for remote interface
         */
        sendRemote: function () {
            var that = this;

            that._remoteQueue.push(Utils.toArray(arguments));
            that._runRemoteQueue();
        },



        /**
         * Load or reLoad the Widget.
         *
         * @param {Object} data - Widget's data values
         * @param {Bool} readOnly - Default to `false`. True if the widget is currently read only for the viewer
         */
        launch: function (data, readOnly) {

            if (readOnly !== undefined) {
                this.options.readOnly = readOnly;
            }

            if (data !== undefined) {
                this.data = data;
            }

            // Force enable Remote message
            this.disableRemote = false;

            this.sendRemote('launchWidget', this.data, this.options.readOnly);
        },

        /**
         * Sets the color value of widget header.
         *
         * @example
         * embedded.setChromeColor("red");
         *
         * @param {String} color - The name of the color we want to set
         */
        setChromeColor: function (color) {
            this.dispatchEvent('onColorize', [color]);
            this.sendRemote('onColorize', color);
        },

        /**
         * Sets the title of the Widget.
         *
         * @example
         * embedded.setTitle('Netvibes Blog');
         *
         * @param {String} title - The title of the widget
         */
        setTitle: function (value) {
            this.dispatchEvent('onUpdateTitle', [value]);
            this.sendRemote('onUpdateTitle', value);
        },

        /**
         * Sets the icon for the Widget.
         *
         * @example
         * embedded.setIcon("http://www.netvibes.com/favicon.ico");
         * // OR
         * embedded.setIcon("http://www.netvibes.com", true);
         *
         * @param {String} url - The url of the icon. The URL should include the protocol (http://)
         * @param {Boolean} search - If `true`, try to autodiscover the icon for the given url. Internal use only
         */
        setIcon: function (url, search) {
            this.dispatchEvent('onUpdateIcon', [url, search]);
            this.sendRemote('onUpdateIcon', url, search);
        },

        /**
         * Sets the value of the given preference.
         *
         * @example
         * embedded.setValue("nbItems", "5");
         *
         * @param {String} name - The name of the preference we want to set
         * @param {String} value - The value of the preference
         */
        setValue: function (name, value) {
            this.dispatchEvent('onUpdateValue', [name, value]);
            this.sendRemote('onUpdateValue', name, value);
        },

        /**
         * Sets the values of the given preferences.
         *
         * @example
         * embedded.setValue({
         *    "nbItems", "5",
         *    "openOutside": true
         * });
         *
         * @param {Object} values - The preferences indexed by name value we want to set
         */
        setValues: function (values) {
            var name;
            for (name in values) {
                if (values.hasOwnProperty(name)) {
                    this.setValue(name, values[name]);
                }
            }
        },

        /**
         * Sets the height value of widget iframe.
         *
         * @example
         * embedded.resizeHeight(100);
         *
         * @param {Number} height - the height we want to set
         */
        resizeHeight: function (value, force) {
            this.dispatchEvent('onResizeHeight', [value, force]);
            this.sendRemote('onResize');
        },

        /**
         * Sets the width value of widget iframe.
         *
         * @example
         * embedded.resizeWidth(100);
         *
         * @param {Number} width - The width we want to set
         */
        resizeWidth: function (value, force) {
            this.dispatchEvent('onResizeWidth', [value, force]);
            this.sendRemote('onResize');
        },



        /**
         * Call when a Widget Register into the execution Environment.
         * Once done, fire the <launch> callback if autoLaunch options is `false`.
         */
        onRegisterWidget: function () {

            var that = this,
                options = that.options;

            // Record loadTime
            that.loadTime = new Date().getTime();

            // Force enable Remote message
            that.disableRemote = false;

            // Launch if offlineMode or AsyncFrame cause it does not launch by itself
            // in order to pass data.
            if (
                options.autoLaunch &&
                    (options.offlineMode || options.useAsyncFrame)
            ) {
                that.launch();
            }
        },

        /**
         * Triggered when the widget's title is modified.
         * Implementations MUST trigger it when widget.setTitle() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} title - The title of the widget. Can contain HTML code
         */
        onUpdateTitle: function (title) {

            if (this.title !== title) {

                this.title = title;

                // Update outer frame title if not set has options
                if (
                    this.elements.title &&
                        this.options.buildHeader &&
                            this.options.title === null
                ) {
                    setElementAttributes(this.elements.title, {
                        text: UWAString.stripTags(title)
                    });
                }
            }
        },

        /**
         * Triggered when the widget's icon is modified.
         * Implementations MUST trigger it when widget.setIcon() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} url - The url of the icon. The URL should include the protocol (http://)
         */
        onUpdateIcon: function (url) {

            if (this.icon !== url) {

                this.icon = url;

                // Update outer frame title if not set has options
                if (this.options.buildHeader) {

                    var icon = this.elements.icon,
                        iconTmp = createElement('img',  {
                            src: url,
                            onload: function () {
                                icon.src = url;
                            }
                        });

                    // IE fix
                    if (iconTmp.complete && iconTmp.width > 0) {
                        icon.src = url;
                    }
                }
            }
        },

        onUpdatePreferences: function (preferences) {
            this.preferences = preferences;
        },

        onUpdateValue: function (name, value) {

            if (this.data[name] !== value) {
                this.data[name] = value;
            }
        },

        onResizeHeight: function (value, force) {

            var options = this.options,
                maxHeight = options.maxHeight,
                isMaxHeight = maxHeight && value > maxHeight;

            if (
                this.elements.iframe &&
                    (force || options.height === 'auto')
            ) {
                this.elements.iframe.height = isMaxHeight ? maxHeight : value;
            }
        },

        onResizeWidth: function (value, force) {

            var options = this.options;

            if (
                this.elements.iframe &&
                    (force || options.width === 'auto')
            ) {
                this.elements.iframe.width = value;
            }
        },

        onColorize: function (color) {

            var options = this.options,
                elements = this.elements;

            options.color = color;

            if (options.buildHeader) {

                if (color !== 'transparent') {

                    setElementStyles(elements.header, {
                        background: 'url("' + options.uwa + UWA.paths.css + 'themes/blueberry/img/moduleheader' +
                            (color !== 'white' ? '_' + color : '') + '.png?v=' + this.version + '") repeat-x scroll center top transparent'
                    });

                } else {
                    setElementStyles(elements.header, {
                        background: null
                    });
                }

                setElementStyles(elements.title, {
                    color: (color !== 'transparent' ? 'white' : 'black')
                });
            }
        },

        onViewRequest: function (infos) {
            if (!infos) {
                infos = {};
            }
            infos.error = 'No view implementation in Embedded mode';
            this.sendRemote('onViewError', infos);
        },



        /**
         * Get Javascript `<script>` tags to display widget.
         *
         * @param {Boolean} asynchronous - using asynchronous Javascript
         * @return {String} Javascript `<script>` tags to display widget
         */
        getCode: function (asynchronous) {

            // Add Javascript Libs
            var i, l, name, code,
                that = this,
                url = that.url,
                jsonEncode = JSON.stringify,
                options = that.options,
                codeOptions = {},
                //scripts = ['/lib/vendors/curl.js', '/lib/vendors/json2.js', '/lib/UWA/js/Core.js', '/lib/UWA/js/Utils/InterCom.js', '/lib/UWA/js/Embedded.js'];
                scripts = ['/lib/c/UWA/js/UWA_Embedded.js'],
                hosts =  {
                    uwa: options.uwa,
                    exposition: options.exposition
                };

            // Build Export Options params JSON Encode like
            for (name in options) {
                if (options.hasOwnProperty(name)) {
                    if (
                        name !== 'container' &&                             // Ignore container
                            options[name] !== null &&                       // Ignore null value
                                that.defaultOptions[name] !== options[name] // Ignore same has default
                    ) {

                        if (!isEmpty(options[name])) {
                            codeOptions[name] = options[name];
                        }
                    }
                }
            }

            // Asynchronous Widget import
            if (asynchronous && scripts.length === 1) {

                // Build Javascript Call
                code = [
                    '<script type="text/javascript">',
                    'var UWA = {hosts:' + jsonEncode(hosts) + '}, UWA_ASYNC = UWA_ASYNC || [];',
                    '    UWA_ASYNC.push({url: "' + url + '",options:' + jsonEncode(codeOptions) + '});',
                    '(function () {',
                    '    var a = document.getElementsByTagName("script"), b = a[a.length - 1] || document.body.lastChild,',
                    '        c = b.parentNode, d = document.createElement("script"), e = document.createElement("div");',
                    '    e.id = "UWA_ASYNC"; d.type = "text/javascript"; d.async = true;',
                    '    d.src = ("https:" == document.location.protocol ? "https://" : "http://") + UWA.hosts.uwa.split("://")[1] + "' + scripts[0] + '?v=' + this.version + '";',
                    '    c.insertBefore(d, b); c.insertBefore(e, b)',
                    '})();',
                    '</script>'
                ];

            // Synchronous Widget import
            } else {

                code = [];

                // Set UWA Javascript Env
                code.push('<script type="text/javascript"> var UWA = {hosts:' + jsonEncode(hosts) + '}; </script>');

                // Add Javascript File
                for (i = 0, l = scripts.length; i < l; i++) {
                    code.push('<script type="text/javascript" src="' + options.uwa + scripts[i] + '?v=' + this.version + '"></script>');
                }

                // Build Javascript Call
                code.push('<script type="text/javascript">');
                code.push('var MyWidget = new UWA.Embedded("' + url + '"' + (!isEmpty(codeOptions) ? ',' + jsonEncode(codeOptions) : '') + ');');
                code.push('</script>');
            }

            return code.join("\n");
        }
    });


    /**
     * @property {Object} Instances - UWA.Embedded instances garbadge collector indexed by id.
     * @protected
     */
    Embedded.Instances = {};

    /**
     * @property {Object} Servers - UWA.Utils.InterCom.Server instances garbadge collector indexed by id.
     * @protected
     */
    Embedded.Servers = {};

    /*
        This property for Asynchronous UWA.Embedded usage contain objects with url and options properties.
    */
    (function () {
        var i, l, UWA_ASYNC;
        if (window.UWA_ASYNC) {

            UWA_ASYNC = window.UWA_ASYNC;
            UWA.Widgets = UWA.Widgets || [];

            for (i = 0, l = UWA_ASYNC.length; i < l; i++) {
                UWA.Widgets[i] = new Embedded(UWA_ASYNC[i].url, UWA_ASYNC[i].options || {});
            }
        }
    }());

    return UWA.namespace('Embedded', Embedded, UWA);
});


/*
Copyright 2006-2015 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define, Promise*/


/**
 * A Promise wrapper with a similar API.
 *
 *
 * @module   UWA/Promise
 *
 *
 * @example
 * // 1. Simple usage example
 * var promise = new UWA.Promise(function(resolve, reject) {
 *     // do a thing, possibly async, then...
 *
 *     if (isValid()) { // everything turned out fine
 *         resolve("Stuff worked!");
 *     } else {
 *         reject(Error("It broke"));
 *     }
 * });
 *
 * promise.then(function(result) {
 *     console.log(result); // "Stuff worked!"
 * }, function(err) {
 *     console.log(err); // Error: "It broke"
 * });
 *
 * // 2. Concrete usage example using UWA.Data.request
 * function getUrl(url) {
 *
 *     // Return a new promise.
 *     return new UWA.Promise(function(resolve, reject) {
 *
 *         UWA.Data.request(url, {
 *             onComplete: resolve,
 *             onFailure: reject,
 *             onTimeout: reject
 *         });
 *     });
 * }
 *
 * getUrl('http://example.com').then(
 *     function success() {
 *         console.log('getUrl success', arguments);
 *     },
 *     function fail() {
 *         console.log('getUrl fail', arguments);
 *     }
 * );
 */
define('UWA/Promise', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Class',
    'UWA/Internal/Deprecate'
], function (Core, Utils, Class, Deprecate) {
    'use strict';
    // Don't use Promise directly as one can replace global.Promise by UWAPromise (that's
    // not a good idea but well.)
    var NativePromise = Promise;

    function UWAPromise(resolver) {
        this._promise = resolver instanceof NativePromise ? resolver : new NativePromise(resolver);
    }

    function wrapMethod(method) {
        return function () {
            return UWAPromise.cast(this._promise[method].apply(this._promise, arguments));
        };
    }

    function wrapStatic(method) {
        return function () {
            return UWAPromise.cast(NativePromise[method].apply(NativePromise, arguments));
        };
    }

    var prototype = UWAPromise.prototype = Object.create(NativePromise.prototype);

    prototype.constructor = UWAPromise;

    /**
     * Appends a rejection handler callback to the promise, and returns a
     * new promise resolving to the return value of the callback if it is
     * called, or to its original fulfillment value if the promise is instead fulfilled.
     *
     * @param {Function} onRejected -
     * @return {UWA.Promise} a new wrapped promise
     *
     * @function
     * @alias UWA.Promise.prototype.catch
     * @memberOf module:UWA/Promise
     */
    prototype['catch'] = wrapMethod('catch');


    /**
     * Appends fullfillment and rejection handlers to the promise, and
     * returns a new promise resolving to the return value of the called handler.
     *
     * @param {Function} onFullfilled Callback to execute when the promise is fullfilled
     * @param {Function} onRejected Callback to execute when the promise is rejected
     * @return {UWA.Promise} a new wrapped promise
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.then
     */
    prototype.then = wrapMethod('then');

    /**
     * Alias of {@link module:UWA/Promise.UWA.Promise#catch|catch}
     *
     * Use this if you support ES3 browsers
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.fail
     */
    prototype.fail = prototype['catch'];

    /**
     * The passed callback will always be called (without argument), wether the promise resolves or
     * not.
     *
     * @param {Function} onFullfilledOrRejected function to execute
     * @return {UWA.Promise} a new wrapped promise
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.finally
     */
    prototype['finally'] = function (onFullfilledOrRejected) {
        var originalPromise = this;
        function end() {
            return UWAPromise.cast(onFullfilledOrRejected())
                .then(function () { return originalPromise; });
        }
        return this.then(end, end);
    };

    /**
     * Alias of {@link module:UWA/Promise#finally|finally}
     *
     * Use this if you support ES3 browsers
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.fin
     */
    prototype.fin = prototype['finally'];

    /**
     * Like {@link module:UWA/Promise.UWA.Promise#then|then}, but will raise any unhandled error/rejection
     *
     * This method is not in the ES6 Promise standard.
     *
     * @param {Function} onFullfilled function to execute when the promise is resolved
     * @param {Function} onRejected function to execute when the promise is rejected
     *
     * @return {UWA.Promise} a new wrapped promise
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.done
     */
    prototype.done = function (onFullfilled, onRejected) {
        return this.then(onFullfilled, onRejected).fail(function (e) {
            var result = UWAPromise.deferred();
            Utils.setImmediate(function () {
                Utils.setImmediate(function () {
                    result.reject(e);
                });
                throw e instanceof Error ? e : new Error(e);
            });
            return result.promise;
        });
    };

    /**
     * Like {@link module:UWA/Promise.UWA.Promise#then|then}, but if the result is
     * an array, it will be spread as arguments to the success callback
     *
     * @param {Function} onFullfilled
     * @param {Function} onRejected
     * @return {UWA.Promise} to continue the promise chain
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.prototype.spread
     */
    prototype.spread = function (onFullfilled, onRejected) {
        return this.then(function (result) {
            return onFullfilled[Array.isArray(result) ? 'apply' : 'call'](null, result);
        }, onRejected);
    };

    /**
     * Returns a promise that resolves when the first promise in the iterable resolves.
     *
     * @param {Object} iterable -
     * @return {UWA.Promise} a new wrapped promise
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.race
     *
     * @example
     * var p1 = new UWA.Promise(function(resolve, reject) {
     *     setTimeout(resolve, 500, "one");
     * });
     *
     * var p2 = new UWA.Promise(function(resolve, reject) {
     *     setTimeout(resolve, 100, "two");
     * });
     *
     * UWA.Promise.race([p1, p2]).then(function(value) {
     *   // value == "two"
     * });
    */
    UWAPromise.race = wrapStatic('race');

    /**
     *
     * Returns a promise that resolves when all of the promises in iterable
     * have resolved. The result is passed an array of values from all the
     * promises. If something passed in the iterable array is not a promise,
     * it's converted to one by Promise.cast. If any of the passed in promises
     * rejects, the all Promise should also reject (and receives the value of
     * the promise that rejected.
     *
     * @param {Object} iterable -
     * @return {UWA.Promise}
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.all
     *
     * @example
     * var p = new UWA.Promise(function(resolve, reject) {
     *     resolve(3);
     * });
     *
     * UWA.Promise.all([true, p]).then(function(values) {
     *   // values == [ true, 3 ]
     * });
     *
     */
    UWAPromise.all = function (array) {
        if (typeof array.length !== 'number') {
            return UWAPromise.reject(new TypeError('Not an iterable'));
        }

        return UWAPromise.cast(NativePromise.all(Utils.toArray(array)));
    };

    /**
     * Returns a Promise object that is rejected with the given reason.
     *
     * @param {Object} reason -
     * @return {UWA.Promise}
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.reject
     */
    UWAPromise.reject = wrapStatic('reject');

    /**
     * Returns a Promise object that is resolved with the given value.
     * If the value is a thenable (i.e. has a then method), the returned
     * promise will "follow" that thenable, adopting its eventual state;
     * otherwise the returned promise will be fulfilled with the value.
     *
     * @param {Object} value -
     * @return {UWA.Promise}
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.resolve
     */
    UWAPromise.resolve = wrapStatic('resolve');

    /**
     * Casts a value to a UWA.Promise. If it's already an UWA.Promise, it will return the
     * argument as it is. If it's a native, unwrapped promise, it will wrap it in an
     * UWA.Promise. If it is another value, it will return a resolved UWA.Promise with
     * this value.
     *
     * @param {Void} value -
     * @return {UWA.Promise}
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.cast
     *
     * @example
     * UWA.Promise.cast(3).then(function(result) {
     *     // result == 3;
     * });
     *
     * UWA.Promise.cast(someForeignPromise).finally(function () {
     *     // ...
     * });
     */
    UWAPromise.cast = function (value) {
        if (value instanceof UWAPromise) {
            return value;
        }

        if (value instanceof NativePromise) {
            return new UWAPromise(value);
        }

        return UWAPromise.resolve(value);
    };

    /**
     * Return an object with a property "promise" initialized with a UWA.Promise, and two
     * properties "resolve" and "reject" initialized with two functions that repectively
     * resolve and reject the promise.
     *
     * @return {Object}
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.deferred
     *
     * @example
     * // deferred allow you to handle the resolve and reject outsise of the
     * // resolver function to create more complexe Promise behavior.
     * function getUrl(url) {
     *
     *     // Return a new promise.
     *     var dfd = UWA.Promise.deferred(),
     *         data = UWA.Data.request(url, {
     *             onComplete: dfd.resolve,
     *             onFailure: dfd.reject,
     *             onTimeout: dfd.reject
     *         });
     *
     *     return dfd.promise;
     * }
     *
     * getUrl('http://example.com').then(
     *     function success() {
     *         console.log('getUrl success', arguments);
     *     },
     *     function fail() {
     *         console.log('getUrl fail', arguments);
     *     }
     * );
     */
    UWAPromise.deferred = function () {
        var result = {};
        var promise = new UWAPromise(function (resolve, reject) {
            result.resolve = resolve;
            result.reject = reject;
            return result;
        });
        result.promise = promise;
        return result;
    };

    /**
     * Returns a promise always resolved when all given promises are settled (resolved or rejected).
     * The result is an array of objects either { state: "fulfilled", value: v } or { state:
     * "rejected", reason: r }
     *
     * This method is not in the ES6 Promise standard.
     *
     * @param {Array} promises a list of promises (like Promise.all, values will be cast to
     * Promise)
     *
     * @return {UWA.Promise} a new always resolved wrapped promise with a list containing
     * the state of all given promises
     *
     * @function
     * @memberOf module:UWA/Promise
     * @alias UWA.Promise.allSettled
     */
    UWAPromise.allSettled = function (promises) {
        return UWAPromise.all(Utils.toArray(promises).map(function (promise) {
            if (!(promise instanceof NativePromise)) {
                return { state: 'fullfilled', value: promise };
            }
            return promise.then(function (value) {
                return { state: 'fullfilled', value: value };
            }, function (reason) {
                return { state: 'rejected', reason: reason };
            });
        }));
    };

    Deprecate.property(Class, 'Promise', {
        value: UWAPromise,
        name: 'UWA.Class.Promise',
        message: 'Use UWA.Promise instead.'
    });

    return Core.namespace('Promise', UWAPromise, Core);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global document, define, setTimeout, clearTimeout*/

/**
 * Load external resources globally. Please use this with caution and as a last resort.
 * Use conventions from project you are working on to load resources (ex: don't load AMD
 * modules with this).
 *
 * @module   UWA/Utils/Asset
 */
define('UWA/Utils/Asset', [
    'UWA/Promise',
    'vendors/webcomponents/WeakMap'
], function (Promise) {
    'use strict';

    var memoizedPromises = new WeakMap();

    function getDocument(options) {
        return options.container.ownerDocument;
    }

    var normalizeSourceLink;
    function normalizeSource(source) {
        if (!normalizeSourceLink) normalizeSourceLink = document.createElement('a');
        normalizeSourceLink.href = source;
        return normalizeSourceLink.href;
    }

    function memoizeOnce(source, options, fn) {
        if (options.force) return fn();

        var document = getDocument(options);
        var memoized = memoizedPromises.get(document);
        if (!memoized) {
            memoized = {};
            memoizedPromises.set(document, memoized);
        }

        if (!memoized.hasOwnProperty(source)) {
            memoized[source] = fn();
        }

        return memoized[source];
    }

    function makeLoader(name, loader) {
        return function (source, options) {
            source = normalizeSource(source);
            options = Object.assign({
                force: false,
                timeout: 60000,
                container: document.head
            }, options);

            return memoizeOnce(source, options, function () {
                var timeoutCallback;
                var timeoutId;

                var promise = new Promise(function (resolve, reject) {
                    timeoutCallback = loader(source, options, resolve, reject);

                    timeoutId = setTimeout(function () {
                        timeoutCallback();
                        reject(new Error("Asset." + name + ": Timeout while loading " + source));
                    }, options.timeout);
                });

                promise.fin(function () {
                    clearTimeout(timeoutId);
                });

                return promise;
            });
        };
    }

    /**
     * Load and execute an external JavaScript file.
     *
     * @param {String} source the source URL of the JS file.
     * @param {Object} options option hash
     * @param {Boolean} [options.force=false] by default, the file will be loaded only
     * once. Passing `force: true` will force the file to be loaded again.
     * @param {Number} [options.timeout=60000] a timeout in milliseconds
     * @param {DOMElement} [options.container=document.head] where to put the created DOM
     * element
     *
     * @returns {Promise<DOMElement, Error>} a promise resolved with the script DOMElement
     * or rejected with an Error.
     *
     * @example
     * Asset.js("http://example.org/somejs.js")
     *     .then(
     *         function () {
     *             // Loaded
     *         },
     *         function () {
     *             // Failure
     *         }
     *     );
     *
     * @function js
     * @memberOf module:UWA/Utils/Asset
     */
    var js = makeLoader('js', function (source, options, resolve, reject) {
        var script = getDocument(options).createElement('script');
        script.setAttribute('type', 'text/javascript');

        if (script.addEventListener) {
            script.addEventListener('load', function () {
                resolve(script);
            });

            script.addEventListener('error', function () {
                reject(new Error("Asset.js: Error while loading " + source));
            });
        } else {
            // On IE < 10, there is no way to know if a JS is correctly loaded or not.
            script.attachEvent('onreadystatechange', function () {
                if (script.readyState === "loaded" || script.readyState === "complete") {
                    resolve(script);
                }
            });
        }

        options.container.appendChild(script);

        script.src = source;

        return function () {
            options.container.removeChild(script);
        };
    });

    /**
     * Load and executed an external CSS file.
     *
     * @param {String} source the source URL of the CSS file.
     * @param {Object} options option hash
     * @param {Boolean} [options.force=false] by default, the file will be loaded only
     * once. Passing `force: true` will force the file to be loaded again.
     * @param {Number} [options.timeout=60000] a timeout in milliseconds
     * @param {DOMElement} [options.container=document.head] where to put the created DOM
     * element
     *
     * @returns {Promise<StyleSheet, Error>} a promise resolved with the DOM StyleSheet
     * created or rejected with an Error.
     *
     * @example
     * Asset.css("http://example.org/somecss.css")
     *     .then(
     *         function () {
     *             // Loaded
     *         },
     *         function () {
     *             // Failure
     *         }
     *     );
     *
     * @function css
     * @memberOf module:UWA/Utils/Asset
     */
    var css = makeLoader('css', function (source, options, resolve, reject) {
        var link = getDocument(options).createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('type', 'text/css');

        if (link.addEventListener) {
            link.addEventListener('load', function () {
                resolve(link.sheet);
            });

            link.addEventListener('error', function () {
                reject(new Error("Asset.css: Error while loading " + source));
            });
        } else {
            // On IE < 10, there is no way to know if a CSS is correctly loaded or not.
            link.attachEvent('onload', function () {
                resolve(link.styleSheet);
            });
        }

        options.container.appendChild(link);

        link.setAttribute('href', source);

        return function () {
            options.container.removeChild(link);
        };
    });

    return {
        js: js,
        css: css
    };
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document
*/

/*jshint
    unused: false, maxparams: false
*/

/**
 * @module   UWA/Environment
 *
 */
define('UWA/Environment', [
    'UWA/Core',
    'UWA/String',
    'UWA/Array',
    'UWA/Class',
    'UWA/Class/Timed',
    'UWA/Class/Events',
    'UWA/Class/Debug',
    'UWA/Class/Options',
    'UWA/Utils',
    'UWA/Element',
    'UWA/Event',
    'UWA/Json',
    'UWA/Data',
    'UWA/Internal/StringMap',
    'UWA/Widget',
    'UWA/Controls/Form',
    'UWA/Controls/WidgetPopupMenu',
    'UWA/Embedded',
    'UWA/Promise',
    'UWA/Utils/Client',
    'UWA/Utils/Asset'
], function (
    UWA,
    UWAString,
    UWAArray,
    Class,
    Timed,
    Events,
    Debug,
    Options,
    Utils,
    Element,
    Event,
    Json,
    Data,
    StringMap,
    Widget,
    Form,
    WidgetPopupMenu,
    Embedded,
    Promise,
    Client,
    Asset
) {
    'use strict';

    function getSubscribeLink(widget) {

        var subscribeLink = UWA.hosts.netvibes + '/subscribe.php',
            params = {
                module: 'UWA',
                moduleUrl: widget.getUrl()
            };

        widget.getPreferences().forEach(function (preference) {
            params[preference.name] = preference.value;
        });

        return subscribeLink + '?' + Utils.toQueryString(params);
    }

    // Memoize widget source retrieval. See fetchJsonWidget.
    var widgetSources = Object.create(null);

    var Environment = Class.extend(Timed, Events, Debug, Options, /** @lends module:UWA/Environment.UWA.Environment# */ {

        /**
         * Current platform name where environment running (e.g "netvibes").
         *
         * @type {String}
         */
        name: null,

        /**
         * Flag to know if the environment is inited.
         * Environment is likely ready once it is instanciated and the DOM is ready to be manipulated.
         *
         * @type {Boolean}
         * @private
         */
        inited: false,

        /**
         * Flag to know if a widget is registered.
         * A widget is not registered until the environment is *loaded*
         *
         * @type {Boolean}
         */
        registered: false,

        /**
         * Flag to know if a widget is launched.
         * A widget is not launched until the environment is *registered*
         *
         * @type {Boolean}
         */
        launched: false,

        /**
         * Current widget registered in this environment.
         *
         * @type {UWA.Widget}
         */
        widget: null,

        /**
         * HTML Dom elements related to this environment
         *
         * @property {String} title - Title HTML element
         * @property {String} edit - Edit HTML element
         * @property {String} body - Body HTML element
         * @property {String} icon - Icon HTML element
         * @type {Object}
         */
        html: null,

        /**
         * Stores environment's available features. See {@link module:UWA/Environment.UWA.Environment#hasFeature}.
         *
         * @type {Object}
         */
        features: {},

        /**
         * Available views classes
         *
         * @type {Object}
         * @private
         */
        views: {},

        /**
         * Default environment options
         * @private
         */
        defaultOptions: {
            formOptions: {
                nativeInputs: false
            },
            defaultView: {
                type: 'windowed'
            },
            initialView: null
        },

        /**
         * The Environment object provide base methods to run an UWA Widget execution Environment and load Widgets.
         *
         * > It's an abstract object, and must be extended to be useful.
         * > The object must fill <html> property with DOM elements (at least body), in the <onInit> or <onRegisterWidget> methods for example.
         *
         * Run Stack:
         *
         * ```
         * var environment = new UWA.Environment();
         * // Periodical[init]: init 100ms (document.body && !that.inited)
         * this.dispatchEvent('onInit');
         * this.inited = true;
         *
         * var widget = environment.getWidget();
         * -> this.registerWidget();
         * // Periodical[register]: register 100ms (that.inited && !that.registered)
         * this.dispatchEvent('onRegisterWidget');
         * this.registered = true;
         *
         * environment.launchWidget();
         * // Periodical: launch 100ms (that.isDataReady() && that.registered)
         * this.widget.launch();
         * this.widget.dispatchEvent('beforeLoad');
         * this.widget.dispatchEvent('onLoad');
         * this.widget.dispatchEvent('afterLoad');
         * ```
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @!param {Object} [options.defaultView={type: 'windowed'}] - Object representing the
         * default view to apply when no view is selected. See <onViewRequest>
         * @!param {Object} [options.initialView=null] - Object representing the initial view to
         * apply when the widget is starting. If no initialview is given, defaults to defaultView.
         *
         * @constructs UWA.Environment
         * @mixes UWA.Class.Timed
         * @mixes UWA.Class.Events
         * @mixes UWA.Class.Debug
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Environment
         */
        init: function (options) {

            var that = this;

            that.setOptions(options);

            // Init property
            that.html = {};
            that.view = {};

            // Run Init dispatch
            that.dispatchInit();

            // TODO normalize the options argument
            //
            // Example:
            // - options.html
            // - options.data
            // - options.id
        },

        /**
         * Dispatch "onInit" event to setup the environment html elements and events,
         * when container readyState is interactive.
         *
         * @see {@link http://dev.w3.org/html5/spec/the-end.html#the-end}
         */
        dispatchInit: function () {

            var that = this;

            that.setPeriodical('init', function () {

                // Dispatch OnInit event as soon as possible
                // NOTE: it's not onDomReady it's before, yeah weird but
                // mandatory for the momment

                // TODO: caja: remove document.body usage
                // TODO: replace with onDomReady will require lot of change
                if (document.body && !that.inited) {

                    that.clearPeriodical('init');

                    that.dispatchEvent('onInit');

                    that.inited = true;
                }

            }, 100, true);
        },

        /**
         * Check if the environment supports a feature. Please see environments documentation for a
         * list of supported features.
         *
         * @param {String} name the name of the feature
         * @param {Object} [options] hash of key/value to check if the feature supports those
         * options
         * @return {Boolean} true if the environment support it
         */
        hasFeature: function (name, options) {
            var option,
                feature = UWA.owns(this.features, name) && this.features[name];

            if (!feature) {
                return false;
            }

            if (options) {
                for (option in options) {
                    if (UWA.owns(options, option) && (!UWA.owns(feature, option) ||
                            options[option] !== feature[option])) {
                        return false;
                    }
                }
            }

            return true;
        },

        /* Group: Widget management */

        /**
         * Returns the widget currently registered in the Environment.
         * If no widget is registered, the Environment creates one and registers it.
         *
         * @return {UWA.Widget} The UWA.Widget instance (maybe newly created) registered widget.
         */
        getWidget: function () {

            var that = this,
                widget = that.widget || new Widget();

            if (!that.widget) {
                that.registerWidget(widget);
            }

            return widget;
        },

        /**
         * Registers a Widget into the execution Environment.
         * Once done, fire the `onRegisterWidget` callback.
         *
         * @param {Object} widget - The <UWA.Widget> instance to register
         */
        registerWidget: function (widget) {

            var that = this;

            // Store widget
            that.widget = widget;

            that.setPeriodical('register', function () {

                if (that.inited && !that.registered) {

                    var element,
                        html = that.html;

                    that.clearPeriodical('register');

                    // Set widget environment
                    widget.environment = that;

                    // Map environment html with widget elements
                    for (element in html) {
                        if (html.hasOwnProperty(element) &&
                                html[element] !== window) { // Avoid window element that may used by environment
                            widget.elements[element] = UWA.extendElement(html[element]);
                        }
                    }

                    // Set widget body alias
                    widget.body = html.body;

                    // Create the instances array if not yet exists
                    UWA.Widgets = UWA.Widgets || {};
                    UWA.Widgets.instances = UWA.Widgets.instances || [];
                    UWA.Widgets.instances.push(widget);

                    // Run "onRegisterWidget" callbacks
                    that.dispatchEvent('onRegisterWidget');

                    // Register menus
                    that.registerMenus();

                    // Set Widget has registered
                    that.registered = true;
                }

            }, 100, true);
        },

        /**
         * Launch the registered widget by fire the widget.launch method.
         * If needed, wait until the environment is fully loaded and a widget registered.
         *
         * > Internal or advanced use only.
         *
         * @param {Object} data - Widget's data values
         * @param {Boolean} [readOnly=false] - `true` if the widget is currently read only for the viewer
         */
        launchWidget: function (data, readOnly) {

            var widget,
                that = this;

            that.setPeriodical('launch', function () {

                if (that.isDataReady() && that.registered) {

                    that.clearPeriodical('launch');

                    widget = that.getWidget();

                    widget.launch(data, readOnly);
                }

            }, 100, true);
            //}, 0);
            //}, 100);
        },

        /**
         * Destroy the elements and its children of widgets.
         * Remove all events and remove the elements from the dom.
         * Clear all Delayeds and Periodicals timers.
         * Remove current environment widget Instance from <UWA.Widgets.instances>.
         */
        destroy: function () {

            var element, view,
                that = this,
                html = that.html,
                widget = that.widget;

            if (widget) {

                // Remove instance
                UWA.Widgets.instances.splice(UWA.Widgets.instances.indexOf(widget), 1);

                // Destroy Widget
                widget.destroy();

                // Reset widget
                that.widget = null;
            }

            // Remove Delayed
            that.clearDelayed();

            // Remove Periodical
            that.clearPeriodical();

            // Destroy Elements
            for (element in html) {
                if (html.hasOwnProperty(element)) {
                    Element.destroy.call(html[element]);
                }
            }

            for (view in that.view) {
                if (that.view.hasOwnProperty(view) && that.view[view]) {
                    that.view[view].destroy();
                }
            }

            // Remove Events
            that.removeEvent();

            // Reset Environment
            that.registered = false;
            that.launched = false;
        },

        /* Group: Widget Default Events Listeners */

        onInit: function () {

        },

        onRegisterWidget: function () {

            var that = this,
                html = that.html,
                widget = that.widget;

            // Init preferences storage
            that.data = new StringMap();

            // Handle menus container click delegation
            if (html.menus) {
                Element.addEvent.call(html.menus, 'click', function (e) {
                    var target = Event.getElement(e),
                        menu = that.widget.getMenu(target.getAttribute('data-name'));

                    if (menu) {
                        that.dispatchEvent('onMenuExecute', [menu]);
                        if (menu.items) {
                            if (!that.popupMenu) {
                                that.popupMenu = new WidgetPopupMenu(that).inject(document.body);
                            }
                            that.popupMenu
                                .setTarget(target)
                                .setItems(menu.items)
                                .toggle();
                        }
                    }
                });
            }

            // Handle edit click
            if (html.editAction) {
                Element.show.call(html.editAction);
                Element.addEvent.call(html.editAction, 'click', function (event) {
                    Event.stop(event);
                    that.dispatchEvent('toggleEdit');
                });
            }

            // Handle refresh click
            if (html.refreshAction) {
                Element.show.call(html.refreshAction);
                Element.addEvent.call(html.refreshAction, 'click', function (event) {
                    Event.stop(event);
                    that.dispatchEvent('onRefresh');
                });
            }

            // Update share link
            if (html.shareAction) {

                // Set default link
                html.shareAction.href = getSubscribeLink(widget);

                // Creste dynamic link for live prefs subscribe
                Element.addEvent.call(html.shareAction, 'click', function (event) {
                    Event.stop(event);
                    that.dispatchEvent('onOpenURL', getSubscribeLink(widget));
                });
            }

            // Handle wrapper external links
            if (html.wrapper) {
                Element.handleExternalLinks.call(html.wrapper, function (href, event) {
                    that.dispatchEvent('onOpenURL', [href, event]);
                });
            }

            // Handle viewport OR wrapper resize
            if ((html.viewport || html.wrapper)) {
                Element.addEvent.call((html.viewport || html.wrapper), 'resize', function () {
                    that.dispatchEvent('onResize');
                });
            }

            // Add onKeyboardAction event on document
            Element.addEvent.call(document, 'keydown', function (event) {
                var keyCode = event.which || event.keyCode;
                that.dispatchEvent('onKeyboardAction', [keyCode, event]);
            });

            // Add className info on widget body
            if (html.body) {
                [
                    Client.Engine.name,
                    Client.Engine.name + Client.Engine.version,
                    Client.Platform.name,
                    Client.Features.touchEvents ? 'touch' : 'no-touch',
                    widget.readOnly && 'readonly',
                    that.name && 'environment-' + that.name
                ].forEach(function (klass) {
                    if (klass) {
                        Element.addClassName.call(html.body, klass);
                    }
                });
            }

            // Trigger first resize before widget is launched
            that.dispatchEvent('onResize');

            // Trigger onViewRequest to initialize the default view
            that.dispatchEvent('onViewRequest', [that.options.initialView]);
        },

        /* Group: Widget Menu handlers */

        /**
         * Register menus to be displayed in widget chrome.
         *
         * Note: widgets can add specific menu items using `setMenu`
         * methods in their own code.
         */
        registerMenus: function () {
            // To be implemented in derivated classes
        },

        /**
         * Called when a menu item has been added or removed
         * through `widget.setMenu` or `widget.removeMenu`.
         *
         * The entire menu is rebuilt.
         * This method can be overrided by derivated classes.
         *
         * @param {Array} menus - Menu descriptors
         */
        onUpdateMenu: function (menus) {
            if (!this.html.menus) {
                // If the environment do not provide a menu container,
                // do nothing
                return;
            }

            if (!menus) {
                menus = this.widget.menus;
            }

            // We want to rebuilt the entire menu
            this.html.menus.empty();

            menus.forEach(function (menu) {
                var visible, element;

                if (UWA.is(menu.visible, 'function')) {
                    visible = menu.visible();
                } else {
                    visible = (menu.visible !== false);
                }

                if (visible !== false) {
                    element = UWA.createElement('span', {
                        'class': 'uwa-widget-menu-button',
                        'data-name': menu.name
                    });
                    if (menu.help) {
                        element.set('title', menu.help);
                        element.set('uwa-tooltip', UWAString.escapeHTML(menu.help));
                    }
                    if (menu.icon) {
                        element.addClassName('uwa-icon ' + menu.icon);
                    }
                    if (menu.className) {
                        element.addClassName(menu.className);
                    }
                    element.inject(this.html.menus);

                    if (this.html.header) {
                        this.html.header.set('data-menus-items', this.html.menus.childNodes.length);
                    }
                }

            }, this);
        },

        /**
         * Event fired when a menuItem is executed
         *
         * @param {Object} menuItem the menu item descriptor
         */
        onMenuExecute: function (menuItem) {
            if (UWA.is(menuItem.onExecute, 'string')) {
                this.widget.dispatchEvent(menuItem.onExecute, [menuItem]);
            }
        },

        /* Group: Environment Data Storage Mapping */

        /**
         * Check if Environment Data Storage is ready.
         *
         * @return {Boolean} `true` if environment data storage is ready else `false`.
         */
        isDataReady: function () {
            return !UWA.Storage || UWA.Storage.allInstancesReady();
        },

        /**
         * Retuns all the widget data stored in the environment, used
         * internally to launch the widget. The Environments implementations
         * should override it if it does not use a Storage instance in the
         * data property.
         *
         * @return {Object} All the datas of the widget.
         */
        getAllData: function () {
            return this.data.getAll();
        },

        /**
         * Retrieve data key current value.
         *
         * @param {String} key - The key of value to get
         * @return {Void} Current key value.
         */
        getData: function (key) {
            this.log('getData:' + key);
            return this.data.get(key);
        },

        /**
         * Set current data key value.
         *
         * @param {String} key - The key of value to get
         * @param {String} value - The value of value to store
         * @return {Void} Current key value.
         */
        setData: function (key, value) {
            this.log('setData:' + key + ',' + value);
            return this.data.set(key, value);
        },

        /**
         * Delete data key from storage.
         *
         * @param {String} key - The key of value to get
         * @return {Void} Previous key value.
         */
        deleteData: function (key) {
            this.log('deleteData:' + key);
            return this.data.remove(key);
        },

        /* Group: Events Methods */

        /**
         * Executes the listeners method associated with the given event name.
         *
         * > Internal or advanced use only.
         *
         * @param {String} name - the event name (e.g. "onUpdateTitle");
         * @param {Array} args - Array of parameters that should be passed to each listener
         * @param {Object} bind - Context on which listener will be executed (object that should represent the `this` variable inside listener function)
         * @return Nothing, but calls the listeners associated with the given event name.
         */
        dispatchEvent: function (name, args, bind, dispatched) {

            this.log('environment.event:' + name);

            // copy bind value for widget
            var environment = this,
                widget = environment.widget;

            // Callback from Widget
            if (!dispatched && widget) {
                environment.addEventOnce(
                    name,
                    widget.dispatchEvent.bind(widget, name, args, bind, true)
                );
            }

            environment._parent(name, args, bind);
        },

        /* Group: Widget Loader Methods */

        /**
         * Asynchronously load an UWA widget from url source.
         *
         * > Internal or advanced use only.
         *
         * ##### Example
         *
         * ```html
         * <div class="app" tabindex="1">
         *  <script type="text/javascript">
         *      (function () {
         *          var environment = new UWA.Environment();
         *
         *          environment.loadWidget('http://uwa.netvibes.com/apps/samples.php', {
         *              onComplete: function (widget, environment) {
         *
         *                  // Set widget data
         *                  widget.setValues({
         *                       activeTab: 'tab8',
         *                       my_text: 'my data...'
         *                  })
         *
         *                  // Manipulate widget object
         *                  widget.setTitle('Updated Title');
         *                  widget.setIcon('http://example.org', '`true`');
         *
         *                  // Launch the widget
         *                  environment.launchWidget();
         *              }
         *          });
         *      }());
         *  </script>
         * </div>
         * ```
         *
         * @param {String} url - The URL of the UWA widget source
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Function} [options.onComplete] - Called with the resulting Widget instance as first argument.
         * @param {Function} [options.onFailure] - Called if an error occurs
         * @param {Function} [options.onTimeout] - Called if a timeout occurs while fetching widget informations
         * @param {Function} [options.embedded] - Used as a boolean to load the widget as embedded or inlined‡
         * @return {this}
         */
        loadWidget: function (widgetUrl, options) {

            var defaultOptions = {
                onFailure: function (error/*, request, options*/) {
                    throw error;
                },
                onTimeout: function (error/*, request, options*/) {
                    throw error;
                },
                onComplete: function (/*widget*/) {
                    // Nothing to do by default...
                }
            };

            options = UWA.extend(defaultOptions, options);

            // Set Current widget url
            widgetUrl = Utils.buildUrl(window.location.toString(), widgetUrl);

            if (options.embedded) {
                this.loadEmbeddedWidget(widgetUrl, options);

            } else {
                this.loadInlinedWidget(widgetUrl, options);
            }

            return this;
        },

        /**
         * Load a widget for inline use.
         *
         * ##### Example
         *
         * ```
         * var environment = new UWA.Environment();
         *
         * // Load JSON Widget object
         * environment.loadInlinedWidget('http://example.org/widget.html, {
         *    onComplete: function(widget, environment) {
         *
         *        // Set widget data
         *        widget.setValues({
         *            activeTab: 'tab8',
         *            my_text: 'my data...'
         *        })
         *
         *        // Manipulate widget object
         *        widget.setTitle('Updated Title');
         *        widget.setIcon('http://example.org', '`true`');
         *
         *
         *        // Launch the widget
         *        environment.launchWidget();
         *    }
         * });
         *
         * // Load a widget using existent XHTML
         * var myWidget =
         * '<?xml version="1.0" encoding="utf-8"?>' +
         * '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"' +
         * '    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' +
         * '<html xmlns="http://www.w3.org/1999/xhtml"' +
         * '    xmlns:widget="http://www.netvibes.com/ns/">' +
         * '    <head>' +
         * ' ' +
         * '         <!-- Application Metas -->' +
         * '         <title>Title of the Widget</title>' +
         * '         <meta name="author" content="John Doe" />' +
         * '         <meta name="description" content="A descriptive description" />' +
         * ' ' +
         * '         <!-- Application Standalone emulation files -->' +
         * '         <link rel="stylesheet" type="text/css"' +
         * '             href="http://uwa.netvibes.com/lib/c/UWA/assets/css/standalone.css" />' +
         * '         <script type="text/javascript"' +
         * '             src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Standalone_Alone.js">' +
         * ' ' +
         * '       </head>' +
         * '       <body>' +
         * '            <p>Hello world!</p>' +
         * '       </body>' +
         * '</html>';
         *
         * var environment = new UWA.Environment();
         *
         * // The first argument is only used as a key cache, it does not have
         * // to be an URL
         * environment.loadInlinedWidget('widget42', {
         *    fetcher: myWidget,
         *    onComplete: function (widget, Environment) {
         *        // same as above example
         *    }
         * });
         *
         * // Json Wigdet argument format
         * var myWidget = {
         *    "title": "Hello World",
         *    "icon": "http://example.org/favicon.png",
         *    "richIcon": "http://example.org/richIcon.png",
         *    "metas": {
         *        "version": "1.0.0",
         *        "apiVersion": "1.3",
         *        "autoRefresh": "10",
         *        "description": "Display Hello World for UWA",
         *        "author": "Netvibes",
         *        "strictMode": "`false`",
         *        "debugMode": "`false`",
         *        "screenshot": "http://example.org/screenshot.png",
         *        "thumbnail": "http://example.org/thumbnail.png"
         *    },
         *    "plugins": [],
         *    "preferences": [[
         *        {
         *            "type": "text",
         *            "name": "my_text",
         *            "label": "My text pref",
         *            "defaultValue": ""
         *        },
         *        {
         *            "type": "password",
         *            "name": "my_password",
         *            "label": "My password pref",
         *            "defaultValue": ""
         *        },
         *        {
         *            "type": "boolean",
         *            "name": "my_checkbox",
         *            "label": "My checkbox pref",
         *            "defaultValue": ""
         *        },
         *        {
         *            "type": "hidden",
         *            "name": "my_hidden",
         *            "defaultValue": ""
         *        },
         *        {
         *            "type": "range",
         *            "name": "my_range",
         *            "label": "My range pref",
         *            "defaultValue": "10",
         *            "step": "5",
         *            "min": "5",
         *            "max": "15"
         *        },
         *        {
         *            "type": "list",
         *            "name": "my_list",
         *            "label": "My list",
         *            "defaultValue": "Value1",
         *            "options": [
         *                {
         *                    "label": "Label1",
         *                    "value": "Value1"
         *                },
         *                {
         *                    "label": "Label2",
         *                    "value": "Value2"
         *                },
         *                {
         *                    "label": "Label3",
         *                    "value": "Value3"
         *                }
         *            ]
         *        }
         *    ],
         *    "body": "<p>Loading...</p>",
         *    "script": "var MyWidget = { onLoad: function() { widget.body.setContent('Hello World!'); }; \n widget.onLoad = MyWidget.onLoad;",
         *    "style": ".myClassName { color: red; }"
         * };
         *
         * var environment = new UWA.Environment();
         *
         * // The first argument is only used as a key cache, it does not have
         * // to be an URL
         * environment.loadInlinedWidget('widget42', {
         *    fetcher: myWidget,
         *    onComplete: function (widget, Environment) {
         *        // same as above example
         *    }
         * });
         * ```
         *
         * @param {String} sourceURL - The widget's source URL, used to fetch the
         *  widget informations and as a key cache.
         * @param {Object} options
         * @param {String|Function} [options.fetcher] - How to get the data (see examples):
         * - If this is 'JSON' or 'XML' (the default), it will use an internal fetcher
         * to get the widget informations.
         * - If this is a function, it will be called with the url and the options
         * to use (onComplete, onFailure, onTimeout...)
         * - You can also pass the widget informations directly, either via an object or an XML string.
         * @param {Function} [options.onComplete] ) - Callback used to return the widget instance
         * @param {Function} [options.onTimeout] - If the request timeout
         * @param {Function} [options.onFailure] - If the request fails or if there is an error in its result
         * @return {this}
         *
         */
        loadInlinedWidget: (function () {

            var handleFetchWidgetResponse,
                fetchedWidgets = {};

            function handleError(url, type, arg) {
                if (fetchedWidgets[url]) {
                    UWAArray.invoke(fetchedWidgets[url], type, arg);
                    delete fetchedWidgets[url];
                }
            }

            handleFetchWidgetResponse = function (sourceURL, result) {
                var error = result.expositionError || result.error || result.errors;

                if (error && !(UWA.is(error, 'array') && error.length === 0)) {
                    handleError(sourceURL, 'onFailure', error);
                    return;
                }

                result = this.convertSourceToJson(result);

                if (!result.className) {
                    if (!result.checksum) {
                        result.checksum = Utils.getCRC32(sourceURL);
                    }
                    result.className = 'w-' + result.checksum;
                }

                if (result.style) {
                    // Put CSS
                    Utils.setCss(result.className, result.style, '.' + result.className, sourceURL);
                    delete result.style;
                }

                if (typeof result.script === 'string') {
                    // Eval JavaScript
                    result.script = new Function('widget', result.script); //eslint-disable-line no-new-func
                }

                result.styles = this.filterExternalResources('style', result.styles || []);
                result.scripts = this.filterExternalResources('script', result.scripts || []);

                var assets = [];

                // Load external ressources
                while (result.styles.length) {
                    assets.push(Asset.css(Utils.buildUrl(sourceURL, result.styles.shift())));
                }

                while (result.scripts.length) {
                    assets.push(Asset.js(Utils.buildUrl(sourceURL, result.scripts.shift())));
                }

                Promise.all(assets).done(
                    function () {
                        var waiting = fetchedWidgets[sourceURL];
                        fetchedWidgets[sourceURL] = result;
                        if (UWA.is(waiting, 'array')) {
                            UWAArray.invoke(waiting, 'onComplete', result);
                        }
                    },
                    function (err) {
                        handleError(sourceURL, 'onFailure', err);
                    }
                );
            };

            return function (url, options) {

                var fetched = fetchedWidgets[url],
                    fetcher = options.fetcher || 'XML',
                    onComplete = options.onComplete,
                    that = this;

                options.onComplete = function (json) {

                    var widget = that.getWidget();
                    widget.uwaUrl = url;

                    widget.setTitle(json.title);
                    widget.setIcon(json.icon);
                    widget.setMetas(json.metas);
                    widget.setPreferences(json.preferences);
                    widget.setPlugins(json.plugins);
                    widget.setBody(json.body);

                    // Set className on wrapper
                    that.html.wrapper.addClassName(json.className);

                    if (json.script) {
                        json.script(widget);
                    }

                    onComplete(widget, that);
                };

                if (UWA.is(fetched, 'object')) {
                    options.onComplete(fetched);

                } else {

                    if (UWA.is(fetched, 'array')) {
                        fetched.push(options);
                    } else {
                        fetchedWidgets[url] = [options];
                    }

                    options = UWA.merge({
                        onComplete: handleFetchWidgetResponse.bind(this, url),
                        onTimeout: handleError.bind(this, url, 'onTimeout'),
                        onFailure: handleError.bind(this, url, 'onFailure')
                    }, options);


                    if (UWA.is(fetcher, 'function')) {
                        // Custom fetcher function
                        fetcher.call(this, url, options);

                    } else if (!UWA.is(fetcher, 'string') || fetcher.length > 4) {

                        // Already fetched data
                        options.onComplete(fetcher);

                    } else {

                        // Fetcher name (JSON or XML)
                        fetcher = fetcher.toUpperCase();

                        if (fetcher === 'JSON') {
                            this.fetchJsonWidget(url, options);
                        } else {
                            this.fetchXmlWidget(url, options);
                        }
                    }
                }
                return this;
            };
        }()),

        /**
         * Load widget from url and render it using <UWA.Embedded>.
         *
         * > Internal or advanced use only.
         *
         * @param {String} url - the URL of the UWA widget source
         * @param {Object} options - a JavaScript object containing setting/value pairs
         *  This object can take a handful of settings, the only required one being 'onComplete',
         *  because you need to always set a callback method that will receive the widget and environment parameter.
         *  That method *must have one parameter* to receive the widget object returned by the environment.
         * @return {this}
         */
        loadEmbeddedWidget: function (url, options) {

            var embedded, widget,
                environment = this,
                setStyle = Element.setStyle,
                embeddedOptions = {
                    cache: options.cache,
                    container: environment.html.body,
                    displayHeader: false,
                    displayFooter: false,
                    displayEdit: true,
                    autoLaunch: false
                };

            // If embedded options is a object using it has to
            // configure Embedded instance.
            if (UWA.is(options.embedded, 'object')) {
                UWA.extend(embeddedOptions, options.embedded);
            }

            // Create embedded instance.
            embedded = new Embedded(url, embeddedOptions);

            // Remove possible duplicate padding on widget body.
            setStyle.call(environment.html.body, 'padding', 0);
            setStyle.call(embedded.elements.body, 'padding', 0);

            // onRegisterWidget event from environment initilize event mapping
            // between environment instance and embedded instance.
            environment.addEvent('onRegisterWidget', function () {

                var events = {},
                    eventsListeners = {

                        // Pure forward from embedded to widget.
                        onUpdateValue: true,
                        onRefresh: true,
                        onUpdateTitle: true,
                        onUpdateIcon: true,
                        onUpdateCounter: true,
                        onSearch: true,
                        onResetSearch: true,
                        onShowEdit: true,
                        onKeyboardAction: true,
                        onViewError: true,
                        onViewChange: true,
                        onEdit: true,
                        endEdit: true,

                        // Advanced forward from embedded to widget.
                        onLoad: function () {

                            // Launch embedded instance
                            embedded.launch(
                                environment.getAllData(),
                                environment.getWidget().readOnly
                            );
                        }
                    };

                // Configure events from eventsListeners
                Object.keys(eventsListeners).forEach(function (eventName) {

                    var eventListener = eventsListeners[eventName];

                    // If eventListener is true just forward to widget.
                    if (eventListener === true) {
                        eventListener = embedded.sendRemote.bind(embedded, eventName);
                    }

                    events[eventName] = eventListener;
                });

                // Map events listeners.
                environment.addEvents(events);
            });

            // Init widget that will trigger onRegisterWidget on environment.
            widget = environment.getWidget();

            // onRegisterWidget event from embedded init events mapping between
            // embedded instance and widget instance.
            embedded.addEvent('onRegisterWidget', function () {

                var events = {},
                    eventsListeners = {

                        // Pure forward from embedded to widget.
                        onRefresh: true,
                        onUpdateTitle: true,
                        onUpdateIcon: true,
                        onUpdateCounter: true,
                        onSearch: true,
                        onResetSearch: true,
                        onHideEdit: true,
                        onShowEdit: true,
                        onOpenURL: true,
                        onViewRequest: true,

                        // Advanced forward from embedded to widget.
                        onInitConfig: function (config) {
                            if (config.preferences) {
                                widget.setPreferences(config.preferences);
                            }
                            if (config.plugins) {
                                widget.setPlugins(config.plugins);
                            }
                            if (config.metas) {
                                widget.setMetas(config.metas);
                            }
                        },
                        onUpdatePreferences: function (preferences) {
                            widget.setPreferences(preferences);
                        },
                        onUpdateValue: function (name, value) {
                            widget.setValue(name, value);
                        }
                    };

                // onEdit and endEdit, to display the preferences panel outside the frame
                if (!embeddedOptions.displayEdit) {
                    UWA.merge(eventsListeners, {
                        onEdit: true,
                        endEdit: true
                    });
                }

                // Configure events from eventsListeners
                Object.keys(eventsListeners).forEach(function (eventName) {

                    var eventListener = eventsListeners[eventName];

                    // If eventListener is true just forward to widget.
                    if (eventListener === true) {
                        eventListener = function () {
                            widget.dispatchEvent(eventName, arguments);
                        };
                    }

                    events[eventName] = eventListener;
                });

                // Map events listeners.
                embedded.addEvents(events);

                // Call onComplete callback
                options.onComplete(widget, environment);
            });

            // Save Embedded instance
            environment.embedded = embedded;

            return environment;
        },

        convertSourceToJson: (function () {

            var preferenceAttributes = ['name', 'defaultValue', 'type', 'label', 'step', 'min', 'max'],
                optionsAttributes = ['label', 'value'],
                jsMimeTypes = /(java|ecma)script$/i;

            function eachChildNodes(node, each, elementOnly) {

                var i, l, childNode,
                    childNodes = [].slice.call(node.childNodes);

                for (i = 0, l = childNodes.length; i < l; i++) {
                    childNode = childNodes[i];

                    if (!elementOnly || childNode.nodeType === 1) {
                        each(childNode, childNode.nodeValue);
                    }
                }
            }

            function eachAttributes(node, each) {

                var i, l, attribute,
                    attributes = node.attributes || [];

                for (i = 0, l = attributes.length; i < l; i++) {
                    attribute = attributes[i];
                    each(attribute.name, attribute.value);
                }
            }

            var handlers = {
                'widget:preferences': function (json, node) {
                    eachChildNodes(node, function (childNode) {

                        var options,
                        preference = {};

                        eachAttributes(childNode, function (name, value) {
                            if (preferenceAttributes.indexOf(name) !== -1) {
                                preference[name] = value;
                            }
                        });

                        // Only process valid preferences
                        if (preference.name) {

                            // Handle list type preferences
                            if (preference.type === 'list' || preference.type === 'checklist') {

                                options = [];

                                eachChildNodes(childNode, function (option) {

                                    var optionValue = {};

                                    eachAttributes(option, function (name, value) {
                                        if (optionsAttributes.indexOf(name) !== -1) {
                                            optionValue[name] = value;
                                        }
                                    });

                                    if (optionValue.label) {
                                        options.push(optionValue);
                                    }
                                }, true);

                                preference.options = options;
                            }

                            json.preferences.push(preference);
                        }
                    }, true);
                },

                'widget:plugins': function (json, node) {
                    eachChildNodes(node, function (childNode) {

                        var plugin = {
                            name: node.getAttribute('name'),
                            options: {}
                        };

                        // Attributes are properties
                        eachAttributes(childNode, function (name, value) {
                            plugin[name] = value;
                        });

                        // Options are properties
                        eachChildNodes(childNode, function (option) {

                            var optionName = option.getAttribute('name'),
                            optionValue = option.getAttribute('value'),
                            optionType = option.tagName;

                            if (optionType === 'widget:options') {

                                plugin.options[optionName] = {};

                                // sub Options are properties of parent option
                                eachChildNodes(option, function (opt) {

                                    var name = opt.getAttribute('name'),
                                    value = opt.getAttribute('value');

                                    if (name) {
                                        plugin.options[optionName][name] = value;
                                    }

                                }, true);

                            } else if (optionName) {
                                plugin.options[optionName] = optionValue;
                            }

                        }, true);

                        if (plugin.name) {
                            json.plugins.push(plugin);
                        }

                    });
                },

                link: function (json, node, attributes) {
                    if (attributes.href) {

                        var tmp = attributes.rel;

                        // Handle icon
                        if (tmp === 'icon') {
                            json.icon = attributes.href;

                            // Handle external stylesheets
                        } else if (tmp === 'stylesheet' &&
                                   // Ignore standalone stylesheets
                                   !attributes.href.contains('UWA/assets') &&
                                       !attributes.href.contains('standalone.css') &&
                                           !attributes.href.contains('uwa/style.css')) {
                            json.styles.push(attributes.href);
                        }
                    }

                },

                meta: function (json, node, attributes) {
                    // Booleanise value
                    var tmp = attributes.content;
                    tmp = (tmp === 'false' ? false : (tmp === 'true') ? true : tmp);

                    json.metas[attributes.name] = tmp;
                },

                script: function (json, node, attributes) {

                    // Handle internal script if they are JS only
                    if (!attributes.src && (

                        // html5 recommendation : default script type is JS
                        (!attributes.language && !attributes.type) ||

                            // or if a type is defined it must match JS
                            jsMimeTypes.test(attributes.type) ||

                                // or if a language is set as there is no standard identifier
                                attributes.language)) {

                        // Reset script buffer
                        var tmp = '';

                        // Handle script content using childNodes
                        eachChildNodes(node, function (childNode, nodeValue) {
                            tmp += nodeValue;
                        });

                        // Avoid Script that overide UWA
                        if (!/UWA(\s+)?=/.test(tmp)) {

                            // Concatenate buffer with others scripts
                            json.script += tmp;
                        }

                        // Handle external scripts but ignore environment script
                    } else if (
                        attributes.src &&
                            !attributes.src.contains('Standalone') &&
                                !attributes.src.contains('load.js.php')
                    ) {
                        json.scripts.push(attributes.src);
                    } else {
                        return node;
                    }
                },

                title: function (json, node) {
                    eachChildNodes(node, function (childNode, nodeValue) {
                        json.title += nodeValue;
                    });
                },

                style: function (json, node) {
                    eachChildNodes(node, function (childNode, nodeValue) {
                        json.style += nodeValue;
                    });
                },

                fallback: function (json, node, attributes, nodeName) {
                    var element;
                    // If nodeName is body assign it to widget.body but
                    // change tagname to div.
                    if (nodeName === 'body') {
                        element = document.createElement('div');
                        element.className = node.className;
                        json.body = element;

                    // Create the element
                    } else {
                        element = document.createElement(nodeName);
                    }

                    // Convert attributes to element attribute
                    eachAttributes(node, function (name, value) {
                        element.setAttribute(name, value);
                    });

                    // Generate elements tree
                    eachChildNodes(node, function (childNode, nodeValue) {

                        switch (childNode.nodeType) {

                        // Element nodes
                        case 1:
                            var child = xhtmlWidgetToJson(childNode, json); //eslint-disable-line no-use-before-define

                            // Inject element if exist
                            if (child) {
                                element.appendChild(child);
                            }

                            break;

                        // Text nodes
                        case 4: // TextNode
                        case 3: // CDATA
                            element.appendChild(document.createTextNode(nodeValue));
                            break;

                        // Ignored nodes
                        case 8:
                            break;
                        }
                    });
                    return element;
                }

            };

            function xhtmlWidgetToJson(node, jsonWidget) {

                // Get first document node childNode
                if (node.nodeType === 9) {
                    node = node.childNodes[0];
                }

                var nodeName = node.nodeName.toLowerCase(),
                    nodeAttributes = {};

                // Convert attributes into object
                eachAttributes(node, function (name, value) {
                    nodeAttributes[name] = value;
                });

                return handlers[handlers.hasOwnProperty(nodeName) ? nodeName : 'fallback'](jsonWidget, node, nodeAttributes, nodeName);
            }

            /**
             * Convert a widget from text or XML document to a plain JavaScript object.
             *
             * > Internal or advanced use only.
             *
             * @param {String|Object} source
             * - If it is a String, parse it with as an XML document, then
             *   converts this document to an Object
             * - If it is an XML document, converts it to an Object
             * - If it is an object, returns it
             * @return A JavaScript object containing all the information of the widget.
             */
            return function (source) {

                if (UWA.is(source, 'string')) {

                    try {
                        source = Utils.loadXml(source);
                    } catch (invalidXML) {

                        UWA.log('Invalid UWA XHTML source detected, fallback on HTML parsor.');

                        source = Utils.loadHtml(source);
                    }
                }

                var result;

                if (!UWA.is(source, 'object')) {

                    result = {
                        title: '',
                        icon: '',
                        preferences: [],
                        plugins: [],
                        metas: {},
                        body: [],
                        script: '',
                        scripts: [],
                        style: '',
                        styles: []
                    };

                    xhtmlWidgetToJson(source, result);

                } else {
                    result = source;
                }

                return result;
            };
        }()),

        /**
         * @param {String} sourceURL - The widget URL
         * @param {Object} options
         * @param {Object} [options.server=UWA.hosts.exposition] - The exposition server to use
         * @param {Function} [options.onComplete] - The callback used to return the widget informations
         */
        fetchJsonWidget: function (sourceURL, options) {

            if (!(sourceURL in widgetSources)) {
                widgetSources[sourceURL] = new Promise(function (resolve, reject) {
                    // options.onTimeout and options.onFailure are not handled here.
                    var url,
                        parameters = {
                            mode: 'full',
                            uwaUrl: sourceURL
                        };

                    if (UWA.debug) {
                        parameters.flush = 1;
                        parameters.mode = 'full_debug';
                    }

                    url = (options.server || UWA.hosts.exposition) + '/widget/json';

                    Json.request(url, {
                        data: parameters,
                        onComplete: resolve,
                        onFailure: reject,
                        useJsonpRequest: true
                    });
                });
            }

            widgetSources[sourceURL].then(options.onComplete, options.onError);
        },

        /**
         * Asynchronously fetch <widget> from an XHTML widget raw source.
         *
         * > Internal or advanced use only.
         *
         * @param {String} sourceURL - the widget URL
         * @param {Object} options
         * @param {Function} [options.onComplete] - The callback used to return the widget informations
         * @param {Function} [options.onFailure] - The callback used when the request fails (see Data.request)
         * @param {Function} [options.onTimeout] - The callback used when the request timeouts (see Data.request)
         * @param {Function} [options.cache] - The cache time to pass to the widget server (see Data.request)
         */
        fetchXmlWidget: function (sourceURL, options) {

            // Load Widget from ajax
            Data.request(sourceURL, {
                cache: options.cache,
                type: 'text',
                onFailure: options.onFailure,
                onTimeout: options.onTimeout,
                onComplete: options.onComplete
            });
        },

        /**
         * Allow the environment to prevent loading some resources, or change resources URL.
         * Override this method in an Environment implementation.
         *
         * @param {String} type - The resource type
         * @param {Array} Array of String resourges: the resources URL included in the widget
         * @return {Array} the resources to include.
         */
        filterExternalResources: function (type, resources) {
            return resources;
        },

        /* Group: Events */

        /**
         * Triggered when the widget is launched.
         * This event MUST be declared in any widget, in order for any of the widget's JavaScript code to be executed.
         * Implementations MUST trigger this event once the application is done loading.
         *
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onLoad
         * @inner
         */

        /**
         * Triggered when the widget is refreshed (manually or programmatically).
         * Implementations SHOULD trigger this event when preferences values are updated.
         * If this event is not declared, the <UWA.Widget.onLoad> event will be triggered instead.
         */
        onRefresh: function () {

            var widget = this.getWidget();

            // flush Widget data
            widget.data = {};

            // If there is no onRefresh events registered on the widget,
            // trigger onLoad instead, but we do not let it be re-dispatched.
            if (!widget.hasEvent('onRefresh')) {
                widget.dispatchEvent('onLoad', undefined, undefined, true);
            }
        },

        /**
         * Triggered when the widget is resized (manually or programmatically).
         * Implementations SHOULD trigger this event when the size of the application container is resized
         * (for instance, when the user resizes the containing column, or changes the number of columns on the page).
         *
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onResize
         * @inner
         */

        /**
         * Triggered when a key is pressed within the widget's area.
         * Implementations may first require the user to click within the widget's area in order to limit the interaction to that widget only.
         * Implementations SHOULD pass the key-code as first argument of the event.
         *
         * @param {String} key - The pressed key's code
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onKeyboardAction
         * @inner
         */

        /**
         * Triggered when a search is performed from within the platform.
         *
         * Implementing platforms that feature a search form MAY trigger this event, with the search query as first argument,
         * so that the widget may use it to further perform a search with its own data, if such a thing is possible.
         *
         * @param {String} query - The search query
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onSearch
         * @inner
         */

        /**
         * Triggered when a search is reseted from within the platform.
         *
         * Implementing platforms that feature a search form MAY trigger this event,
         * so that the widget may use it to further reset the last search, if such a thing is possible.
         *
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onResetSearch
         * @inner
         */

        /**
         * Triggered when the widget's icon is modified.
         * Implementations MUST trigger it when widget.setIcon() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} url - The url of the icon. The URL should include the protocol (http://)
         */
        onUpdateIcon: function (icon) {

            var that = this,
                html = that.html;

            function destroyIconLoader() {
                html.iconLoader.destroy();
                delete html.iconLoader;
            }

            // Update element if exist
            if (html.icon) {

                // Cancel previous icon loader
                if (html.iconLoader) {
                    destroyIconLoader();
                }

                // Create a new loader
                html.iconLoader = UWA.createElement('img', {
                    styles: {
                        display: 'none'
                    },
                    events: {
                        load: function () {
                            html.icon.getElement('img').setAttribute('src', icon);
                            destroyIconLoader();
                        },
                        error: function () {
                            destroyIconLoader();
                        }
                    }
                }).inject(that.html.wrapper);

                // Load new icon
                html.iconLoader.setAttribute('src', icon);
            }
        },

        /**
         * Triggered when the widget's title is modified.
         * Implementations MUST trigger it when widget.setTitle() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {String} title - The title of the widget. Can contain HTML code
         */
        onUpdateTitle: function (title) {

            var titleElement = this.html.title;

            // Update element if exist
            if (titleElement) {
                titleElement.setHTML(title);
            }
        },

        /**
         * Triggered when the widget's counter is modified.
         * Implementations MUST trigger it when widget.setCounter() is used.
         * Implementations MAY also trigger for internal reasons.
         *
         * @param {Number|Boolean|String} count - The number of results or status for the current search/unread items
         * @param {String} [type] - The number of results type (e.g 'search').
         */
        onUpdateCounter: function (count) {

            var counterElement = this.html.counter;

            // Update element if exist
            if (counterElement) {
                counterElement.setText(count ? '(' + (count === true ? '●' : count) + ')' : '');
            }
        },

        /**
         * Triggered when a widget's preference is added.
         * Implementations SHOULD trigger this event when a preferences is added (manually or programmatically).
         *
         * @param {Array} preferences - An Array of preferences in their JSON serialization
         * @memberof module:UWA/Environment.UWA.Environment#
         * @method onUpdatePreferences
         */

        /**
         * Triggered when edition of preferences begin.
         */
        onEdit: function () {
            var that = this,
                html = that.html,
                widget = that.getWidget(),
                widgetMetas = widget.metas,
                widgetPreferences = widget.getPreferences();

            // Clear edit content if exist
            if (html.edit) {

                // Clear edit
                html.edit.empty();

                // Add preferences form if required
                if (widget.hasPreferences()) {
                    // Is there the preferences form already displayed ?
                    if (html.preferences) {
                        // Backup filled values to inject them into the fields
                        var formValues = html.preferences.getFormValues();

                        widgetPreferences.forEach(function (field) {
                            if (UWA.is(formValues[field.name])) {
                                field.value = formValues[field.name];
                            }
                        });
                    }

                    // Add Submit button
                    widgetPreferences.push({
                        type: 'submit',
                        name: 'endEdit',
                        value: UWA.i18n('Done')
                    });

                    // Remove Preference Controls instance if exist
                    if (html.preferences) {
                        html.preferences.destroy();
                    }

                    html.preferences = new Form({
                        nativeInputs: this.options.formOptions.nativeInputs,
                        darkBackground: this.options.formOptions.darkBackground,
                        fields: widgetPreferences,
                        events: {
                            onChange: function (event, name, value) {

                                // Set new widget value
                                widget.setValue(name, value);

                                // Dispatch Event
                                if (that.embedded) {
                                    that.embedded.sendRemote('dispatchEvent', event, name, value);
                                } else {
                                    that.dispatchEvent(event, [name, value]);
                                }
                            },

                            onSubmit: function (event, values) {

                                var needRefresh = false;

                                // Subscribe to onUpdateValue only once
                                that.addEventOnce('onUpdateValue', function () {
                                    needRefresh = true;
                                });

                                // Set new widget values
                                Object.keys(values).forEach(function (name) {
                                    widget.setValue(name, values[name]);
                                });

                                // force to saveValues immediatly and dispatch
                                // event "endEdit" when it's done
                                that.dispatchEvent('endEdit');

                                // Then fire "onRefresh" if values changed
                                if (needRefresh) {
                                    that.dispatchEvent('onRefresh');
                                }
                            }
                        }
                    }).inject(html.edit);
                }

                // Add Widget Author info and/or link
                if (widgetMetas.author) {
                    html.edit.addContent({
                        tag: 'div',
                        'class': 'moduleInfos',
                        html: [{
                            tag: 'p',
                            html: [
                                UWA.i18n('Widget by') + ' ',
                                {
                                    tag: 'strong',
                                    html: widgetMetas.website ? {
                                        tag: 'a',
                                        href: widgetMetas.website,
                                        text: widgetMetas.author
                                    } : {
                                        tag: 'span',
                                        text: widgetMetas.author
                                    }
                                }
                            ]
                        }]
                    });
                }

            }

            // Fire "onShowEdit"
            that.dispatchEvent('onShowEdit');
        },

        /**
         * Triggered when preferences showing.
         */
        onShowEdit: function () {
            var html = this.html;

            // Hide Widget Body
            if (html.wrapper) {
                html.wrapper.addClassName('onEdit');
            }
        },

        /**
         * Triggered when edition of preferences ending.
         */
        endEdit: function () {
            var that = this;

            // Fire "onHideEdit" notification
            that.dispatchEvent('onHideEdit');
        },

        /**
         * Triggered when preferences hiding.
         */
        onHideEdit: function () {
            var html = this.html;

            // Hide Widget Preference Form
            if (html.wrapper) {
                html.wrapper.removeClassName('onEdit');
            }
        },

        /**
         * Triggered when preferences is closed (even by cliking on
         * 'Done' or by clicking on the cross icon).
         */
        onCloseEdit: function () {
            var that = this;

            that.html.preferences.destroy();
            that.html.preferences = null;
        },

        /**
         * Open an url into a new environment browser window.
         *
         * > Implementation can differ between environments.
         *
         * Behavior differ between execution environments:
         *  - open the page in an iframe on the same screen
         *  - open the page in a new window/tab
         *  - open the page in a new browser window (desktop widgets)
         *
         * @param {String} url - The url to open in a new window
         * @return {Boolean} `true` if it successfully opens the url (according to the subprotocol)
         */
        onOpenURL: function (url) {

            url = Utils.parseUrl(url);

            // Remove subprotocol and use source only
            if (!window.open(url.source, '_blank')) {
                window.alert(UWAString.format(
                    UWA.i18n('Unable to open "{0}", Please turn off your popup blocker and try again.'),
                    UWAString.truncate(url.source, 50)
                ));

                return false;
            }
        },

        /**
         * Try to change the widget view. This event can be triggered from the
         * widget by <UWA.Widget.requestView> or manually within the
         * environment.
         *
         * @param {Object} view - view parameters. It needs to have at least one
         *  field 'type' indicating the view name. Other properties are
         *  optional and passed to the view.
         */
        onViewRequest: (function () {

            // Shortcut to send a view event. If the argument 'error' is
            // defined, send an onViewError event, else send a view
            // onViewChange
            function sendEvent(that, event, error) {
                if (error) {
                    event.error = error;
                }
                that.dispatchEvent(error ? 'onViewError' : 'onViewChange', [event]);
            }

            // Shortcut to replace a view from an object after destroying the
            // current view if needed
            function replaceView(views, name, value) {
                if (views[name]) {
                    views[name].destroy();
                }
                views[name] = value;
            }

            // Create a view and initialize its events
            function viewFactory(environment, event) {
                var View = environment.views[event.type],
                    view = View && new View(environment, event);

                return view && view.addEvents({
                    onEnter: function () {
                        if (environment.view.next === this) {
                            // If successfully entered, we can safely replace the current view
                            replaceView(environment.view, 'current', this);
                            if (this.isSingle()) {
                                Environment._currentSingleView = this;
                            }

                            environment.view.next = null;

                            sendEvent(environment, this.event);
                        }
                    },

                    onLeave: function () {
                        if (environment.view.current === this) {
                            if (Environment._currentSingleView === this) {
                                Environment._currentSingleView = null;
                            }

                            // If no view is scheduled, schedule a new default view instance
                            if (!environment.view.next) {
                                environment.view.next = viewFactory(environment, environment.options.defaultView);
                            }

                            environment.view.next.enter();
                        }
                    },

                    onError: function (error) {
                        if (environment.view.next === this) {
                            // The view sent onError while being scheduled for the next view:
                            // destroy it and go back to the current view.
                            replaceView(environment.view, 'next');
                            environment.view.current.enter();
                        }
                        sendEvent(environment, this.event, error);
                    }
                });
            }

            return function (event) {
                var view,
                    that = this;

                if (!event) {
                    event = that.options.defaultView;
                }

                event = UWA.clone(event);

                if (that.view.current && that.view.current.event) {
                    event.previous = UWA.clone(that.view.current.event);
                    delete event.previous.previous; // Keep only one previous view at a time
                }

                if (that.view.current && that.view.current.matchEvent(event)) {
                    sendEvent(that, event, 'This view is already active.');
                } else {
                    view = viewFactory(that, event);
                    if (!view) {
                        sendEvent(that, event, 'No implementation available for the view "' + event.type + '".');
                    } else if (view.isSingle() && Environment._currentSingleView &&
                            Environment._currentSingleView !== that.view.current) {
                        sendEvent(that, event, 'An environment is already in single view.');
                        view.destroy();
                    } else {
                        // Schedule this new view to be the next one to launch.
                        replaceView(that.view, 'next', view);
                        if (!that.view.current) {
                            that.view.next.enter();
                        } else {
                            that.view.current.leave();
                        }
                    }
                }
            };
        }()),

        /**
         * Triggered when the view changed, it saves the view is the widget.
         *
         * @param {Object} view - Wiew parameters, like for <onViewRequest>
         */
        onViewChange: function (view) {
            this.getWidget()._view = view;
        },

        /**
         * Triggered when the view fails to change.
         *
         * @param {Object} view view parameters, like for <onViewRequest>, with one
         *    additional parameter 'error' representing the error message.
         */
        onViewError: function (event) {
            this.log('View error: ' + Json.encode(event));
        }
    });

    /**
     * Base class to create views. An instance of a view is tied to a single
     * event and environment. Each valid request to change a view will create
     * a new View instance, and this instance may be used more than one time
     * (example: if a view fails to enter, the previous view will be entered
     * again)
     *
     * @class UWA.Environment.AbstractView
     * @mixes UWA.Class.Events
     * @memberof module:UWA/Environment
     */
    Environment.AbstractView = Class.extend(Events, /** @lends module:UWA/Environment.UWA.Environment.AbstractView# */ {

        /**
         * the view event
         *
         * @type {Object}
         */
        event: null,

        /**
         * the environment
         *
         * @type {UWA.Environment}
         */
        environment: null,

        /**
         * @constructor
         * @constructs UWA.Environment.AbstractView
         *
         * @param {UWA.Environment} environment the current environment
         * @param {Object} event the view event.
         */
        init: function (environment, event) {
            this.environment = environment;
            this.event = event;
        },

        /**
         * Destroy this instance. It should not be used after that.
         */
        destroy: function () {
            this.removeEvents();
            if (Environment._currentSingleView === this) {
                Environment._currentSingleView = null;
            }
        },

        /**
         * Called when the view is activated. This method must dispatch the
         * event onEnter or onError.
         */
        enter: function () {
            this.dispatchEvent('onEnter');
        },

        /**
         * Called when the view is deactivated. This method must dispatch the
         * event onLeave or onError.
         */
        leave: function () {
            this.dispatchEvent('onLeave');
        },

        /**
         * Check if the view should be in single mode (= only one view can be in single mode at a
         * time)
         *
         * @returns {Boolean}
         */
        isSingle: function () {
            return false;
        },

        /**
         * Check if this view matches another event. If it matches, there is no need to leave the
         * current view and create another view.
         *
         * @returns {Object} another view event
         */
        matchEvent: function (event) {
            return this.event.type === event.type;
        },

        /**
         * Default action to do when the view is activating. Adds a CSS class on the widget body
         * with the view type.
         */
        onEnter: function () {
            var html = this.environment.html;

            if (html.wrapper && html.body) {
                UWAArray.invoke([html.wrapper, html.body], 'addClassName', this.event.type + '-view');
            }
        },


        /**
         * Default action to do when the view is deactivating. Removes the CSS class added by
         * <onEnter>.
         */
        onLeave: function () {
            var html = this.environment.html;

            if (html.wrapper && html.body) {
                UWAArray.invoke([html.wrapper, html.body], 'removeClassName', this.event.type + '-view');
            }
        }
    });

    /**
     * The default view, common to all environments.
     * @class UWA.Environment.prototype.views.windowed
     */
    Environment.prototype.views.windowed = Environment.AbstractView.extend({});


    /**
     * The fullscreen view. This view is only available if the client supports
     * the fullscreen API. See <UWA.Utils.Client.Features.fullscreen>
     *
     * Notes:
     *    The HTML fullscreen API has some limitations. It can only be activated
     *    if requested inside a click event. It means that you can only change
     *    the view to fullscreen if the current view immediatly leaves. It also
     *    means that you can't change the view to fullscreen when the widget is
     *    embedded, as the interframe communication is asynchronous.
     *
     * @class UWA.Environment.prototype.views.fullscreen
     */
    if (Client.Features.fullscreen) {
        Environment.prototype.views.fullscreen = Environment.AbstractView.extend({

            enter: function () {
                var events,
                    self = this,
                    target = self.getTarget();

                events = {
                    fullscreenchange: function () {
                        if (document.fullscreenElement === target) {
                            self.dispatchEvent('onEnter');
                        } else {
                            self.dispatchEvent('onLeave');
                            Element.removeEvents.call(document, events);
                        }
                    },
                    fullscreenerror: function () {
                        self.dispatchEvent('onError', ['Error while trying to set the fullscreen']);
                        Element.removeEvents.call(document, events);
                    }
                };

                Element.addEvents.call(document, events);

                target.requestFullscreen();
            },

            leave: function () {
                if (document.fullscreenElement === this.getTarget()) {
                    document.exitFullscreen();
                } else {
                    this.dispatchEvent('onLeave');
                }
            },

            isSingle: function () {
                return true;
            },

            getTarget: function () {
                var html = this.environment.html;
                return html.content || html.body;
            }

        });
    }

    return UWA.namespace('Environment', Environment, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Deprecated module. Use UWA/Promise instead.
 */
define('UWA/Class/Promise', [
    'UWA/Core',
    'UWA/Promise',
    'UWA/Internal/Deprecate'
], function (Core, UWAPromise, Deprecate) {
    'use strict';

    Deprecate.warn('Module UWA/Class/Promise', 'Use UWA/Promise instead');

    return Core.namespace('Class/Promise', UWAPromise, Core, 'replace');
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * This module declare/extends UWA to work without third party Framework.
 *
 * @module   UWA/Drivers/Alone
 *
 */
define('UWA/Drivers/Alone', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Internal/Deprecate',
    'UWA/Function',
    'UWA/String',
    'UWA/Array',
    'UWA/Date',
    'UWA/Object',
    'UWA/Utils',
    'UWA/Class',
    'UWA/Dispatcher',
    'UWA/Utils/Client',
    'UWA/Ajax',
    'UWA/Json',
    'UWA/Storage',
    'UWA/Data',
    'UWA/Element',
    'UWA/Fx',
    'UWA/Plugins/Abstract',
    'UWA/Controls/Pager',
    'UWA/Controls/Img',
    'UWA/Controls/Form',
    'UWA/Widget',
    'UWA/Environment',
    'UWA/Promise',
    'UWA/Class/Promise'
], function (UWA, Event, Deprecate) {
    'use strict';

    var Driver = {

        /**
         * The current driver name (e.g "Alone").
         *
         * @type {String}
         * @alias UWA.driver
         * @memberOf module:UWA/Drivers/Alone
         */
        driver: 'Alone',

        /**
         * Extent a DOM Element with UWA.Element methods.
         *
         * @example
         * var el = UWA.extendElement(document.getElementById('myElementId'));
         *
         * @param {Element} element - The Element to extend
         * @return {Element} the extended Element.
         *
         * @alias UWA.extendElement
         * @memberOf module:UWA/Drivers/Alone
         */
        extendElement: function (element) {

            if (element && !element._isUwaExtended) {
                if (element.nodeName === '#document') {
                    UWA.merge(element, UWA.Element);
                    Deprecate.warn('UWA.extendElement(document)');
                } else {
                    UWA.extend(element, UWA.Element);
                }
                element._isUwaExtended = true;
            }

            return element;
        },

        /**
         * Create a DOM Element with UWA.Element methods.
         *
         * @example
         * var myElement = UWA.createElement('a', {
         *    'class': 'myClass1 myClass2',
         *    html: '<span>Hello World</span>',
         *    styles: {
         *      ...
         *    },
         *    events: {
         *        click: function(event) {
         *            UWA.Event.stop(event);
         *            ...
         *        }
         *    }
         * });
         *
         * @param {String} tagName - The element tag name (eg: 'div')
         * @param {Object} options - Element attributes and options
         * @return {Element} The new Element.
         *
         * @alias UWA.createElement
         * @memberOf module:UWA/Drivers/Alone
         */
        createElement: function (tagName, options) {
            return new UWA.Element(tagName, options);
        }
    };

    function extendRootElements() {
        if (window.document) {
            if (window.document.body) {
                Driver.extendElement(window.document.body);
            }
            if (window.document.documentElement) {
                Driver.extendElement(window.document.documentElement);
            }
        }
    }
    extendRootElements();
    Event.onDomReady(extendRootElements);

    return UWA.namespace('UWA', Driver, window, true);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/*jshint
    unused: false
*/

/**
 * Data Storage API Abstract Adapter.
 *
 * @module   UWA/Storage/Adapter/Abstract
 *
 */
define('UWA/Storage/Adapter/Abstract', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Storage'
], function (UWA, Class, Options) {
    'use strict';

    var Abstract = Class.extend(Options, /** @lends module:UWA/Storage/Adapter/Abstract.UWA.Storage.Adapter.Abstract# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Abstract',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: -1,

        /**
         * Data Storage API Abstract Adapter.
         *
         * @param {Object} storage - UWA.Storage instance used by adapter
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Storage.Adapter.Abstract
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Storage/Adapter/Abstract
         */
        init: function (storage, options) {

            // Instance of UWA.Storage
            this.storage = storage || {};

            // Configure the database name
            this.database = null;

            // Cache the data so we can work synchronously
            this.data = {};

            // Third party script includes
            this.includes = [];

            // When set, we're ready to transact data
            this.storage.isReady = false;

            this.setOptions(options);
        },

        /**
         * This should be overloaded with an actual functionality presence check
         *
         * @return {Boolean}
         */
        isAvailable: function () {
            return false;
        },

        // All get/set/rem functions across the engines should add this to the
        // first line of those functions to prevent accessing the engine while unstable.
        interruptAccess: function () {

            if (!this.storage.isReady) {
                throw new Error('Storage Adapter ' + this.type + ' is not ready.');
            }

            return true;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key Value or `null`.
         */
        get: function (key) {
            this.interruptAccess();
            return this.data[key] || null;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            this.data[key] = value;
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var beforeDelete = this.data[key];
            this.data[key] = null;
            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/Abstract', Abstract, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, location
*/

/**
 * Data Storage API DOM adapter implementation.
 *
 * > Use feature detection in order to fallback from globalStorage, localStorage, sessionStorage.
 *
 * @module   UWA/Storage/Adapter/Dom
 *
 */
define('UWA/Storage/Adapter/Dom', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    function isWritable(db) {

        var writable = false;

        try {
            db.setItem('uwa-test', 1);
            db.removeItem('uwa-test');
            writable = true;
        } catch (e) {
            // Avoid Error: QUOTA_EXCEEDED_ERR
        }

        return writable;
    }

    function isAvailableSession() {
        return !!window.sessionStorage && isWritable(window.sessionStorage);
    }

    function isAvailableLocal() {
        return !!(window.localStorage || window.globalStorage) &&
                    isWritable(!window.globalStorage ? window.localStorage : window.globalStorage[location.hostname]);
    }

    /**
     * @class UWA.Storage.Adapter.Dom
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Dom
     */
    var Dom = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Dom.UWA.Storage.Adapter.Dom# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Dom',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 5 * 1024 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            if (window.localStorage || window.globalStorage) {
                this.db = !window.globalStorage ? window.localStorage : window.globalStorage[location.hostname];
            } else if (window.sessionStorage) {
                this.db = window.sessionStorage;
            }

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return isAvailableSession() || isAvailableLocal();
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();
            var out = this.db.getItem(this.database + '-' + key),

                // Gecko's getItem returns {value: 'the value'}, WebKit returns 'the value'
                value = (out && out.value !== undefined ? out.value : out);

            return value || undefined;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            this.db.setItem(this.database + '-' + key, value);
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var out = this.get(key);
            this.db.removeItem(this.database + '-' + key);
            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/Dom', Dom, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document
*/

/**
 * Data Storage API Microsoft Internet Explorer adapter implementation.
 *
 * @module   UWA/Storage/Adapter/IE
 *
 */
define('UWA/Storage/Adapter/IE', [
    'UWA/Core',
    'UWA/Utils/Client',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Client, Abstract) {
    'use strict';

    function createDbElement(database) {

        // Create a hidden div to store attributes in
        var dbElement = document.createElement('div');
        dbElement.id = 'uwa-' + database;
        dbElement.style.display = 'none';
        dbElement.style.behavior = "url('#default#userData')";
        document.documentElement.appendChild(dbElement);

        return dbElement;
    }

    function removeDbElement(dbElement) {
        document.documentElement.removeChild(dbElement);
    }

    /**
     * @class UWA.Storage.Adapter.IE
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/IE
     */
    var IE = Abstract.extend(/** @lends module:UWA/Storage/Adapter/IE.UWA.Storage.Adapter.IE# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'IE',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 64 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = 'uwa-data-storage-' + database;

            // Create a hidden div to store attributes in
            this.db = createDbElement(this.database);

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {

            var testStorage, testValue,
                testDbName = 'testStorage',
                isAvailable = false;

            if (window.ActiveXObject) {

                try {

                    testValue = new Date().getTime();
                    testStorage = createDbElement(testDbName);

                    // Test save if save exist
                    if (testStorage.hasOwnProperty('save')) {

                        testStorage.setAttribute(testDbName, testValue);
                        testStorage.save(testDbName);

                        testStorage.load(testDbName);
                        testStorage.getAttribute(testDbName);
                    }

                    isAvailable = true;

                } catch (e) {
                    // Ignore possible forbiden errors
                }

                removeDbElement(testStorage);
            }

            return isAvailable;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {

            key = String(key);

            if (key.match(/^\d/) !== null) {
                key = 'X' + key;
            }

            return key.toUpperCase();
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            this.db.load(this.database);

            return this.db.getAttribute(this.getKey(key)) || undefined;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            this.db.setAttribute(this.getKey(key), value);

            this.db.save(this.database);
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var beforeDelete = this.get(key);

            this.db.removeAttribute(this.getKey(key));

            this.db.save(this.database);

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/IE', IE, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define, window*/
/*eslint valid-jsdoc: 2*/

/**
 * This module provides classes to manage easily cookies.
 * @module   UWA/Utils/Cookie
 *
 * Source https://github.com/ScottHamper/Cookies/blob/master/src/cookies.js
 * License: Public Domain
 *
 */

define('UWA/Utils/Cookie', [
    'UWA/Core'
], function (UWA) {
    'use strict';

    /**
     * @constructor
     * @alias module:UWA/Utils/Cookie
     */
    var Cookie = {};

    // Allows for setter injection in unit tests
    var document = window.document;

    // Used to ensure cookie keys do not collide with
    // built-in `Object` properties
    var cacheKeyPrefix = 'nv.';

    // Define a max value for expiration date
    var maxExpireDate = new Date('Fri, 31 Dec 9999 23:59:59 UTC');

    var cache = null;
    var cachedDocumentCookie = null;

    /**
     * Cookie.defaults
     * An object representing default options to be used when setting and expiring cookie values.
     *
     * ##### Available Options
     *
     * | Options          |  Description                                        |  Default
     * | ---------------- | --------------------------------------------------- | -----------------
     * | `path`           | A string value of the path of the cookie            | "/"
     * | `domain`         | A string value of the domain of the cookie          | undefined
     * | `expires`        | A number (of seconds), a date parsable string,      | undefined
     * |                  | or a Date object of when the cookie will expire.    |
     * | `secure`         | A boolean value of whether or not the cookie        | false
     * |                  | should only be available over SSL                   |
     *
     * @example
     * Cookie.defaults = {
     *     path: '/',
     *     secure: true
     * };
     *
     */
    Cookie.defaults = {
        path: '/',
        secure: false
    };

    /**
     * Get extended options
     *
     * @param {Object} options - cookie options
     * @return {Object} - extended cookie options
     */
    function getExtendedOptions(options) {
        return {
            path: options && options.path || Cookie.defaults.path,
            domain: options && options.domain || Cookie.defaults.domain,
            expires: options && options.expires || Cookie.defaults.expires,
            secure: options && options.secure !== undefined ? options.secure : Cookie.defaults.secure
        };
    }

    /**
     * Check date validity
     *
     * @param {Date} date - date
     * @return {Boolean} - if true, date is valid
     */
    function isValidDate(date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    }

    /**
     * Get the expiration date
     *
     * @param {Date} expires - expires
     * @param {Date} now - new date
     * @return {Date} expires - expires
     */
    function getExpiresDate(expires, now) {
        now = now || new Date();

        if (typeof expires === 'number') {
            expires = expires === Infinity ?
                maxExpireDate : new Date(now.getTime() + expires * 1000);
        } else if (typeof expires === 'string') {
            expires = new Date(expires);
        }

        if (expires && !isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    }

    /**
     * Generate the cookie string
     *
     * @param {String} key - cookie key
     * @param {String} value - cookie value
     * @param {Object} options - cookie options
     * @return {String} cookieString - the cookie string
     */
    function generateCookieString(key, value, options) {
        key = key.replace(/[^#$&+\^`|]/g, encodeURIComponent);
        key = key.replace(/\(/g, '%28').replace(/\)/g, '%29');
        value = String(value).replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    }

    /**
     * Get cookie key/value from cookie string
     *
     * @param {String} cookieString - cookie string
     * @return {Object} key/value
     */
    function getKeyValuePairFromCookieString(cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        var key = cookieString.substr(0, separatorIndex);
        var decodedKey;
        try {
            decodedKey = decodeURIComponent(key);
        } catch (e) {
            throw new Error('Could not decode cookie with key "' + key + '" [' + e + ']');
        }

        return {
            key: decodedKey,
            value: cookieString.substr(separatorIndex + 1) // Defer decoding value until accessed
        };
    }

    /**
     * Get cache from cookie string
     *
     * @param {String} documentCookie - cookie string
     * @return {Object} cookieCache - cookie cache
     */
    function getCacheFromString(documentCookie) {
        var cookieCache = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieCache[cacheKeyPrefix + cookieKvp.key] === undefined) {
                cookieCache[cacheKeyPrefix + cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieCache;
    }

    /**
     * Renew cookie cache
     *
     * @return {Object} mixed
     */
    function renewCache() {
        cache = getCacheFromString(document.cookie);
        cachedDocumentCookie = document.cookie;
    }

    /**
     * Returns the value of the most locally scoped cookie with the specified key.
     *
     * @param {String} key - cookie key
     * @return {String} value - cookie value
     */
    Cookie.get = function (key) {
        if (cachedDocumentCookie !== document.cookie) {
            renewCache();
        }

        var value = cache[cacheKeyPrefix + key];

        return value === undefined ? undefined : decodeURIComponent(value);
    };

    /**
     * Sets a cookie in the document. If the cookie does not already exist, it will be created.
     *
     * @param {String} key - cookie key
     * @param {String} value - cookie value
     * @param {Object} options - cookie options
     * @return {Object} Cookie
     */
    Cookie.set = function (key, value, options) {
        options = getExtendedOptions(options);
        options.expires = getExpiresDate(value === undefined ? -1 : options.expires);

        document.cookie = generateCookieString(key, value, options);

        return Cookie;
    };

    /**
     * Expires a cookie, removing it from the document
     *
     * @param {String} key - cookie key
     * @param {Object} options - cookie options
     * @return {Object} - Cookie
     */
    Cookie.expire = function (key, options) {
        return Cookie.set(key, undefined, options);
    };

    /**
     * A boolean value of whether or not the browser has cookies enabled.
     *
     * @return {Boolean} - if true, cookies are enabled
     */
    function areEnabled() {
        var testKey = 'cookie.js';
        var isActive = Cookie.set(testKey, 1).get(testKey) === '1';
        Cookie.expire(testKey);
        return isActive;
    }

    Cookie.enabled = areEnabled();

    return UWA.namespace('Utils/Cookie', Cookie, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * Data Storage API Cookies adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Cookies
 *
 */
define('UWA/Storage/Adapter/Cookies', [
    'UWA/Core',
    'UWA/String',
    'UWA/Utils',
    'UWA/Utils/Cookie',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, UWAString, Utils, Cookie, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Cookies
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Cookies
     */
    var Cookies = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Cookies.UWA.Storage.Adapter.Cookies# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Cookies',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 1024 * 4,

        /**
         * @property {Object} defaultOptions - The default adapter options.
         * @protected
         */
        defaultOptions: {
            path: '/',
            duration: 100, // 100 days by default
            expires: 86400 * 100, // (100 days)
            secure: false,
            domain: ''
        },

        init: function (storage, options) {

            var uri = Utils.parseUrl(window.location);

            this.defaultOptions = {
                domain: ['80', '443'].indexOf(uri.port) !== -1 && uri.domain,
                secure: uri.protocol === 'https'
            };

            this._parent(storage, options);

            if (this.options.duration) {
                this.options.expires = this.options.duration * 86400;
                delete this.options.duration;
            }
        },

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = database;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return Cookie.enabled;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return 'uwa-' + this.database + '-' + key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            return Cookie.get(key);
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            var options = this.options;

            this.interruptAccess();

            return Cookie.set(key, value, options);
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var options = this.options;
            var out = this.get(key);

            Cookie.expire(this.getKey(key), options);

            return out;
        }

    });

    return UWA.namespace('Storage/Adapter/Cookies', Cookies, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Data Storage API Object (not persistent) adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Object
 *
 */
define('UWA/Storage/Adapter/Object', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Object
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Object
     */
    var MyObject = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Object.UWA.Storage.Adapter.Object# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Object',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            this.db = {};

            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return true;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            return this.db[key];
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            this.db[key] = value;
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var out = this.get(key);
            delete this.db[key];
            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/Object', MyObject, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Data Storage API HTML5 (openDatabase) adapter implementation.
 *
 * DEPRECATED: try not to use UWA/Storage anymore
 *
 * > Use openDatabase, executeSql, transaction.
 *
 * @module   UWA/Storage/Adapter/Html5
 *
 */
define('UWA/Storage/Adapter/Html5', [
    'UWA/Core',
    'UWA/Storage/Adapter/Object',
    'UWA/Internal/Deprecate'
], function (UWA, Object, Deprecate) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Html5
     * @extends UWA.Storage.Adapter.Object
     * @memberof module:UWA/Storage/Adapter/Html5
     */
    var Html5 = Object.extend(/** @lends module:UWA/Storage/Adapter/Html5.UWA.Storage.Adapter.Html5# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Html5',

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {
            Deprecate.warn("UWA/Storage/Adapter/Html5", "Use WebSQL directly if you really need to.");
            this._parent(database);
        }

    });

    return UWA.namespace('Storage/Adapter/Html5', Html5, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Instances of classes implementing or extending
 * {@link module:UWA/Class/Listener|UWA.Class.Listener}
 * will have the ability to listen to events emitted by instances of
 * {@link module:UWA/Class/Events|UWA.Class.Events} observables.
 *
 * @module   UWA/Class/Listener
 *
 *
 * @example
 *  TODO
 */
define('UWA/Class/Listener', [
    'UWA/Core',
    'UWA/Class'
], function (Core, Class) {
    'use strict';

    var observableIdCounter, Listener;

    // counter for generating unique Ids for observables
    observableIdCounter = 0;

    function invertControlOf(impl) {
        return function (observable, name, callback, priority) {
            var typeOfName, events, evt, invertedApi = observable[impl];

            typeOfName = Core.typeOf(name);
            if ('object' === typeOfName) {
                events = name;
            }

            // check input params types
            if (invertedApi && (events || ('string' === typeOfName && Core.is(callback, 'function')))) {

                if (!Core.is(this._listeningTo)) {
                    this._listeningTo = {};
                }

                if (!Core.is(observable._observableId)) {
                    observable._observableId = 'o' + (++observableIdCounter);
                }

                this._listeningTo[observable._observableId] = observable;

                if (!events) {
                    events = {};
                    events[name] = callback;
                }

                for (evt in events) {
                    if (events.hasOwnProperty(evt)) {
                        invertedApi.call(observable, evt, events[evt], this, priority);
                    }
                }

            } else {
                throw new Error('invalid input args');
            }

            return this;
        };
    }

    Listener = Class.extend({

        /**
         * Listen to a particular event emitted by an object implementing
         * {@link module:UWA/Class/Events|UWA.Class.Events}.
         *
         * This is indeed the inversion-of-control version of
         * {@link module:UWA/Class/Events#addEvent|UWA.Class.Events.addEvent}.
         * The advantage of using this form,
         * instead of `observable.addEvent(name, listener, this)`, is that
         * {@link module:UWA/Class/Listener#listenTo|listenTo} allows this listening
         * object to keep track of the listened events, and they can be removed
         * all at once later on.
         *
         * Note that the listener callback function passed as input argument
         * will always be called with this caller Listener object as context.
         *
         * {@link module:UWA/Class/Listener#listenTo|listenTo} has two different
         * signatures, as illustrated in the example
         * below : either with the observed emitter object, the name of the event,
         * the callback function and an optional priority or with the observed
         * emitter object and an hash of `{ eventName: callback }` pairs. Note that
         * with the later form, no priority can be specified.
         *
         * {@link module:UWA/Class/Listener#listenTo|listenTo} is meant to be used in your code
         * in conjunction with {@link module:UWA/Class/Listener#stopListening|stopListening}.
         *
         * @example
         * var myObserver, myObservable;
         *
         * myObserver = new UWA.Class.Listener();
         * myObservable = new UWA.Class.Events();
         *
         * myObserver.listenTo(myObservable, 'someEvent', function () {
         *     UWA.log('Some event occurred!');
         * });
         * myObserver.listenTo(myObservable, {
         *     someOtherEvent: function () {
         *         UWA.log('Some other event occurred!');
         *     },
         *     andSomethingElse: function () {
         *         UWA.log('Something else to take care of...');
         *     }
         * });
         * myObserver.stopListening();
         *
         * @param {Object}        observable   -  the observed emitter object, must implement {@link module:UWA/Class/Events|UWA.Class.Events}
         * @param {String|Object} name         -  the name (string) of the listened event or a hash of {event: callback} pairs
         * @param {Function}      [callback]   -  the listener callback, if name argument is a string.
         * @param {Number}        [priority=0] - the priority level of the listener, if name argument is a string.
         *                                       Listeners with higher priority will be executed before listeners
         *                                       with lower priority. Listeners with same priority
         *                                       level will be executed at the same order as they were added.
         * @return {this}
         * @throw error if the input arguments are invalid, for example if observable
         *        does not implement <UWA.Class.Events>
         * @method module:UWA/Class/Listener#listenTo
         */
        listenTo: invertControlOf('addEvent'),

        /**
         * Just like {@link module:UWA/Class/Listener#listenTo|listenTo},
         * but causes the bound callback to only fire once
         * before being removed.
         *
         * This is indeed the inversion-of-control version of <UWA.Class.Events.addEventOnce>.
         *
         * Note that the listener callback function will
         * always be called with this caller Listener object as context.
         *
         * There are two ways to call {@link module:UWA/Class/Listener#listenToOnce|listenToOnce},
         * as illustrated in the example
         * below : either with the observed emitter object, the name of the event,
         * the callback function and the optional priority or with the observed
         * emitter object and an hash of `{ eventName: callback }` pairs. Note that
         * with the later form, no priority can be specified.
         *
         * @example
         * var myObserver, myObservable;
         *
         * myObserver = new UWA.Class.Listener();
         * myObservable = new UWA.Class.Events();
         *
         * myObserver.listenToOnce(myObservable, 'someEvent', function () {
         *     UWA.log('Some event occurred!');
         * });
         * myObserver.listenToOnce(myObservable, {
         *     someOtherEvent: function () {
         *         UWA.log('Some other event occurred!');
         *     },
         *     andSomethingElse: function () {
         *         UWA.log('Something else to take care of...');
         *     }
         * });
         *
         * @param  {Object}   observable   - the observed emitter object, must implement {@link module:UWA/Class/Events|UWA.Class.Events}
         * @param  {Mixed}    name         - the name (string) of the listened event or a hash of `{event: callback}` pairs
         * @param  {Function} [callback]   - the listener callback, if name argument is a string.
         * @param  {Number}   [priority=0] - the priority level of the listener, if name argument is a string.
         *                                   Listeners with higher priority will be executed before listeners
         *                                   with lower priority. Listeners with same priority
         *                                   level will be executed at the same order as they were added.
         *
         * @return {this}
         * @throw error if the input arguments are invalid, for example if observable
         *        does not implement {@link module:UWA/Class/Events|UWA.Class.Events}
         * @method module:UWA/Class/Listener#listenToOnce
         */
        listenToOnce: invertControlOf('addEventOnce'),

        /**
         * Tell this object to stop listening to events.
         *
         * {@link module:UWA/Class/Listener#stopListening|stopListening} is meant
         * to be used in conjunction with {@link module:UWA/Class/Listener#listenTo|listenTo}.
         *
         * Either call {@link module:UWA/Class/Listener#stopListening|stopListening}
         * with no arguments to have the object remove all of its registered callbacks.
         * Or be more precise by telling it to remove just the events it's listening
         * to on a specific object, or a specific event name, or just a specific callback.
         *
         * There are two ways to call {@link module:UWA/Class/Listener#stopListening|stopListening},
         * as illustrated in the example below : either with the (optional, can be null)
         * observed emitter object,
         * the (optional, can be null) name of the event and the (optional, can be null)
         * callback function or with the observed emitter object and an
         * hash of `{ eventName: callback }` pairs.
         *
         * @example
         * var observer, observable, fn;
         *
         * observer = new UWA.Class.Listener();
         * observable = new UWA.Class.Events();
         * fn = function () { UWA.log('Caught!'); };
         *
         * // these are all valid calls to stopListening :
         * observer.listenTo(observable, 'someEvent', fn).stopListening();
         * observer.listenTo(observable, 'someEvent', fn).stopListening(observable);
         * observer.listenTo(observable, 'someEvent', fn).stopListening(null, 'someEvent');
         * observer.listenTo(observable, 'someEvent', fn).stopListening(null, null, fn);
         * observer.listenTo(observable, 'someEvent', fn).stopListening(observable, 'someEvent', fn);
         * observer.listenTo(observable, 'someEvent', fn).stopListening(observable, 'someEvent');
         * observer.listenTo(observable, 'someEvent', fn).stopListening(observable, null, fn);
         * observer.listenTo(observable, 'someEvent', fn).stopListening(null, 'someEvent', fn);
         * observer.listenTo(observable, {
         *     someEvent: fn,
         *     someOtherEvent: fn,
         *     andAThirdEvent: fn
         * }).stopListening(observable, {
         *     someEvent: fn,
         *     someOtherEvent: fn
         * }).stopListening();
         *
         * @param  {Object}   [observable] - the observer emitter to stop listening to
         * @param  {Mixed}    [name]       - the name (string) of the listened event
         *                                   or a hash of `{event: callback}` pairs
         * @param  {Function} [callback]   - the listener callback, if name argument is not a hash
         * @return {this}
         * @method module:UWA/Class/Listener#stopListening
         */
        stopListening: function (observable, name, callback) {
            var remove, implName, typeOfName, observableId,
                listeningTo = this._listeningTo;

            // we will make use of removeEvent api by default ...
            implName = 'removeEvent';

            // nothing to be done if i am not listening to anything :
            if (listeningTo) {

                typeOfName = Core.typeOf(name);

                if (!callback) {

                    if (false === typeOfName) {
                        remove = true;  // I should stop referencing observable
                                        // as an object i am listeningTo.
                    } else if ('object' === typeOfName) {
                        implName = 'removeEvents';
                        callback = this;// for removeEvents api, the second arg is
                                        // the context, aka this here.
                    }
                }

                if (observable) {
                    listeningTo = {};
                    // note: no need to test whether or not observable._observableId
                    // is defined, listeningTo is a local ref to a new object
                    // here...
                    listeningTo[observable._observableId] = observable;
                }

                for (observableId in listeningTo) {
                    observable = listeningTo[observableId];

                    // the actual call to removeEvent or removeEvents is made here :
                    observable[implName](name, callback, this);

                    // remove reference to listened observable in my hash of
                    // listened observables :
                    //
                    // [ A note about this implementation :
                    // It is currently an effort to stay simple and fast.
                    // Because it would be quite expensive to be finer and (instead
                    // of using hasEvent) check
                    // the contextes of all Listeners/Bindings of all Dispatchers
                    // of observable to see if it matches this observer object,
                    // but we do agree that this is a situation leading to mem leaks.
                    // A commit that keeps it speedy while cleaning
                    // up these lingering objects in this._listeningTo is welcome.
                    // The PR https://github.com/jashkenas/backbone/pull/3049
                    // seems to do the job, to be checked !
                    //
                    // Note that a currently broken unit test highlights this mem leak.
                    //
                    // Note also that most of the time, developers are making calls
                    // to observer.stopListening() with no args, in this situation
                    // there is no mem leak possible.]
                    if (remove || !observable.hasEvent()) {
                        delete this._listeningTo[observableId];
                    }
                }
            }
            return this;
        }
    });

    return Core.namespace('Listener', Listener, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 *
 * Models contain the interactive data of your application as well as a large
 * part of the logic surrounding it: conversions, validations, computed
 * properties, and access control.
 *
 * You extend {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} class
 * with your domain-specific methods, and Model provides a basic set of functionality
 * for managing changes.
 *
 * Furthermore Models benefit from {@link module:UWA/Class/Model.UWA.Class.Model#sync|a great syncing system with the backend data},
 * built as close as possible to the RESTful pattern, that can be easily customized
 * to suit your needs.
 *
 * __Events triggered by instances of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}__:
 *
 * First of all, please note that any event that is triggered by an instance of
 * {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
 * that is in a collection will also be triggered on the collection directly,
 * for convenience. This allows to any code to listen to a collection for changes
 * to specific attributes in any of its models! Please see {@link module:UWA/Class/Collection|UWA/Class/Collection}
 * for a description.
 *
 * | Event name             | Arguments passed to listener callback    | Description                                                                                             |
 * | ---------------------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------------|
 * |  'onAdd'               |  model, collection, options              |  Triggered when the model is added to a Collection.                                                     |
 * |  'onRemove'            |  model, collection, options              |  Triggered when the model is removed from a Collection.                                                 |
 * |  'onChange'            |  model, options                          |  Triggered when any model's attribute has changed.                                                      |
 * |  'onChange:attr'       |  model, new_attr_value, options          |  Triggered when the specific attribute attr of the model has been modified.                             |
 * |  'onDestroy'           |  model, model.collection if any, options |  Triggered when the model is destroyed.                                                                 |
 * |  'onSync'              |  model, backend response, options        |  Triggered whenever the model is successfully synced to/from the backend (saved, destroyed or fetched). |
 * |  'onRequest'           |  model, XmlHttpRequest, options          |  Triggered by default implementation of sync as the XHR begins to go to the backend.                    |
 * |  'onError'             |  model, backend error, options           |  Triggered when a save/fetch/destroy operation fails in the backend.                                    |
 * |  'onValidationFailure' |  model, validation error, options        |  Triggered when validate() failed. Note that the error is also available in options.validationError.    |
 * |  'onAnyEvent'          |  event name, event data...               |  Triggered for any triggered event, passing the event name as the first argument.                       |
 *
 * __Define your own custom model by sub-classing {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}__:
 *
 * A {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} can be extended (i.e. sub-classed), and it must be in
 * 99% of your cases, using {@link module:UWA/Class.UWA.Class#extend|UWA.Class.extend} mechanism
 * and defining an {@link module:UWA/Class/Model.UWA.Class.Model#setup|setup} function
 * when extending that will be invoked when a model is created.
 *
 * The methods and properties you should override/implement when defining your
 * custom models by sub-classing {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} are :
 *
 * - {@link module:UWA/Class/Model.UWA.Class.Model#setup|setup}, to initialize
 *     a newly created instance of model.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}, to implement,
 *     customize or fine-tune the manner in which models are persisted in or
 *     fetched from the backend.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse}, to transform the
 *     raw backend response into an hash of attributes for the model.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}, to implement
 *     your custom validation logic of the attributes.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#url|url}, to return the relative
 *     or absolute URL of the model in the backend.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot}, if you’re
 *     using a model outside of a collection.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|idAttribute}, to
 *     transparently map from the unique identifying key in the backend to this
 *     model’s {@link module:UWA/Class/Model.UWA.Class.Model#id|id}.
 * - {@link module:UWA/Class/Model.UWA.Class.Model#defaults|defaults}, to specify
 *     the default attributes values hash for the model.
 *
 * By extending/subclassing {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}, you can define your own
 * business logic on top of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}, see an example
 * below that will show you the benefits of defining your custom models
 * for your business logic.
 *
 * @module UWA/Class/Model
 *
 *
 * @example
 * // The following is a brief and contrived example, but it demonstrates defining a model
 * // with a custom business logic method (adopt method), setting an attribute,
 * // saving it to the backend, ...
 *
 * define('MyProject/Model/Person', [
 *     'UWA/Class/Model',
 *     'UWA/Class/Debug',
 *     'UWA/String'
 * ], function (Model, Debug, UWAString) {
 *
 *     'use strict';
 *
 *     var Person = Model.extend(Debug, {
 *
 *         urlRoot: '/person',
 *
 *         defaults: {
 *             name: 'Foetus',
 *             age: 0,
 *             child: ''
 *         },
 *
 *         setup: function () {
 *
 *             var that = this;
 *             that.log("Welcome to this world");
 *
 *             that.addEvent("onChange:name", function (person) {
 *                 that.log(UWAString.format('Changed my name to {0}', person.get("name")));
 *             });
 *
 *             that.addEvent('onValidationFailure', function (person, error) {
 *                 person.log(error);
 *             })
 *         },
 *
 *         // Validate data before you set or save it :
 *         validate: function (attributes) {
 *             if (attributes.age < 0 && attributes.name !== 'Benjamin Button') {
 *                 return "Only Ben Button can be negative years old!";
 *             }
 *         },
 *
 *         // some business logic on my model :
 *         adopt: function (newChildsName) {
 *             this.set({
 *                 child: newChildsName
 *             });
 *             this.log(UWAString.format('{0} just adopted {1}', this.get(name), newChildsName));
 *         }
 *     });
 *
 *     return Person;
 * });
 *
 * require(['MyProject/Model/Person'], function (Person) {
 *
 *     var angelina = new Person({
 *         name: "Jolie",
 *         age: 38,
 *         child: 'Shiloh'
 *     });
 *
 *     alert(angelina.isNew()); // alerts 'true'
 *
 *     angelina.adopt('Pax Thien');
 *
 *     var child = angelina.get("child"); // returns 'Pax Thien'
 *
 *     // A request PUT /user with a payload containing the attributes
 *     // will be performed.
 *     // The backend should persist the data and return a response containing the new `id`
 *     angelina.save({
 *         age: 39
 *     }, {
 *         wait: true,
 *         onComplete: function (person, response) {
 *             person.log('Successfully saved!');
 *         },
 *         onFailure: function (person, error) {
 *             person.log(person.toJSON());
 *             person.log(error.responseText);
 *         }
 *     });
 *
 *     // Assuming that there is already a person saved in DB
 *     // with an ID that is '2' :
 *     var brad = new Person({
 *         id:2
 *     });
 *
 *     alert(brad.isNew()); // alerts 'false'
 *
 *     // This fetch call will perform a GET /user/1 request
 *     // The backend should return the id, name and email from the database.
 *     brad.fetch({
 *         onComplete: function (brad) {
 *             brad.log('I have been fetched from IMDB.');
 *         }
 *     });
 *
 *     // Because brad has an ID, a request DELETE /person/2 will be
 *     // performed :
 *     brad.destroy({
 *         onComplete: function (bradZombie) {
 *             bradZombie.log('I have been removed from IMDB.');
 *         }
 *     });
 * });
 *
 */
define('UWA/Class/Model', [
    'UWA/Core',
    'UWA/String',
    'UWA/Data',
    'UWA/Class',
    'UWA/Class/Events',
    'UWA/Class/Listener'
], function (Core, UWAString, Data, Class, Events, Listener) {
    'use strict';

    var Model,

        // Init cid counter prefix to 0
        modelIdCounter = 0,

        // Map from CRUD to HTTP for the default Model.sync implementation below.
        methodMap = {
            'create': 'POST',
            'update': 'PUT',
            'patch': 'PATCH',
            'delete': 'DELETE',
            'read': 'GET'
        };

    // No need to use UWA.Utils.attempt, this is just a wrapper to call onFailure callback
    // not only with the Error and response but instead with model, response and options hash.
    function wrapFailure(model, options) {
        var onFailure = options.onFailure;
        options.onFailure = function (resp) {
            if (onFailure) {
                onFailure(model, resp, options);
            }
            model.dispatchEvent('onError', [model, resp, options]);
        };
    }

    function urlError() {
        throw new Error('A "url" property or function must be specified');
    }

    // Utility function that given a list of arguments that can be arrays
    // or singulars, returns a concatenated array of all these args.
    // E.g. : getArgsArray('albert', ['william', 'harry'], 'charles')
    // returns ['albert', 'william', 'harry', 'charles']
    function getArgsArray(args) {
        return Array.prototype.concat.apply([], Array.prototype.slice.call(args, 0));
    }

    Model = Class.extend(Events, Listener, /** @lends module:UWA/Class/Model.UWA.Class.Model# */{ // bypass

        /// Internal Private Properties documented for maintainers of this code ///
        /// Never ever use these properties in your client developer code ! ///

        /* _attributes:
        The internal private _attributes property is the hash containing
        the model's state — usually (but not necessarily) a form of the JSON
        object representing the model data on the backend. It's often a
        straightforward serialization of a row from the database, but it
        could also be client-side computed state.
        Please use <set> to update _attributes instead of modifying _attributes
        directly. If you'd like to retrieve and munge a copy of the model's
        _attributes, use <toJSON> method instead.
        */

        /* _changed:
        The internal private _changed hash contains all the attributes that have
        changed since the last "onChange" event was triggered. Please do not
        update this private _changed property directly since its state is internally
        maintained by <set>. A copy of _changed can be acquired from <changedAttributes>
        method.
        */

        /* _previousAttributes:
        Internal private _previousAttributes hash containing all the previous
        attributes of a model being changed. Please do not
        update or access to this private _previousAttributes property directly
        since its state is internally maintained by <set>. A copy of
        _previousAttributes can be acquired from <previousAttributes>
        method, or more finely for a given attribute with <previous> API. Note
        that previous attributes are only available during the course of a "onChange"
        event. Without this, the entire notion of hasChanged() makes no sense.
        */

        /* _changing:
        Internal boolean flag to mark that this model is being changed.
        It is usefull in particular for nested calls to <set> to know that
        that they don't have to perform some stuff already done by the top nesting
        call to <set>. Nested calls to set can happen when listeners to changes
        themselves call the <set> method. */

        /* _pending:
        Internal private boolean to deal with changes that can be
        recursively nested within "onChange" events. */

        /* Group: Creating And Cloning Instances of Model.

            *Create and clone models with these two methods*.
        */

        /**
         * When creating an instance of a model, you can pass in the initial
         * values of the attributes, which will be set on the model.
         *
         * It is not recommended to override this {@link module:UWA/Class/Model.UWA.Class.Model#init|init}
         * method for the construction of an instance of a model. You should rather implement the
         * {@link module:UWA/Class/Model.UWA.Class.Model#setup|setup}
         * method, which will be invoked when the model is created.
         *
         * In rare cases, if you're looking to get fancy, you may want to override
         * this init constructor, which allows you to replace the actual constructor
         * function for your model. In this case, please call first the parent
         * {@link module:UWA/Class/Model.UWA.Class.Model#init|init} method in your
         * overridden {@link module:UWA/Class/Model.UWA.Class.Model#init|init}
         * method (see code example below)
         *
         * If you pass a `{collection: ...}` in the options, the model gains a
         * {@link module:UWA/Class/Model.UWA.Class.Model#collection|collection}
         * property that will be used to indicate which
         * {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
         * the model belongs to, and is used to help compute the model's
         * {@link module:UWA/Class/Model.UWA.Class.Model#url|url}.
         * This {@link module:UWA/Class/Model.UWA.Class.Model#collection|collection}
         * property is normally created automatically
         * when you first add a model to a collection. Note that the reverse is
         * not true, as passing this option to the constructor will not automatically
         * add the model to the collection. Useful, sometimes.
         *
         * If `{parse: true}` is passed as an option, the attributes will first be
         * converted by the {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse}
         * method before being set on the model.
         *
         * @param {Object} [attributes] - attributes hash
         * @param {Object} [options] - options hash
         *
         * @example
         * // A first example, provided that you have already defined a Book model :
         * var bookIRead = new Book({
         *     title: "One Thousand and One Nights",
         *     author: "Scheherazade"
         * });
         *
         * // Another example where the init constructor function is overriden :
         * // (not really pertinent since what is done in init could have simply
         * // done in setup.)
         * var Library = UWA.Class.Model.extend({
         *     init: function() {
         *         this._parent.apply(this, arguments);
         *         this.books = new Books();
         *     },
         *     parse: function(data, options) {
         *         this.books.reset(data.books);
         *         return data.library;
         *     }
         * });
         *
         * @constructs UWA.Class.Model
         * @memberof module:UWA/Class/Model
         */
        init: function (attributes, options) {

            var defaults,
                attrs = attributes || {};

            /**
             * A special property of models, the {@link module:UWA/Class/Model.UWA.Class.Model#cid|cid}
             * or client id is a unique identifier automatically generated and assigned to all
             * instances of models when they're first created. Client ids are handy when the
             * model has not yet been saved to the backend, and does not yet have
             * its eventual true {@link module:UWA/Class/Model.UWA.Class.Model#id|id},
             * but already needs to be visible in the UI. __Do not modify this
             * property, only meant to be read__.
             *
             * @name module:UWA/Class/Model.UWA.Class.Model#cid
             * @type {String}
             * @readonly
             */
            this.cid = "c" + (++modelIdCounter);
            this._attributes = {};

            if (options) {

                // Set current collection
                if (Core.is(options.collection)) {
                    /**
                     * A special property of models, {@link module:UWA/Class/Model.UWA.Class.Model#collection|collection}
                     * is a reference to the {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
                     * your model belongs to, if any. This {@link module:UWA/Class/Model.UWA.Class.Model#collection|collection}
                     * property is normally created automatically when you first add a model to a collection. *Most of
                     * the time, you do not need to use this property*, except maybe to compute your model's url.
                     * __Do not modify this property, only meant to be read or set at construction time__.
                     *
                     * @name module:UWA/Class/Model.UWA.Class.Model#collection
                     * @type {UWA.Class.Collection}
                     * @readonly
                     */
                    this.collection = options.collection;
                }

                // Allow parse attributes
                if (options.parse === true) {
                    attrs = (this.parse(attributes, options)) || {};
                }
            }

            // Merge attrs with defaults
            defaults = Core.result(this, 'defaults');
            if (Core.is(defaults)) {
                attrs = Core.merge(Core.clone(attrs, false), defaults);
            }

            // Set attrs value
            this.set(attrs, options);

            this._changed = {};
            this.setup.apply(this, arguments);
        },

        /**
         * Returns a new instance of the model with identical attributes.
         *
         * __Note that the cloned instance returned__:
         *
         * * does not register any of the listeners registered by the original
         * instance.
         * * does not belong to any collection, even if the original instance
         * belongs to a collection.
         *
         * __Note__: When cloning a model, in addition to the remarks made above, keep in
         * mind that _attributes values that are objects are not deep copied_.
         * The example below demonstrates this.
         * You can take care of this deep copy by yourself by overriding the
         * {@link module:UWA/Class/Model.UWA.Class.Model#init|init}
         * constructor, but be aware that performing a deep copy of attributes
         * values with {@link module:UWA/Core.clone|UWA.clone}
         * can become an expensive operation for very large, deep objects.
         *
         * @returns {UWA.Class.Model} - a new instance of the model with identical attributes.
         *
         * @example
         * var johnny, clone;
         *
         * johnny = new UWA.Class.Model({
         *     'name': 'John Doe',
         *     'address': { // a better code would have split this address
         *                  // into 4 separate attributes...
         *         'street': '1st Street',
         *         'city': 'Austin',
         *         'state': 'TX',
         *         'zipCode': 78701
         *     }
         * });
         *
         * clone = johnny.clone();
         * clone.set('name', 'John LookAlike');
         * clone.get('address').city = 'Dallas';
         *
         * JSON.stringify(johnny);
         * // this returns :
         * // {"name":"John Doe",
         * //  "address":{
         * //     "street":"1st Street",
         * //     "city":"Dallas", // <-----
         * //     "state":"TX",
         * //     "zipCode":78701
         * // }}
         * //
         * // As you can see, John Doe's 'address' value has changed
         * // (city is now Dallas), but not its
         * // 'name' attribute value. This is the expected behavior.
         * // A way to change this normal behavior is to override your contructor,
         * // but be aware of the performance hit... :
         *
         * MyModel = UWA.Class.Model.extend({
         *     init: function(attributes, options) {
         *         this._parent(UWA.clone(attributes), options); // a deep copy is performed.
         *     }
         * });
         */
        clone: function () {
            return new this.constructor(this._attributes);
        },

        /* Group: Methods & Properties To Be Overridden.

            *These are the methods and properties you should override/implement
            when defining your custom models by sub-classing {@link module:UWA/Class/Model|Model}*.
        */

        /**
         * Override this method to initialize a newly created instance of model.
         *
         * *Do not directly call {@link module:UWA/Class/Model.UWA.Class.Model#setup|setup}
         * in your application code. It is internally used and consequently only meant
         * to be overridden*
         *
         * Called when a new instance of a model is created, to initialize it.
         * Its use is optional; however it is a good practice to use it, that
         * is to say to implement it.
         *
         * The default implementation does nothing.
         *
         * It is passed the same arguments that were passed to the constructor
         * {@link module:UWA/Class/Model.UWA.Class.Model#init|init} method.
         *
         * @example
         * var Todo = UWA.Class.Model.extend({
         *     setup: function(){
         *         UWA.log('This model has been initialized.');
         *     }
         * });
         *
         * var myTodo = new Todo();
         * // Logs: This model has been initialized.
         */
        setup: function () {
            return;
        },

        /**
         * Override this method to implement, customize or fine-tune the manner
         * in which models are persisted in or fetched from the backend.
         *
         * This method is internally called by {@link module:UWA/Class/Model.UWA.Class.Model#save|save},
         * {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} and
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy}, *so
         * you're not meant to call directly this {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * method in your code*.
         *
         * By default, {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * makes a RESTful Ajax request to the
         * model's {@link module:UWA/Class/Model.UWA.Class.Model#url|url}, using
         * {@link module:UWA/Data.UWA.Data.request|UWA.Data.request}
         * API by default under the cover, unless you choose to use another Ajax
         * implementation by using the option 'ajax' (see below).
         * Consequently an error will be thrown if the model does not have an URL and
         * no url is passed as an option in the options hash.
         * The map from CRUD operation passed to HTTP verb used in Ajax request is
         * the following :
         *
         * * a 'create' operation will launch a POST request.
         * * a 'read' operation will launch a GET request.
         * * an 'update' operation will launch a PUT request.
         * * a 'patch' operation will launch a PATCH request.
         * * a 'delete' operation will launch a DELETE request.
         *
         * This default mapping can be easily
         * overridden if an options.method is passed to
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} :
         * ```
         * model.save(null, {
         *     method: 'PUT' // this will be passed to sync method
         *                   // and eventually to Data.request
         * });
         * ```
         *
         * In most of the cases, this default implementation should suffice your
         * needs (especially if you deal with a RESTful backend API), with some
         * little tweaks. So before overriding
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} on your
         * model definition, think about you can achieve the same result just
         * by passing the appropriate options and overriding the
         * {@link module:UWA/Class/Model.UWA.Class.Model#url|url} method or
         * {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot} property.
         *
         * Here is an example about how the default behavior of
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} can be
         * (indirectly by {@link module:UWA/Class/Model.UWA.Class.Model#save|save})
         * used to endorse/un-endorse a Post item in the backend :
         * ```
         * var Post, p;
         *
         * Post = UWA.Class.Model.extend({
         *     urlRoot: '/Posts',
         *
         *     idAttribute: 'pid',
         *
         *     save: function (attrs, options) {
         *         options = UWA.extend({}, options);
         *         if (!this.isNew()) {
         *             options.url += UWA.Utils.toQueryString(this.pick(this.idAttribute))
         *         } else {
         *             options.url = '/NewPost';
         *         }
         *         return this._parent(attrs, options);
         *     },
         *
         *     toggleLikeStatus: function () {
         *         return this.save({
         *             endorsed: !this.get('endorsed')
         *         }, {
         *             url: this.urlRoot + '/endorse'
         *         });
         *     }
         * });
         *
         * p = new Post();
         * p.save(); // this launches a HTTP POST request to '/NewPost'
         * p.set('pid', 'post1'); // to simulate in this example an identification returned by the backend
         * p.toggleLikeStatus(); // this launches a HTTP PUT request to '/Posts/endorse?pid=post1'
         * ```
         *
         * Now if you want to override this {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * method for fine-tuning, your implementation must fulfill this specification :
         *
         * * it is passed the CRUD operation name ("create", "read", "patch", "update"
         *     or "delete"), the model in question and an hash
         *     of options passed by the callees (at least
         *     {@link module:UWA/Class/Model.UWA.Class.Model#save|save},
         *     {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} and
         *     {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy}
         *     but also any custom API of your own making calls to
         *     {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}).
         * * Regarding the options being passed, it is recommended to shallow
         *     clone this options hash in your implementation and possibly
         *     extend this clone. Then pass it to any underlying API you are
         *     using that takes options as input (such as UWA.Data.request)
         * * options.onFailure (if provided) must be called (synchronously or
         *     asynchronously) upon failure of your backend to complete the operation
         *     passed as argument. The response of the backend must be passed
         *     to onFailure. Generally this is an error message.
         * * options.onComplete (if provided) must be called (synchronously or
         *     asynchronously) after the successful completion in the backend
         *     of the operation passed as argument. The response of the
         *     backend must be passed to onComplete. This response must be
         *     parsable by your implementation of {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse}
         *     so that the model attributes are correctly updated automatically.
         * * it must return a request object with a cancel() method to cancel the
         *     operation. If the operation is synchronous and consequently not
         *     cancellable, just return a dummy cancel() method on this object.
         *     If you use XmlHttpRequest, return it.
         *
         * You never have to deal with setting/unsetting attributes of the model
         * in your overridden implementation of {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}.
         * This is done by the callers {@link module:UWA/Class/Model.UWA.Class.Model#save|save},
         * {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} and
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy}. See the
         * implementation example below.
         *
         * __Some possible customizations could be__:
         *
         * * Use setTimeout to batch rapid-fire updates into a single request.
         * * Send up the models as XML instead of JSON.
         * * Persist models via WebSockets instead of Ajax.
         * * Persist models into Local Storage instead of Ajax.
         * * etc.
         *
         * @param {Object} method - the CRUD operation to perform. Can be one of 'create', 'update', 'patch', 'delete' or 'read'
         * @param {Object} model - the model to be synchronized.
         * @param {Object} [options] - hash of options
         * @param {Function} [options.ajax=null] - Allow to specify another function for
         *                                       Ajax requests than {@link module:UWA/Data.UWA.Data.request|UWA.Data.request}.
         *                                       The function passed must have the same signature as
         *                                       {@link module:UWA/Data.UWA.Data.request|UWA.Data.request} and
         *                                       call the same onComplete and onFailure callbacks. See
         *                                       documentation of {@link module:UWA/Data.UWA.Data.request|UWA.Data.request}
         *
         * @return {Object} - An object that contains the cancel method to cancel the
         * CRUD operation. (typically for example a
         * {@link module:UWA/Data.UWA.Data.request|UWA.Data.request}). Note that
         * the response headers are available available as `options.responseHeaders`
         *
         * @example
         * // Provided that we have a Safe object is capable to deal with find,
         * // findAll, insert, update and remove operations of models..., here is
         * // an example of a custom implementation of sync :
         *
         * var MyPreciousModel;
         *
         * MyPreciousModel = UWA.Class.Model.extend({
         *
         *     sync: function (method, model, options) {
         *         var id, attrs, idAttrName, resp, errorMessage;
         *
         *         if (method === 'create' || method === 'update' || method === 'patch') {
         *             attrs = model.toJSON(options);
         *         }
         *         id = model.id;
         *         idAttrName = model.idAttribute;
         *
         *         try {
         *             switch (method) {
         *             case "read":
         *                 resp = Core.is(id) ? this.safe.find(id) : this.safe.findAll();
         *                 break;
         *             case "create":
         *                 resp = this.safe.insert(attrs, idAttrName);
         *                 break;
         *             case "update":
         *             case "patch":
         *                 resp = this.safe.update(id, attrs);
         *                 break;
         *             case "delete":
         *                 resp = this.safe.remove(id);
         *                 break;
         *             default:
         *                 throw new Error(UWAString.format('Unsupported method "{0}"', method));
         *             }
         *
         *         } catch (error) {
         *             errorMessage = error.message;
         *         }
         *
         *         if (resp) {
         *             if (options && options.onComplete) {
         *                 options.onComplete(resp);
         *             }
         *         } else {
         *             if (options && options.onFailure) {
         *                 options.onFailure(errorMessage || UWAString.format('Model "{O}" not found in the safe', id));
         *             }
         *         }
         *
         *         // return a dummy obj with a cancel() method since
         *         // operations in this.safe are synchronous and not
         *         // cancellable.
         *         return {
         *             cancel: function () {
         *                 return;
         *             }
         *         };
         *     }
         * });
         *
         * slushFund = new MyPreciousModel({
         *     id: 'bahamas_offshore'
         * });
         * slushFund.safe = new Safe(...);
         * slushFund.fetch();
         * slushFunc.set('owner', 'Norbert Damoff');
         * sluchFund.save();
         */
        sync: function (method, model, options) {

            var request;

            if (!Core.is(options)) {
                options = {};
            }

            // Use Data.request as default implementation for ajax calls :
            var ajax = Core.is(options.ajax, 'function') ? options.ajax : Data.request;

            // Default request options :
            var params = {
                method: methodMap[method],
                type: 'json',
                headers: {}
            };

            // Ensure that we have a URL :
            if (!options.url) {
                params.url = (Core.result(model, 'url')) || urlError();
            }

            // Ensure that we have the appropriate request data :
            if ((!Core.is(options.data)) && model && (method === 'create' || method === 'update' || method === 'patch')) {
                params.headers['Content-Type'] = "application/json";
                params.data = options.attrs || (model.toJSON(options));
            }

            // By default, data passed in to the data option as an object
            // (technically, anything other than a string) will be processed
            // by UWA.Ajax using Utils.toQueryString and
            // transformed into a query string. We don't want UWA.Ajax to
            // process our data this way for non-GET requests, so we convert
            // it into a string by ourselves using JSON.stringify :
            if (params.method !== 'GET' && Core.is(params.data, 'object')) {
                params.data = JSON.stringify(params.data);
            }

            // Wrap the original onComplete and onFailure callbacks to pass
            // along the response headers from Data.request into options.responseHeaders :
            var onComplete = options.onComplete;
            options.onComplete = function (resp, headers) {
                var status;
                if (request) {
                    status = request.xhr ? request.xhr.status : 200;
                } else {
                    status = 200;
                }
                options.responseHeaders = headers;
                if (onComplete) {
                    // @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
                    onComplete((method === 'delete' && (status === 202 || status === 204)) ? undefined : resp);
                }
            };
            var onFailure = options.onFailure;
            // Also build a comprehensive response for onFailure :
            options.onFailure = function (error, resp, headers) {
                options.responseHeaders = headers;
                if (onFailure) {
                    if (!resp || 0 === resp.length) {
                        resp = error.message || '';
                    }
                    onFailure(resp);
                }
            };

            // Build the request options, allowing the user to override any Ajax options :
            var reqOpts = Core.extend(params, options);

            // Perform the request :
            request = options.request = ajax(reqOpts.url, reqOpts);

            model.dispatchEvent('onRequest', [model, request, options]);

            return request;
        },

        /**
         * Override this method to transform the raw backend response into an hash
         * of attributes for the model.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse}
         * is called whenever a model's data is returned by the backend,
         * in {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch}, and
         * {@link module:UWA/Class/Model.UWA.Class.Model#save|save}. The function
         * is passed the raw response object, and should return the attributes hash
         * to be set on the model.
         *
         * The default implementation is a no-op, simply passing through the
         * raw response from the backend, considering it is valid JSON data.
         * Override this if you need to work with a preexisting APIs
         * (which will be your case most of the time indeed), or see with the backend
         * developers if they can better namespace their responses (which is an
         * even better solution if you can!).
         *
         * __Notes__:
         *
         *   * You are not allowed to change the id of your model during
         *       {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse}
.        *       Use {@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|idAttribute}
         *       instead.
         *   * {@link module:UWA/Class/Model.UWA.Class.Model#parse|parse} is an
         *       excellent place to extract and vivify incoming nested JSON into
         *       associated submodels.
         *
         * @param {Object} resp - the raw response from the backend, to be parsed.
         * @param {Object} options - hash of options passed by the calling API (save, fetch, ...)
         *
         * @return {Object} - the attributes hash to be set on the model
         *
         * @example
         * // Here is a small tip about how to deal with a backend sending responses
         * // in different formats for each C/R/U/D operation, which is a common use
         * // case.
         *
         * MyModel = UWA.Class.Model.extend({
         *     // we override sync so that the C/R/U/D operation type is sent
         *     // to the APIs making calls to parse (namely save, destroy, fetch)
         *     // in the options hash :
         *     sync: function (method, model, options) {
         *         options.operation = method;
         *         return this._parent.apply(this, arguments);
         *     },
         *
         *     // now parse will be passed the C/R/U/D operation type in options,
         *     // allowing you to deal with heterogenous response formats from
         *     // your ennoying backend :
         *     parse: function (response, options) {
         *         var attrs;
         *         switch (options.operation) {
         *             case 'create' :
         *                 // parse the backend response to creation ...
         *                 break;
         *             case 'delete' :
         *                 // parse the backend response to deletion ...
         *                 break;
         *             case ...
         *         }
         *         return attrs;
         *     }
         * });
         */
        parse: function (resp) {
            return resp;
        },

        /**
         * Override this method (undefined by default) to implement your custom
         * validation logic of the attributes.
         *
         * This method is left undefined, and you're encouraged to override it
         * with your custom validation logic, if you have any that can be
         * performed in JavaScript. By default {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * is called before {@link module:UWA/Class/Model.UWA.Class.Model#save|save},
         * but can also be called before {@link module:UWA/Class/Model.UWA.Class.Model#set|set}
         * if `{validate:true}` is passed.
         * The {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * method is passed the model attributes, as well as the
         * options from {@link module:UWA/Class/Model.UWA.Class.Model#set|set}
         * or {@link module:UWA/Class/Model.UWA.Class.Model#save|save}. If the
         * attributes are valid, don't return anything from
         * {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate};
         * if they are invalid, return an error of
         * your choosing. It can be as simple as a string error message to be
         * displayed, or a complete error object that describes the error
         * programmatically. If {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * returns an error, {@link module:UWA/Class/Model.UWA.Class.Model#save|save}
         * will not continue, and the model attributes will not be modified in the
         * backend. Failed validations trigger an "onValidationFailure" event, and set the
         * {@link module:UWA/Class/Model.UWA.Class.Model#validationError|validationError}
         * property on the model with the value returned by this method.
         *
         * "onValidationFailure" events are useful for providing coarse-grained
         * error messages at the model or collection level.
         *
         * @param {Object} attributes - the hash of attributes to validate
         * @param {Object} [options] - hash of options
         *
         * @return {Void} If the attributes are valid, don't return
         *   anything from {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate};
         *   if they are invalid, return an error of your choosing. It can be as
         *   simple as a string error message to be displayed, or a complete error
         *   object that describes the error programmatically.
         *
         * @example
         * var Chapter = UWA.Class.Model.extend({
         *   validate: function(attrs, options) {
         *     if (attrs.end < attrs.start) {
         *       return "can't end before it starts";
         *     }
         *   }
         * });
         *
         * var one = new Chapter({
         *   title : "Chapter One: The Beginning"
         * });
         *
         * one.addEvent("onValidationFailure", function(model, error) {
         *   alert(model.get("title") + " " + error);
         * });
         *
         * one.save({
         *   start: 15,
         *   end:   10
         * });
         * @method module:UWA/Class/Model.UWA.Class.Model#validate
         */

        // internal method that is making use of <validate>, if defined...
        /**
         * @private
         */
        _validate: function (attrs, options) {
            var error;

            if (!(options.validate && this.validate)) {
                return true;
            }

            attrs = Core.extend(Core.extend({}, this._attributes), attrs);

            /**
             * Error value returned by {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
             * during the last failed validation of this model. It can consequently be of any type (string,
             * object, ...) depending on what you choose to return in your implementation
             * of {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}.
             * __Do not modify this property, only meant to be read__.
             *
             * @name module:UWA/Class/Model.UWA.Class.Model#validationError
             * @type {Void}
             * @readonly
             */
            error = this.validationError = (this.validate(attrs, options)) || null;

            if (!error) {
                return true;
            }

            this.dispatchEvent('onValidationFailure', [this, error, Core.extend(options, {validationError: error})]);

            return false;
        },

        /**
         * Override this method to return the relative or absolute URL of the model
         * in the backend.
         *
         * *Normally you should not call {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * in your application code. It is internally used and consequently only
         * meant to be overridden*
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * returns the relative or absolute (depending if your backend is
         * on a different domain) URL where the model's resource would be located
         * on the backend. If your models URLs logic is different, override
         * this method with the correct logic.
         *
         * The default implementation of {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * generates URLs of the form "[model.collection.url]/[model.id]", but you
         * may override this url format by specifying an explicit
         * {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot}
         * if the model's collection shouldn't be taken into account.
         * See {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot}
         * property.
         *
         * If {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot}
         * is not defined, this default implementation delegates to
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#url|UWA.Class.Collection.url}
         * to generate the URL, so make sure that you have it defined, or a
         * {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot} property,
         * if all models of this class share a common root URL. A model with an
         * id of 101, stored in a {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
         * with an url property of "/documents/7/notes", would have this URL:
         * "/documents/7/notes/101"
         *
         * Once again, if your models URLs logic is totally different, simply
         * override and redefine this {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * method with your own logic.
         *
         * Another way to specify URLs is to pass an {url: ...} option to the
         * {@link module:UWA/Class/Model.UWA.Class.Model#save|save},
         * {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} or
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy} API,
         * this option will take precedence over this {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * method in the default implementation of {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}.
         *
         * @returns {String} - The relative or absolute URL of the model's resource on the backend.
        */
        url: function () {
            var url;
            url = (Core.result(this, 'urlRoot')) || (Core.result(this.collection, 'url')) || urlError();
            if (!this.isNew()) {
                url += url.charAt(url.length - 1) === '/' ? '' : '/';
                url += encodeURIComponent(this.id);
            }
            return url;
        },

        /**
         * Define this property if you're using a model outside of a collection.
         *
         * Define this property if you're using a model outside
         * of a collection, to enable the default {@link module:UWA/Class/Model.UWA.Class.Model#url|url}
         * function to generate URLs
         * based on the model id : "[urlRoot]/id"
         * Normally, you won't need to define this.
         * Note that {@link module:UWA/Class/Model.UWA.Class.Model#urlRoot|urlRoot}
         * may also be a function.
         *
         * @member {String|Function} module:UWA/Class/Model.UWA.Class.Model#urlRoot
         */

        /**
         * Override this property to transparently map from the unique
         * identifying key in the backend to this model's
         * {@link module:UWA/Class/Model.UWA.Class.Model#id|id}.
         * By default, the model's unique identifier is stored under
         * the 'id' attribute in the backend.
         * If you are directly communicating with a backend that uses a different
         * unique key, you may set a Model's
         * {@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|idAttribute}
         * to transparently map from that key to {@link module:UWA/Class/Model.UWA.Class.Model#id|id}.
         *
         * @example
         * // Say that we work with a backend that identifies users with
         * // the attribute/field 'user_ID', by specifying it in the
         * // idAttribute property, it's a no brainer for the client side
         * // code :
         * var UserModel = UWA.Class.Model.extend({
         *     idAttribute: 'user_ID'
         * });
         *
         * var user1 = new UserModel({
         *     firstname: 'Colin',
         *     lastname: 'newman'
         * });
         *
         * user1.save(null, {
         *     onComplete: function () {
         *         UWA.log(user1.id); // logs the id of user1,
         *                            // that is indeed the value in the id column
         *                            // 'user_ID' in the database...
         *     }
         * });
         *
         * @default 'id'
         * @type {String}
         */
        idAttribute: 'id',

        /**
         * Define this property to specify the default attributes values hash
         * for the model.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#defaults|defaults}
         * hash (or function) can be used to specify the default
         * attributes values for the model. When creating an instance
         * of the model, any unspecified attributes will be set to their default value.
         *
         * Note that {@link module:UWA/Class/Model.UWA.Class.Model#defaults|defaults}
         * may also be a function.
         *
         * @example
         * // Here is an example that show how you can make use of default
         * // attributes values as placeholders for a form or whatever :
         * var User = UWA.Class.Model.extend({
         *     validate: function(attributes) {
         *         // Here some validation code of the attributes
         *         // so that we make sure data is valid before save()...
         *     },
         *
         *     defaults: {
         *         'name': 'Type your name', // ok, this is obvious :)
         *         'street': 'Type your street',
         *         'city': 'Type your city',
         *         'state': 'Type your state code',
         *         'zipCode': 'Type your zip code'
         *     }
         * });
         *
         * // Another example :
         * // Whenever you want to inherit from and extend default attributes
         * // from a parent model, use this pattern of code :
         * var ChildModel = ParentModel.extend({
         *     defaults: function () {
         *         var parentDefaults = ParentModel.prototype.defaults;
         *         if (UWA.is(parentDefaults, 'function')) {
         *             parentDefaults = parentDefaults();
         *         }
         *         // In any case, clone what we got from the parent :
         *         parentDefaults = UWA.clone(parentDefaults, false);
         *         return UWA.extend(parentDefaults || {}, {
         *             'extra_attr' : 'nice to have!'
         *         });
         *     }
         * });
         *
         * @member {String|Function} module:UWA/Class/Model.UWA.Class.Model#defaults
         */

        /* Group: Mutator methods

            *These methods modify the attributes of the model*.
        */

        /**
         * Set a hash of attributes (one or many) on the model.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#set|set} sets a hash of
         * attributes (one or many) on the model. If any of the
         * attributes change the model's state, a "onChange" event will be triggered
         * on the model. Change events for specific attributes are also triggered,
         * and you can bind to those as well, for example: "onChange:title", and
         * "onChange:content". You may also pass individual keys and values.
         *
         * The signature handles both "key", value and {key: value} -style arguments.
         * See example of code below.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#set|set} accepts as an
         * optional last argument an hash of options, that
         * will be passed to {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * if defined and also attached to the onChange
         * events sent. You can also pass the option `{silent: true}` to silently
         * set attributes (in this case onChange events will not be fired).
         *
         * Note that calling `m.set('attr', undefined)` if equivalent to calling
         * `m.unset('attr')`, but prefer {@link module:UWA/Class/Model.UWA.Class.Model#unset|unset}
         * in your code.
         *
         * @return {Boolean}
            * true if succeeded to set the hash of attributes on the model.
            * false if validation of attributes was required but failed.
         *
         * @example:
         *   // Setting up several attributes with an hash :
         *   note.set({
         *       title: "March 20",
         *       content: "In his eyes she eclipses..."
         *   });
         *
         *   // Setting up a single attribute :
         *   book.set("title", "A Scandal in Bohemia");
         *
         * See Also:
         *   {@link module:UWA/Class/Model.UWA.Class.Model#unset|unset},
         *   {@link module:UWA/Class/Model.UWA.Class.Model#clear|clear}

         */
        set: function (key, val, options) {

            /*jshint maxstatements: 47*/
            var attr, attrs,
                change, changes, changing, changed, current, prev, i, len, unset, silent;

            if (key) {

                // Handle both "key", value and {key: value} -style arguments:
                if (Core.is(key, 'object')) {
                    attrs = key;
                    options = val || {};
                } else {
                    attrs = {};
                    attrs[key] = val;
                    options = options || {};
                }

                // Run validation :
                if (!this._validate(attrs, options)) {
                    return false;
                }

                // Extract attributes and options.
                unset = options.unset;
                silent = options.silent;
                changes = [];
                changing = this._changing;
                this._changing = true;

                if (!changing) {
                    this._previousAttributes = Core.clone(this._attributes, false);
                    this._changed = {};
                }

                // Check for changes of id :
                // (note: no need to use if (idAttribute in attrs), hasOwnProperty is OK)
                if (attrs.hasOwnProperty(this.idAttribute)) {
                    /**
                     * A special property of instance of models, the
                     * {@link module:UWA/Class/Model.UWA.Class.Model#id|id}
                     * is an arbitrary string (integer id or UUID). If you set the
                     * {@link module:UWA/Class/Model.UWA.Class.Model#id|id} in
                     * the attributes hash (using {@link module:UWA/Class/Model.UWA.Class.Model#set|set}), it
                     * will be copied onto the model as this direct property
                     * {@link module:UWA/Class/Model.UWA.Class.Model#id|id}. Models can be
                     * retrieved by id from collections, and the id is used to generate model
                     * URLs by default.
                     *
                     * Think of this property model.id as a shortcut for
                     * `model.get(model.idAttribute)`.
                     *
                     * __Do not modify this property, only to be read.__
                     *
                     * @name module:UWA/Class/Model.UWA.Class.Model#id
                     * @type {String}
                     * @readonly
                     */
                    this.id = attrs[this.idAttribute];
                }

                // to avoid repeated dereferencing in the loop just below.
                current = this._attributes;
                prev = this._previousAttributes;
                changed = this._changed;

                // For each set attribute, update or delete the current value :
                // (note: This code could probably be optimized if Core.equals
                // returned the diff between the two compared objects? Only two
                // calls to Core.equals would be performed then?)
                for (attr in attrs) {

                    val = attrs[attr];

                    if (!Core.equals(current[attr], val)) {
                        changes.push(attr);
                    }

                    if (Core.equals(prev[attr], val)) {
                        delete changed[attr];
                    } else {
                        changed[attr] = val;
                    }

                    if (unset) {
                        delete current[attr];
                    } else {
                        current[attr] = val;
                    }
                }

                // Trigger all relevant attribute changes:
                if (!silent) {

                    if (changes.length) {
                        this._pending = true;
                    }

                    for (i = 0, len = changes.length; i < len; i++) {
                        change = changes[i];
                        this.dispatchEvent("onChange:" + change, [this, current[change], options]);
                    }
                }

                if (!changing) {

                    if (!silent) {

                        // there's a while loop here because changes can be
                        // recursively nested within "onChange" events.
                        while (this._pending) {
                            this._pending = false;
                            this.dispatchEvent('onChange', [this, options]);
                        }
                    }

                    this._pending = false;
                    this._changing = false;
                }
            }

            return true;
        },

        /**
         * Remove an attribute of the model.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#unset|unset}
         * removes an attribute by deleting it from the internal attributes hash.
         * Fires a "onChange" event unless silent is passed as an option.
         * If the attribute does not exist, nothing is performed.
         *
         * @param {String} attr - the name of the attribute to remove.
         * @param {Object} [options] - hash of options. If silent is passed as
         *       an option, no "onChange" event is fired.
         *
         * @return {Boolean}
         *  * true if succeeded to remove the attribute of the model
         *  * false if validation of attributes was required but failed.
         */
        unset: function (attr, options) {
            return this.set(attr, undefined, Core.extend(Core.extend({}, options), {
                unset: true
            }));
        },

        /**
         * Removes all attributes from the model.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#clear|clear} removes all
         * attributes from the model, including the {@link module:UWA/Class/Model.UWA.Class.Model#id|id}
         * attribute.
         * Fires a "onChange" event unless `{ silent: true }` is passed as an option.
         *
         * @param {Object} [options] - hash of options. If silent is passed as
         *       an option, no "onChange" event is fired.
         *
         * @return {Boolean}
         *  * true if succeeded to remove all attributes from the model.
         *  * false if validation of attributes was required but failed.
         */
        clear: function (options) {

            var key,
                attrs = {};

            options = options ? Core.clone(options) : {};

            // i could make use of <keys> API here ...
            for (key in this._attributes) {
                attrs[key] = undefined;
            }

            return this.set(attrs, Core.extend(options, {
                unset: true
            }));
        },

        /* Group: Accessor methods

            *These methods do not modify the model's attributes and return some
            representation of the attributes*.
        */

        /**
         * Get the current value of an attribute from the model.
         *
         * @param {String} attr - the name of the attribute which value to be retrieved
         *
         * @return {Void} The value of the attribute.
         *
         * @example
         * var aNote = new Note({
         *     title:'a note'
         * });
         * aNote.get('title'); // returns 'a note'
         */
        get: function (attr) {
            return this._attributes[attr];
        },

        /**
         * Similar to {@link module:UWA/Class/Model.UWA.Class.Model#get|get}, but
         * returns the HTML-escaped version of an
         * attribute of this model. If you're interpolating data from the model
         * into HTML, using escape to retrieve attributes will prevent XSS attacks.
         *
         * @param {String} attr - the name of the attribute which value to escape.
         *
         * @return {String} the HTML-escaped version of attr
         *
         * @example
         *   var hacker = new UWA.Class.Model({
         *       name: "<script>console.log('xss')</script>"
         *   });
         *
         *   UWA.log(hacker.escape('name'));
         */
        escape: function (attr) {
            var value = this.get(attr);
            return !Core.is(value) ? '' : UWAString.escapeHTML(value.toString());
        },

        /**
         * Returns true if the attribute is set to a non-null or non-undefined value.
         *
         * @param {String} attr - the name of the attribute to check.
         *
         * @return {Boolean} return true if the attribute is set to a non-null or
         *       non-undefined value, false otherwise.
         *
         * @example
         * if (note.has("title")) {
         *     ...
         * }
         */
        has: function (attr) {
            return Core.is(this.get(attr));
        },

        /**
         * Returns the names of the model's attributes.
         *
         * @return {Array} an array containing the names of the model's attributes.
         *
         * @example
         * var model = new UWA.Class.Model({
         *     one : 1,
         *     two : 2,
         *     three : 3
         * });
         * model.keys();
         * // returns ["one", "two", "three"]
         */
        keys: function () {
            return Object.keys(this._attributes);
        },

        /**
         * Return all of the values of the model's attributes.
         *
         * @return {Array} an array containing the values of the model's attributes.
         *
         * @example
         * var model = new UWA.Class.Model({
         *     one : 1,
         *     two : 2,
         *     three : 3
         * });
         * model.values();
         * // returns [1, 2, 3]
         */
        values: function () {

            var i, l,
                attrs = this.keys(),
                values = [];

            for (i = 0, l = attrs.length; i < l; i++) {
                values.push(this.get(attrs[i]));
            }

            return values;
        },

        /**
         * Returns the model's attributes into a list of [key, value] pairs.
         *
         * @return {Array} an array containing [key, value] pairs
         *
         * @example
         * var model = new UWA.Class.Model({
         *     one : 1,
         *     two : 2,
         *     three : 3
         * });
         * model.pairs();
         * // returns [['one', 1], ['two', 2], ['three', 3]]
         */
        pairs: function () {

            var i, l, attr,
                attrs = this.keys(),
                pairs = [];

            for (i = 0, l = attrs.length; i < l; i++) {
                attr = attrs[i];
                pairs.push([attr, this.get(attr)]);
            }

            return pairs;
        },

        /**
         * Return a shallow copy (see {@link module:UWA/Core.UWA.clone|UWA.clone})
         * of the model's attributes.
         *
         * This can be used for persistence, serialization, or for augmentation
         * before being sent to the backend. So you might need to override this
         * method to suit your persistence/serialization needs...
         *
         * Note that the name of this method is a bit confusing (since its does not actually
         * returns a JSON string), but it conforms to
         * ,
         * in that way that it will be called by JSON.stringify to
         * determine the model's JSON representation.
         *
         * @param {Object} [options] - hash of options passed by the calling API (save, fetch, ...)
         *
         * @return {Object} a shallow copy of this model's attributes.
         *
         * @example
         * var artist = new UWA.Class.Model({
         *     firstName: "Wassily",
         *     lastName: "Kandinsky"
         * });
         *
         * artist.set({birthday: "December 16, 1866"});
         *
         * UWA.log(JSON.stringify(artist)); // JSON.stringify called the toJSON()
         *                                  // method to determine the model's
         *                                  // JSON representation
         */
        toJSON: function () {
            return Core.clone(this._attributes, false);
        },

        /**
         * Returns a copy of the model's attributes containing only the
         * whitelisted attributes.
         *
         * @param {...string} - an attribute name or an array of attributes names
         *
         * @return {Object} a copy of the whitelisted model's attributes
         *
         * @example
         * var model = new UWA.Class.Model({
         *     name : 'moe',
         *     age: 50,
         *     userid : 'moe1'
         * });
         * model.pick('name', 'age');
         * // returns {name : 'moe', age : 50}
         *
         * model.pick(['age', 'userid']);
         * // returns {age : 50, userid : 'moe1'}
         *
         * model.pick(['name'], 'age', 'userid');
         * // returns {name : 'moe', age : 50, userid : 'moe1'}
         */
        pick: function () {

            var that = this,
                copy = {},
                attrs = getArgsArray(arguments);

            attrs.forEach(function (attr) {
                if (that.has(attr)) {
                    copy[attr] = that.get(attr);
                }
            });

            return copy;
        },

        /**
         * Returns a copy of the model's attributes without the
         * blacklisted attributes.
         *
         * @param {...string} - an attribute name or an array of attributes names
         *
         * @return {Object} a copy of the model's attributes without the
         *   blacklisted attributes.
         *
         * @example
         * var model = new UWA.Class.Model({
         *     name : 'moe',
         *     age: 50,
         *     userid : 'moe1'
         * });
         * model.omit('name', 'age');
         * // returns {userid : 'moe1'}
         *
         * model.omit(['age', 'userid']);
         * // returns {name : 'moe'}
         *
         * model.omit(['name'], 'age', 'userid');
         * // returns {}
         */
        omit: function () {

            var i, l, attr,
                copy = {},
                blacklist = getArgsArray(arguments),
                attrs = this.keys();

            for (i = 0, l = attrs.length; i < l; i++) {
                attr = attrs[i];
                if (blacklist.indexOf(attr) === -1) {
                    // not found in blacklist, let's add it to the copy :
                    copy[attr] = this.get(attr);
                }
            }

            return copy;
        },

        /**
         * Returns true if the model has not yet been saved into the backend, false
         * otherwise.
         *
         * Has this model been saved to the backend yet? If the model does not
         * yet have an {@link module:UWA/Class/Model.UWA.Class.Model#id|id},
         * it is considered to be new.
         *
         * @return {Boolean} true if this model is new, false otherwise.
         */
        isNew: function () {
            return !Core.is(this.id);
        },

        /**
         * Run {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * to check this model state.
         *
         * @param {Object} options - Options hash.
         *
         * @return {Boolean} true if this model state is valid, false otherwise.
         *
         * @example:
         * var Chapter = UWA.Class.Model.extend({
         *     validate: function (attrs, options) {
         *         if (attrs.end < attrs.start) {
         *             return "can't end before it starts";
         *         }
         *     }
         * });
         *
         * var one = new Chapter({
         *     title: "Chapter One: The Beginning"
         * });
         *
         * one.set({
         *     start: 15,
         *     end: 10
         * });
         *
         * if (!one.isValid()) {
         *     alert(one.get("title") + " " + one.validationError);
         * }
         */
        isValid: function (options) {
            return !this.validate || !this.validate(this._attributes, options);
        },

        /* Group: Methods to call by listeners of 'onChange' events.

            *These methods are to be used during the course of a "onChange"
            event (that is to say called in callbacks listening to changes)*.
        */

        /**
         * Returns true if the model has changed since the last "onChange" event.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#hasChanged|hasChanged}
         * returns true if the model has changed since the last "onChange" event.
         * *This method is to be used during the course of a "onChange"
         * event (that is to say called in your callback listening to changes), to
         * check if some specific attribute has changed since the last "onChange"
         * event.* (see example below).
         *
         * @param {String} [attr] - If an attribute is passed, returns true if that specific
         *       attribute has changed.
         *
         * @return {Boolean} true if if the model has changed since the last "onChange" event.
         *
         * @example
         * var bookIRead = new Book({
         *     title:'Alice In Wonderland'
         * });
         * bookIRead.addEvent("onChange", function() {
         *     if (bookIRead.hasChanged("title")) {
         *         ...
         *     }
         * });
         */
        hasChanged: function (attr) {

            var key,
                hasChanged = false,
                changed = this._changed;

            if (changed) {
                if (Core.is(attr)) {
                    hasChanged = Core.owns(changed, attr);
                } else {

                    for (key in changed) {
                        if (Core.owns(changed, key)) {
                            hasChanged = true;
                            break;
                        }
                    }
                }
            }

            return hasChanged;
        },

        /**
         * Retrieve a hash of only the model's attributes that have changed.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#changedAttributes|changedAttributes}
         * retrieve a hash of only the model's attributes that have changed, or
         * false if there are none.
         * This can be used to figure out which portions of a UI
         * should be updated, or what calls need to be made to sync the changes
         * to the backend. Note that unset attributes will be set to undefined in
         * the returned hash.
         * You can also pass an attributes object to diff against the model,
         * determining _if there would be a change_.
         * So, this method can be used during the course of a "onChange"
         * event (that is to say called in your callback listening to changes), to
         * detect the changes from the previous version of the object.
         * *But alternately, you can use this method outside the course of a
         * "onChange" event, passing a diff hash to determine what would be
         * the changes if this hash was passed to {@link module:UWA/Class/Model.UWA.Class.Model#set|set}*.
         *
         * @param {Object} [diff] - an external attributes hash can be passed in,
         *       returning the attributes in that hash which differ from the model.
         *
         * @return {Object|false} - hash of only the model's attributes that
         * have changed, or false if there are none.
         */
        changedAttributes: function (diff) {

            var changed, attr,
                changedAttrs = false;

            if (Core.is(diff, 'object')) {

                // If called outside the course of an "onChange" event (that is
                // to say if this._changing is false), diff is compared
                // against the current attributes (this._attributes), otherwise
                // against the _previousAttributes:
                changed = this._changing ? this._previousAttributes : this._attributes;

                for (attr in diff) {
                    if (!Core.equals(changed[attr], diff[attr])) {
                        changedAttrs = changedAttrs || {};
                        changedAttrs[attr] = diff[attr];
                    }
                }

            } else if (this.hasChanged()) {
                changedAttrs = Core.clone(this._changed, false);
            }

            return changedAttrs;
        },

        /**
         * Get the previous value of a changed attribute.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#previous|previous}
         * returns the previous value of a changed attribute.
         * *This method is to be used during the course of a "onChange"
         * event (that is to say called in your callback listening to changes),
         * to get the previous value of a changed attribute.*
         * (see example below).
         *
         * @param {String} attribute - the name of the attribute
         * @return {Void} previous value of the changed attribute.
         *
         * @example
         * var actress = new Model({
         *     name: "Norma Jeane Baker"
         * });
         * actress.addEvent("onChange:name", function (model, name) {
         *     alert("Changed name from " + actress.previous("name") + " to " + name);
         * });
         * actress.set({name : "Marilyn Monroe"});
         */
        previous: function (attr) {
            var previousAttrs = this._previousAttributes;
            return Core.is(attr) && previousAttrs ? previousAttrs[attr] : null;
        },

        /**
         * Return a copy of the model's previous attributes.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#previousAttributes|previousAttributes}
         * returns a copy of the model's previous attributes. Useful for getting
         * a diff between versions of a model. Also useful for getting back to a
         * valid state after a backend-side error occurs during save or update.
         * This allows for example to immediately update an UI when the user
         * makes a change to the model, without waiting for the response of the
         * call made to the backend to persist the changes. If the backend rejects
         * the request or executes it differently, the client can be restored to
         * its previous valid state.
         *
         * *This method is to be used during the course of a "onChange"
         * event (that is to say called in your callback listening to changes), to
         * get a copy of the model's previous attributes.*
         *
         * @return {Object} a copy of the model's previous attributes.
         */
        previousAttributes: function () {
            return Core.clone(this._previousAttributes, false);
        },

        /* Group: Methods performing CRUD operations in the backend

            *These methods performs Create, Read, Update or Delete operations
            in the backend.*

        */

        /**
         * Save the model in the backend (e.g CREATE/UPDATE/PATCH).
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#save|save}
         * saves the model in the backend by delegating to
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} and eventually
         * (in the default implementation of {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync})
         * to {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}.
         *
         * The attributes hash (as in {@link module:UWA/Class/Model.UWA.Class.Model#set|set})
         * should contain the attributes you'd like to change — keys that aren't
         * mentioned won't be altered — but a complete representation of the resource
         * will be sent to the backend.
         * (This is just a shortcut version of a {@link module:UWA/Class/Model.UWA.Class.Model#set|set}
         * + {@link module:UWA/Class/Model.UWA.Class.Model#save|save} calls sequence)
         * As with {@link module:UWA/Class/Model.UWA.Class.Model#set|set}, you may
         * pass individual keys and values instead of a hash.
         * If the model has a {@link module:UWA/Class/Model.UWA.Class.Model#validate|validate}
         * method, and validation fails, the model
         * will not be saved. If the model {@link module:UWA/Class/Model.UWA.Class.Model#isNew|isNew},
         * the save will be a "create" (HTTP POST in default
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} implementation),
         * if the model already exists in the backend, the save will be an "update" (HTTP PUT
         * in default {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} implementation).
         *
         * If instead, you'd only like the changed attributes to be sent to the
         * backend, call model.save(attrs, {patch: true}). A 'patch' operation
         * is launched. In the default {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * implementation, that 'patch' operation is implemented with an HTTP PATCH
         * request sent to the backend with just the attributes passed to
         * {@link module:UWA/Class/Model.UWA.Class.Model#save|save}, not the whole
         * hash of this model's attributes. (See RFC 6902)
         *
         * Calling {@link module:UWA/Class/Model.UWA.Class.Model#save|save} with new
         * attributes will cause a "onChange" event to
         * be immediately fired and an "onSync" event after the backend has
         * successfully performed the CREATE/UPDATE/PATCH operation or an 'onError'
         * event if the backend failed to perform the operation. With the default
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} implementation,
         * an "onRequest" event is fired as the XHR begins to go to the backend.
         *
         * Pass `{wait: true}` if you'd like to wait for the backend response before
         * setting the new attributes on the model.
         *
         * Another option is to immediately alter the model attributes in the
         * client (these changes will consequently be immediately reflected in the
         * UI) without waiting for the backend response (*latency compensation*
         * aka *reactive optimistic UI*), but revert the model
         * attributes to their previous values if the backend fails to save the
         * model (see {@link module:UWA/Class/Model.UWA.Class.Model#previousAttributes|previousAttributes}
         * method).
         *
         * Save accepts onComplete and onFailure callbacks in the options hash, which
         * are both passed (model, response, options) as arguments.
         *
         * __Note__: The signature handles both "key", value and {key: value} -style arguments.
         *   See example of code below.
         *
         * @return {Object|false} If validation is successful, returns an object that
         *     contains the cancel method, to cancel the operation if needed.
         *     If validation failed, returns false.
         *
         * @example
         * var Cake;
         *
         * Cake = Model.extend({
         *     defaults: {
         *         type: 'plain',
         *         nuts: false
         *     },
         *     urlRoot: 'cake'
         * });
         *
         * Cake.implement(Debug);
         *
         * myCake = new Cake();
         *
         * // save called with a hash of attribute names and values :
         * myCake.save({
         *     type: 'coconut',
         *     nuts: true
         * }, {
         *     wait:true,
         *     onComplete: function(model, response) {
         *         model.log('Successfully saved!');
         *     },
         *     onFailure: function(model, error) {
         *         model.log(model.toJSON());
         *         model.log('error.responseText');
         *     }
         * });
         *
         * // save called with a key, value -style arguments :
         * myCake.save('price', 99.99, {
         *     wait: true
         * });
         */
        save: function (key, val, options) {

            var attributes, attrs, method, onComplete, request,
                that = this;

            attributes = that._attributes;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if ((!Core.is(key)) || (Core.typeOf(key)) === 'object') {
                attrs = key;
                options = val;
            } else {
                attrs = {};
                attrs[key] = val;
            }
            options = Core.extend({
                validate: true // by default, save validates data before setting attrs.
            }, options);

            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !options.wait) {
                if (!that.set(attrs, options)) {
                    return false;
                }
            } else if (!that._validate(attrs, options)) {
                return false;
            }

            // Set temporary attributes if `{wait: true}` :
            if (attrs && options.wait) {
                that._attributes = Core.extend(Core.extend({}, attributes), attrs);
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            if (options.parse === undefined) {
                options.parse = true;
            }
            onComplete = options.onComplete;
            options.onComplete = function (resp) {
                // Ensure attributes are restored during synchronous saves:
                var serverAttrs;
                that._attributes = attributes;
                serverAttrs = that.parse(resp, options);
                if (options.wait) {
                    serverAttrs = Core.extend(attrs || {}, serverAttrs);
                }
                if (typeof serverAttrs === "object" && serverAttrs !== null && !that.set(serverAttrs, options)) {
                    return false;
                }
                if (onComplete) {
                    onComplete(that, resp, options);
                }
                return that.dispatchEvent('onSync', [that, resp, options]);
            };
            wrapFailure(this, options);
            method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
            if (method === 'patch') {
                options.attrs = attrs;
            }
            request = this.sync(method, this, options);

            // Restore attributes :
            if (attrs && options.wait) {
                that._attributes = attributes;
            }
            return request;
        },

        /**
         * (READ) Fetches the attributes for this model from the backend.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} resets the
         * model's state from the backend by delegating to
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}. Returns a
         * request/operation object that contains the cancel method.
         * Useful if the model has never been
         * populated with data, or if you would like to ensure that you have the
         * latest backend state. A "onChange" event will be triggered if the
         * backend's state differs from the current attributes. With the default
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync} implementation,
         * a "onRequest" event will be trigerred as the XHR begins to go to the
         * backend. An "onSync" event is triggered if the backend successfully
         * performed the READ operation. An 'onError' event is fired if the
         * backend failed to perform the operation.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#fetch|fetch} accepts onComplete
         * and onFailure callbacks in the options hash, which are both passed
         * (model, response, options) as arguments.
         *
         * @param {Object} options - Options hash
         *
         * @return {Object} An object that contains the cancel method, allowing to
         *       cancel the operation made into the backend.
         *
         * @example
         * // Poll every 10 seconds to keep the channel model up-to-date.
         * window.setInterval(function () {
         *     channel.fetch();
         * }, 10000);
         */
        fetch: function (options) {

            var onComplete,
                that = this;
            options = options ? Core.clone(options, false) : {};
            if (options.parse === undefined) {
                options.parse = true;
            }
            onComplete = options.onComplete;
            options.onComplete = function (resp) {
                if (!that.set(that.parse(resp, options), options)) {
                    return false;
                }
                if (onComplete) {
                    onComplete(that, resp, options);
                }
                return that.dispatchEvent('onSync', [that, resp, options]);
            };
            wrapFailure(this, options);
            return this.sync('read', this, options);
        },

        /**
         * Destroys the model in the backend.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy} destroys
         * the model in the backend by delegating a 'delete' operation to
         * {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}.
         *
         * The default implementation of {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * makes an HTTP DELETE request to the backend to implement this 'delete' operation.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy} accepts
         * onComplete and onFailure callbacks in the options hash, which
         * are both passed (model, response, options) as arguments.
         *
         * {@link module:UWA/Class/Model.UWA.Class.Model#destroy|destroy} triggers
         * a "onDestroy" event on the model, which will bubble
         * up through any collections that contain it (that will themselves emit
         * 'onRemove' events) and an "onSync" event it the backend
         * successfully performs the model's deletion or an 'onError' event if
         * the backend failed to perform the 'delete' operation.
         * With the default {@link module:UWA/Class/Model.UWA.Class.Model#sync|sync}
         * implementation, an "onRequest" event is fired as it begins the XHR to
         * the backend.
         *
         * Pass `{wait: true}` if you'd like to wait for the backend to respond
         * before removing the model from the collection.
         *
         * @param {Object} options - Options hash.
         *
         * @return {Object} An object that contains the cancel method or false if the model
         * {@link module:UWA/Class/Model.UWA.Class.Model#isNew|isNew}
         */
        destroy: function (options) {
            var destroy, onComplete, request,
                that = this;

            options = options ? Core.clone(options, false) : {};
            onComplete = options.onComplete;

            destroy = function () {
                return that.dispatchEvent('onDestroy', [that, that.collection, options]);
            };

            options.onComplete = function (resp) {
                if (options.wait || that.isNew()) {
                    destroy();
                }
                if (onComplete) {
                    onComplete(that, resp, options);
                }
                if (!that.isNew()) {
                    return that.dispatchEvent('onSync', [that, resp, options]);
                }
            };

            if (that.isNew()) {
                options.onComplete();
                return false;
            }

            wrapFailure(that, options);
            request = that.sync('delete', that, options);

            if (!options.wait) {
                destroy();
            }

            return request;
        }

    });

    return Core.namespace('Model', Model, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/* jshint maxlen: 224 */
/**
 * A logical ordered grouping of instances of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
 * with methods and properties
 * for working with (grouping, sorting, filtering, etc) these groups of models.
 *
 * __Events triggered by instances of {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}__:
 *
 * Any event that is triggered by an instance of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
 * in a collection will also
 * be triggered on the collection directly, for convenience. This allows you to
 * listen for changes to specific attributes in any model in a collection.
 *
 * For example, you can listen to `"onChange"` events fired by the collection
 * to be notified when any model in the collection has been modified :
 *
 * ```javascript
 * documents.addEvent("onChange:selected", ...)
 * ```
 *
 * Now here are the events that are specific to instances of {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection} :
 *
 * |  Event name    | Arguments passed to callback | Description                                                                                                                                                             |
 * | -------------- | ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * |   'onAdd'      | model, collection, options   | This event is fired when a model is added to a collection.                                                                                                              |
 * |   'onRemove'   | model, collection, options   | This event is fired when a model is removed from a collection. The model's index before removal is available as `options.index`                                         |
 * |   'onReset'    | collection, options          | This event is fired when the collection's entire contents have been replaced. For convenience, the list of any previous models is available as `options.previousModels` |
 * |   'onSort'     | collection, options          | This event is fired when the collection has been re-sorted.                                                                                                             |
 * |   'onAnyEvent' | event name, event data...    | This event is fired for any other triggered event, passing the event name as the first argument.                                                                        |
 *
 * __Define your own custom collection by sub-classing
 * {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}:__
 *
 * Just like {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} and
 * {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}, a
 * {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
 * can be extended (i.e. sub-classed) using {@link module:UWA/Class.UWA.Class#extend|UWA.Class.extend}
 * mechanism and defining an {@link module:UWA/Class/Collection.UWA.Class.Collection#setup|setup}
 * function when extending will be invoked when a collection is created.
 *
 * The methods you have to (or that you should) override when defining your custom
 * collection are the following :
 *
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#setup|setup} method,
 * to initialize a newly created instance of collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#sync|sync} method,
 * to retrieve a data collection from the backend.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse} method,
 * to transform the backend response into an array of models.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property,
 * to specify the model class the collection contains.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
 * property, to maintain the collection in order.
 *
 * By extending/subclassing {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection},
 * you can define your own business logic on top of
 * {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}, see an advanced example
 * below that will show you the benefits of defining your custom collections
 * for your business logic.
 *
 * __Mutator methods that will modify the contents of the collection__
 *
 * These are the methods that allows you to :
 *
 * - add models to the collection ({@link module:UWA/Class/Collection.UWA.Class.Collection#add|add},
 * {@link module:UWA/Class/Collection.UWA.Class.Collection#push|push},
 * {@link module:UWA/Class/Collection.UWA.Class.Collection#unshift|unshift}),
 * - remove models from the collection ({@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove},
 * {@link module:UWA/Class/Collection.UWA.Class.Collection#pop|pop},
 * {@link module:UWA/Class/Collection.UWA.Class.Collection#shift|shift}),
 * - force the re-sorting of the collection ({@link module:UWA/Class/Collection.UWA.Class.Collection#sort|sort}),
 * - smartly update or replace the contents of the collection ({@link module:UWA/Class/Collection.UWA.Class.Collection#set|set},
 * {@link module:UWA/Class/Collection.UWA.Class.Collection#reset|reset}).
 *
 * __Accessor methods that do not modify the collection but return some representation of the collection__
 *
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#get|get} gets a model from the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#at|at} returns a model from a collection, given a position.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#first|first} returns the first model of the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#last|last} returns the last model of the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#toArray|toArray} returns a shallow copy of all the models
 * in the collection, as an array.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#slice|slice} returns a portion of the
 * collection as an array of models.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest} returns all but the N first
 * models in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#initial|initial} returns all but the N
 * last models in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without} returns a copy of the
 * collection with all of the passed instances of models removed.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#indexOf|indexOf} returns the first index
 * at which a given model can be found in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#lastIndexOf|lastIndexOf} returns the last
 * index at which a model can be found.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#contains|contains} returns true if the
 * model is present in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#size|size} returns the number of models
 * in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#isEmpty|isEmpty} returns true if the
 * collection contains no model.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#toJSON|toJSON} returns an array containing
 * the attributes hash of each model in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#pluck|pluck} plucks an attribute from
 * each model in the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#shuffle|shuffle} returns a shuffled copy
 * of the collection models as an array.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#where|where} returns an array of all the
 * models in the collection that match the passed attributes.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#findWhere|findWhere} returns the first
 * model in the collection that matches the passed attributes.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#invoke|invoke} invokes a provided model
 * method name once per model of the collection.
 *
 * __Iteration methods taking as arguments functions to be called back when processing the collection__
 *
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#forEach|forEach} executes a provided
 * function once per model of the collection.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#map|map} returns a new array with the
 * results of calling a provided function on every model.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every} tests whether all models in
 * the collection pass the test implemented by the provided function.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some} tests whether some model in
 * the collection passes the test implemented by the provided function.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#sortBy|sortBy} returns a sorted copy of
 * the collection’s models.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#groupBy|groupBy} splits the collection
 * into sets.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#countBy|countBy} sorts the collection
 * into groups and returns a count of models in each group
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#find|find} returns the first model in
 * the collection for which the provided filtering function ‘filter’ returns true.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter} creates a new array with
 * all the models of this collection for which the provided filtering function ‘filter’ returns true.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#reject|reject} returns the models in this
 * collection without the models that the truth test (filter) passes.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#reduce|reduce} applies a function against
 * an accumulator and each model to reduce the collection to a single value.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#reduceRight|reduceRight}, the
 * right-associative version of reduce.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max} returns the maximum model in the
 * collection, with regards to a criterion.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#min|min} returns the minimum model in the
 * collection, with regards to a criterion.
 *
 * __Methods performing C/R/U/D operations in the backend__
 *
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} fetches the default set of
 * models for this collection from the backend.
 * - {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} create a new instance of
 * a model within the collection.
 *
 * @module UWA/Class/Collection
 *
 *
 * @example
 * // This example is a brief overview of some of the methods/APIs offered
 * // by UWA.Class.Collection. Have a look at the detailed documentation of each API
 * // if needed.
 *
 * // Given this model definition :
 * var Post = UWA.Class.Model.extend({});
 * // Let's define a collection Posts of Post models :
 * var Posts = UWA.Class.Collection.extend({
 *     url: "/blogposts",
 *     model: Post // the type of models inside the collection
 * });
 * // An url has been set for this collection, it will be used when requests will
 * // be made to the backend.
 * // Let's instanciate a new collection :
 * var postsList = new Posts();
 * // And 3 new Post models :
 * var post1 = new Post({
 *     title: "Post1 title",
 *     message: "message 1"
 * });
 * var post2 = new Post({
 *     title: "Post2 title",
 *     message: "message 2"
 * });
 * var post3 = new Post({
 *     title: "Post3 title",
 *     message: "message 3"
 * });
 * // Now these models can be added this way to the collection :
 * postsList.add(post1);
 * // Or this way :
 * postsList.add([post2, post3]);
 * // Models can be directly created in the collection this way :
 * postsList.add(new Post({
 *     title: "Post4 title",
 *     message: "message 4"
 * }));
 * // ... or this way :
 * postsList.add({
 *     title: "Post5 title",
 *     message: "message 5"
 * });
 * // Now, to get the array of the models in the collection :
 * var posts = postsList.toArray();
 * // Models and their attributes can be accessed this way :
 * postsList.at(0).get("title"); // at() returns the post in the collection at the
 *                               // given position 0. Note that collections are
 *                               // 0-based.
 * // or this way :
 * postsList.get("3chk57hl").get("title");
 * // ... if there is a model identified with the id "3chk57hl"
 * // Collections have a forEach() method allowing to execute a provided function
 * // once per model in the collection. For example, to display the title of each
 * // Post in the collection :
 * postsList.forEach(function (post) {
 *     UWA.log(post.get("title"));
 * });
 * // This could also be coded this way :
 * postsList.pluck("title").forEach(function (title) {
 *     UWA.log(title);
 * });
 * // The method filter() allows to return an array of all models that pass a given
 * // criterion. Let's get the list of Posts which title's number is above 3 :
 * var somePosts = postsList.filter(function (post) {
 *     return parseInt(post.get("title")[4], 10) > 3;
 * });
 * // find() works just like filter() but returns the first model satisfying the criterion.
 * // Let's fetch data from the backend (after a reset to empty it) :
 * postsList.fetch({
 *     reset: true,
 *     onComplete: function (posts, response, options) {
 *         posts.pluck("title").forEach(function (title) {
 *             UWA.log(title);
 *         });
 *     },
 *     onFailure: function (posts, response, options) {
 *         UWA.log("Oupss");
 *     }
 * });
 * // Just like models, collections emit events that can be listened to.
 * // To get notified of any attribute change of any post in the collection :
 * postsList.addEvent('onChange', function (post) {
 *     UWA.log(UWA.String.format("{0} changed !", post.get("title")));
 * });
 * // The complete list of events emitted by collections can be found above.
 * // Once again, this example is a brief overview of some of the methods/APIs offered
 * // by UWA.Class.Collection. Have a look at the detailed documentation of each API.
 */

/*jshint maxparams:7*/
define('UWA/Class/Collection', [
    'UWA/Core',
    'UWA/Array',
    'UWA/Utils',
    'UWA/Class',
    'UWA/Class/Debug',
    'UWA/Class/Events',
    'UWA/Class/Listener',
    'UWA/Class/Model'
], function (Core, UWAArray, Utils, Class, Debug, Events, Listener, Model) { // jshint ignore:line
    'use strict';

    var setOptions, addOptions, lookupIterator, Collection;

    // default options for set :
    setOptions = {
        add: true,
        remove: true,
        merge: true
    };

    // default options for add :
    addOptions = {
        add: true,
        remove: false
    };

    lookupIterator = function (value) {
        return Core.is(value, 'function') ? value : function (model) {
            return model.get(value);
        };
    };

    Collection = Class.extend(Events, Listener, /** @lends module:UWA/Class/Collection.UWA.Class.Collection# */{ // bypass

        /* Group: Creating And Cloning Instances of Collection */

        /**
         * When creating a Collection, you may choose to pass in a model instance
         * or an array of model instances. However, if the collection being created
         * has a reference (via {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model}
         * property) to a model constructor, the
         * collection can internally instantiate models by passing a raw
         * attribute/data object or an array of raw attributes/data objects.
         *
         * You can also choose not to pass any initial model, in this case, the
         * created instance of collection will be empty.
         *
         * It is not recommended to override this method for the construction of an
         * instance of a collection. If you want to run some initialization code
         * when an instance of your collections is constructed, you should rather
         * implement the {@link module:UWA/Class/Collection.UWA.Class.Collection#setup|setup}
         * method, which will be invoked when the collection is created.
         *
         * @param {Void} [models] - Can be one of the following :
         *
         *  - an array of instances of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
         *  - an array of raw attributes/data objects, if the collection being
         *  created has a reference (via {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property)
         *  to a model constructor
         *  - a single instance of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
         *  - a raw attribute/data object, if the collection being created has a
         *  reference (via {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property)
         *  to a model constructor
         *
         * @param {Object} [options] - an hash of options. Next to your custom options, you can use :
         * @param {Function|String} [options.url=null] - Allow to override {@link module:UWA/Class/Collection.UWA.Class.Collection#url|url}
         * at construction time
         * @param {Constructor} [options.model=null] - Allow to override {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model}
         * at construction time
         * @param {Function|String} [options.comparator=null] - Allow to override
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator} at construction time
         *
         * @example
         * var tabs, spaces;
         *
         * // provided that you have already defined a class TabSet
         * // inheriting from UWA.Class.Collection :
         * tabs = new TabSet([tab1, tab2, tab3]);
         *
         * // Another example using the base Collection class,
         * // starting with no data
         * spaces = new UWA.Class.Collection([], {
         *   model: Space,
         *   url: '/spaces'
         * });
         *
         * @constructs UWA.Class.Collection
         * @memberof module:UWA/Class/Collection
         */
        init: function (models, options) {
            if (!Core.is(options)) {
                options = {};
            }
            if (options.url) {
                this.url = options.url;
            }
            if (options.model) {
                this.model = options.model;
            }
            if (options.comparator !== undefined) {
                this.comparator = options.comparator;
            }
            this._reset();

            // declare listener of models changes ON THIS INSTANCE :
            // TODO : not necessary anymore, with fix for issue #15371. Can be removed.
            this._modelListener = function (event, model, collection, options) {
                return this._onModelEvent(event, model, collection, options); // this is defined on my prototype.
            };
            this.setup(models, options);
            if (models) {
                this.reset(models, Core.extend({
                    silent: true
                }, options));
            }
        },

        /**
         * Returns a new instance of the collection with an identical list of models.
         *
         * __Notes__:
         *
         * * the original collection and its clone share references to
         *     the same models (see code example below).
         * * the cloned collection does not register any of the listeners
         *     registered by the original collection.
         *
         * @return {UWA.Class.Collection} - A new instance of the collection with an identical list of models.
         *
         * @example
         * var fruits, clonedFruits; // collections of fruits
         *
         * // five fruits per day !
         * fruits = new Collection([{
         *     type: 'Banana'
         * }, {
         *     type: 'Orange'
         * }, {
         *     type: 'Strawberry'
         * }, {
         *     type: 'Apple'
         * }, {
         *     type: 'Mango'
         * }]);
         *
         * UWA.log(fruits.first().get('type')); // outputs 'Banana'
         *
         * clonedFruits = fruits.clone();
         *
         * // A change on a model referenced by the cloned collection
         * // is also visible to the original collection :
         *
         * clonedFruits.first().set('type', 'Pinapple');
         *
         * UWA.log(fruits.first().get('type')); // outputs 'Pinapple'
         *
         * // Adding models to the cloned collection does not affect
         * // the original collection :
         *
         * clonedFruits.push({
         *     type: 'Lemon'
         * });
         *
         * UWA.log(fruits.first().get('type')); // outputs 'Pinapple'
         */
        clone: function () {
            return new this.constructor(this._models);
        },

        /* Group: Methods & Properties To Be Overridden.

            *These are the methods and properties you should override/implement
            when defining your custom collections by sub-classing UWA.Class.Collection
        */

        /**
         * Override this method to initialize a newly created instance of collection.
         *
         * *Do not directly call {@link module:UWA/Class/Collection.UWA.Class.Collection#setup|setup}
         * in your application code. It is internally used and consequently only meant to be overridden*
         *
         * The default implementation does nothing.
         *
         * Overriding it with you own initialization logic is optional; however
         * it is a good practice to implement it when sub-classing a collection.
         *
         * It is passed the same arguments that were passed to the constructor
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#init|init} method.
         *
         * @example
		 * var TodoList = UWA.Class.Collection.extend({
         *
         *     // this collection contains Todo models :
         *     model: Todo,
         *
         *     // When a TodoList is modified (or its Todos themselves), we want
         *     // to maintain a reference to the most important todo
         *     // let's bind our internal callbacks in the implementation of setup,
         *     // this is the appropriate place for that :
         *     setup: function (models, options) {
         *         this.addEvents({
         *             onRemove: this._onRemove,
         *             onAdd: this._onAdd,
         *             'onChange:priority': this._onChange
         *         }, this);
         *         this._topTodo = null;
         *         this._topTodoWeight = UWA.is(options.weightMinorant, 'number') ? options.weightMinorant : -1;
         *     },
         *
         *     // ...
         * });
         *
         * var Tasks = new TodoList([], {
         *     weightMinorant: -1
         * });
         */
        setup: function () {
            return;
        },

        /**
         * Override this method to implement, customize or fine-tune the manner
         * in which a collection resource data is fetched from the backend.
         *
         * *Do not directly call {@link module:UWA/Class/Collection.UWA.Class.Collection#sync|sync}
         * in your application code. It is internally used by
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} and
         * consequently only meant to be overridden*
         *
         * By default, {@link module:UWA/Class/Collection.UWA.Class.Collection#sync|sync}
         * makes a GET RESTful Ajax request to the
         * collection's {@link module:UWA/Class/Collection.UWA.Class.Collection#url|url},
         * using {@link module:UWA/Data.UWA.Data.request|UWA.Data.request} API under
         * the cover, to fetch the collection resource data.
         * Consequently an error will be thrown if the collection does not have an
         * URL and no url is passed as an option in the options hash.
         *
         * Can be overridden for custom behavior. In this case, you have to respond
         * to a `"read"` operation request (made by
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch})
         * by sending back an array of model attribute objects to `options.onComplete`
         * success callback and returning a request object that contains a `cancel` method,
         * allowing to cancel the request made to the backend (if feasible).
         *
         * @param {String} method - the CRUD method, that should be `"read"`
         * @param {Object} collection - the collection to be read
         * @param {Object} [options] - onComplete and onFailure callbacks, and all other options
         *  for {@link module:UWA/Data.UWA.Data.request|UWA.Data.request}
         *
         * @return {Object} - a request object that contains the `cancel` method, allowing
         *  to cancel the request made to the backend.
         *
         * @example
         *   // This is an (uncomplete) implementation reading some data collection
         *   // from the local storage.
         *
         *   var MyCollection, myCollec, keys = [], len = 10;
         *
         *   MyCollection = UWA.Class.Collection.extend({
         *       sync: function (method, collection, options) {
         *           var resp, errorMessage, name = 'MyCollection';
         *
         *           try {
         *               switch (method) {
         *               case "read":
         *                   resp = localStorage.getItem(name).split(',').map(function (id) {
         *                       data = localStorage.getItem(name + "-" + id);
         *                       return data && JSON.parse(data);
         *                   }, this).filter(function (attrs) {
         *                       return attrs; // Remove all falsy values
         *                   }, this);
         *                   break;
         *               default:
         *                   throw new Error(UWA.String.format('Unsupported method "{0}"', method));
         *               }
         *
         *           } catch (error) {
         *               errorMessage = error.message;
         *           }
         *
         *           if (resp) {
         *               if (options && options.onComplete) {
         *                   options.onComplete(resp);
         *               }
         *           } else {
         *               if (options && options.onFailure) {
         *                   options.onFailure(errorMessage || 'Unknown error');
         *               }
         *           }
         *
         *           // return an obj with a dummy cancel() method,
         *           // because in this implementation of sync() we synchronously
         *           // call options.onComplete, cancel is a no-op.
         *           return {
         *               cancel: function () {
         *                   return;
         *               }
         *           };
         *       }
         *   });
         *
         *   // Initialize the localStorage content :
         *   for (i = 1; i <= len; i++) {
         *       localStorage.setItem(name + '-' + i, JSON.stringify({
         *           attr: Math.random().toString(36).substring(7);
         *       }));
         *       keys.push(i);
         *   }
         *   localStorage.setItem(name, keys.join(','));
         *
         *   // create a collection and fetch its content.
         *   // This will call our implementation of sync for the operation
         *   // "read" :
         *   myCollec = new MyCollection();
         *   myCollec.fetch({
         *       onComplete: function (collec, response, options) {
         *           UWA.log(myCollec.toJSON());
         *       }
         *   });
         */
        sync: function () {
            return Model.prototype.sync.apply(this, arguments);
        },

        /**
         * Override this method to transform the backend response into an array of
         * models.
         *
         * *Do not directly call {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse}
         * in your application code. It is internally used and consequently only meant to be overridden*
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse} is called whenever a
         * collection's models are returned by the backend, in {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch}.
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse} is passed the raw response
         * object, and should return the array of model attributes to be added to the collection. The default
         * implementation is a no-op, simply passing through the JSON response.
         *
         * *Override this if you need to work with a preexisting backend API*,
         * or better namespace your backend responses
         *
         * @param {Object} response - the raw response object returned by the backend API.
         * @param {Object} [options] - an hash of options passed by caller
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set}
         *
         * @return {Array} - the array of model attributes to be added to the collection.
         *
         * @example
         * var Tweets = UWA.Class.Collection.extend({
         *     // Twitter's GET search/tweets API 1.1 returns tweets under "statuses",
         *     // so let's implement parse() to get the tweets under "statuses" ! :
         *     parse: function (response) {
         *         return response.statuses;
         *     }
         * });
         */
        parse: function (resp) {
            return resp;
        },

        /**
         * Override this property to specify the model class
         * the collection contains.
         *
         * Override this property to specify the model
         * class that the collection contains. If defined, you can pass
         * raw attributes objects (and arrays) to {@link module:UWA/Class/Collection.UWA.Class.Collection#init|init},
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add},
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#push|push},
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#unshift|unshift},
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create},
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set} and
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#reset|reset}, and the attributes will
         * be converted into a model of the proper type.
         *
         * The default model for a collection is just a {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}.
         * This should be overridden in most cases.
         *
         * __Override this property with a value that is__:
         *
         * * either a sub-class of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
         * * or a function that returns a sub-class of {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
         *
         * __You can override this property__:
         *
         * * When sub-classing the {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection} class,
         * * When constructing an instance of collection, passing a model
         *     option in the options hash of the constructor (see constructor doc)
         *
         * @example
         * // provided that you have defined WorkOfArt model class :
         * var Museum = UWA.Class.Collection.extend({
         *     model: WorkOfArt
         * });
         *
         * // provided that you have defined a Player model class :
         * var footballTeam = new UWA.Class.Collection([], {
         *     model: Player
         * });
         *
         * // provided that you have defined Triangle and TriangleV2 model classes,
         * // and a global Application object :
         * var Mesh = UWA.Class.Collection.extend({
         *     model: function () {
         *         return Application.version >= 2 ? TriangleV2 : Triangle;
         *     }
         * });
         *
         * @type {UWA/Class/Model}
         */
        model: Model,

        /**
         * Override this property to maintain the collection in order.
         *
         * By default there is no comparator for a collection. If you define a
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator} property,
         * it will be used to maintain the collection in sorted order. This means that as models are
         * added, they are inserted at the correct index in the internal container of models. A
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         * can be defined :
         *
         * * as a function that takes a model as single argument and return a
         *     numeric or string value by which the model should be ordered
         *     relative to others,
         * * as a comparator function that expects two models, and returns -1 if
         *     the first model should come before the second, 0 if they are of
         *     the same rank and 1 if the first model should come after.
         * * or as a string indicating the attribute to sort by.
         *
         * Note how even though all of the chapters in this example are added
         * backwards, they come out in the proper order:
         *
         * ```
         * var Chapter, chapters;
         * Chapter = UWA.Class.Model;
         * chapters = new UWA.Class.Collection();
         * chapters.comparator = 'page';
         * chapters.add(new Chapter({page: 9, title: "The End"}));
         * chapters.add(new Chapter({page: 5, title: "The Middle"}));
         * chapters.add(new Chapter({page: 1, title: "The Beginning"}));
         *
         * chapters.pluck('title'); // returns ["The Beginning", "The Middle", "The End"]
         * ```
         *
         * *Collections with a comparator will not automatically re-sort if you
         * later change model attributes*, so you may wish to call {@link module:UWA/Class/Collection.UWA.Class.Collection#sort|sort}
         * after changing model attributes that would break the sorting logic.
         *
         * Automatic re-sorting on a model attribute
         * change can also be easily added on a per-collection basis, but be aware of
         * the performance hit ! :
         *
         * ```
         * var collection = new UWA.Class.Collection([], {
         *    comparator: 'attrName'
         * });
         * collection.addEvent('onChange:' + collection.comparator, function (model, val, options) {
         *     this.sort(options);
         * });
         * ```
         *
         * Changing the value of this {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         * property at runtime will not re-sort the collection. Call {@link module:UWA/Class/Collection.UWA.Class.Collection#sort|sort}
         * to force the re-sorting of the collection if necessary.
         *
         * @member {String|Function} module:UWA/Class/Collection.UWA.Class.Collection#comparator
         */

        /* Group: Mutator methods

            *These methods modify the collection*.

            These are the methods that allows you to :
                * add models to the collection (add, push, unshift),
                * remove models from the collection (remove, pop, shift),
                * force the re-sorting of the collection (sort),
                * smartly update or replace the contents of the collection (set, reset).
        */

        /**
         * Insert a model or an array of models inside this collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add} fires `"onAdd"` events. You
         * can use the option `{silent: true}` to suppress the emission of the `"onAdd"` event(s).
         *
         * If a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is defined
         * on this collection, you may also pass raw attributes objects, and have them be vivified as instances of the
         * model.
         *
         * If this collection is sortable, model(s) is(are) inserted in this
         * collection so that it remains sorted. Pass `{sort: false}` so that sorting
         * is disabled when the model(s) is(are) added.
         *
         * Pass `{at: index}` to splice the model into the collection at the
         * specified index. Note that sorting is disabled with with this option.
         *
         * If you're adding models to the collection that are already in the
         * collection, they'll be ignored, unless you pass `{merge: true}`, in
         * which case their attributes will be merged into the corresponding
         * models, firing any appropriate `"onChange"` events.
         *
         * @param {UWA/Class/Model|Array} models - a model or an array of models. Or raw attributes object(s)
         *  if a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is defined
         *  on this collection.
         *
         * @param {Object} [options] - an hash of options, see description above.
         *  It will also be passed to the listeners of fired "onAdd" events.
         *
         * @return {UWA/Class/Model|Array|Boolean} - the added (or preexisting (potentially merged),
         * if duplicate) model. Or the array of added (or merged) models.
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add} can also return
         * false or an array containing false values if some models did
         * not pass validation.
         *
         * @example:
         * var ships = new UWA.Class.Collection();
         *
         * ships.addEvent("onAdd", function(ship) {
         *     UWA.log(UWA.String.format("Ahoy {0} !", ship.get("name")));
         * });
         *
         * ships.add([
         *     {name: "Flying Dutchman"},
         *     {name: "Black Pearl"}
         * ]);
         */
        add: function (models, options) {
            return this.set(models, Core.extend(Core.extend({merge: false}, options), addOptions));
        },

        /**
         * Add a model or an array of models at the end of this collection.
         *
         * If a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is
         * defined on this collection, you may also pass raw attributes objects, and have them be
         * vivified as instances of the model.
         *
         * An event `"onAdd"` is fired (several events if an array is passed),
         * unless you pass the option `{silent: true}`
         *
         * This method takes the same options as {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add},
         * though passing `{at: index}` will have no effect since models will be necessarily added at the
         * end of this collection. (Sorting is necessarily disabled since we want
         * models to be inserted at the end of the collection).
         *
         * If you're pushing models that are already in the
         * collection, they will be ignored, unless you pass `{merge: true}`, in
         * which case their attributes will be merged into the corresponding
         * models, firing any appropriate `"onChange"` events.
         *
         * @param {UWA/Class/Model|Array} models - a model or an array of models. Or raw attributes object(s)
         *  if a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is defined on this collection
         * @param {Object} [options] - an hash of options, see
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add} method
         *  for a description. It will also be passed to the listeners of fired "onAdd" events.
         *
         * @return {UWA/Class/Model|Array|Boolean} - the added (or merged) model. Or the array of added (or
         *  merged) models. {@link module:UWA/Class/Collection.UWA.Class.Collection#push|push} can also
         *  return false or an array containing false values if some models to push did not pass validation.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#unshift|unshift}, {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         */
        push: function (models, options) {
            return this.add(models, Core.merge({
                at: this.length
            }, options));
        },

        /**
         * Add a model or an array of models at the beginning of this collection.
         *
         * If a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is defined
         * on this collection, you may also pass raw attributes objects, and have them be vivified as instances of the
         * model.
         *
         * An event `"onAdd"` is fired (several events if an array is passed),
         * unless you pass the option `{silent: true}`
         *
         * This method takes the same options as {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add},
         * though passing `{at: index}` will have no effect since models will be necessarily added at the
         * beginning of this collection. (Sorting is necessarily disabled since we want
         * models to be inserted at the beginning of the collection).
         *
         * If you're unshifting models that are already in the
         * collection, they will be ignored, unless you pass `{merge: true}`, in
         * which case their attributes will be merged into the corresponding
         * models, firing any appropriate `"onChange"` events.
         *
         * @param {UWA/Class/Model|Array} models - a model or an array of models. Or raw attributes object(s)
         *  if a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model} property is defined
         *  on this collection
         * @param {Object} [options] - an hash of options, see
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add} method for a description.
         *  It will also be passed to the listeners of fired "onAdd" events.
         *
         * @return {UWA/Class/Model|Array|Boolean} - the added (or merged) model. Or the array of added (or
         *  merged) models. {@link module:UWA/Class/Collection.UWA.Class.Collection#push|push} can also
         *  return false or an array containing false values if some models to push did not pass validation.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#push|push}, {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
        */
        unshift: function (models, options) {
            return this.add(models, Core.merge({
                at: 0
            }, options));
        },

        /**
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove} remove a model or an
         * array of models from the collection. The models are specified by their ids, their cids, or by
         * passing instances of models.
         *
         * An event `"onRemove"` is fired (several events if an array is passed).
         * You can use the option `{silent: true}` to suppress the emission of these
         * `"onRemove"` events.
         *
         * The model's index before removal is available to listeners of this
         * `"onRemove"` event as `options.index`
         *
         * @param {UWA/Class/Model|String} models - an id, an instance of
         * {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} or a cid, identifying a model
         * in the collection. Or an array of any of these types of ids.
         *
         * @param {Object} [options] - an hash of options, see available
         *  options above. It will also be passed to the listeners of  fired "onRemove" events.
         *
         * @return {UWA/Class/Model|Array} - the removed model (undefined if model to be removed could not
         *         be found) or the array of removed models (can contain some
         *         undefined values if some models to remove could not be found).
         *
         * @example
         * var Cyclist, podium1989, logPodium,
         *     gregLemond, pedroDelgado, laurentFignon,
         *     laurent_cid;
         *
         * Cyclist = UWA.Class.Model.extend({
         *     idAttribute: 'jerseyNumber'
         * });
         *
         * gregLemond = new Cyclist({
         *     name: 'Greg Lemond',
         *     jerseyNumber: 141,
         *     team: 'ADR'
         * });
         *
         * pedroDelgado = new Cyclist({
         *     name: 'Pedro Delgado',
         *     jerseyNumber: 1,
         *     team: 'Reynolds-Banesto'
         * });
         *
         * laurentFignon = new Cyclist({
         *     name: 'Laurent Fignon',
         *     jerseyNumber: 41,
         *     team: 'Systeme U'
         * });
         *
         * laurent_cid = laurentFignon.cid;
         *
         * podium1989 = new UWA.Class.Collection([ gregLemond,
         *                                         laurentFignon,
         *                                         pedroDelgado], {
         *                                             model: Cyclist
         *                                         });
         *
         * logPodium = function (removedCyclist, cyclists, options) {
         *     var removedCyclistName = removedCyclist.get('name');
         *     UWA.log(UWA.String.format("{0} got removed from classification because of {1}", removedCyclistName, options.reason));
         *     UWA.log("The podium is now :");
         *     UWA.log(JSON.stringify(cyclists));
         * };
         *
         * podium1989.addEvent('onRemove', logPodium);
         *
         * podium1989.remove(1, {
         *     reason: 'doping'
         * });
         *
         * // This logs :
         * //
         * // Pedro Delgado got removed from classification because of doping :
         * // The podium is now :
         * // [{
         * //      "name":"Greg Lemond",
         * //      "jerseyNumber":141,
         * //      "team":"ADR"
         * //   }, {
         * //      "name":"Laurent Fignon",
         * //      "jerseyNumber":41,
         * //      "team":"Systeme U"
         * // }]
         *
         *
         * podium1989.remove([gregLemond, laurent_cid], {
         *     reason: 'non-compliant equipment'
         * });
         *
         * // This logs (2 events fired) :
         * //
         * // Greg Lemond got removed from classification because of non-compliant equipment
         * // The podium is now :
         * // [{
         * //      "name":"Laurent Fignon",
         * //      "jerseyNumber":41,
         * //      "team":"Systeme U"
         * // }]
         * // Laurent Fignon got removed from classification because of non-compliant equipment
         * // The podium is now :
         * // []
         */
        remove: function (models, options) {
            var index, model, i, len, singular;
            if (!Core.is(options)) {
                options = {};
            }
            singular = !Array.isArray(models);
            models = singular ? [models] : Core.clone(models, false);
            for (i = 0, len = models.length; i < len; i++) {
                model = models[i] = this.get(models[i]);
                if (model) {
                    delete this._byId[model.id];
                    delete this._byId[model.cid];
                    index = this.indexOf(model);
                    this._models.splice(index, 1);
                    this.length--;
                    if (!options.silent) {
                        options.index = index;
                        model.dispatchEvent('onRemove', [model, this, options]);
                    }
                    this._removeReference(model);
                } // if (model)
            }
            return singular ? models[0] : models;
        },

        /**
         * Remove and return the last model from the collection.
         *
         * It takes the same options as {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove}
         * and also fires an `"onRemove"` event, unless `{silent: true}` is passed as an option.
         *
         * @param {Object} [options] - an hash of options, see {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove}
         *  method for a description.
         *
         * @return {Object} - The removed model.
         */
        pop: function (options) {
            var model;
            model = this.at(this.length - 1);
            this.remove(model, options);
            return model;
        },

        /**
         * Remove and return the first model from a collection.
         *
         * It takes the same options as {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove}
         * and also fires an `"onRemove"` event, unless `{silent: true}` is passed as an option.
         *
         * @param {Object} [options] - an hash of options, see
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove} method for a description.
         *
         * @return {Object} - The removed model.
        */
        shift: function (options) {
            var model;
            model = this.at(0);
            this.remove(model, options);
            return model;
        },

        /**
         * Force the collection to re-sort itself.
         *
         * You don't need to call this under normal circumstances,
         * as a collection with a {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         * will sort itself whenever a model is added.
         *
         * However, there are two cases where the sort order will not be maintained :
         * * Sorting can be disabled when a model is added, if `{sort: false}` is
         *     passed to {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}.
         * * If some attributes values change in a model, the collection's models
         *     may not be correctly sorted anymore.
         *
         * In this cases, you may need to call this {@link module:UWA/Class/Collection.UWA.Class.Collection#sort|sort}
         * method, to force the collection to re-sort itself.
         *
         * Note that in the second case, automatic re-sorting on a model attribute
         * change can be easily added on a per-collection basis, but be aware of
         * the performance hit ! :
         *
         * ```
         * var collection = new UWA.Class.Collection([], {
         *    comparator: 'attrName'
         * });
         * collection.addEvent('onChange:' + collection.comparator, function (model, val, options) {
         *     this.sort(options);
         * });
         * ```
         *
         * Calling {@link module:UWA/Class/Collection.UWA.Class.Collection#sort|sort} triggers a `"onSort"`
         * event on the collection.
         *
         * This method will throw an error if a {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         * property has not been defined on this collection.
         *
         * @param {Object} [options] - an hash of options, that will be passed
         *  to listeners of the "onSort" event.
         *
         * @return {Object} - {this} instance of collection.
         *
         * @example
         * var ContactModel, contactData, contacts;
         *
         * ContactModel = UWA.Class.Model.extend({
         *     idAttribute: 'lastName'
         * });
         *
         * contactData = [{
         *     firstName: 'John',
         *     lastName: 'Deere',
         *     phone: '1-111-1111'
         * }, {
         *     firstName: 'Jane',
         *     lastName: 'Eyre',
         *     phone: '2-222-2222'
         * }, {
         *     firstName: 'Jude',
         *     lastName: 'Law',
         *     phone: '3-333-3333'
         * }];
         *
         * contacts = new UWA.Class.Collection(contactData, {
         *     model:ContactModel,
         *     comparator: 'firstName' // keep models sorted by firstName
         * });
         *
         * UWA.log(JSON.stringify(contacts));
         *
         * // The created collection is sorted, despite original data
         * // wasn't :
         * // [{
         * //     "firstName": "Jane",
         * //     "lastName": "Eyre",
         * //     "phone": "2-222-2222"
         * // }, {
         * //     "firstName": "John",
         * //     "lastName": "Deere",
         * //     "phone": "1-111-1111"
         * // }, {
         * //     "firstName": "Jude",
         * //     "lastName": "Law",
         * //     "phone": "3-333-3333"
         * // }]
         *
         * contacts.get('Deere').set('firstName', 'Zlatan');
         * contacts.add({
         *     firstName: 'Jacob',
         *     lastName: 'Delafon',
         *     phone: '4-444-4444'
         * }, {
         *     sort: false
         * });
         *
         * UWA.log(JSON.stringify(contacts));
         *
         * // At this point, the collection order has not been
         * // maintained at all :
         * // [{
         * //     "firstName": "Jane",
         * //     "lastName": "Eyre",
         * //     "phone": "2-222-2222"
         * // }, {
         * //     "firstName": "Zlatan",
         * //     "lastName": "Deere",
         * //     "phone": "1-111-1111"
         * // }, {
         * //     "firstName": "Jude",
         * //     "lastName": "Law",
         * //     "phone": "3-333-3333"
         * // }, {
         * //     "firstName": "Jacob",
         * //     "lastName": "Delafon",
         * //     "phone": "4-444-4444"
         * //  }]
         *
         * contacts.sort();
         *
         * UWA.log(JSON.stringify(contacts));
         *
         * // The collection has been re-sorted :
         * // [{
         * //     "firstName": "Jacob",
         * //     "lastName": "Delafon",
         * //     "phone": "4-444-4444"
         * // }, {
         * //     "firstName": "Jane",
         * //     "lastName": "Eyre",
         * //     "phone": "2-222-2222"
         * // }, {
         * //     "firstName": "Jude",
         * //     "lastName": "Law",
         * //     "phone": "3-333-3333"
         * // }, {
         * //     "firstName": "Zlatan",
         * //     "lastName": "Deere",
         * //     "phone": "1-111-1111"
         * // }]
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         */
        sort: function (options) {
            if (!Core.is(options)) {
                options = {};
            }
            if (!this.comparator) {
                throw new Error('Cannot sort a collection without a comparator');
            }

            // Run sort based on type of comparator.
            if (Core.is(this.comparator, 'string') || this.comparator.length === 1) {
                this._models = this.sortBy(this.comparator, this);
            } else {
                this._models.sort(this.comparator.bind(this));
            }
            if (!options.silent) {
                this.dispatchEvent('onSort', [this, options]);
            }
            return this;
        },

        /**
         * Performs a smart update of the collection with the passed list of models.
         *
         * The {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set} method performs a smart
         * update of the collection with the passed list of models. Its default behavior is the following:
         *
         * * if a model in the list isn't yet in the collection it will be added;
         * * if the model is already in the collection its attributes will be merged;
         * * and if the collection contains any models that are no longer present in the list,
         *     they'll be removed.
         *
         * In other words, using {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set} will
         * attempt to synchronize the array of
         * models passed in with the internal state of the models in the collection
         * by intelligently deciphering the differences and adding, removing, and
         * merging according to the differences.
         *
         * All of the appropriate `"onAdd"`, `"onRemove"`, and `"onChange"` events are
         * fired as this happens.
         *
         * If you want to customize this default behavior, you can tune it with
         * the following options: `{add: false}`, `{remove: false}`, or `{merge: false}`.
         *
         * @param {UWA/Class/Model|Array} models - (optional) a model or an array of models. Or raw
         *  attributes object(s) if a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model}
         *  property is defined on this collection.
         *
         * @param {Object} [options] - an hash of options, see description above.
         *
         * @returns {UWA/Class/Model|Array|Boolean} - Returns the touched models in the collection, that is to say the
         *  added (or merged) model. Or the array of added (or merged) models.
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set} can also return false or an array
         *  containing false values if some models did not pass validation.
         *
         * @example
         * var kingCrimson, // the band
         *     NMEAnnouncement,
         *     robert, ian, greg, newGreg, michael, peter, mel, keith, // some members
         *     Member = UWA.Class.Model.extend({
         *         idAttribute: 'name'
         *     });
         *
         * robert = new Member({
         *     name: 'Robert Fripp',
         *     position: 'Lead guitarist'
         * });
         *
         * ian = new Member({
         *     name: 'Ian McDonald',
         *     position: 'Saxophonist'
         * });
         *
         * greg = new Member({
         *     name: 'Greg Lake',
         *     position: 'Singer & Bassist'
         * });
         *
         * michael = new Member({
         *     name: 'Michael Giles',
         *     position: 'Drummer'
         * });
         *
         * peter = new Member({
         *     name: 'Peter Sinfield',
         *     position: 'Lyricist'
         * });
         *
         * mel = new Member({
         *     name: 'Mel Collins',
         *     position: 'Flutist'
         * });
         *
         * keith = new Member({
         *     name: 'Keith Tippett',
         *     position: 'Pianist'
         * });
         *
         * // Original line-up :
         * kingCrimson = new UWA.Class.Collection([
         *     robert,
         *     ian,
         *     greg,
         *     michael,
         *     peter
         * ], {
         *     model: Member
         * });
         *
         * NMEAnnouncement = function (template) {
         *     return function (member) {
         *         UWA.log(UWA.String.format(template,
         *                                   member.get('name'),
         *                                   member.get('position')));
         *     };
         * };
         *
         * kingCrimson.addEvents({
         *     onAdd: NMEAnnouncement("{0} joined King Crimson as {1}"),
         *     onRemove: NMEAnnouncement("{0} left King Crimson. He/She was the {1} of the band"),
         *     'onChange:position': function (member) {
         *         UWA.log(UWA.String.format("{0} (who was previously the {1}) is now the {2} of King Crimson",
         *                                   member.get('name'),
         *                                   member.previous('position'),
         *                                   member.get('position')));
         *     }
         * });
         *
         * // For the second album, Greg no longer plays the bass,
         * // Ian left the band and Mel & Keith joined the band.
         * // So the line-up for the second album is :
         * kingCrimson.set([
         *     robert, {
         *         name: 'Greg Lake',
         *         position: 'Singer'
         *     },
         *     michael,
         *     peter,
         *     mel,
         *     keith
         * ]);
         *
         * // This will output to the console :
         *
         * // "Greg Lake (who was previously the Singer & Bassist) is now the Singer of King Crimson"
         * // "Ian McDonald left King Crimson. He/She was the Saxophonist of the band"
         * // "Mel Collins joined King Crimson as Flutist"
         * // "Keith Tippett joined King Crimson as Pianist"
         */
        set: function (models, options) {
            /*jshint maxcomplexity:38 */
            /*jshint maxstatements:72 */
            // TODO : Optimize!
            var at, sortable, sortAttr, toAdd, toRemove, modelMap, add, merge,
                remove, order, i, l, id, targetModel, model, attrs, existing,
                sort, orderedModels, ii, il, singular, that = this;

            options = Core.merge(Core.merge({}, options), setOptions);
            if (options.parse) {
                models = that.parse(models, options);
            }
            singular = !Array.isArray(models);
            models = singular ? (models ? [models] : []) : Core.clone(models, false);
            at = options.at;
            targetModel = that.model;
            sortable = that.comparator && (!Core.is(at)) && options.sort !== false;
            sortAttr = (Core.typeOf(that.comparator) === 'string') ? that.comparator : null;
            toAdd = [];
            toRemove = [];
            modelMap = {};
            add = options.add;
            merge = options.merge;
            remove = options.remove;
            order = !sortable && add && remove ? [] : false;

            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            for (i = 0, l = models.length; i < l; i++) {
                attrs = models[i];

                if (attrs instanceof Model) {
                    id = model = attrs;
                } else {
                    id = attrs[targetModel.prototype.idAttribute];
                }

                // If a duplicate is found, prevent it from being added and
                // optionally merge it into the existing model.
                existing = that.get(id);
                if (existing) {
                    if (remove) {
                        modelMap[existing.cid] = true;
                    }
                    if (merge) {
                        attrs = attrs === model ? model._attributes : attrs;
                        if (options.parse) {
                            attrs = existing.parse(attrs, options);
                        }
                        existing.set(attrs, options);
                        if (sortable && !sort && existing.hasChanged(sortAttr)) {
                            sort = true;
                        }
                    }
                    models[i] = existing;

                // If this is a new, valid model, push it to the toAdd list.
                } else if (add) {
                    model = models[i] = that._prepareModel(attrs, options); // note: this can lead set to return false.

                    if (model) {
                        models[i] = model;
                        toAdd.push(model);

                        // Listen to added models' events, and index models for lookup by
                        // id and by cid.
                        model.addEvent('onAnyEvent', that._modelListener, that);
                        that._byId[model.cid] = model;
                        if (Core.is(model.id)) {
                            that._byId[model.id] = model;
                        }
                    }
                }
                if (order && (existing || model)) {
                    order.push(existing || model);
                }
            }

            // Remove nonexistent models if appropriate.
            if (remove) {
                for (i = 0, l = that.length; i < l; ++i) {
                    model = that._models[i];
                    if (!modelMap[model.cid]) {
                        toRemove.push(model);
                    }
                }
                if (toRemove.length) {
                    that.remove(toRemove, options);
                }
            }

            // See if sorting is needed, update length and splice in new models.
            if (toAdd.length || (order && order.length)) {
                if (sortable) {
                    sort = true;
                }
                that.length += toAdd.length;
                if (Core.is(at)) {
                    for (ii = 0, il = toAdd.length; ii < il; ii++) {
                        that._models.splice(at + ii, 0, toAdd[ii]);
                    }
                } else {
                    if (order) {
                        that._models.length = 0;
                    }
                    orderedModels = order || toAdd;
                    for (ii = 0, il = orderedModels.length; ii < il; ii++) {
                        that._models.push(orderedModels[ii]);
                    }
                }
            }

            // Silently sort the collection if appropriate.
            if (sort) {
                that.sort({
                    silent: true
                });
            }

            // Unless silenced, it's time to fire all appropriate add/sort events :
            if (!options.silent) {

                // Trigger onAdd events.
                for (i = 0, l = toAdd.length; i < l; i++) {
                    model = toAdd[i];
                    model.dispatchEvent('onAdd', [model, that, options]);
                }

                // Trigger onSort if the collection was sorted.
                if (sort || (order && order.length)) {
                    that.dispatchEvent('onSort', [that, options]);
                }
            }

            // return the added (or merged) model (or models).
            return singular ? models[0] : models;
        },

        /**
         * Replaces the models in the collection with a new set of model(s).
         *
         * Adding and removing models one at a time is all well and good,
         * but sometimes you have so many models to change that you'd rather
         * just update the collection in bulk. Use {@link module:UWA/Class/Collection.UWA.Class.Collection#reset|reset}
         * to replace a collection with a new list of models (or attribute hashes), triggering a single
         * `"onReset"` event at the end. It is essentially like removing all
         * model(s) in a collection and adding a new model(s).
         *
         * For convenience, within a `"onReset"` event,
         * the list of any previous models is available as `options.previousModels`.
         *
         * Calling {@link module:UWA/Class/Collection.UWA.Class.Collection#reset|reset} without passing
         * any models as arguments will empty the entire collection.
         *
         * Parameters:
         *
         * @param {UWA/Class/Model|Array} [models] - a model or an array of models. Or raw
         *  attributes object(s) if a {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model}
         *  property is defined on this collection.
         *
         * @param {Object} [options] - an hash of options.
         *
         * @return {UWA/Class/Model|Array|Boolean} - the added model. Or the array of added models.
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#reset|reset} can also return
         *  false or an array containing false values if some models did not pass validation.
         *
         * @example
         * var Even, evens, newlySetModels;
         *
         * Even = UWA.Class.Model.extend({
         *     validate: function (attrs) {
         *         if (attrs.id % 2 !== 0) {
         *             return "odd";
         *         }
         *     }
         * });
         *
         * evens = new UWA.Class.Collection([{
         *     id: 2
         * }, {
         *     id: 4
         * }, {
         *     id: 6
         * }], {
         *     model: Even
         * });
         *
         * UWA.log(evens.length); // outputs 3.
         *
         * newlySetModels = evens.reset([{
         *     id: 7
         * }, {
         *     id: 2
         * }, {
         *     id: 10
         * }], {
         *     validate: true
         * });
         *
         * UWA.log(JSON.stringify(newlySetModels));
         * // outputs [false,{"id":2},{"id":10}]
         *
         * UWA.log(evens.length); // outputs 2.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}, {@link module:UWA/Class/Collection.UWA.Class.Collection#remove|remove}
         */
        reset: function (models, options) {
            var model, i, len, myModels;
            options = options ? Core.clone(options, false) : {};

            myModels = this._models;
            for (i = 0, len = myModels.length; i < len; i++) {
                model = myModels[i];
                this._removeReference(model);
            }
            options.previousModels = this._models;
            this._reset();
            models = this.add(models, Core.extend({
                silent: true
            }, options));
            if (!options.silent) {
                this.dispatchEvent('onReset', [this, options]);
            }
            return models;
        },

        /* Group: Accessor methods

            *These methods do not modify the collection and return some representation
            of the collection*.
        */

        /**
         * Get a model from the collection.
         *
         * Get a model from the collection, specified by an id, a cid, or by
         * passing in a model.
         *
         * @param {String|UWA/Class/Model} obj - an id, an instance of
         * {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} or a cid, identifying a model
         * in the collection.
         *
         * @return {UWA/Class/Model|undefined} - The model, if found. Undefined, if not found.
         *
         * @example
         * var contactRawData, contact, contacts;
         *
         * contactRawData = {
         *     id: '01',
         *     firstName: 'John',
         *     lastName: 'Doe',
         *     phone: '1-111-1111'
         * };
         *
         * contact = new UWA.Class.Model(contactRawData);
         *
         * contacts = new UWA.Class.Collection([contact]);
         *
         * // All of the below return a reference to the contact model in
         * // the contacts collection, using get() :
         *
         * UWA.log(contacts.get(contact));
         * UWA.log(contacts.get(contactRawData.id));
         * UWA.log(contacts.get(contact.cid));
         */
        get: function (obj) {
            if (Core.is(obj)) {
                return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
            }
        },

        /**
         * Return a model from a collection, given a position.
         *
         * Useful if your collection is sorted, and if your collection isn't sorted,
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#at|at} will still retrieve models
         * in insertion order.
         *
         * __Notes__:
         *
         * * To retrieve the last item of the collection, use {@link module:UWA/Class/Collection.UWA.Class.Collection#last|last}.
         * * To retrieve the first item of the collection, use {@link module:UWA/Class/Collection.UWA.Class.Collection#first|first}.
         *
         * @param {Integer} index - the zero-based index
         *
         * @return {UWA/Class/Model|undefined} - The model or undefined, if the index is out of bounds.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#first|first}, {@link module:UWA/Class/Collection.UWA.Class.Collection#last|last}, {@link module:UWA/Class/Collection.UWA.Class.Collection#size|size}
         */
        at: function (index) {
            return this._models[index];
        },

        /**
         * Returns the first model of the collection.
         *
         * Passing N will return the first N models in the collection.
         *
         * @param {Integer} [n=1] - The number of first models in the collection
         * to return.
         *
         * @return {UWA/Class/Model|Array} - The first model of the collection
         *  or an array of the first n models.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#last|last}
         */
        first: function (n, guard) {
            // LRG : Remark : Not sure that the guard stuff, that allows
            // to use this method with map, should be kept ?
            if (Core.is(n) && !guard) {
                return this._models.slice(0, n);
            }
            return this._models[0];
        },

        /**
         * Returns the last model of the collection.
         *
         * Passing N will return the last N models in the collection.
         *
         * @param {Integer} [n=1] - The number of last models in the collection to return.
         *
         * @return {UWA/Class/Model|Array} - the last model of the collection or
         *  an array of the last n models.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#first|first}
         */
        last: function (n, guard) {
            // LRG : Remark : Not sure that the guard stuff, that allows
            // to use this method with map, should be kept ?
            if (Core.is(n) && !guard) {
                return this._models.slice(Math.max(this._models.length - n, 0));
            }
            return this._models[this._models.length - 1];
        },

        /**
         * Returns a shallow copy of all the models in the collection, as an array.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#toArray|toArray} returns a new
         * "one-level deep" copy (as an array) that contains copies of references of the models of the collection.
         * Consequently *both the collection and the returned array refer to the same models*.
         *
         * * If a referenced model changes, the changes are visible to both the
         * copy returned by {@link module:UWA/Class/Collection.UWA.Class.Collection#toArray|toArray}
         * and the original collection.
         *
         * * If a new model is added to the collection (with {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         * for example), a copy previously returned by {@link module:UWA/Class/Collection.UWA.Class.Collection#toArray|toArray}
         * is not affected.
         *
         * * If a new model is added to the copy returned by {@link module:UWA/Class/Collection.UWA.Class.Collection#toArray|toArray},
         * the collection is not affected.
         *
         * @returns {Array} - a shallow copy of all the models in the collection, as an array.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#slice|slice}
         */
        toArray: function () {
            return this.slice();
        },

        /**
         * Returns a portion of the collection as an array of models.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#slice|slice} does not alter the collection,
         * but copies reference of models sliced from the collection into the new returned array.
         * Consequently *both the collection and the new returned array refer to the same models*.
         *
         * - If a referenced model changes,
         * the changes are visible to both the returned slice and the original
         * collection.
         * - If a new model is added to the collection (with {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         * for example), a previously returned slice is not affected.
         * - If a new model is added to returned slice, the collection is not affected.
         *
         * @param {Integer} [begin=0] - Zero-based index at which to begin extraction.
         *  As a negative index, begin indicates an offset from the end
         *  of the collection. If begin is omitted, {@link module:UWA/Class/Collection.UWA.Class.Collection#slice|slice}
         *  begins from index 0.
         *
         * @param {Integer} [end] - Zero-based index at which to end extraction.
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#slice|slice} extracts up to but
         *  not including end. As a negative index, end indicates an offset from the end of the collection.
         *  If end is omitted, slice extracts to the end of the collection.
         *
         * @return {Array} - The portion of models sliced from the collection.
         *
         * @example
         * // A fruity example
         * var salad1, salad2, salad3, // arrays of fruits
         *     listSaladIngredients, raspberryIdx,
         *     fruits; // collection of fruits
         *
         * // five fruits per day !
         * fruits = new Collection([{
         *     type: 'Banana'
         * }, {
         *     type: 'Orange'
         * }, {
         *     type: 'Strawberry'
         * }, {
         *     type: 'Apple'
         * }, {
         *     type: 'Mango'
         * }]);
         *
         * listSaladIngredients = function (salad) {
         *     UWA.log(salad.map(function (fruit) {
         *         return fruit.get('type');
         *     }).join(' + '));
         * };
         *
         * salad1 = fruits.slice(-2);
         * listSaladIngredients(salad1);
         * // outputs "Apple + Mango"
         *
         * salad2 = fruits.slice(1, 4);
         * listSaladIngredients(salad2);
         * // outputs "Orange + Strawberry + Apple"
         *
         * salad3 = fruits.slice(2, -1);
         * listSaladIngredients(salad3);
         * // outputs "Strawberry + Apple"
         *
         * // let's mutate the strawberry into a raspberry in
         * // our fruits collection :
         * fruits.findWhere({
         *     type: 'Strawberry'
         * }).set('type', 'Raspberry');
         *
         * listSaladIngredients(salad2);
         * // outputs "Orange + Raspberry + Apple"
         *
         * listSaladIngredients(salad3);
         * // outputs "Raspberry + Apple"
         *
         * // Oops, we shouldn't play with the genes,
         * // let's find the raspberry in the latest salad array ...
         * raspberryIdx = -1;
         * if (salad3.some(function (fruit, idx, salad) {
         *     if (fruit.get('type') === 'Raspberry') {
         *         raspberryIdx = idx;
         *         return true;
         *     }
         *     return false;
         * })) {
         *     // ... and mutate it back into a Strawberry :
         *     salad3[raspberryIdx].set('type', 'Strawberry');
         * }
         *
         * fruits.findWhere({
         *     type: 'Raspberry'
         * }); // return undefined
         *
         * UWA.is(fruits.findWhere({
         *     type: 'Strawberry'
         * })); // returns true
         */
        slice: function (begin, end) {
            return this._models.slice(begin, end);
        },

        /**
         * Returns all but the N first models in the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest} returns the rest of the
         * models of the collection (its tail) as an array. You can pass an index to return the models of the
         * collection from that index onward. The default behavior of {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest}
         * is to return all models but the first.
         *
         * Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest} does not alter
         * the collection, but copies references of models that formed the tail of collection into the
         * new returned array. Consequently *both the collection and the new returned array refer to
         * the same models*.
         *
         * - If a referenced model changes, the changes are visible to both the returned tail and the original
         * collection.
         * - If a new model is added to the collection (with {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         * for example), a previously returned tail is not affected.
         * - If a new model is added to returned tail, the collection is not affected.
         *
         * @param {Integer} [n] - to return the models of the collection from
         *  that index onward.
         *
         * @return {Array} - An array of the rest of the models of the collection.
         *
         * @example
         * var daltons;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe'
         * }, {
         *     firstName: 'Jack'
         * }, {
         *     firstName: 'William'
         * }, {
         *     firstName: 'Averell'
         * }]);
         *
         * UWA.log(JSON.stringify(daltons.rest()));
         *
         * // This logs (Joe has been arrested) :
         * // [{"firstName":"Jack"},{"firstName":"William"},{"firstName":"Averell"}]
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#initial|initial}
         */
        rest: function (n, guard) {
            // LRG : Remark : Not sure that the guard stuff, that allows
            // to use this method with map, should be kept ?
            return this._models.slice(((!Core.is(n)) || guard ? 1 : n));
        },

        /**
         * Returns all but the N last models in the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#initial|initial} returns as an array
         * all models but the last model in the collection (default behavior). You can pass an index N
         * to exclude the last N elements from the result. The default behavior of
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest} is to return all models
         * but the first (n=1 by default)
         *
         * Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#initial|initial} does not
         * alter the collection, but copies references of models into the new returned array.
         * Consequently *both the collection and the new returned array refer to
         * the same models*.
         *
         * * If a referenced model changes,
         * the changes are visible to both the returned array and the original
         * collection.
         *
         * * If a new model is added to the collection (with {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         * for example), a previously returned array is not affected.
         *
         * * If a new model is added to returned array, the collection is not affected.
         *
         * @param {Integer} [n] - to exclude the last n models from the returned array.
         *
         * @returns {Array} - An array of all models but the N last models of the collection.
         *
         * @example
         * var daltons;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe'
         * }, {
         *     firstName: 'Jack'
         * }, {
         *     firstName: 'William'
         * }, {
         *     firstName: 'Averell'
         * }]);
         *
         * UWA.log(JSON.stringify(daltons.initial(2)));
         *
         * // This logs :
         * [{"firstName":"Joe"},{"firstName":"Jack"}]
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#rest|rest}
         */
        initial: function (n, guard) {
            // LRG : Remark : Not sure that the guard stuff, that allows
            // to use this method with map, should be kept ?
            return this._models.slice(0, this._models.length - ((!Core.is(n)) || guard ? 1 : n));
        },

        /**
         * Returns a copy of the collection with all of the passed instances of
         * models removed.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without} returns a copy
         * of the collection with all of the passed instances of models removed.
         *
         * Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without} does not
         * alter the collection (no models are removed from the collection), but return a copy of references
         * of models except the ones that are passed in.
         * Consequently *both the collection and the returned array refer to the same models*.
         *
         * - If a referenced model changes, the changes are visible to both the copy returned by
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without} and the original collection.
         * - If a new model is added to the collection (with {@link module:UWA/Class/Collection.UWA.Class.Collection#add|add}
         * for example), a copy previously returned by {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without}
         * is not affected.
         * - If a new model is added to the copy returned by {@link module:UWA/Class/Collection.UWA.Class.Collection#without|without},
         * the collection is not affected.
         *
         * @param {UWA/Class/Model|Array} - The models not to return.
         *
         * @return {Array} - a copy of the collection with all of the passed instances of
         *   models removed.
         *
         * @example
         * var daltons,
         *     joe, bill,
         *     wanted;
         *
         * daltons = new UWA.Class.Collection([{
         *     name: 'Joe'
         * }, {
         *     name: 'Jack'
         * }, {
         *     name: 'William'
         * }, {
         *     name: 'Averell'
         * }]);
         *
         * joe = daltons.findWhere({
         *     name: 'Joe'
         * });
         *
         * bill = daltons.findWhere({
         *     name: 'William'
         * });
         *
         * // During the Federal Bank hold-up, Joe and Bill
         * // were having fun at the saloon :
         * wanted = daltons.without(joe, bill);
         *
         * UWA.log(JSON.stringify(wanted));
         *
         * // this logs :
         * // [{"name":"Jack"},{"name":"Averell"}]
         */
        without: function () {

            var rest;
            rest = Array.prototype.concat.apply([], Array.prototype.slice.call(arguments));
            return this._models.filter(function (model) {
                return (rest.indexOf(model)) === -1;
            });
        },

        /**
         * Returns the first index at which a given model can be found in the
         * collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#indexOf|indexOf} compares sought
         * model to models of the collection using strict equality (triple-equals operator), and returns
         * the first index at which a given model can be found in the collection, or -1 if it is
         * not present.
         *
         * @param {Object} sought - Model to locate in the collection.
         * @param {Integer} [fromIndex=0] - The index to start the search at.
         *  If the index is greater than or equal to the collection's length,
         *  -1 is returned, which means the collection will not be searched.
         *  If the provided index value is a negative number, it is taken
         *  as the offset from the end of the collection. Note: if the provided
         *  index is negative, the collection is still searched from front
         *  to back. If the calculated index is less than 0, then the whole
         *  collection will be searched.
         *  Defaults to 0 (Entire collection is searched)
         *
         * @return {Integer} - The first index at which the model is found in the
         *  collection, or -1 if not found.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#lastIndexOf|lastIndexOf}
         */
        indexOf: function (sought, fromIndex) {
            return this._models.indexOf(sought, fromIndex);
        },

        /**
         * Returns the last index at which a model can be found.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#lastIndexOf|lastIndexOf} returns
         * the last index at which a given model can be found in the collection, or -1 if it is not
         * present. The array is searched backwards, starting at fromIndex.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#lastIndexOf|lastIndexOf} compares
         * sought model to models of the collection using strict equality (triple-equals operator).
         *
         * @param {Object} sought - Model to locate in the collection.
         * @param {Integer} [fromIndex] - The index to start searching backwards.
         *  Defaults to the collection's length, i.e. the whole collection will be
         *  searched. If the index is greater than or equal to the
         *  collection's length, the whole collection will be searched.
         *  If the provided index value is a negative number, it is taken
         *  as the offset from the end of the collection. Note that even
         *  when the index is negative, the collection is still searched
         *  from front to back. If the calculated index is less than 0,
         *  -1 is returned, i.e. the collection will not
         *  be searched.
         *
         * @return {Integer} - The last index at which a given element can be found
         *      in the collection, or -1 if it is not present.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#indexOf|indexOf}
         */
        lastIndexOf: function (sought, fromIndex) {
            return this._models.lastIndexOf(sought, fromIndex);
        },

        /**
         * Returns true if the model is present in the collection.
         *
         * @param {UWA/Class/Model} model - Model to search in the collection.
         *
         * @return {Boolean} - true if the passed model is present in the collection,
         *  false otherwise.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#indexOf|indexOf}
         */
        contains: function (model) {
            return this.indexOf(model) !== -1;
        },

        /**
         * Returns the number of models in the collection.
         *
         * @return {Integer} - The number of models in the collection.
         */
        size: function () {
            return this._models.length;
        },

        /**
         * Returns true if the collection contains no model.
         *
         * @return {Boolean} - True if the collection contains no model.
         */
        isEmpty: function () {
            return this._models.length === 0;
        },

        /**
         * Returns an array containing the attributes hash of each model in the collection.
         *
         * This method returns an array containing the return value of each Model's toJSON
         * method in the collection, which by default will be its attributes hash.
         * This can be used to serialize and persist the collection as a whole.
         *
         * Note that the name of this method is a bit confusing (since its does not actually
         * returns a JSON string), but it conforms to JavaScript s JSON API at
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify,
         * in that way that it will be called by JSON.stringify to
         * determine the collection's JSON representation.
         *
         * Specified options will be passed to each model's toJSON method.
         *
         * @param {Object} [options] - an hash of options that will be passed to each model's toJSON method.
         *
         * @return {Array} - An array containing the attributes hash of each model in the collection.
         *
         * @example
         * var collection = new UWA.Class.Collection([
         *   {name: "Tim", age: 5},
         *   {name: "Ida", age: 26},
         *   {name: "Rob", age: 55}
         * ]);
         *
         * UWA.log(JSON.stringify(collection));
         */
        toJSON: function (options) {
            return this.map(function (model) {
                return model.toJSON(options);
            });
        },

        /**
         * Pluck an attribute from each model in the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#pluck|pluck} is a very handy method
         * that picks up an attribute from each model in the collection of models and returns an array
         * of all the values for this specific attribute in the collection. This is equivalent to calling
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#map|map} and returning a single
         * attribute from the callback.
         *
         * @param {String} attrName - The name of the attribute to pluck.
         *
         * @return {Array} - An array of all the values in this
         *  collection for this specific attribute.
         *
         * @example
         * var daltons, msg;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe',
         *     size: '4ft6in'
         * }, {
         *     firstName: 'Jack',
         *     size: '5ft6in'
         * }, {
         *     firstName: 'William',
         *     size: '6ft4in'
         * }, {
         *     firstName: 'Averell',
         *     size: '7ft'
         * }]);
         *
         * msg = "The Daltons are " + daltons.pluck('firstName').join(',');
         * UWA.log(msg);
         */
        pluck: function (attr) {
            return this._models.map(function (value) {
                return value.get(attr);
            });
        },

        /**
         * Returns a shuffled copy of the collection models as an array.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#shuffle|shuffle} returns a shuffled
         * copy of the collection models, as an array, using a version of the Fisher-Yates shuffle.
         *
         * @return {Array} - A shuffled copy of the collection's models.
         */
        shuffle: function () {
            var rand, shuffled;
            shuffled = [];
            this.forEach(function (model, index) {
                rand = Utils.random(index);
                shuffled[index] = shuffled[rand];
                shuffled[rand] = model;
            });
            return shuffled;
        },

        /**
         * Return an array of all the models in the collection that match the
         * passed attributes.
         *
         * Useful for simple cases of {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter}.
         *
         * @param {Object} attrs - an hash of attributes to filter the models.
         *
         * @return {Array} - all the models in the collection that match the
         *  passed attributes. An empty array if there is no match.
         *
         * @example
         * var friends, musketeers;
         *
         * friends = new UWA.Class.Collection([{
         *     name: "Athos",
         *     job: "Musketeer"
         * }, {
         *     name: "Porthos",
         *     job: "Musketeer"
         * }, {
         *     name: "Aramis",
         *     job: "Musketeer"
         * }, {
         *     name: "d'Artagnan",
         *     job: "Guard"
         * }]);
         *
         * musketeers = friends.where({
         *     job: "Musketeer"
         * });
         *
         * UWA.log(musketeers.length); // this logs '3'
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter}
         */
        where: function (attrs, first) {
            if (!Core.is(attrs)) {
                return (first ? undefined : []);
            }

            return this[first ? 'find' : 'filter'](function (model) {
                var key;
                for (key in attrs) {
                    if (attrs[key] !== model.get(key)) {
                        return false;
                    }
                }
                return true;
            });
        },

        /**
         * Returns the first model in the collection that matches the passed attributes.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#findWhere|findWhere} is just like
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#where|where}, but it directly returns
         * only the first model in the collection that matches the passed attributes.
         *
         * @param {Object} attrs - an hash of attributes to find the model.
         *
         * @return {Object} - The first model in the collection that matches the
         *  passed attributes. Undefined if not found.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#where|where}, {@link module:UWA/Class/Collection.UWA.Class.Collection#find|find}
         */
        findWhere: function (attrs) {
            return this.where(attrs, true);
        },

        /**
         * Invoke a provided model method name once per model of the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#invoke|invoke} calls the model
         * method named by methodName on each model in the collection, and returns the array of results.
         * Any extra arguments passed to {@link module:UWA/Class/Collection.UWA.Class.Collection#invoke|invoke}
         * will be forwarded on to the method invocation.
         *
         * @param {String} methodName - the name of a method of the model
         * @param {Void} Other parameters - parameters passed to the method call.
         *
         * @return {Array} - The list of the results of method call.
         *
         * @example
         * var shoppingList;
         *
         * shoppingList = new UWA.Class.Collection([{
         *     name: 'bananas'
              }, {
                  name: 'washing powder'
              }, {
                  name: 'eggs'
              }, {
                  name: 'pen'
         * }]);
         * // This will set the attribute 'quantity' to 1 on all items in
         * // the shopping list :
         * shoppingList.invoke('set', 'quantity', 1);
         *
         */
        invoke: function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(this._models);
            return UWAArray.invoke.apply(null, args);
        },

        /* Group: Iteration methods

            *Methods taking as arguments functions to be called back when processing
            the collection*.

            When these methods are called, the length of the collection is sampled,
            and any model added beyond this length from within the callback is not
            visited. Other changes to the collection (modifying attributes of a
            model or deleting a model) may affect the results of the
            operation if the method visits the changed model afterwards. *While the
            specific behavior of these methods in such cases is well-defined, you
            should not rely upon it so as not to confuse others who might read
            your code*.

            As a rule of thumb :

            * If you must mutate the collection by adding models, removing models
                or re-sorting the collection (why would you do that inside your
                callback, padawan?), iterate on a cloned collection (see
                {@link module:UWA/Class/Collection.UWA.Class.Collection#clone|clone}).
            * Most of the time, your callback function signature should take at most
                only two arguments (the current model that is visited and sometimes
                its index), this should prevent you from misbehaving.
        */

        /**
         * Executes a provided function once per model of the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#forEach|forEach} executes the
         * provided callback function once for each model of the collection.
         *
         * __Notes__:
         *
         * - If a context parameter is provided to {@link module:UWA/Class/Collection.UWA.Class.Collection#forEach|forEach},
         * it will be used as the this value for each callback invocation as if
         * callback.call(context, model, index, models) was called.
         * If context is undefined or null, the this value within the function
         * depends on whether the function is in strict mode or not
         * (passed value (undefined or null) if in strict mode, global object
         * if in non-strict mode).
         * - There is no way to stop or break a {@link module:UWA/Class/Collection.UWA.Class.Collection#forEach|forEach}
         * loop. The solution is to use {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every} or
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some}.
         * - To prevent potential unwanted side effects (like corrupting the collection), as a rule of thumb :
         *     * you should not (in your callback implementation) add
         *         or remove models from the list passed as third argument
         *         to callback.
         *     * most of the time, your callback signature should take at most
         *         only two arguments (the current model that is visited and
         *         its index), this should prevent you from misbehaving.
         *
         * @param {Function} callback - Function to execute for each model.
         *  It is invoked with three arguments:
         *  - the current model
         *  - the index of the current model
         *  - the *array of models* of the collection being traversed
         *  (not the collection itself). Please read note above
         *  about this argument.
         *
         * @param {Object} context - Object to use as this when executing callback.
         *
         * @example
         * var daltons;
         *
         * daltons = new UWA.Class.Collection([{
         *     name: 'Joe'
         * }, {
         *     name: 'Jack'
         * }, {
         *     name: 'William'
         * }, {
         *     name: 'Averell'
         * }]);
         *
         * daltons.forEach(function (dalton, idx) {
         *     UWA.log(UWA.String.format("Dalton #{0} is {1}", idx+1, dalton.get('name')));
         * });
         *
         * // This logs :
         * // Dalton 1 is Joe
         * // Dalton 2 is Jack
         * // Dalton 3 is William
         * // Dalton 4 is Averell
         */
        forEach: function (callback, context) {
            return this._models.forEach(callback, context);
        },

        /**
         * Returns a new array with the results of calling a provided function
         * on every model.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#map|map} calls a provided callback
         * function once for each model of the collection, in order, and constructs a new array from the results.
         *
         * callback is invoked with three arguments:
         *
         * * the current model,
         * * the index of the current model,
         * * and an array of the models being traversed (not the collection
         *     itself). Please read notes below about this argument.
         *
         * callback must return a value of any type.
         *
         * If a context parameter is provided to {@link module:UWA/Class/Collection.UWA.Class.Collection#map|map},
         * it will be used as the this for each invocation of the callback. If it is not provided, or
         * is null, the global object associated with callback is used instead.
         *
         * __Notes__:
         *
         * To prevent potential unwanted side effects (like corrupting the
         * collection), as a rule of thumb:
         *
         * * you should not (in your callback implementation) add
         *     or remove models from the list passed as third argument
         *     to callback.
         * * most of the time, your callback signature should take at most
         *     only two arguments (the current model that is visited and
         *     its index), this should prevent you from misbehaving.
         *
         * @param {Function} callback - Function to execute for each model.
         *  It is invoked with three arguments:
         *  - the current model
         *  - the index of the current model
         *  - the *array of models* of the collection being traversed
         *  (not the collection itself). Please read note above
         *  about this argument.
         *
         * @param {Object} context - Object to use as this when executing callback.
         *
         * @returns {Array} - a new array with the results of calling callback
         *  on every model.
         *
         * @example
         * var daltons, getSizeInInches,
         *     cachedRegexp = /^([1-9]\d*)ft(([1-9]\d*)in)?$/,
         *     footInInches = 12;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe',
         *     size: '4ft6in'
         * }, {
         *     firstName: 'Jack',
         *     size: '5ft6in'
         * }, {
         *     firstName: 'William',
         *     size: '6ft4in'
         * }, {
         *     firstName: 'Averell',
         *     size: '7ft'
         * }]);
         *
         * getSizeInInches = function (dalton) {
         *     var matchingGroups = dalton.get('size').match(cachedRegexp);
         *     return parseInt(matchingGroups[1], 10)*footInInches + parseInt(matchingGroups[3] || 0, 10);
         * };
         *
         * UWA.log(JSON.stringify(daltons.map(getSizeInInches)));
         *
         * // This logs :
         * // [54,66,76,84]
         */
        map: function (callback, context) {
            return this._models.map(callback, context);
        },

        /**
         * Tests whether all models in the collection pass the test
         * implemented by the provided function.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every} executes the provided
         * callback function once for each model present in the collection until it finds one where
         * callback returns a falsy value (a value that becomes false when converted to a Boolean).
         * If such a model is found, {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every}
         * immediately returns false. Otherwise, {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every}
         * returns true, meaning that the provided callback function returned true for all models of
         * the collection.
         *
         * callback is invoked with three arguments:
         *
         *  * the current model,
         *  * the index of this current model,
         *  * and an array of the models being traversed.
         *
         * If a context parameter is provided to {@link module:UWA/Class/Collection.UWA.Class.Collection#every|every},
         * it will be used as the this for each invocation of the callback. If it is not provided, or
         * is null, the global object associated with callback is used instead.
         *
         * __Notes__:
         *
         * To prevent potential unwanted side effects (like corrupting the
         * collection), as a rule of thumb:
         *
         * * you should not (in your callback implementation) add
         *     or remove models from the list passed as third argument
         *     to callback.
         * * most of the time, your callback signature should take at most
         *     only two arguments (the current model that is visited and
         *     its index), this should prevent you from misbehaving.
         *
         * @param {Function} callback - Function to execute for each model.
         *  It is invoked with three arguments:
         *  - the current model
         *  - the index of the current model
         *  - the *array of models* of the collection being traversed
         *  (not the collection itself). Please read note above
         *  about this argument.
         *
         * @param {Object} context - Object to use as this when executing callback.
         *
         * @return {Boolean} - false if at least one model does not pass the test implemented
         *  by callback, true otherwise.
         */
        every: function (callback, context) {
            return this._models.every(callback, context);
        },

        /**
         * Tests whether some model in the collection passes the test
         * implemented by the provided function.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some} executes the callback
         * function once for each model present in the collection until it finds one where callback
         * returns a true value.
         * If such a model is found, {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some}
         * immediately returns true.
         * Otherwise, {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some} returns false.
         *
         * Callback is invoked with three arguments:
         *
         *  * the current model,
         *  * the index of this current model,
         *  * and an array of the models being traversed.
         *
         * If a context parameter is provided to {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some},
         * it will be used as the this for each invocation of the callback. If it is not provided, or
         * is null, the global object associated with callback is used instead.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#some|some} does not mutate the
         * collection on which it is called (read notes below though), unless of course your callback
         * modifies models.
         *
         * __Notes__:
         *
         * To prevent potential unwanted side effects (like corrupting the
         * collection), as a rule of thumb:
         *
         * * you should not (in your callback implementation) add
         *     or remove models from the list passed as third argument
         *     to callback.
         * * most of the time, your callback signature should take at most
         *     only two arguments (the current model that is visited and
         *     its index), this should prevent you from misbehaving.
         *
         * @param {Function} callback - Function to execute for each model.
         *  It is invoked with three arguments:
         *  - the current model
         *  - the index of the current model
         *  - the *array of models* of the collection being traversed
         *  (not the collection itself). Please read note above
         *  about this argument.
         *
         * @param {Object} context - Object to use as this when executing callback.
         *
         * @return {Boolean} - true if at least one model passes the test implemented
         *  by callback, false otherwise.
         */
        some: function (callback, context) {
            return this._models.some(callback, context);
        },

        /**
         * Returns a sorted copy of the collection's models.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#sortBy|sortBy} returns a stably
         * sorted copy of the collection's models, ranked in ascending order by the results of running
         * each model through the passed 'hash' function.
         * Hash may also be the string name of a model attribute to sort by.
         *
         * Note that *the collection and the returned sorted array reference the
         * same models*
         *
         * __Notes__:
         *  sortBy does not make use of the {@link module:UWA/Class/Collection.UWA.Class.Collection#comparator|comparator}
         *  property at all.
         *
         * @param {String|Function} hash - The string name of a model attribute to sort by. Or a
         *  function to execute on each model in the collection to return a
         *  hash value (of any type: numerical, string, logical, or object).
         *  Hash takes a model as argument.
         *
         * @param {Object} context - Object to use as this when executing hash.
         *
         * @return {Array} - A sorted copy of the collection's models.
         *
         * @example
         * var daltons,
         *     daltonsByAscendingName, daltonsByAscendingSize,
         *     cachedRegexp,
         *     footInInches = 12;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe',
         *     size: '4ft6in'
         * }, {
         *     firstName: 'Jack',
         *     size: '5ft6in'
         * }, {
         *     firstName: 'William',
         *     size: '6ft4in'
         * }, {
         *     firstName: 'Averell',
         *     size: '7ft'
         * }]);
         *
         * daltonsByAscendingName = daltons.sortBy('firstName');
         *
         * UWA.log(JSON.stringify(daltonsByAscendingName));
         *
         * // [{
         * //      "firstName":"Averell",
         * //      "size":"7ft"
         * //  }, {
         * //      "firstName":"Jack",
         * //      "size":"5ft6in"
         * //  }, {
         * //      "firstName":"Joe",
         * //      "size":"4ft6in"
         * //  }, {
         * //      "firstName":"William",
         * //      "size":"6ft4in"
         * //  }]
         *
         * cachedRegexp = /^([1-9]\d*)ft(([1-9]\d*)in)?$/;
         * daltonsByAscendingSize = daltons.sortBy(function (dalton) {
         *     var matchingGroups = dalton.get('size').match(cachedRegexp);
         *     return parseInt(matchingGroups[1], 10)*footInInches + parseInt(matchingGroups[3] || 0, 10);
         * });
         *
         * UWA.log(JSON.stringify(daltonsByAscendingSize));
         *
         * // [{
         * //      "firstName":"Joe",
         * //      "size":"4ft6in"
         * //  }, {
         * //      "firstName":"Jack",
         * //      "size":"5ft6in"
         * //  }, {
         * //      "firstName":"William",
         * //      "size":"6ft4in"
         * //  }, {
         * //      "firstName":"Averell",
         * //      "size":"7ft"
         * //  }]
         *
         * // Note that daltons collection remained unchanged.
         */
        sortBy: function (hash, context) {
            var lookupHash, sortedModels;
            lookupHash = lookupIterator(hash);
            sortedModels = this._models.map(function (model, index, list) {
                return {
                    model: model,
                    index: index,
                    criteria: lookupHash.call(context, model, index, list)
                };
            });
            sortedModels.sort(function (left, right) {
                var a, b;
                a = left.criteria;
                b = right.criteria;
                if (a !== b) {
                    if (a > b || a === undefined) {
                        return 1;
                    }
                    if (a < b || b === undefined) {
                        return -1;
                    }
                }
                if (left.index < right.index) {
                    return -1;
                }
                return 1;
            });
            return sortedModels.map(function (model) {
                return model.model;
            });
        },

        /**
         * Splits the collection into sets.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#groupBy|groupBy} splits the collection
         * into sets, grouped by the result of running each model through hash.
         *
         * If hash is a string instead of a function, groups by the property
         * named by hash on each of the model.
         *
         * *The collection and the returned object (associative array)
         * reference the same models*
         *
         * The collection and all its models are left unmodified by
         * this method.
         *
         * @param {String|Function} hash - The string name of a model attribute to sort by. Or a
         *  function to execute on each model in the collection to return a
         *  hash value (of any type: numerical, string, logical, or object).
         *  Hash takes a model as argument.
         *
         * @param {Object} context - Object to use as this when executing hash.
         *
         * @return {Object} - An object (aka associative array) which keys are the
         *  ones computed by the hash argument and which values are arrays of
         *  models (the sets/groups).
         *
         * @example
         * var CartItem, cartList, cartsByComCode;
         *
         * CartItem = UWA.Class.Model.extend({
         *
         *     defaults: {
         *         plucode: 0,
         *         title: 'cnpdx.cart',
         *         discount: 100,
         *         qty: 5,
         *         price: 100,
         *         extendcode: 0,
         *         checked: false,
         *         salemode: 1,
         *         comcode: 0,
         *         guide: '3'
         *     }
         * });
         *
         * // a collection with some cartitems:
         *
         * cartList = new UWA.Class.Collection([{
         *     plucode: '123454',
         *     title: 'coffee drinking',
         *     discount: 80,
         *     qty: 5,
         *     price: 10,
         *     extendcode: '123451,123452',
         *     salemode: 2,
         *     comcode: '7-301',
         *     guide: 3
         * }, {
         *     plucode: '123423',
         *     title: 'photography',
         *     discount: 80,
         *     qty: 5,
         *     price: 100,
         *     extendcode: '123421,123422',
         *     salemode: 2,
         *     comcode: '7-302',
         *     guide: 3
         * }, {
         *     plucode: '123424',
         *     title: 'coffee drinking',
         *     discount: 80,
         *     qty: 5,
         *     price: 10,
         *     extendcode: '123421,123422',
         *     salemode: 2,
         *     comcode: '7-302',
         *     guide: 3
         * }], {
         *     model: CartItem
         * });
         *
         * cartsByComCode = cartList.groupBy('comcode');
         *
         * UWA.log(JSON.stringify(cartsByComCode));
         *
         * // This outputs :
         * // {
         * //     "7-301": [{
         * //         "plucode": "123454",
         * //         "title": "coffee drinking",
         * //         "discount": 80,
         * //         "qty": 5,
         * //         "price": 10,
         * //         "extendcode": "123451,123452",
         * //         "salemode": 2,
         * //         "comcode": "7-301",
         * //         "guide": 3,
         * //         "checked": false
         * //     }],
         * //
         * //     "7-302": [{
         * //         "plucode": "123423",
         * //         "title": "photography",
         * //         "discount": 80,
         * //         "qty": 5,
         * //         "price": 100,
         * //         "extendcode": "123421,123422",
         * //         "salemode": 2,
         * //         "comcode": "7-302",
         * //         "guide": 3,
         * //         "checked": false
         * //     }, {
         * //         "plucode": "123424",
         * //         "title": "coffee drinking",
         * //         "discount": 80,
         * //         "qty": 5,
         * //         "price": 10,
         * //         "extendcode": "123421,123422",
         * //         "salemode": 2,
         * //         "comcode": "7-302",
         * //         "guide": 3,
         * //         "checked": false
         * //     }]
         * // }
         */
        groupBy: function (hash, context) {
            var iterator, result, models = this._models;

            iterator = lookupIterator(hash);

            result = {};

            this.forEach(function (model, index) {
                var key = iterator.call(context, model, index, models);
                if (!Core.owns(result, key)) {
                    result[key] = [];
                }
                result[key].push(model);
            });

            return result;
        },

        /**
         * Sorts the collection into groups and returns a count of models in each group
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#groupBy|groupBy} is similar to
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#groupBy|groupBy}, but instead of
         * returning a list of models, returns a count for the number of models in that group.
         *
         * If hash is a string instead of a function, groups by the property
         * named by hash on each of the model.
         *
         * *The collection and the returned object (associative array)
         * reference the same models*
         *
         * The collection and all its models are left unmodified by
         * this method.
         *
         * @param {String|Function} hash - The string name of a model attribute to sort by. Or a
         *  function to execute on each model in the collection to return a
         *  hash value (of any type: numerical, string, logical, or object).
         *  Hash takes a model as argument.
         *
         * @param {Object} context - Object to use as this when executing hash.
         *
         * @returns {Object} - An object (aka associative array) which keys are the
         *  ones computed by the hash argument and which values are the
         *  counts of models in each group.
         *
         * @example
         * var BugReport, Backlog, rawBacklogData, myBacklog;
         *
         * BugReport = (function () {
         *
         *     var states, releaseNumberRegExp, ownerTrigramRegExp;
         *
         *     states = {
         *         open: 'Open',
         *         underAnalysis: 'Under Analysis',
         *         rejected: 'Rejected',
         *         fixed: 'Fixed'
         *     };
         *
         *     // cached RegExp for releases numbers :
         *     releaseNumberRegExp = /^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/;
         *
         *     // cached RegExp for owner bi/trigram :
         *     ownerTrigramRegExp = /^[a-zA-Z][a-zA-Z0-9]{1,2}$/;
         *
         *     return UWA.Class.Model.extend({
         *         defaults: {
         *             abstract: '',
         *             state: 'open',
         *             owner: '',
         *             release: ''
         *         },
         *         validate: function(attrs, options) {
         *             if (!UWA.owns(states, attrs.state)) {
         *                 return UWA.String.format('Invalid state "{0}"', attrs.state);
         *             }
         *             if (!releaseNumberRegExp.test(attrs.release)) {
         *                 return UWA.String.format('Invalid release number "{0}"', attrs.release);
         *             }
         *             if (!attrs.abstract) {
         *                 return UWA.String.format('Invalid abstract "{0}"', attrs.abstract);
         *             }
         *             if (!ownerTrigramRegExp.test(attrs.owner)) {
         *                 return UWA.String.format('Invalid owner trigram "{0}"', attrs.owner);
         *             }
         *         }
         *     });
         * })();
         *
         * Backlog = UWA.Class.Collection.extend({
         *     model: BugReport,
         *
         *     logStatistics: function () {
         *         var statLog, stats, attrValues, lastAttrValIdx;
         *         // This is a way (probably not the cleanest) to access BugReport's metadatas :
         *         Object.keys(this.model.prototype.defaults).forEach(function (attrName) {
         *             if (attrName === 'abstract') return; // no stats concerning abstracts !
         *             statLog = attrName + ': ';
         *             stats = this.countBy(attrName);
         *             attrValues = Object.keys(stats);
         *             lastAttrValIdx = attrValues.length - 1;
         *             attrValues.forEach(function (attrVal, idx) {
         *                 var count;
         *                 count = stats[attrVal];
         *                 statLog += UWA.String.format('{0} bugs are {1}{2}', count, attrVal, idx < lastAttrValIdx ? ', ' : '.');
         *             });
         *             UWA.log(statLog);
         *         }, this);
         *     }
         * });
         *
         * // some raw json data from osyrix :
         * rawBacklogData = [{
         *     abstract: 'UWA.Class.Model is bug-free',
         *     state: 'open',
         *     owner: 'XXS',
         *     release: '2.0.3'
         * }, {
         *     abstract: 'UWA.Class.Collection does not make Coffee',
         *     state: 'underAnalysis',
         *     owner: 'LRG',
         *     release: '2.0.4'
         * }, {
         *     abstract: 'UWA.Class.Collection of bugs',
         *     state: 'open',
         *     owner: 'WTF',
         *     release: '2.0.0'
         * }, {
         *     abstract: 'UWA.Class.Events did not wake me up this morning',
         *     state: 'fixed',
         *     owner: 'AAA',
         *     release: '2.0.1'
         * }, {
         *     abstract: 'UWA.Class.View the future',
         *     state: 'fixed',
         *     owner: 'BBB',
         *     release: '2.0.0'
         * }, {
         *     abstract: 'UWA.Class.Model kit',
         *     state: 'rejected',
         *     owner: 'LRG',
         *     release: '2.0.1'
         * }, {
         *     abstract: 'UWA.Class.Collection is empty',
         *     state: 'underAnalysis',
         *     owner: 'LRG',
         *     release: '2.0.9'
         * }];
         *
         * myBacklog = new Backlog([]);
         *
         * myBacklog.addEvent('onValidationFailure', function (backlog, error, options) {
         *     UWA.log('failed to create model because ' + error);
         * });
         *
         * myBacklog.set(rawBacklogData, {
         *     validate: true
         * }).logStatistics();
         *
         * // this logs :
         *
         * // state: 2 bugs are open, 2 bugs are underAnalysis, 2 bugs are fixed, 1 bugs are rejected.
         * // owner: 1 bugs are XXS, 3 bugs are LRG, 1 bugs are WTF, 1 bugs are AAA, 1 bugs are BBB.
         * // release: 1 bugs are 2.0.3, 1 bugs are 2.0.4, 2 bugs are 2.0.0, 2 bugs are 2.0.1, 1 bugs are 2.0.9.
         */
        countBy: function (hash, context) {
            var iterator, result, models = this._models;

            iterator = lookupIterator(hash);

            result = {};

            this.forEach(function (model, index) {
                var key = iterator.call(context, model, index, models);
                if (!Core.owns(result, key)) {
                    result[key] = 0;
                }
                result[key]++;
            });

            return result;
        },

        /**
         * Returns the first model in the
         * collection for which the provided filtering function 'filter' returns true.
         *
         * @param {Function} filter - Function to test each model of this collection.
         *  It is passed three parameters :
         *  - model : the current model to test
         *  - index : the index of the current model in this collection
         *  - models : the array of models of this collection
         *
         * @param {Object} context - Object to use as this when executing filter.
         *
         * @return {Object} - The first model in the collection for which the provided
         *   filtering function 'filter' returns true. Undefined if not found.
         *
         * @example
         * var theBeatles, hasTwoPositions;
         *
         * theBeatles = new UWA.Class.Collection([{
         *     name: 'Ringo Starr',
         *     position: 'drummer'
         * }, {
         *     name: 'Paul McCarthney',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'John Lennon',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'Georges Harrisson',
         *     position: 'Bassist'
         * }]);
         *
         * hasTwoPositions = function (beatle) {
         *     return beatle.get('position').split(' & ').length > 1;
         * };
         *
         * theBeatles.find(hasTwoPositions);
         *
         * // returns the first Beatle who has two positions,
         * // Sir Paul McCarthney :
         * // {
         * //      name: 'Paul McCarthney',
         * //      position: 'guitarist & singer'
         * //  }
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter}
         */
        find: function (filter, context) {
            var result;
            this.some(function (model, index, models) {
                if (filter.call(context, model, index, models)) {
                    result = model;
                    return true;
                }
            });
            return result;
        },

        /**
         * Creates a new array with all the models of this collection for
         * which the provided filtering function 'filter' returns true.
         *
         * Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter} does not
         * alter the collection (no models are removed from the collection)
         *
         * @param {Function} filter - Function to test each model of this collection.
         *  It must return a boolean and it is passed three parameters :
         *  - model : the current model to test
         *  - index : the index of the current model in this collection
         *  - models : the array of models of this collection
         *
         * @param {Object} context - Object to use as this when executing filter.
         *
         * @return {Array} - Returns a new array of models that pass the filter function
         *
         * @example
         * // First example, with the Fab Four
         * var theBeatles, hasTwoPositions;
         *
         * theBeatles = new Collection([{
         *     name: 'Ringo Starr',
         *     position: 'drummer'
         * }, {
         *     name: 'Paul McCarthney',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'John Lennon',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'Georges Harrisson',
         *     position: 'Bassist'
         * }]);
         *
         * hasTwoPositions = function (beatle) {
         *     return beatle.get('position').split(' & ').length > 1;
         * };
         *
         * theBeatles.filter(hasTwoPositions);
         *
         * // returns the second and third models in a new array :
         * //  [{
         * //      name: 'Paul McCarthney',
         * //      position: 'guitarist & singer'
         * //  }, {
         * //      name: 'John Lennon',
         * //      position: 'guitarist & singer'
         * //  }]
         *
         * // Second example, where we want to return the names of the audiophiles in a contacts book :
         * var Contact, myContactsBook;
         *
         * Contact = UWA.Class.Model.extend({
         *     idAttribute: 'name',
         *     isInterestedIn: function (interest) {
         *         var interests = this.get('interests');
         *         if (UWA.is(interests, 'array')) {
         *             return interests.indexOf(interest) > -1;
         *         }
         *         return false;
         *     }
         * });
         *
         * // define and instanciation at the same time. Don't do that in your code.
         * myContactsBook = new (UWA.Class.Collection.extend({
         *     model: Contact,
         *     listAudiophilesNames: function () {
         *         return UWA.Array.invoke(this.filter(function (contact) {
         *             return contact.isInterestedIn('audio');
         *         }), 'get', 'name');
         *     }
         * }))([{
         *     name: 'Jen',
         *     interests: ['audio', 'gaming', 'running']
         * }, {
         *     name: 'Ben',
         *     interests: ['skating', 'eating', 'tap-dancing']
         * }, {
         *     name: 'Ken',
         *     interests: ['partying', 'life in plastic', 'audio']
         * }]);
         *
         * myContactsBook.listAudiophilesNames(); // returns ["Jen", "Ken"]
         */
        filter: function (filter, context) {
            return this._models.filter(filter, context);
        },

        /**
         * Returns the models in this collection without the models that
         * the truth test (filter) passes. The opposite of {@link module:UWA/Class/Collection.UWA.Class.Collection#filter|filter}.
         *
         * Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#reject|reject} does not
         * alter the collection (no models are removed from the collection).
         *
         * @param {Function} filter - Function to test each model of this collection.
         *  It is passed three parameters :
         *  - model : the current model to test
         *  - index : the index of the current model in this collection
         *  - models : the array of models of this collection
         *
         * @param {Object} context - Object to use as this when executing filter.
         *
         * @return {Array} - Returns a new array of models that do not pass the filter
         *  function.
         *
         * @example
         * var theBeatles, isADrummer;
         *
         * theBeatles = new UWA.Class.Collection([{
         *     name: 'Ringo Starr',
         *     position: 'drummer'
         * }, {
         *     name: 'Paul McCarthney',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'John Lennon',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'Georges Harrisson',
         *     position: 'Bassist'
         * }]);
         *
         * isADrummer = function (beatle) {
         *     return beatle.get('position') === 'drummer';
         * };
         *
         * theBeatles.reject(isADrummer);
         * // returns all the models, except Ringo.
         */
        reject: function (iterator, context) {
            return this.filter(function (model, idx, models) {
                return !iterator(model, idx, models);
            }, context);
        },

        /**
         * Apply a function against an accumulator and each
         * model to reduce the collection to a single value.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#reduce|reduce} applies a function
         * (passed as reducer) against an accumulator and each
         * model of this collection (from left-to-right) as to reduce this collection
         * to a single value (that is the final value of the accumulator).
         * Note that this collection and all its models are left unmodified by
         * this method.
         *
         * @param {Function} reducer - Iterator function to execute on each model in the
         * collection against an accumulator. It takes four arguments :
         * - previousValue
         *     The value previously returned in the last invocation of the
         *     reducer function, or initialValue, if supplied. (See below.)
         * - currentModel
         *     The current model being processed in this collection.
         * - index
         *     The index of the current model being processed in this collection.
         * - models
         *      The list of models being reduced (not the collection itself!)
         *
         * @param {Object} [initialValue] - Object to use as the first argument to the first call
         *  to the reducer function. That is to say this is the initial value
         *  of the accumulator. This parameter is optional : If initialValue is
         *  provided in the call to {@link module:UWA/Class/Collection.UWA.Class.Collection#reduce|reduce},
         *  then, the first time reducer is
         *  called, previousValue will be equal to initialValue and currentModel
         *  will be equal to the first model in this collection. If no initialValue
         *  is provided, then previousValue will be equal to the first model in
         *  this collection and currentModel will be equal to the second. (note
         *  that in this later case, reducer must be a function taking two models
         *  to output a new model)
         *
         * @param {Object} [context] - The object the reducer will be bound to when
         *  called.
         *
         * @returns {UWA/Class/Model} - The reduced single value of the collection.
         *
         * @example
         * var theBeatles, creditor;
         *
         * theBeatles = new UWA.Class.Collection([{
         *     name: 'Ringo Starr',
         *     position: 'drummer'
         * }, {
         *     name: 'Paul McCarthney',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'John Lennon',
         *     position: 'guitarist & singer'
         * }, {
         *     name: 'Georges Harrisson',
         *     position: 'Bassist'
         * }]);
         *
         * creditor = function (credits, currentBeatle, idx) {
         *     credits += currentBeatle.get('name') + " (" + currentBeatle.get('position') + ")";
         *     if (idx < 3) {
         *         credits += " & ";
         *     }
         *     return credits;
         * };
         *
         * theBeatles.reduce(creditor, "The Beatles are ");
         * // returns "The Beatles are Ringo Starr (drummer) & Paul McCarthney (guitarist & singer)
         * // & John Lennon (guitarist & singer) & Georges Harrisson (Bassist)"
         */
        reduce: function (reducer, initialValue, context) {

            var boundReducer = reducer;

            if (context) {
                boundReducer = boundReducer.bind(context);
            }
            if (arguments.length > 1) {
                return this._models.reduce(boundReducer, initialValue);
            }

            // In this case, prevent from calling UWA's reduce polyfill with
            // undefined _if no initialValue is provided_, which could lead to
            // surprises...
            return this._models.reduce(boundReducer);
        },

        /**
         * This is the right-associative version of {@link module:UWA/Class/Collection.UWA.Class.Collection#reduce|reduce}.
         * See {@link module:UWA/Class/Collection.UWA.Class.Collection#reduce|reduce} for
         * more details about the behavior of this method.
         *
         * @param {Function} reducer - Iterator function to execute on each model in the
         *  collection against an accumulator. It takes four arguments :
         *    - - previousValue
         *        The value previously returned in the last invocation of the
         *        reducer function, or initialValue, if supplied. (See below.)
         *    - - currentModel
         *        The current model being processed in this collection.
         *    - - index
         *        The index of the current model being processed in this collection.
         *    - - collection
         *        The collection {@link module:UWA/Class/Collection.UWA.Class.Collection#reduceRight|reduceRight}
         *        is called upon.
         *
         * @param {Object} [initialValue] - Object to use as the first argument to the first call
         *  to the reducer function. That is to say this is the initial value
         *  of the accumulator. This parameter is optional : If initialValue is
         *  provided in the call to {@link module:UWA/Class/Collection.UWA.Class.Collection#reduceRight|reduceRight},
         *  then, the first time reducer is
         *  called, previousValue will be equal to initialValue and currentModel
         *  will be equal to the last model in this collection. If no initialValue
         *  is provided, then previousValue will be equal to the last model in
         *  this collection and currentModel will be equal to the second-to-last
         *  model. (note that in this later case, reducer must be a function taking
         *  two models to output a new model)
         *
         * @param {Object} [context] - The object the reducer will be bound to when
         *  called.
         *
         * @return {UWA/Class/Model} - The reduced single value of the collection.
         */
        reduceRight: function (reducer, initialValue, context) {

            var boundReducer = reducer;

            if (context) {
                boundReducer = boundReducer.bind(context);
            }
            if (arguments.length > 1) {
                return this._models.reduceRight(boundReducer, initialValue);
            }

            // In this case, prevent from calling UWA's reduceRight polyfill with
            // undefined _if no initialValue is provided_, which could lead to
            // surprises...
            return this._models.reduceRight(boundReducer);
        },

        /**
         * Returns the maximum model in the collection, with regards to a criterion.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max} returns the maximum model
         * in the collection. If an hash function is
         * provided, it will be used on each model to generate the criterion
         * by which the model is ranked. The criterion computed by the hash
         * function must be a number (otherwise undefined will be returned).
         * Hash may also be the string name of a model attribute *which values
         * are numbers*.
         *
         * If the collection is empty, undefined is returned.
         *
         * __Notes__:
         *
         * To prevent potential unwanted side effects (like corrupting the
         * collection), as a rule of thumb :
         *
         *  * you should not (in your hash function) add
         *      or remove models from the list passed as third argument
         *      to the hash function.
         *  * most of the time, your hash function signature should take at most
         *      only two arguments (the current model that is visited and
         *      its index), this should prevent you from misbehaving.
         *
         * @param {String} hash - The string name of a model attribute *which type is a
         *  number*. Or a function used on each model to  generate the criterion
         *  by which the model is ranked. It is invoked with three arguments:
         *      - - the current model
         *      - - the index of the current model in the collection
         *      - - the *array of models* of the collection being traversed
         *          (not the collection itself). Please read note above
         *          about this argument.
         *  It must return a criterion which type is number.
         *
         * @param {Object} [context] - Object to use as this when executing
         *  the hash function.
         *
         * @return {Object} - the maximum model in the collection, with regards to the
         *  computed criterion. If there are several maxima, the first found is
         *  returned. undefined is returned if criteria are not numbers or
         *  if the collection is empty.
         *
         * @example
         * var daltons, getSizeInInches, maxName,
         *     cachedRegexp = /^([1-9]\d*)ft(([1-9]\d*)in)?$/,
         *     footInInches = 12;
         *
         * daltons = new UWA.Class.Collection([{
         *     firstName: 'Joe',
         *     age: 32,
         *     size: '4ft6in'
         * }, {
         *     firstName: 'Jack',
         *     age: 37,
         *     size: '5ft6in'
         * }, {
         *     firstName: 'William',
         *     age: 23,
         *     size: '6ft4in'
         * }, {
         *     firstName: 'Averell',
         *     age: 27,
         *     size: '7ft'
         * }]);
         *
         * // the hash function, returning an integer :
         * getSizeInInches = function (dalton) {
         *     var matchingGroups = dalton.get('size').match(cachedRegexp);
         *     return parseInt(matchingGroups[1], 10)*footInInches + parseInt(matchingGroups[3] || 0, 10);
         * };
         *
         * maxName = daltons.max(getSizeInInches).get('firstName');
         * UWA.log(UWA.String.format("The taller Dalton is {0}", maxName)); // This logs 'The taller Dalton is Averell'
         *
         * maxName = daltons.max('age').get('firstName');
         * UWA.log(UWA.String.format("The eldest Dalton is {0}", maxName)); // This logs 'The eldest Dalton is Jack'
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#min|min}
         */
        max: function (hash, context) {
            var result, lookupHash;
            if (!hash || this.isEmpty()) {
                return undefined;
            }
            lookupHash = lookupIterator(hash);
            // neutral value for max is -Infinity:
            result = {
                computed: -Infinity,
                model: undefined
            };
            this.forEach(function (model, index, models) {
                var computed;
                computed = lookupHash.call(context, model, index, models);
                if (computed >= result.computed) {
                    result = {
                        model: model,
                        computed: computed
                    };
                    return result;
                }
            });
            return result.model;
        },

        /**
         * Returns the minimum model in the collection, with regards to a criterion.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#min|min} returns the minimum model
         * in the collection. Please see {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max}
         * for a detailed explanation of its behavior.
         *
         * __Notes__:
         *  Please read notes for method {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max}.
         *
         * @param {String} hash - The string name of a model attribute *which type is a
         *  number*. Or a function used on each model to generate the
         *  criterion by which the model is ranked. Please see {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max}
         *  for a detailed explanation of its behavior.
         *
         * @param {Object} [context] - Object to use as this when executing
         *  the hash function.
         *
         * @return {Object} - the minimum model in the collection, with regards to the
         *  computed criterion. If there are several minima, the first found is
         *  returned. undefined is returned if criteria are not numbers or
         *  if the collection is empty.
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#max|max}
         */
        min: function (hash, context) {
            var result, lookupHash;
            if (!hash || this.isEmpty()) {
                return undefined;
            }
            lookupHash = lookupIterator(hash);
            // neutral value for min is Infinity:
            result = {
                computed: Infinity,
                model: undefined
            };
            this.forEach(function (model, index, models) {
                var computed;
                computed = lookupHash.call(context, model, index, models);
                if (computed < result.computed) {
                    result = {
                        model: model,
                        computed: computed
                    };
                    return result;
                }
            });
            return result.model;
        },

        /* Group: Methods performing CRUD operations in the backend

            *These methods performs Create, Read, Update or Delete operations
            in the backend.*

        */

        /**
         * Fetches the default set of models for this collection from the backend.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} fetches the default
         * set of models for this collection from the backend, setting them on the collection when they arrive.
         *
         * *It performs a READ operation on the backend.*
         *
         * The options hash takes onComplete and onFailure callbacks which will both be
         * passed `(collection, response, options)` as arguments.
         *
         * When the model data returns from the backend, it uses
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set}
         * to (intelligently) merge the fetched models, unless you pass `{reset: true}`, in which case the
         * collection will be (efficiently) reset.
         *
         * Delegates to {@link module:UWA/Class/Collection.UWA.Class.Collection#sync|sync} under the covers for custom persistence
         * strategies and returns a request that contains the cancel method, allowing
         * to cancel the request made to the backend.
         *
         * The backend handler for fetch requests should ideally return a JSON
         * array of models. If not, you can implement the {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse}
         * method to transform the data returned by the backend into a JSON array of models attributes.
         *
         * The behavior of {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} can
         * be customized by using the available {@link module:UWA/Class/Collection.UWA.Class.Collection#set|set}
         * options. For example, to fetch a collection, getting an `"onAdd"` event
         * for every new model, and a `"onChange"` event for every changed existing
         * model, without removing anything:
         *
         * ```
         * collection.fetch({remove: false});
         * ```
         *
         * {@link module:UWA/Data.UWA.Data.request|UWA.Data.request} options can also be passed directly as
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} options, so to fetch
         * a specific page of a paginated collection:
         *
         * ```
         * documents.fetch({data: {page: 3}})
         * ```
         *
         * __Notes__:
         *  Note that {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} should not
         *  be used to populate collections on page load — ideally all models needed at load time should already be
         *  bootstrapped in to place (for example in a `<script>` DOM element created
         *  in the initial page HTML markup served by the backend).
         *
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#fetch|fetch} is intended for
         *  lazily-loading models for interfaces that are not needed immediately: for example,
         *  documents with collections of notes that may be toggled open and closed.
         *
         * @param {Object} [options] - an hash of options. Note that this options hash will
         *  be passed to your Model's constructor, but also to the
         *  {@link module:UWA/Class/Collection.UWA.Class.Collection#sync|sync} method
         *  (see code example).
         *  Passing `{parse: false}` disables the parsing of the backend
         *  response, but why would you do that ?
         *  Passing `{reset: true}` to reset/empty the collection before fetching
         *  models.
         *
         * @returns {Object} - An object that contains the cancel method, allowing to
         *  cancel the request made to the backend.
         *
         * @example
         * var MyCollection, mc;
         *
         * MyCollection = UWA.Class.Collection.extend({
         *     url: '/Items'
         * });
         *
         * mc = new MyCollection();
         *
         * // This will launch a GET request to /Items?page=1
         * mc.fetch({
         *     data: {
         *         page: 1
         *     }
         * });
         *
         * @see {@link module:UWA/Class/Collection.UWA.Class.Collection#parse|parse}
         */
        fetch: function (options) {
            var onComplete, onFailure, that = this;
            options = options ? Core.clone(options, false) : {};
            if (options.parse === undefined) {
                options.parse = true;
            }
            onComplete = options.onComplete;
            options.onComplete = function (resp) {
                var method;
                method = options.reset ? 'reset' : 'set';
                that[method](resp, options);
                if (onComplete) {
                    onComplete(that, resp, options);
                }
                return that.dispatchEvent('onSync', [that, resp, options]);
            };

            // wrap the error :
            onFailure = options.onFailure;
            options.onFailure = function (resp) {
                if (onFailure) {
                    onFailure(that, resp, options);
                }
                that.dispatchEvent('onError', [that, resp, options]);
            };

            return that.sync('read', that, options);
        },

        /**
         * Create a new instance of a model within the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} is a convenience to
         * create a new instance of a model within
         * the collection. It is equivalent to instantiating a model with a hash
         * of attributes, saving the model to the backend, adding the model
         * to the collection after being successfully created and eventually
         * returning the new model.
         *
         * *It performs a CREATE operation on the backend.*
         *
         * If client-side validation failed, the model will be unsaved with
         * validation errors and not added to the collection.
         *
         * *In order for this method {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create}
         * to work properly, you should set the {@link module:UWA/Class/Collection.UWA.Class.Collection#model|model}
         * property of the collection*.
         *
         * This {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} method can accept
         * either an attributes hash or an existing, unsaved model object.
         *
         * Creating a model will cause an immediate `"onAdd"` event to be triggered
         * on the collection, a `"onRequest"` event as the new model is sent to
         * the backend, as well as a `"onSync"` event, once the backend has responded
         * with the successful creation of the model.
         *
         * Pass `{wait: true}` in the options hash if you'd like to wait for the
         * backend's response before adding the new model to the collection.
         *
         * {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} being an asynchonous
         * operation, it accepts `onComplete` and `onFailure` callbacks in the `options` hash, which are
         * both passed `(model, response, options)` as arguments.
         *
         * (In the `onFailure` callback, no matter if you set the `wait` option to
         * true or false, the model has not been saved in the backend (up to
         * you to try to save it once again). Though if you set the `wait` option
         * to false, you probably have to eventually remove the model passed to
         * `onFailure` callback from the collection if you really cannot save it
         * into the backend)
         *
         * __Notes__:
         *
         * *Do not pass the identifying attribute
         * {@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|Model.idAttribute} in the hash of
         * attributes*, {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} is meant
         * to create *new* models in the collection and in the backend at the
         * same time, not to update existing ones. If you passed the identifying
         * attribute {@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|Model.idAttribute} in
         * the hash of attributes, you could
         * end up in some situations with a modified model in the backend that
         * is left unmodified in the client application.
         *
         * Though {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} is an asynchronous
         * operation, it does not return a request object with a cancel() method, allowing you to cancel it.
         * Whether this {@link module:UWA/Class/Collection.UWA.Class.Collection#create|create} API should
         * return the created model or a request object is subject to debate.
         * Now if you really want to get your hands on the request, here are some
         * tips to cancel XmlHttpRequests :
         *
         * ```
         * var request, model;
         * model = coll.create(attrs, {
         *     beforeSend: function (_request)  { request = _request; }
         * });
         * request.cancel();
         *
         * // or this way :
         * coll.addEventOnce('onRequest', function (model, request) {
         *     request.cancel();
         * });
         * model = coll.create(attrs);
         * ```
         *
         * @param {Object} attributes - the hash of attributes. It should not contain
         *  the attribute identifying a model ({@link module:UWA/Class/Model.UWA.Class.Model#idAttribute|Model.idAttribute}),
         *  please read note above about this.
         *
         * @param {Object} [options] - the options hash
         *
         * @return {Object|Boolean} - The new added and saved model if it passed validation
         *  and could consequently be built. false if the attributes
         *  do not pass validation. (please also read note below)
         */
        create: function (attributes, options) {
            var model, onComplete,
                that = this;
            options = options ? Core.clone(options, false) : {};
            model = that._prepareModel(attributes, options);
            if (!model) {
                return false;
            }
            if (!options.wait) {
                that.add(model, options);
            }
            onComplete = options.onComplete;
            options.onComplete = function (model, resp) {
                if (options.wait) {
                    that.add(model, options);
                }
                if (onComplete) {
                    return onComplete(model, resp, options);
                }
            };
            model.save(null, options);
            return model;
        },

        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function () {
            this.length = 0;
            this._models = [];
            this._byId = {};
            return this._byId;
        },

        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function (attrs, options) {
            var model;
            if (attrs instanceof Model) {
                if (!attrs.collection) {
                    attrs.collection = this;
                }
                return attrs;
            }
            options = Core.is(options) ? Core.clone(options, false) : {};
            options.collection = this;
            model = new this.model(attrs, options);
            if (!model.validationError) {
                return model;
            }
            this.dispatchEvent('onValidationFailure', [this, model.validationError, options]);
            return false;
        },

        // Internal method to sever a model's ties to a collection.
        _removeReference: function (model) {
            if (this === model.collection) {
                delete model.collection;
            }
            return model.removeEvent('onAnyEvent', this._modelListener, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "onAdd" and "onRemove" events that originate
        // in other collections are ignored.
        // Warning : although i named the third argument 'collection', it is not
        // necessarily a collection that is sent. E.g. : for event onRequest, the
        // xhr is sent, not a collection.
        _onModelEvent: function (event, model, collection, options) {
            if ((event === 'onAdd' || event === 'onRemove') && collection !== this) {
                return;
            }
            if (event === 'onDestroy') {
                this.remove(model, options);
            }
            if (model && event === ("onChange:" + model.idAttribute)) {
                delete this._byId[model.previous(model.idAttribute)];
                if (Core.is(model.id)) {
                    this._byId[model.id] = model;
                }
            }
            return this.dispatchEvent(event, [model, collection, options]);
        }
    });

    return Core.namespace('Collection', Collection, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * The container/object for the Javascript logic that renders and updates
 * an isolated logical chunk of UI.
 *
 * A {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} does not store
 * any data or groups of data; it is
 * commonly the hub that references
 * {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model} or
 * {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
 * of data and does something with that data.
 *
 * If it helps, think of {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * as the location in your Javascript
 * code that brings together and controls the following parts:
 *
 * * data (i.e. {@link module:UWA/Class/Model.UWA.Class.Model|UWA.Class.Model}
 * or {@link module:UWA/Class/Collection.UWA.Class.Collection|UWA.Class.Collection}
 * of models)
 * * *compiled* HTML templates
 * * reference/hook into DOM element that contains the HTML markup forming the UI
 * * events and functions driving the UI
 *
 * The views' job, then, is to take these parts (i.e. data, template, DOM, events)
 * and {@link module:UWA/Class/View.UWA.Class.View#render|render} the UI region. Instead of digging into a JSON object, looking
 * up an element in the DOM, and updating the HTML by hand, you can (for
 * example) bind your view's {@link module:UWA/Class/View.UWA.Class.View#render|render} function to the model's "onChange"
 * event — and now everywhere that model data is displayed in the UI, it is
 * always immediately up to date !
 *
 * __Here are some points about views__:
 *
 * * {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} contain all of
 * the parts necessary to construct an
 * isolated and logical region of a web application UI. UWA.Class.View objects
 * glue together data, templates, events and the rendering and re-rendering
 * logic that occurs when data changes.
 * * {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} don't determine
 * anything about your HTML or CSS for you, and can be used with any JavaScript
 * templating library.
 * * Views do not have to be connect to a model or a collection (i.e. data).
 * A view can simply manage an isolated and logical region of a web application.
 * * It is common practice for a view to reference compiled templates (i.e.
 * chunks of html meant to present some data). This might be a stretch for some
 * considering that views typically are templates. This is not the case
 * with {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}!
 * {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} are not templates!
 * * {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * don’t contain the HTML markup for your application; they contain the logic
 * behind the presentation of the model’s data to the user. The presentation
 * itself is achieved using a JavaScript templating engine (up to you to pick up
 * your favorite templating engine) and CSS stylesheets* (pick up your favorite CSS
 * guru).
 *
 * __Events triggered by instances of {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}__:
 *
 * By default, instances of {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * do not fire any event other than the ones fired by its base class
 * {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract|UWA.Controls.Abstract} :
 *
 * | Event name             | Description                                                                                |
 * | ---------------------- | -------------------------------------------------------------------------------------------|
 * |  'onPreInject'         |  Triggered before {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#inject} |
 * |  'onPostInject'        |  Triggered after {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#inject}  |
 * |  'onResize'            |  Invoked when control needs to resize.                                                     |
 *
 * But, since {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * implements {@link module:UWA/Class/Events.UWA.Class.Events|UWA.Class.Events}, your
 * sub-classes inheriting from {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * are able to fire any custom event you
 * choose to define. **This can be useful for some observed sub-views to communicate
 * with their observing parent/aggregating view!**
 *
 * __Define your own custom view by sub-classing {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}__:
 *
 * Get started with views by defining your custom view class by
 * extending/subclassing the base class {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View}
 * before you instantiate it so that you can add your own domain specific
 * properties. You'll want to override the
 * {@link module:UWA/Class/View.UWA.Class.View#render|render} function, specify your
 * declarative events, and perhaps the {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
 * {@link module:UWA/Class/View.UWA.Class.View#className|className}, or
 * {@link module:UWA/Class/View.UWA.Class.View#id|id} of
 * the View's root {@link module:UWA/Class/View.UWA.Class.View#container|container}
 * element. You can also define some domain
 * specific properties for instances to inherit. (see code example below)
 * Don't forget to override the {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy} function !
 *
 * Properties like {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
 * {@link module:UWA/Class/View.UWA.Class.View#id|id},
 * {@link module:UWA/Class/View.UWA.Class.View#className|className},
 * {@link module:UWA/Class/View.UWA.Class.View#container|container}, and
 * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents}
 * may also be defined as a function, if you want to wait to define them until
 * runtime (for example to wait until the DOM is ready).
 *
 * @module UWA/Class/View
 *
 *
 * @example
 * var doc, DocumentRow, docRow1;
 *
 * doc = new UWA.Class.Model({
 *   title: 'The Big Nowhere',
 *   author: 'James Ellroy',
 *   publisher: 'Rivages Noir'
 * });
 *
 * DocumentRow = UWA.Class.View.extend(UWA.Class.Debug, {
 *
 *   tagName: "li",
 *
 *   className: "document-row",
 *
 *   domEvents: {
 *     "click .icon":         "open",
 *     "click button.edit":   "openEditDialog",
 *     "click button.delete": "delete"
 *   },
 *
 *   setup: function() {
 *     this.listenTo(this.model, "onChange", this.render);
 *     this.log('initialized!');
 *   },
 *
 *   render: function () {
 *     // Here typically we should render a compiled template...
 *     // Also note that there is no need to re-bind DOM events
 *     // thanks to event delegation handled by the 'container'
 *     // of the View !
 *     this.container.setContent([
 *         {
 *             tag: 'span',
 *             'class': 'icon',
 *             text: '<OPEN>'
 *         },
 *         {
 *             tag: 'span',
 *             'class': 'title',
 *             text: this.model.get('title')
 *         },
 *         {
 *             tag: 'button',
 *             'class': 'edit'
 *         },
 *         {
 *             tag: 'button',
 *             'class': 'delete'
 *         }
 *     ]);
 *     return this;
 *   },
 *
 *   open: function (domClickEvent) {
 *     this.dispatchEvent('onOpen', [this.model]);
 *     // this event can be caught by the parent view to display
 *     // the doc abstract in an overlay panel for example.
 *   },
 *
 *   openEditDialog: function (domClickEvent) {
 *     this.dispatchEvent('onOpenEditDialog', [this.model]);
 *     // this event can be caught by the parent view to display
 *     // the doc editor in an overlay panel for example.
 *   },
 *
 *   delete: function (domClickEvent) {
 *       var that = this;
 *       that.disable(); // to disable user's interaction with the
 *                       // doc being removed.
 *       // Now let's destroy the model in the backend server :
 *       // if deletion in the backend succeeds, this view is destroyed
 *       // otherwise we warn our parent view that deletion failed and
 *       // enable this view.
 *       that.model.destroy({
 *         onComplete: that.destroy.bind(that),
 *         onFailure: function (model, response, options) {
 *           var msg = UWA.String.format(
 *              'Oops! Failed to delete doc {0} because {1}.',
 *              that.model.get('title'),
 *              response
 *           );
 *           that.dispatchEvent('onError', [msg]);
 *           that.enable();
 *         }
 *       }, {
 *         wait: true
 *       });
 *   },
 *
 *   disable: function (timeOut) {
 *     return this;
 *   },
 *
 *   enable: function () {
 *     return this;
 *   },
 *
 *   // We override this destroy method to ...
 *   destroy: function () {
 *       // 1) stop listening to our observed model, this is very important
 *       // so that our view can be effectively removed by the GC (otherwise
 *       // it is held by the model, as a registered observer).
 *       this.stopListening();
 *       this.model = null;
 *
 *       // 2) Eventually call this._parent() so that our container element
 *       // is destroyed and removed from the DOM.
 *       this._parent();
 *   }
 * });
 *
 * UWA.Event.onDomReady(function () {
 *   docRow1 = new DocumentRow({
 *     model: doc,
 *     id: "document-row-" + doc.id
 *   });
 *
 *   docRow1.addEvent('onOpen', function (doc) {
 *     alert(UWA.String.format('This is the abstract for document {0}', doc.get('title')));
 *   });
 *
 *   docRow1.addEvent('onOpenEditDialog', function (doc) {
 *     alert(UWA.String.format('This is the editor for document {0}', doc.get('title')));
 *   });
 *
 *   docRow1.render().inject(document.getElementById('docs'));
 * });
 */
define('UWA/Class/View', [
    'UWA/Core',
    'UWA/Element',
    'UWA/Class',
    'UWA/Class/Listener',
    'UWA/Controls/Abstract'
], function (Core, Element, Class, Listener, Abstract) {
    'use strict';

    var View, _idCounter, _viewOptions;

    // List of options to be merged as properties on the View object itself :
    _viewOptions = ['model', 'collection', 'container', 'id', 'attributes', 'className', 'tagName', 'domEvents'];

    _idCounter = 0;

    function result(object, property) {

        var value;

        if (object) {

            value = object[property];

            if (Core.is(value, 'function')) {
                value = value.call(object);
            }
        }

        return value;
    }


    View = Abstract.extend(Listener, /** @lends module:UWA/Class/View.UWA.Class.View# */{ // bypass

        /**
         * Define the id of the View's container element.
         *
         * By default, a View's container element is created without any id attribute.
         *
         * You can choose what will be the id of your View's container element
         * by setting this property with a String but it may also be defined as a function,
         * if you want to wait to define the id until runtime/creation time (for example
         * to wait until the DOM is ready).
         *
         * @example
         * var MyView;
         *
         * // when instanciated, this view will have a div
         * // element identified with 'the_model_cid' as a root container:
         * MyView = UWA.Class.View.extend({
         *     id: function () {
         *         return this.model.cid; // i want model cids for unique identifiers in the DOM
         *                                // (which is not always a good idea)
         *     }
         * });
         *
         * @member {String|Function} module:UWA/Class/View.UWA.Class.View#id
         */

        /**
         * *Element/function*: The root DOM element of the view.
         *
         * All views have a root DOM element at all times (the
         * {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * property), whether they have already been inserted into the page or
         * not. In this fashion, views can be rendered at any time (by calling
         * {@link module:UWA/Class/View.UWA.Class.View#render|render}), and inserted/injected
         * (see {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#inject|UWA.Controls.Abstract.inject}
         * for example) into
         * the DOM all at once, in order to get high-performance UI rendering
         * with as few reflows and repaints as possible.
         *
         * In the vast majority of situations in your application, *you shouldn’t
         * assign this {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * property*. Actually, *in a perfect application
         * (less tied to HTML), you would never assign to
         * {@link module:UWA/Class/View.UWA.Class.View#container|container}.
         * You should let the View create its
         * {@link module:UWA/Class/View.UWA.Class.View#container|container} element for you,
         * from its {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
         * {@link module:UWA/Class/View.UWA.Class.View#className|className},
         * {@link module:UWA/Class/View.UWA.Class.View#id|id} and
         * {@link module:UWA/Class/View.UWA.Class.View#attributes|attributes} properties,
         * if specified (if not, {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * is an empty div) and then inject the View to an existing HTML*. This :
         *
         * * reduces the coupling between your JavaScript
         * and your HTML, allowing you more flexibility and making it easier to
         * update what is going where, without having to tear things apart before
         * putting them back together.
         * * provides a nice encapsulation : the view is only responsible for
         * rendering itself; whoever created/instanciated it is responsible for
         * placing it where it needs to go in the existing HTML.
         *
         * Though, having said that, there are exceptions to this,
         * like progressive enhancement,
         * when you need to take existing HTML and attach JavaScript functionality
         * to it. So, if you are in this situation and you do need to
         * assign an existing DOM element to the
         * {@link module:UWA/Class/View.UWA.Class.View#container|container} property of your
         * View, here are several clean ways to do it (the behind-the-scenes
         * rule being that this container property must always be evaluated
         * when the DOM is ready).
         *
         * First of all, you can define the {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * property as a function returning a DOM element :
         *
         * ```
         * var MyView, myView;
         *
         * MyView = UWA.Class.View.extend({
         *     // this must be defined as a function so that it does not get
         *     // evaluated before the DOM is ready!
         *     container: function () {
         *         return widget.getElement('#someElement');
         *     },
         *
         *     domEvents: {
         *         "click #someButton": "clicked"
         *     },
         *
         *     clicked: function (domEvent) {
         *         UWA.log("I was clicked!");
         *     }
         * });
         *
         * UWA.Event.onDomReady(function () {
         *     myView = new MyView();
         * });
         * ```
         *
         * You can also use the {@link module:UWA/Class/View.UWA.Class.View#setup|setup}
         * method of your View to query the DOM by yourself to find your element
         * that will be the {@link module:UWA/Class/View.UWA.Class.View#container|container}
         *
         * ```
         * var MyView, myView;
         *
         * MyView = UWA.Class.View.extend({
         *     domEvents: {
         *         "click #someButton": "clicked"
         *     },
         *
         *     setup: function () {
         *         this.container = widget.getElement("#someElement");
         *     }
         *
         *     clicked: function (domEvent) {
         *         UWA.log("I was clicked!");
         *     }
         * });
         *
         * UWA.Event.onDomReady(function () {
         *     myView = new MyView();
         * });
         * ```
         *
         * In the two examples above, the
         * {@link module:UWA/Class/View.UWA.Class.View#container|container} element
         * is specified in the definition of your MyView class, meaning that
         * --unless explicitely overridden at instanciation time-- all instances
         * of MyView will by default share the same DOM element as their container.
         * Just keep this in mind!
         *
         * There are times when it does not make sense to specify the target
         * DOM element that will be the container directly in your view definition.
         * Let's not go into all of the details on when, because that is also largely
         * a question of style and preferences. Though you will fairly regularly find
         * yourself in situations where you want to decouple the view definition from
         * the knowledge of its {@link module:UWA/Class/View.UWA.Class.View#container|container}.
         * In these situations all you need to do is specify a
         * {@link module:UWA/Class/View.UWA.Class.View#container|container} when you
         * instantiate the view:
         *
         * ```
         * var MyView, myView;
         *
         * // The MyView class itself does not define a 'container'...
         * MyView = UWA.Class.View.extend({
         *     domEvents: {
         *         "click #someButton": "clicked"
         *     },
         *
         *     clicked: function (domEvent) {
         *         UWA.log("I was clicked!");
         *     }
         * });
         *
         * // If you were to instantiate a MyView without passing any options
         * // to its constructor, you would get a 'container' generated for you
         * // and end up with a <div> by default ...
         * // However, by passing in the 'container' option, you are overriding
         * // the 'container' for that specific instance of the view ! :
         * UWA.Event.onDomReady(function () {
         *     myView = new MyView({
         *         container: widget.getElement('#someElement')
         *     });
         * });
         * ```
         *
         * Please note that :
         *
         * * you can pass either a native DOM element or an
         * UWA-extended {@link module:UWA/Element.UWA.Element|UWA.Element}
         * for this {@link module:UWA/Class/View.UWA.Class.View#container|container} property, in all
         * cases it will be internally extended to an
         * {@link module:UWA/Element.UWA.Element|UWA.Element}.
         * * as explained above, this {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * property may be defined as a function, if you want to wait to
         * define it until runtime.
         *
         * @member {Element|Function} module:UWA/Class/View.UWA.Class.View#container
         */

        /**
         * Define the attributes of the View's container element.
         *
         * You can set some attributes on your View's container element
         * by setting this property with an hash of `{ attributeName: 'attrValue' }`
         * pairs but it may also be defined as a function,
         * if you want to wait to define what will be these attributes and their
         * values until runtime/creation time (for example
         * to wait until the DOM is ready).
         *
         * @example:
         * var MyView, MyOtherView;
         *
         * MyView = UWA.Class.View.extend({
         *     attributes: {
         *        text: 'some placeholder'
         *     }
         * });
         *
         * MyOtherView = UWA.Class.View.extend({
         *     attributes: function () {
         *         return {
         *             text: 'some other placeholder'
         *         };
         *     }
         * });
         *
         * @member {Object|Function} module:UWA/Class/View.UWA.Class.View#attributes
         */

        /**
         * Define the mapping between DOM events in the view
         * and callbacks.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents} is an
         * hash mapping DOM events happening within the scope
         * of your view's container (that acts as a delegate to handle these
         * events) with callbacks.
         *
         * These mappings are written in the format `{"event selector": "callback"}`.
         * The callback may be either the name of a method on the view, or a direct
         * function body. Omitting the selector causes the DOM event to be bound to
         * the view's root element (`this.container`).
         *
         * The domEvents property may also be defined as a function that returns
         * an events hash, to make it easier to programmatically define your
         * events, as well as inherit them from parent views.
         *
         * @example
         * // this example demonstrates the two forms domEvents can take
         * // (hash or function), and how to cleanly inheritate domEvents from a
         * // parent view domEvents, no matter how it is defined (as a hash or a
         * // function)
         *
         * var ParentView = UWA.Class.View.extend({
         *     // domEvent defined as a hash :
         *     domEvents: {
         *         'click button.maximize' : 'onMaximize'
         *     },
         *     onMaximize: function (evt) {
         *         UWA.log('Maximum r&b');
         *     }
         * });
         *
         * var ChildView = ParentView.extend({
         *     // domEvents defined as a function :
         *     domEvents: function () {
         *         var parentEvents = ParentView.prototype.domEvents;
         *         if (UWA.is(parentEvents, 'function')) {
         *             parentEvents = parentEvents();
         *         }
         *         // In any case, clone what we got from the parent :
         *         parentEvents = UWA.clone(parentEvents, false);
         *         return UWA.extend(parentEvents || {}, {
         *               'blur' : 'onBlur'
         *         });
         *     },
         *     onBlur: function (e) {
         *         UWA.log('I got my head checked by a jumbo jet');
         *     }
         * });
         *
         * @member {Object|Function} module:UWA/Class/View.UWA.Class.View#domEvents
         */

        /**
         * Define the tagName of the View's container element.
         *
         * The default {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName}
         * of a View's container element is `<div>`.
         *
         * You can change the {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName}
         * of your View's container element by setting
         * this property with a String but it may also be defined as a function,
         * if you want to wait to define the {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName}
         * until runtime (for example to wait until the DOM is ready).
         *
         * @example:
         * var View1, View2;
         *
         * // when instanciated, this view will have a span element as a root container:
         * view1 = UWA.Class.View.extend({
         *     tagName: 'span'
         * });
         *
         * // when instanciated, this view will have either a span element
         * // or a div element as a root container, depending on the version
         * // of the app.
         * view2 = UWA.Class.View.extend({
         *     tagName: function () {
         *         return app.version === '1.0.0' ? 'span' : 'div';
         *     }
         * });
         *
         * @member {String|Function} module:UWA/Class/View.UWA.Class.View#tagName
         */
        tagName: 'div',

        /**
         * Define the CSS className of the View's container element.
         *
         * By default, a View's container element is created without any class.
         *
         * You can choose what will be the className of your View's container element
         * by setting this property with a String but it may also be defined as a function,
         * if you want to wait to define the className until runtime (for example
         * to wait until the DOM is ready).
         *
         * @example
         * var View1, View2;
         *
         * // when instanciated, this view will have a div element with a class
         * // "foo" as a root container:
         * view1 = UWA.Class.View.extend({
         *     className: 'foo'
         * });
         *
         * // Another way to define the className with a function :
         * view2 = UWA.Class.View.extend({
         *     // the view class is named, necessary because
         *     // I use UWA.Controls.Abstract.getClassNames below ... :
         *     name: 'view2',
         *
         *     className: function () {
         *         return this.getClassNames('-container');
         *     }
         * });
         *
         * @member {String|Function} module:UWA/Class/View.UWA.Class.View#className
         */

        /* Group: Creating Instances of View

            *The constructor for instances of view*
        */

        /**
         * The constructor of Views takes an options hash as argument. There are
         * several special options that, if passed, will be attached directly to
         * the view: model, collection,
         * {@link module:UWA/Class/View.UWA.Class.View#container|container},
         * {@link module:UWA/Class/View.UWA.Class.View#id|id},
         * {@link module:UWA/Class/View.UWA.Class.View#className|className},
         * {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
         * {@link module:UWA/Class/View.UWA.Class.View#attributes|attributes} and
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents}. They
         * become properties of the view instance itself. Other non-special (e.g.
         * `'foo'` in the example above)
         * options only show up in the `options` property of your instance of
         * view.
         *
         * Also, if the view defines an {@link module:UWA/Class/View.UWA.Class.View#setup|setup}
         * function, it will be called when the view is first created.
         *
         * **Most of the time, it is not necessary and it is not recommended
         * to override this method for the construction of an
         * instance of a view. If you want to run some initialization code
         * when an instance of your view is constructed, you should rather
         * implement the {@link module:UWA/Class/View.UWA.Class.View#setup|setup}
         * method, which will be invoked when the collection is created.**
         *
         * Though there are some cases where you might want to override the
         * default constructor logic described above. An example is given below
         * where we want to forbid some properties like
         * {@link module:UWA/Class/View.UWA.Class.View#container|container},
         * {@link module:UWA/Class/View.UWA.Class.View#id|id},
         * {@link module:UWA/Class/View.UWA.Class.View#className|className},
         * {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
         * {@link module:UWA/Class/View.UWA.Class.View#attributes|attributes} or
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents}
         * to be overridden at construction time.
         *
         * @param {Object} [options] - an hash of options, where you can
         *   configure the model, collection,
         *   {@link module:UWA/Class/View.UWA.Class.View#container|container},
         *   {@link module:UWA/Class/View.UWA.Class.View#id|id},
         *   {@link module:UWA/Class/View.UWA.Class.View#className|className},
         *   {@link module:UWA/Class/View.UWA.Class.View#tagName|tagName},
         *   {@link module:UWA/Class/View.UWA.Class.View#attributes|attributes} and
         *   {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents} options that, if
         *   provided, are directly attached as properties to the view.
         *   Note that this options hash is also attached in the view.options
         *   property. Non-special options consequently only show up in this
         *   'options' property of your instance of view.
         *
         * @example
         * var myModel, MyProtectedView;
         *
         * myModel = new UWA.Class.Model();
         *
         * MyProtectedView = UWA.Class.View.extend({
         *     // My protected view class is named, necessary because
         *     // I use UWA.Controls.Abstract.getClassNames below ... :
         *     name: 'my-protected-view',
         *
         *     // Here protect your view from users that may want to change
         *     // its root container or events bindings when instanciated :
         *     init: function (options) {
         *         // don't want anybody to redefine some properties
         *         // id, className, tagName, attributes and domEvents
         *         // at construction time !
         *         // (note: this could also be done with UWA.merge)
         *
         *         // Let's shallow-copy the passed options so that
         *         // we don't mutate them :
         *         var sanitizedOptions = UWA.clone(options, false);
         *
         *         [   'id',
         *             'className',
         *             'tagName',
         *             'attributes',
         *             'domEvents'].forEach(function (propToDelete) {
         *                 delete sanitizedOptions[propToDelete];
         *             });
         *
         *         // don't forget to call the parent class ctor
         *         // because it does many useful other things that are essential
         *         // to your instance of view!
         *         this._parent(sanitizedOptions);
         *     },
         *
         *     id: function () {
         *         return this.model.cid; // i want model cids for unique identifiers
         *     },
         *
         *     className: function () {
         *         return this.getClassNames('-container');
         *     },
         *
         *     tagName: 'div',
         *
         *     attributes: {
         *         text: 'some placeholder'
         *     },
         *
         *     domEvents: {
         *         'click' : '_changeColor'
         *     },
         *
         *     // Do the rest of the initialization in your implementation
         *     // of setup :
         *     setup: function (options) {
         *         this.myCustomViewOption = options.myCustomViewOption || 'long-profile';
         *         this.listenTo(this.model, "onChange:someAttribute", '_updateAPieceOfUI');
         *     },
         *
         *     _updateAPieceOfUI: function (model, options) {
         *         // ...
         *     },
         *
         *     _changeColor: function (clickEvt) {
         *         this.container.toggleClassName('red');
         *     }
         * });
         *
         * UWA.Event.onDomReady(function () {
         *
         *     var instanceOfProtectedView;
         *
         *     // All options passed will have no effect except
         *     // model and myCustomViewOption !
         *     // (userOption will be available as a property
         *     // in instanceOfProtectedView.options)
         *     instanceOfProtectedView = new MyProtectedView({
         *         model: myModel,
         *         id: 1,
         *         className: 'foo',
         *         tagName: 'bar',
         *         attributes: {
         *             text: 'my custom text'
         *         },
         *         domEvents: {
         *             'click' : function (clickEvt) {
         *                 alert('Hello!');
         *             }
         *         },
         *         myCustomViewOption: 'short-profile',
         *         userOption: 'zoo'
         *     });
         *
         *     UWA.log(instanceOfProtectedView.container.className); // This outputs " my-protected-view-container".
         *     UWA.log(instanceOfProtectedView.container.tagName); // This outputs "DIV".
         *     UWA.log(instanceOfProtectedView.container.id); // This outputs "c8".
         *     UWA.log(instanceOfProtectedView.container.textContent); // This outputs "some placeholder".
         *     UWA.log(instanceOfProtectedView.myCustomViewOption); // This outputs "short-profile".
         *     UWA.log(instanceOfProtectedView.options); // This outputs undefined.
         *
         * });
         *
         * @constructs UWA.Class.View
         * @memberof module:UWA/Class/View
         */
        init: function (options) {
            var attrs, i, pickedOption;

            /**
             * A special property of views, the {@link module:UWA/Class/View.UWA.Class.View#cid|cid}
             * or client id is a unique identifier automatically generated and assigned to all
             * instances of views when they're first created. Can be used to prefix ids in the DOM,
             * (see {@link module:UWA/Class/View.UWA.Class.View#id|id} property below) or create
             * unique CSS classnames. Note that you also have
             * {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#getClassNames|UWA.Controls.Abstract.getClassNames}
             * to do the later. __Do not modify this property, it is read only__.
             *
             * @name module:UWA/Class/View.UWA.Class.View#cid
             * @type {String}
             * @readonly
             */
            this.cid = "c" + (++_idCounter);

            // dereference options with its shallow copy not to mutate
            // the original options hash
            options = Core.clone(options || {}, false);

            // add some of the options directly on this view object :
            // (among them, the 'container' property :)
            for (i = _viewOptions.length - 1; i >= 0; i--) {
                pickedOption = _viewOptions[i];
                if (options.hasOwnProperty(pickedOption)) {
                    this[pickedOption] = options[pickedOption];
                    delete options[pickedOption];
                }
            }

            // call parent ctor (Controls.Abstract)
            this._parent(options);

            // ensure that we have a root container :
            if (!this.container) {
                attrs = Core.extend({}, result(this, 'attributes'));
                if (this.id) {
                    attrs.id = result(this, 'id');
                }
                if (this.className) {
                    attrs['class'] = result(this, 'className');
                }
                this.container = Core.createElement(result(this, 'tagName'), attrs);
            } else {
                this._ensureContainer(result(this, 'container'));
            }

            this.setup.apply(this, arguments);
            this.delegateDOMEvents();
        },

        /* Group: Methods & Properties To Be Overridden.

            *These are the methods and properties you should override/implement
            when defining your custom views by sub-classing UWA.Class.View*.
        */

        /**
         * Override this method to initialize a newly created instance of view.
         *
         * __Notes__:
         *
         * * The default implementation does nothing.
         * * It is passed the same arguments that were passed to the constructor
         * {@link module:UWA/Class/View.UWA.Class.View#init|init} method.
         * * {@link module:UWA/Class/View.UWA.Class.View#setup|setup} is automatically
         * called by constructors of views.
         * __So do not directly call it in your application code. It
         * is internally used and consequently only meant to be overridden.__
         * * Overriding it with your own initialization logic is optional; however
         * it is a good practice to implement it when sub-classing a view, because
         * **the {@link module:UWA/Class/View.UWA.Class.View#setup|setup} method is
         * an ideal place to house logic that needs
         * to run when view instances are created. Typically, you should register
         * there to events emitted by your observed model or collection**,
         * using {@link module:UWA/Class/Listener.UWA.Class.Listener#listenTo|listenTo},
         * implemented by instances of views.
         *
         * @example
         * var ProfileView;
         *
         * // Definition of a ProfileView, meant to display data about a User :
         * ProfileView = UWA.Class.View.extend({
         *
         *     className: function () {
         *         return this.getClassNames('-container');
         *     },
         *
         *     setup: function (options) {
         *         var that = this;
         *         that._type = options.type || 'detailed';
         *         that.listenTo(that.model, {
         *             'onChange:firstName' : that._redrawFirstName,
         *             'onChange:lastName' : that._redrawLastName,
         *             'onChange:picUrl' : that._updatePicture
         *         });
         *     },
         *
         *     destroy: function () {
         *         // stop listening to our observed model, this is very important
         *         // so that our view can be effectively removed by the GC (otherwise
         *         // it is held by the model, as a registered observer).
         *         this.stopListening(this.model);
         *         this.model = null;
         *
         *         // Eventually call this._parent() so that our container element
         *         // is destroyed and removed from the DOM.
         *         this._parent();
         *     },
         *
         *     _redrawFirstName : function () {
         *         // ...
         *     },
         *
         *     _redrawLastName : function () {
         *         // ...
         *     },
         *
         *     _updatePicture : function () {
         *         // ...
         *     }
         * });
         */
        setup: function () {
            return;
        },

        /**
         * Override this method to destroy your view.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy} is generally
         * called by parent views, consequently **a view must not destroy itself.**
         *
         * Please also note that **the view and its child views should not be used
         * after {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy}
         * has been invoked/called.** (A way to enforce the detection of such illegal
         * postmortem usages is to set the container reference to null in your
         * implementation of destroy)
         *
         * See also {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#destroy|UWA.Controls.Abstract.destroy}
         * for a description of the default implementation.
         *
         * You **must override** this {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy}
         * method to perform the following tasks (when applicable) in the given order:
         *
         * * 1) stop listening to your child views
         * * 2) destroy and dereference your child views
         * * 3) stop listening to your observed models, this is very important so
         * that your view can be effectively removed by the garbage collector.
         * If you don't do that, your view (and its DOM elements) is held by the
         * observed models, as an observable).
         * * 4) call `this._parent()` in your overridden
         * implementation so that
         * {@link module:UWA/Controls/Abstract.UWA.Controls.Abstract#destroy|UWA.Controls.Abstract.destroy}
         * is eventually called. This will remove all delegated events on the container
         * and remove the container and children elements from the document.
         * * 5) you can eventually set the container reference to null (also
         * other references to other DOM elements), so that any
         * code dealing with the container called after
         * {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy} has been called
         * would fail. This can help detecting some illegal access to zombie views.
         *
         * __Notes__:
         *
         * You don't have to take care in {@link module:UWA/Class/View.UWA.Class.View#destroy|destroy}
         * of not listening anymore (aka detaching) the events defined in
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents}.
         *
         * @return {this} Current {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} instance.
         *
         * @example
         * var MyView = UWA.Class.View.extend({
         *
         *     // the UWA class name, useful to generate CSS classNames:
         *     name: 'AppView',
         *
         *     className: function () {
         *         return this.getClassNames();
         *     },
         *
         *     setup: function (options) {
         *
         *         // listen to events emitted by the model :
         *         this.listenTo(this.model, 'onChange:someAttr', this._updateAPieceOfUI);
         *
         *         // a child view (created but not yet rendered) :
         *         this._childView = new AnotherView();
         *
         *         // Listen to some events of my subViews :
         *         this.listenTo(this._childView, 'onButtonClicked', this._updateAnotherPieceOfUI);
         *     },
         *
         *     destroy: function () {
         *         // 1) stop listening to child view ...
         *         this.stopListening(this._childView);
         *
         *         // 2) destroy and dereference child view :
         *         this._childView.destroy();
         *         this._childView = null;
         *
         *         // 3) stop listening to the events emitted by the model :
         *         this.stopListening(this.model);
         *         this.model = null;
         *
         *         // 4) call implementation of destroy by my parent class.
         *         // This will remove all delegated events on the container
         *         // and remove the container and children elements from the
         *         // document.
         *         this._parent();
         *     },
         *
         *     _updateAPieceOfUI: function (domEvent) {
         *         // ...
         *     },
         *
         *     _updateAnotherPieceOfUI: function () {
         *         // ...
         *     }
         * });
         */
        destroy: function () {
            this.undelegateDOMEvents(); // needed ?
            this._parent();
        },

        /**
         * Override this method to house the logic required to construct the view.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#render|render} is the core
         * method that your view should override, in
         * order to populate its root {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * element, with the appropriate HTML. *The convention is for
         * {@link module:UWA/Class/View.UWA.Class.View#render|render} to always return this*,
         * this allows to chain view methods, like this very common chain of
         * calls :
         * ```
         * myInstanceOfView.render().inject(parentTargetDomElement);
         * ```
         *
         *
         * __Notes__:
         *
         * * It is not a good practice in general to call
         * {@link module:UWA/Class/View.UWA.Class.View#render|render} directly in
         * your implementation of {@link module:UWA/Class/View.UWA.Class.View#setup|setup}.
         * This leads to the view being immediately rendered when it is instanciated.
         * It is better to decouple the instanciation/construction and the rendering of the
         * view, this way you can choose the moment when you want to render
         * the view.
         * * A good coding pattern is to make your implementation of
         * {@link module:UWA/Class/View.UWA.Class.View#render|render}
         * call some other private methods dedicated to the (re-)rendering
         * of some small sub parts of your view. Another very common coding pattern
         * is to call the
         * {@link module:UWA/Class/View.UWA.Class.View#render|render}
         * methods of your sub-views in the implementation of
         * {@link module:UWA/Class/View.UWA.Class.View#render|render}.
         * * (this remark applies to any code in your view that is looking
         * up DOM elements) **To lookup some elements in your view in
         * {@link module:UWA/Class/View.UWA.Class.View#render|render},
         * always use {@link module:UWA/Class/View.UWA.Class.View#getElement|getElement}
         * and {@link module:UWA/Class/View.UWA.Class.View#getElements|getElements}
         * methods, that are scoped to DOM elements within the current view!
         * Never use global lookups like `Widget.getElement` for example!**
         * * In general, {@link module:UWA/Class/View.UWA.Class.View#render|render}
         * is called by the parent/aggregating view.
         *
         * @return {this} Current {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} instance.
         *
         * @example:
         * // TODO
         */
        render: function () {
            return this;
        },

        /* Group: Attach your view to some existing HTML

            *Progressive enhancement using the container property*.
        */

        /**
         * Change the view's {@link module:UWA/Class/View.UWA.Class.View#container|container},
         * including event re-delegation.
         *
         * Use {@link module:UWA/Class/View.UWA.Class.View#setContainer|setContainer}
         * if you'd like to apply a view to a different DOM
         * element. {@link module:UWA/Class/View.UWA.Class.View#setContainer|setContainer}
         * will also create the {@link module:UWA/Class/View.UWA.Class.View#container|container}
         * reference and move the view's delegated events from the old element to the new one.
         *
         * @param {Element} element - A DOM element or an hash of attributes (see
         *   example below)
         * @return {this} Current {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} instance.
         *
         * @example
         * var v = new UWA.Class.View();
         *
         * v.render().inject(widget.body);
         *
         * // example where we want to render the view somewhere else :
         * v.destroy();
         * v.setContainer(widget.getElement('#foo')).render();
         *
         * // example where the view is rendered somewhere else without having
         * // deleted its previously rendered elements :
         * v.setContainer(widget.getElement('#bar')).render();
         *
         * // example where the view is destroyed and re-rendered in a new
         * // container that is injected in the document's body :
         * v.destroy();
         * v.setContainer({
         *     tag: 'ul',
         *     'class': 'myElement items',
         *     html: [
         *         {
         *             tag: 'li',
         *             'class': 'item',
         *             text: 'My first item'
         *         },
         *         {
         *             tag: 'li',
         *             'class': 'item',
         *             text: 'My second item'
         *         }
         *     ]
         * }).render().inject(widget.body);
         */
        setContainer: function (element) {
            this.undelegateDOMEvents();
            this._ensureContainer(element);
            this.delegateDOMEvents();
            return this;
        },

        /**
         * @private
         */
        _ensureContainer: function (container) {
            var typeOf;
            if (container instanceof Element) {
                this.container = container;
                return;
            }
            typeOf = Core.typeOf(container);
            if (typeOf === 'element') {
                this.container = Core.extendElement(container);
            } else if (typeOf === 'object') {
                this.container = Core.createElement(container.tag, container);
            } else {
                throw new Error("Invalid type of container");
            }
        },

        /* Group: Scoped element lookup

            *Element(s) lookup scoped to DOM elements within the current view*.
        */

        /**
         * Gets the first descendant element in the view that matches a CSS selector.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#getElement|getElement} is a
         * {@link module:UWA/Element.UWA.Element#getElements|UWA.Element.getElements} delegate for element lookup,
         * **scoped to DOM elements within the current view**. **Within your view code,
         * this must always be prefered to global lookups** like `document.getElementById('foo')`
         * or `widget.getElement('#foo')`!
         *
         * @param {String} selector - The CSS selector to use (could be more than one rule).
         * @return {UWA.Element} {@link module:UWA/Element.UWA.Element|UWA.Element} matched in the view.
         */
        getElement: function (selector) {
            return this.container.getElement(selector);
        },

        /**
         * Gets all descendants elements that match a CSS selector.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#getElements|getElements} is
         * a {@link module:UWA/Element.UWA.Element#getElements|UWA.Element.getElements} delegate for element lookup,
         * **scoped to DOM elements within the current view**. **Within your view code,
         * this must always be prefered to global lookups** like `document.getElementById('foo')`
         * or `widget.getElement('#foo')`!
         *
         * @param {String} selector - The CSS selector to use (could be more than one rule).
         * @return {Array} Array of {@link module:UWA/Element.UWA.Element|UWA.Element}
         * that matched in the view.
         */
        getElements: function (selector) {
            return this.container.getElements(selector);
        },

        /* Group: Attaching/Detaching Delegated DOM Events to/from callbacks

            *Using delegateDOMEvents and undelegateDOMEvents*.
        */

        /**
         * Attach callbacks to delegated DOM events given a mapping
         *
         * By default, {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * is internally called when a view is instantiated, referencing the
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents} option
         * object for any events that need to be setup. If, for whatever reason, the events attached
         * to a view are removed (the view is {@link module:UWA/Class/View.UWA.Class.View#destroy|destroyed}
         * or {@link module:UWA/Class/View.UWA.Class.View#undelegateDOMEvents|undelegateDOMEvents}
         * has been called), consider the {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * method the tool for refreshing/reattaching the events to the view.
         *
         * To demonstrate the {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * method, in the example below, a view
         * is rendered without setting up events during extending or instantiate.
         * After the view is created, the view's {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents}
         * property is updated thanks to {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * so that the appropriate callback is invoked when the button is clicked
         * depending on the current period of time (morning, afternoon & evening).
         *
         * When {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * is called, perhaps with a different events hash,
         * all callbacks are removed and delegated afresh — **useful for views which
         * need to behave differently when in different modes**.
         *
         * __Notes__:
         *
         * * {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}
         * can be called with no argument. In this case, the events map defined in
         * {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents} is
         * simply re-used for re-attaching delegated events that would have been
         * detached using {@link module:UWA/Class/View.UWA.Class.View#undelegateDOMEvents|undelegateDOMEvents}.
         * * You cannot refresh/reattach the view's DOM events using `setOption` or
         * `setOptions` methods (from {@link module:UWA/Class/Options.UWA.Class.Options|UWA.Class.Options}
         * mixin implemented by views), you have to use
         * {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}.
         *
         * @param {Object} [DOMEvents] - an hash mapping DOM events happening within
         *   the scope of your view's container (that acts as a delegate to handle
         *   these events) with names of callbacks of the view. See
         *   {@link module:UWA/Class/View.UWA.Class.View#domEvents|domEvents} for details.
         *
         * @return {this} Current {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} instance.
         *
         * @example
         *   var MyView, myViewInstance, today, idx,
         *       timeOutInMillisecs, greetingCallbackNames;
         *
         *   MyView = UWA.Class.View.extend(UWA.Class.Debug, {
         *       render: function () {
         *           this.container.addContent({
         *               tag: 'button',
         *               text: 'Give greeting!'
         *           });
         *           return this;
         *       },
         *
         *       // (factorization is not the point of the example here!)
         *       _sayGoodMorning: function () {
         *           this.log('Good Morning!');
         *       },
         *       _sayGoodAfternoon: function () {
         *           this.log('Good Afternoon!');
         *       },
         *       _sayGoodEvening: function () {
         *           this.log('Good Evening!');
         *       },
         *       _sayGoodNight: function () {
         *           this.log('Good night!');
         *       }
         *   });
         *
         *   myViewInstance = new MyView(); // create view ...
         *   myViewInstance.debugMode = true;
         *
         *   timeOutInMillisecs = 6 * 60 * 60 * 1000; // every 6 hours,
         *                                            // the events map is changed
         *
         *   greetingCallbackNames = [
         *       '_sayGoodNight',
         *       '_sayGoodMorning',
         *       '_sayGoodAfternoon',
         *       '_sayGoodEvening'
         *   ];
         *
         *   function bindGreetingCBtoClickEvent () {
         *       myViewInstance.delegateDOMEvents({
         *           'click button': greetingCallbackNames[(idx++)%4]
         *       });
         *       setTimeout(bindGreetingCBtoClickEvent, timeOutInMillisecs);
         *   };
         *
         *   today = new Date();
         *   idx = Math.floor(today.getHours() / 6);
         *
         *   bindGreetingCBtoClickEvent(); // call delegateDOMEvents because we setup the events after the view was created
         *
         *   myViewInstance.render().inject(document.body); // ... render and inject it!
         */
        delegateDOMEvents: function (DOMEvents) {
            var key, method;
            if (!Core.is(DOMEvents)) {
                DOMEvents = result(this, 'domEvents');
            }
            if (!DOMEvents) {
                return this;
            }
            this.undelegateDOMEvents();
            for (key in DOMEvents) {
                method = DOMEvents[key];
                if (typeof method !== 'function') {
                    if (typeof method !== 'string') {
                        throw new Error("Invalid type of value in hash of domEvents!");
                    }
                    method = this[method];
                }
                if (!method) {
                    throw new Error("Method '" + DOMEvents[key] + "' does not exist");
                }
                // this is needed so that events are bound to each instance
                // of View, not bound on prototype's callbacks :
                method = method.bind(this);

                // [ Element.addEvent does not allow to pass a context, this is
                // why i have to bind the method to this above ]
                this.container.addEvent(key, method);
            }
            return this;
        },

        /**
         * Detach callbacks from delegated DOM events
         *
         * {@link module:UWA/Class/View.UWA.Class.View#undelegateDOMEvents|undelegateDOMEvents}
         * clears all callbacks previously bound to the
         * view with {@link module:UWA/Class/View.UWA.Class.View#delegateDOMEvents|delegateDOMEvents}.
         * You usually don't need to use this, but may wish to if you have multiple
         * views attached to the same DOM element.
         *
         * {@link module:UWA/Class/View.UWA.Class.View#undelegateDOMEvents|undelegateDOMEvents}
         * is **also useful if you want to disable a view from the DOM temporarily.**
         *
         * @return {this} Current {@link module:UWA/Class/View.UWA.Class.View|UWA.Class.View} instance.
         */
        undelegateDOMEvents: function () {
            if (this.container) {
                this.container.removeEvent();
            } else {
                throw new Error('unexpected error');
            }
            return this;
        }
    });

    return Core.namespace('View', View, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Class/Store', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/String',
    'UWA/Class',
    'UWA/Class/Debug'
], function (Core, Utils, UWAString, Class, Debug) {
    'use strict';

    var Store;

    /*
      Class: UWA.Class.Store

        *IMPORTANT NOTICE : UWA.Class.Store IS AN EXPERIMENTAL
        FEATURE SUBJECT TO REMOVAL, DEPRECIATION OR CHANGES IN THE NEXT RELEASE!
        IT IS PROVIDED AS A TEMPORARY CONVENIENCE, CONSEQUENTLY DO NOT USE THIS
        IN PRODUCTION CODE!*

        An instance of <UWA.Class.Store> is an object able to support
        Creation/Retrieval/Update/Patch/Deletion of UWA.Class.Models in a named
        space inside an instance of <UWA.Storage>.

        Think of a <UWA.Class.Store> as a table inside a database that
        would be the instance of <UWA.Storage>.

        <UWA.Class.Stores> are useful to sync <UWA.Class.Collections>
        of <UWA.Class.Models> inside a <UWA.Storage>.

        To do so, you first have to create an instance of <UWA.Storage> (if not
        already available) and one or several stores using this storage for
        persistency :
        (start code)
        var myAppStorage, usersStore, issuesStore;

        myAppStorage = new UWA.Storage({
            adapter: 'Dom',
            database: 'myApp'
        });

        usersStore = new UWA.Class.Store(myAppStorage, 'users');

        issuesStore = new UWA.Class.Store(myAppStorage, 'issues');
        (end code)

        Now you have several options to bind the sync implementation of these
        stores to your application models and collections :
        (start code)
        // Either when you define your custom collection and model :
        var Incident, Backlog, critSits;

        Incident = UWA.Class.Model.extend({
            sync: function () {
                // assuming that Incidents are always created
                // by calls to this.collection.create API :
                var store = this.collection.store;
                return store.sync.apply(store, arguments);
            }
        });

        Backlog = UWA.Class.Collection.extend({
            model: Incident,
            store: issuesStore,
            sync: function () {
                return this.store.sync.apply(this.store, arguments);
            }
        });

        // Either at instanciation time, by modifying the sync method _on your
        // instance of Collection or Model_. By doing this way, the original definition
        // of the Collection or Model is not modified (that can be useful if it is
        // shared and used elsewhere, say in another app) :
        critSits = new Backlog();
        critSits.sync = function () {
            return issuesStore.sync.apply(issuesStore, arguments);
        };
        // Do not forget to re-define the model definition used by our
        // critSits instance so that it also makes use of its collection's
        // new sync method, that is to say of the store.
        // (by doing this way, we do not impact the original definition
        // of the Incident model, if shared and used elsewhere)
        critSits.model = critSits.model.extend({
            sync: function () {
                return this.collection.sync.apply(this, arguments);
            }
        });
        (end code)

      Implements:
        <UWA.Class.Debug>
    */
    Store = Class.extend(Debug, {

        init: function (storage, name, options) {
            var store;
            Core.log(["",
                '*IMPORTANT NOTICE : UWA.Class.Store IS AN EXPERIMENTAL ',
                'FEATURE SUBJECT TO REMOVAL, DEPRECIATION OR CHANGES IN THE ',
                'NEXT RELEASE! IT IS PROVIDED AS A TEMPORARY CONVENIENCE, ',
                'CONSEQUENTLY DO NOT USE THIS IN PRODUCTION CODE!*'
            ].join(""));
            this._name = name;
            this._storage = storage;
            this.debugMode = options && options.debugMode;
            store = this._storage.get(this._name);
            this._records = (store && store.split(",")) || [];
        },

        log: function () {
            return this._parent(UWAString.format('Store "{0}": {1}',
                                                 this._name,
                                                 UWAString.format.apply(null, arguments)));
        },

        // Save the current content of the store into the storage :
        _save: function () {
            return this._storage.set(this._name, this._records.join(","));
        },

        // ACCESSORS TO STORAGE ADAPTER :

        _set: function (id, data) {
            return this._storage.set(this._name + "-" + id, JSON.stringify(data));
        },

        _rem: function (id) {
            return this._storage.remove(this._name + "-" + id);
        },

        // IMPLEMENTATION OF THE C/R/U/D OPERATIONS :

        // insert a new model in the storage, giving it a (hopefully:)-unique UUID :
        _insert: function (attrs, idAttrName) {
            var id = Utils.getUUID();
            attrs[idAttrName] = id;
            if (this._set(id, attrs)) {
                this._records.push(id);
                if (!this._save()) {
                    // rollback attempt for fun :
                    if (this._rem(id)) {
                        this._records.pop();
                    } else {
                        this._throwError('Unable to rollback failed insertion of model "{0}"', id);
                    }
                } else {
                    this.log('Successfully inserted model "{0}"', id);
                }
            }
            return this._find(id);
        },

        // Retrieve a model from the storage by id :
        _find: function (id) {
            var data = this._storage.get(this._name + "-" + id);
            return data && JSON.parse(data);
        },

        // Return the array of all models attributes currently in storage.
        _findAll: function () {
            return this._records.map(function (id) {
                return this._find(id);
            }, this).filter(function (attrs) {
                return attrs; // Remove all falsy values
            }, this);
        },

        // Update a model by replacing its copy in the storage :
        // (also able to patch the stored model :)
        _update: function (id, attrs) {
            var updated;
            updated = this._find(id);
            if (updated) {
                updated = this._set(id, Core.extend(updated, attrs));
                if (updated) {
                    updated = this._find(id);
                    if (updated) {
                        this.log('Successfully updated model "{0}"', id);
                    }
                }
            }
            return updated;
        },

        // Delete a model from the storage, returning it.
        _remove: function (id) {
            var deleted = this._rem(id);
            if (deleted) {
                this._records = this._records.filter(function (sid) {
                    return sid !== id;
                });
                if (!this._save()) {
                    // rollback attempt for fun :
                    if (this._set(id, deleted)) {
                        this._records.push(id.toString());
                        deleted = null;
                    } else {
                        this._throwError('Unable to rollback failed deletion of model "{0}"', id);
                    }
                } else {
                    this.log('Successfully removed model "{0}"', id);
                }
            }
            return deleted;
        },

        // Clear storage for this store.
        _clear: function () {
            this._records.forEach(function (id) {
                this._rem(id); // do not check returned value!
            }, this);
            // Remove id-tracking item (e.g., "foo").
            this._storage.rem(this._name);
            // eventually reset this._records :
            this._records.length = 0;
        },

        // throws Error :
        _throwError: function () {
            throw new Error(UWAString.format('Store {0}: {1}',
                                             this._name,
                                             UWAString.format.apply(null, arguments)));
        },

        sync: function (method, model, options) {
            var id, attrs, idAttrName, resp, errorMessage;

            if (method === 'create' || method === 'update' || method === 'patch') {
                attrs = model.toJSON(options);
            }
            id = model.id;
            idAttrName = model.idAttribute;

            try {
                switch (method) {
                case "read":
                    resp = Core.is(id) ? this._find(id) : this._findAll();
                    break;
                case "create":
                    resp = this._insert(attrs, idAttrName);
                    break;
                case "update":
                case "patch":
                    resp = this._update(id, attrs);
                    break;
                case "delete":
                    resp = this._remove(id);
                    break;
                default:
                    this._throwError('Unsupported method "{0}"', method);
                }

            } catch (error) {
                errorMessage = error.message;
            }

            if (resp) {
                if (options && options.onComplete) {
                    options.onComplete(resp);
                }
            } else {
                if (options && options.onFailure) {
                    options.onFailure(errorMessage || UWAString.format('Store "{0}": model "{1}" not found', this._name, id));
                }
            }

            // return a dummy obj with a cancel() method :
            return {
                cancel: function () {
                    return;
                }
            };
        }
    });

    return Core.namespace('Store', Store, Class);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Extends UWA.Environment.prototype to handle Swym Environment.
 *
 * @module   UWA/Environments/Swym
 *
 */
define('UWA/Environments/Swym', [
    'UWA/Core',
    'UWA/Environment',
    'UWA/Storage/Adapter/Dom',
    'UWA/Storage/Adapter/IE',
    'UWA/Storage/Adapter/Cookies',
    'UWA/Storage/Adapter/Object',
    'UWA/Storage/Adapter/Html5',
    'UWA/Class/Collection',
    'UWA/Class/View',
    'UWA/Class/Model',
    'UWA/Class/Store'
], function (UWA, Environment) {
    'use strict';

    var Swym = Environment.extend({

        /**
         * Current platform name where environment running (e.g "swym").
         *
         * @type {String}
         * @private
         */
        name: 'swym'
	});
    return UWA.namespace('Environments/Swym', Swym, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Segmented
 *
 */
define('UWA/Controls/Segmented', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Controls/Abstract'
], function (UWA, Event, Abstract) {
    'use strict';

    var Segmented = Abstract.extend(/** @lends module:UWA/Controls/Segmented.UWA.Controls.Segmented# */{ // bypass

        /**
         * @property {String} name name of the control
         * @private
         */
        name: 'uwa-segmented',

        /**
         * The default controls options.
         *
         * @private
         */
        defaultOptions: {
            title: null,
            multiSelect: false,
            atLeastOneSelected: false,
            constantItemWidth: false,
            className: '',
            data: null
        },

        /**
         * The items length.
         *
         * @type {Number}
         */
        itemLength: 0,

        /**
         * Display a horizontally stacked list of items
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onPreInject`    | Triggered before inject                |
         * | `onPostInject`   | Triggered after inject                 |
         * | `onResize`       | Invoked when control needs to resize   |
         * | `onClick`        | Invoked when an item is clicked        |
         * | `onChange`       | Invoked when an item state change      |
         *
         *
         * @example
         * var myControl = new UWA.Controls.Segmented({
         *     data: {
         *         option_a: {text: 'a'},
         *         option_bb: {text: 'bb'},
         *         option_ccc: {text: 'ccc'},
         *         option_dddd: {text: 'dddd'}
         *     }
         * });
         *
         * myControl.inject(myControlContainer);s
         * // OR
         * myControlContainer.appendChild(myControl.getContent());
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String}  [options.title=null] - Item title
         * @param {Boolean} [options.multiSelect=false] - Item title
         * @param {Boolean} [options.atLeastOneSelected=false] - Allow selecting more than one item
         * @param {Boolean} [options.constantItemWidth=false] - Keep all items the same width
         * @param {String}  [options.className=null] - Customized classname
         * @param {Object}  [options.data={}] - Data to fill in the control
         * @param {Object}  [options.events={}] - Events Callbacks
         *
         * @constructs UWA.Controls.Segmented
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Segmented
         */
        init: function (options) {

            this._parent(options);

            this.options.data = this.options.data || {};
            this.elements.items = {};
            this.selectedItemsName = {};

            this.buildSkeleton();

            if (this.options.data) {
                this.addItems(this.options.data);
            }
        },

        /**
         * Build main dom elements
         */
        buildSkeleton: function () {

            var elements = this.elements,
                options = this.options;

            elements.container = UWA.createElement('ul', {
                'class': this.getClassNames()
            });

            if (options.title) {
                UWA.createElement('li', {
                    'class': this.getClassNames('-title'),
                    html: {
                        tag: 'span',
                        text: options.title
                    }
                }).inject(elements.container);
            }

            elements.itemContainer = elements.container;
        },

        /**
         * Recompute items classnames, with item-first and item-last classes
         * (called each time an item is added)
         */
        updateItemClassNames: function () {

            var name, item,
                itemsElm = this.elements.items,
                count = 0;

            for (name in itemsElm) {
                if (itemsElm.hasOwnProperty(name)) {
                    item = itemsElm[name];

                    // clean state
                    item.removeClassName(this.getClassNames('-item-first'));
                    item.removeClassName(this.getClassNames('-item-last'));

                    item.addClassName(this.getClassNames('-item') + ' ' + name);
                    if (count === 0) {
                        item.addClassName(this.getClassNames('-item-first'));
                    }
                    if (count === this.itemLength - 1) {
                        item.addClassName(this.getClassNames('-item-last'));
                    }
                    count++;
                }
            }
        },

        /**
         * Build an item HTMLelement and add event
         *
         * @param {String} name - Internal item Id
         * @param {Object} itemConfig - Item configuration
         * @return {HTMLElement}
         */
        createItem: function (name, itemConfig) {

            var item,
                items = this.elements.items,
                itemText = itemConfig.text || '',
                self = this;

            item = UWA.createElement('li', {
                html: {
                    tag: 'a',
                    'class': name + '-title ' + this.getClassNames('-item-title'),
                    html: {
                        tag: 'span',
                        text: itemText
                    },
                    events: {
                        click: function (event) {
                            Event.stop(event);
                            self.dispatchEvent('onClick', [name]);
                        }
                    }
                }
            });

            if (itemConfig.title) {
                this.options.data[name].text = itemConfig.title;
                item.getElement('span').setHTML(itemConfig.title);
            }

            items[name] = item;

            if (itemConfig.pinned) {
                item.addClassName('uwa-pinned');
                this.selectItem(name, false);
            }

            return item;
        },

        /* Group: Events */

        /**
         * Resize all items if needed (this.options.constantItemWidth)
         */
        onResize: function () {

            var itemName, width,
                itemsElm = this.elements.items,
                maxWidth = 0;

            if (this.options.constantItemWidth) {
                // get max width
                for (itemName in itemsElm) {
                    if (itemsElm.hasOwnProperty(itemName)) {
                        width = itemsElm[itemName].getDimensions().width;
                        maxWidth = (width > maxWidth) ? width : maxWidth;
                    }
                }

                // resize all items
                for (itemName in itemsElm) {
                    if (itemsElm.hasOwnProperty(itemName) && maxWidth !== 0) {
                        itemsElm[itemName].setStyle('width', maxWidth + 'px');
                    }
                }
            }
        },

        /**
         * Invoked when an item is clicked
         */
        onClick: function (name) {
            if (!this.options.multiSelect) {
                this.selectItem(name);
            } else {
                this.toggleItem(name);
            }
        },

        /**
         * Add some items to the control
         *
         * @param {Object} items - Items to be added
         */
        addItems: function (items) {
            var itemName;
            for (itemName in items) {
                if (items.hasOwnProperty(itemName)) {
                    this.addItem(itemName, items[itemName]);
                }
            }
        },

        /**
         * Add one item at the end of the control
         *
         * @param {String} name - Internal item Id
         * @param {Object} itemConfig - Item configuration
         */
        addItem: function (name, itemConfig) {
            var where, split, relative;

            itemConfig = itemConfig || {};

            // TODO check if data exist ?
            this.options.data[name] = itemConfig;

            if (!itemConfig.where) {
                itemConfig.where = 'bottom';
            }
            split = itemConfig.where.split(' ');
            where = split[0];

            if (split.length === 1 && (where === 'top' || where === 'bottom')) {
                relative = this.elements.itemContainer;
            } else if (split.length === 2 && (where === 'before' || where === 'after')) {
                relative = this.elements.items[split[1]];
            } else {
                throw new Error('Has to be "top", "bottom", "before item" of "after item"');
            }

            this.createItem(name, itemConfig).inject(relative, where);

            this.itemLength++;

            this.updateItemClassNames();
        },

        /**
         * Change an item title.
         *
         * @param {String} itemName - Internal item Id
         * @param {String} newTitle - New title
         */
        setItemTitle: function (itemName, newTitle) {
            var itemElement = this.elements.items[itemName];
            if (itemElement) {
                this.options.data[itemName].text = newTitle;
                itemElement.getElement('span').setHTML(newTitle);
            }
        },

        /**
         * Open or Close an item.
         *
         * @param {String} name - Internal item Id
         * @param {Boolean} state - Select/unselect item
         * @param {Boolean} [notify=true] - Should trigger onChange or not
         */
        setItemState: function (name, state, notify) {

            var itemConfig = this.options.data[name],
                selectedElement = this.elements.items[name];

            notify = (!UWA.is(notify) ? true : notify); // notify by default

            // only one selected item, we can't unselect it
            if (!state && this.options.atLeastOneSelected && this.getSelectedItems().length === 1) {
                return;
            }

            if (selectedElement || this.selectedItemsName[name] !== state) {

                // we can't have more than one selected item
                if (!this.options.multiSelect) {
                    this.unselectItems();
                }

                selectedElement.toggleClassName('selected', state);

                this.selectedItemsName[name] = state;

                if (notify) {
                    this.dispatchEvent('onChange', [name, state, itemConfig]);
                }
            }
        },

        /**
         * Toggle item state.
         *
         * @param {String} name - internal item Id
         * @param {Boolean} [notify=true] - should trigger onChange or not
         */
        toggleItem: function (name, notify) {
            this.setItemState(name, !this.isSelected(name), notify);
        },

        /**
         * Unselect an item.
         *
         * @param {String} name - internal item Id
         * @param {Boolean} [notify=true] - should trigger onChange or not
         */
        unselectItem: function (name, notify) {
            this.setItemState(name, false, notify);
        },

        /**
         * Select an item.
         *
         * @param {String} name - internal item Id
         * @param {Boolean} [notify=true] - should trigger onChange or not
         */
        selectItem: function (name, notify) {
            this.setItemState(name, true, notify);
        },

        /**
         * Get all selected items.
         *
         * @return {Array} an array with all currently selected IDs
         */
        getSelectedItems: function () {
            var itemName,
                items = this.selectedItemsName,
                selected = [];

            for (itemName in items) {
                if (items.hasOwnProperty(itemName) && items[itemName] === true) {
                    selected.push(itemName);
                }
            }

            return selected;
        },

        /**
         * Return an element state
         *
         * @param {String} name - Internal item Id
         */
        isSelected: function (itemName) {
            return this.selectedItemsName[itemName];
        },

        /**
         * Unselect all items
         *
         * @param {Object} [notify=false] - Notify or not
         * @param {String} exceptedItemName - You can unselect all except one item, if neeeded
         */
        unselectItems: function (notify, exceptedItemName) {

            var itemName,
                selectedItemsName = this.selectedItemsName,
                itemsElm = this.elements.items;

            notify = (notify === undefined) ? true : notify;

            for (itemName in itemsElm) {
                if (
                    itemsElm.hasOwnProperty(itemName) &&
                        selectedItemsName[itemName] &&
                            !itemsElm[itemName].hasClassName('uwa-pinned') &&
                                exceptedItemName !== itemName
                ) {
                    itemsElm[itemName].removeClassName('selected');
                    selectedItemsName[itemName] = false;

                    if (notify) {
                        this.dispatchEvent('onChange', [itemName, false, this.options.data[itemName]]);
                    }
                }
            }
        },

        enable: function () {
            this.enabled = true;
            this.getContent().removeClassName('disabled');
        },

        disable: function () {
            this.enabled = false;
            this.getContent().addClassName('disabled');
        },

        isEnabled: function () {
            return this.enabled;
        }
    });

    return UWA.namespace('Controls/Segmented', Segmented, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Accordion
 *
 */
define('UWA/Controls/Accordion', [
    'UWA/Core',
    'UWA/Controls/Segmented'
], function (UWA, Segmented) {
    'use strict';

    var Accordion = Segmented.extend(/** @lends module:UWA/Controls/Accordion.UWA.Controls.Accordion# */{

        /**
         * @property {String} name name of the control
         * @private
         */
        name: 'uwa-accordion',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @private
         */
        defaultOptions: {
            title: null,
            multiSelect: false,
            constantItemWidth: false,
            contentPosition: 'bottom'
        },

        /* Group: Core methods */

        /**
         * Display a vertically stacked list of items (e.g. labels or thumbnails).
         * Each item can be "expanded" or "stretched" to reveal the content associated with that item.
         * There can be zero or more items expanded at a time, depending on the options.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onPreInject`    | Triggered before inject                |
         * | `onPostInject`   | Triggered after inject                 |
         * | `onResize`       | Invoked when control needs to resize   |
         * | `onClick`        | Invoked when a item title is clicked   |
         * | `onChange`       | Invoked when a item open or close      |
         *
         *
         * @example
         * var myControl = new UWA.Controls.Accordion({
         * data: {
         *     option_a: {text: 'a'},
         *     option_bb: {text: 'bb'},
         *     option_ccc: {text: 'ccc'},
         *     option_dddd: {text: 'dddd'}
         * }
         * });
         *
         * myControl.inject(myControlContainer);
         * // OR
         * myControlContainer.appendChild(myControl.getContent());
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.title=null] - Item title
         * @param {Boolean} [options.multiSelect=false] - Allow selecting more than one item
         * @param {Boolean} [options.constantItemWidth=false] - Keep all items the same width
         * @param {String} [options.className=''] - Customized classname
         * @param {Object} [options.data={}] - Data to fill in the control
         * @param {Object} [options.events={}] - Events Callbacks
         *
         * @constructs UWA.Controls.Accordion
         * @extends module:UWA/Controls/Segmented.UWA.Controls.Segmented
         * @memberof module:UWA/Controls/Accordion
         */
        init: function (options) {

            this._parent(options);
        },

        /**
         * Check if accordion has an item
         *
         * @param {String} name - internal item Id
         * @return {Boolean}
         */
        hasItem: function (name) {
            if (this.elements.items[name]) {
                return true;
            }
            return false;
        },

        /**
         * Add one item at the end of the control
         * AND an item content container
         *
         * @param {String} name - Internal item Id
         * @param {Object} itemConfig - Item configuration
         */
        addItem: function (name, itemData) {

            var elements = this.elements,
                itemsElements = elements.items = elements.items || {},
                containers = elements.containers = elements.containers || {};

            this._parent(name, itemData);

            containers[name] = UWA.createElement('div', {
                'class': this.getClassNames('-content')
            }).inject(itemsElements[name], (this.options.contentPosition === 'top') ? 'top' : 'bottom');

            if (itemData.content) {
                this.setContent(name, itemData.content);
            }
        },

        /**
         * Destroy an item and all its children
         *
         * @param {String} name - Internal item Id
         */
        removeItem: function (name) {

            var elements = this.elements,
                itemsElements = elements.items;

            if (itemsElements[name]) {
                itemsElements[name].destroy();
                itemsElements[name] = null;
            }
        },

        /**
         * Add some content to an item, or replace any existing content
         *
         * @param {String} name - Internal item Id
         * @param {String |HTMLelement} content - Content to add
         * @param {Boolean} empty - Empty or not item content before
         *
         * @return {HTMLelement}
         */
        updateContent: function (name, content, empty) {

            var container = this.elements.containers[name];

            if (empty) {
                container.empty();
            }

            // Used only for legacy, to not break HTML construction
            if (UWA.is(content, 'string')) {
                content = UWA.createElement('div', {
                    html: content
                });
            }
            container.addContent(content);

            return container;
        },

        /**
         * Build main dom elements.
         */
        buildSkeleton: function () {

            var elements = this.elements;
            elements.container = UWA.createElement('ul', {
                'class': this.getClassNames()
            });

            // TODO WTF ?
            elements.itemContainer = elements.container;
        },

        /* Group: Events methods */

        /**
         * Invoked when an item is clicked.
         */
        onClick: function (name) {
            this.toggleItem(name);
        },

        /**
         * Invoked when a item is closed or opened
         */
        onChange: function (name, state) {
            if (state && !this.options.multiSelect) {
                this.unselectItems(false, name);
            }
        },

        /* Group: Public methods */

        /**
         * Set item content (removing any existing content).
         *
         * @param {String} name - Internal item Id
         * @param {String|HTMLelement} content - New content
         * @return {HTMLelement}
         */
        setContent: function (name, content) {
            return this.updateContent(name, content, true);
        },

        /**
         * SAdd content to the item.
         *
         * @param {String} name - Internal item Id
         * @param {String|HTMLelement} content - New content
         * @return {HTMLelement}
         */
        addContent: function (name, content) {
            return this.updateContent(name, content, false);
        }

    });

    return UWA.namespace('Controls/Accordion', Accordion, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, ActiveXObject, window, navigator
*/

/**
 * This module provides classes to display a SWF Adobe Flash file.
 *
 * @module   UWA/Controls/Flash
 *
 *
 * @example
 * var myFlash = new UWA.Controls.Flash({
 *     url: 'http://example.com/animation.swf',
 *     flashVars: {
 *         test: 'hello'
 *     }
 * });
 *
 * myFlash.inject(widget.body);
 */
define('UWA/Controls/Flash', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Controls/Abstract'
], function (UWA, Utils, Abstract) {
    'use strict';

    var Flash = Abstract.extend(/** @lends module:UWA/Controls/Flash.UWA.Controls.Flash# */{ // bypass

        /**
         * @property {Number} id - instance unique id
         * @private
         */
        id: null,

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @private
         */
        defaultOptions: {
            url: '',
            width: 320,
            height: 240,
            className: 'uwa-swf',
            pluginspage: 'http://www.macromedia.com/go/getflashplayer',
            flashVars:  '',
            scale: 'exactfit',
            wmode: 'opaque',
            quality: 'hight',
            allowScriptAccess: 'sameDomain', // "always", "sameDomain", or "never"
            bgcolor: false, // #ffffff
            allowfullscreen: 'true'
        },

        /**
         * @property {String} flashVersion - The current detected flash Version.
         * @protected
         */
        flashVersion: null,

        /**
         * Display a SWF Adobe Flash file.
         *
         * @example
         * var myFlash = new UWA.Controls.Flash({
         *     url: 'http://example.com/animation.swf',
         *     flashVars: {
         *         test: 'hello'
         *     }
         * });
         *
         * myFlash.inject(widget.body);
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.url=null] - Flash content url
         * @param {String} [options.width='100%'] - Flash width
         * @param {String} [options.height='100%'] - Flash height
         * @param {String} [options.className='uwa-swf'] - Customized container classname
         * @param {String} [options.flashVars=''] - Custom flashVars
         * @param {String} [options.pluginspage] - Flash plugin url ('http://www.macromedia.com/go/getflashplayer')
         * @param {String} [options.bgcolor=false] - Flash background color
         * @param {String} [options.wmode='opaque'] - Flash transparent state
         * @param {String} [options.scale='exactfit'] - Flash scale state
         * @param {String} [options.quality='high'] - Flash quality
         * @param {String} [options.allowScriptAccess='sameDomain'] - Allow Flash script access
         * @param {String} [options.allowfullscreen=true] - Allow Flash Flash fullscreenAllow
         *
         * @constructs UWA.Controls.Flash
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Flash
         */
        init: function (options) {

            this._parent(options);

            options = this.options;

            this.id = options.id || Utils.random(10);
            this.flashVersion = this.detectFlashVersion();

            this.buildSkeleton();
        },

        /**
         * Build main dom elements.
         * @protected
         */
        buildSkeleton: function () {

            // clean flahVars see http://kb2.adobe.com/cps/141/tn_14143.html
            function escapeAmpersand(string) {
                return String(string).replace(/(&amp;)|(&)/g, '%26');
            }

            // clean flahVars see http://kb2.adobe.com/cps/141/tn_14143.html
            var flashParams, flashParam, flashRequireTag, flashParamTags,
                navigator = window.navigator,
                elements = this.elements,
                options = this.options,
                flashVars = options.flashVars || '',
                flashUrl = escapeAmpersand(options.url || '');

            this.container = elements.container = UWA.createElement('div', {
                'class': options.className
            });

            // Clean flashVars if Object
            if (!UWA.is(flashVars, 'string')) {
                flashVars = escapeAmpersand(Utils.toQueryString(flashVars));
            }

            // Netscape plugin architecture
            if (
                navigator.plugins &&
                    navigator.mimeTypes &&
                        navigator.mimeTypes.length
            ) {

                elements.flashTag = UWA.createElement('embed', {

                    // Plugin Object
                    id: this.id,
                    type: 'application/x-shockwave-flash',
                    src: flashUrl,
                    width: options.width,
                    height: options.height,
                    pluginspage: options.pluginspage,

                    // Flash params
                    flashvars: flashVars,
                    scale: options.scale,
                    quality: options.quality,
                    allowScriptAccess: options.allowScriptAccess,
                    wmode: options.wmode,
                    allowfullscreen: options.allowfullscreen
                });

            // Fucking IE plugin architecture
            } else {

                flashParamTags = [];

                // Flash params
                flashParams = {
                    movie: flashUrl,
                    flashvars: flashVars,
                    quality: options.quality,
                    allowScriptAccess: options.allowScriptAccess,
                    wmode: options.wmode,
                    allowfullscreen: options.allowfullscreen
                };

                for (flashParam in flashParams) {
                    if (flashParams.hasOwnProperty(flashParam)) {
                        flashParamTags.push({
                            tag: 'param',
                            name: flashParam,
                            value: flashParams[flashParam]
                        });
                    }
                }

                // Plugin Object
                elements.flashTag = UWA.createElement('object', {
                    id: this.id,
                    width: options.width,
                    height: options.height,
                    classid: 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000',
                    html: flashParamTags
                });
            }

            // Inject FlashTag
            elements.flashTag.inject(elements.container);

            // save link to plugin tag
            this.object = elements.flashTag;

            // if flash is not installed...
            if (this.flashVersion.major === 0) {

                flashRequireTag = UWA.createElement('p', {
                    text: UWA.i18n('You need Adobe Flash to display this Content.'),
                    styles: {
                        textAlign: 'center'
                    }
                });

                flashRequireTag.inject(elements.container);
            }

            return this.container;
        },

        getFlashContainer: function () {

            if (this.object === undefined) {
                this.getContent();
            }

            return this.object;
        },

        getFlashVersion: function () {
            return this.flashVersion;
        },

        /**
         * Flash detection function from swfObject.
         *
         * @return {Object} Object with major, minor and rev properties.
         */
        detectFlashVersion: function () {

            var axo, counter, x, detectFlashVersion = [0, 0, 0];

            if (navigator.plugins && navigator.mimeTypes.length) {

                x = navigator.plugins['Shockwave Flash'];
                if (x && x.description) {
                    detectFlashVersion =  x.description.replace(/([a-zA-Z]|\s)+/, '').replace(/(\s+r|\s+b[0-9]+)/, '.').split('.');
                }

            // Windows CE
            } else if (navigator.userAgent && navigator.userAgent.indexOf('Windows CE') >= 0) {

                axo = 1;
                counter = 3;
                while (axo) {
                    try {
                        counter++;
                        axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.' + counter);
                        detectFlashVersion = [counter, 0, 0];
                    } catch (eShockwaveFlashCounter) {
                        axo = null;
                    }
                }

            // Windows IE (non mobile)
            } else {

                // do minor version lookup in IE, but avoid fp6 crashing issues
                // see http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6
                try {
                    axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.7');

                } catch (eShockwaveFlash7) {

                    try {

                        axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
                        detectFlashVersion = [6, 0, 21];
                        axo.AllowScriptAccess = 'always'; // error if player version < 6.0.47 (thanks to Michael Williams @ Adobe for this code)

                    } catch (eShockwaveFlash6) {
                        if (detectFlashVersion.major === 6) {
                            return detectFlashVersion;
                        }
                    }

                    try {
                        axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
                    } catch (eShockwaveFlash) {
                        axo = null;
                    }
                }

                if (axo !== null) {
                    detectFlashVersion = axo.GetVariable('$version').split(' ')[1].split(',');
                }
            }

            return {
                major: detectFlashVersion[0],
                minor: detectFlashVersion[1],
                rev: detectFlashVersion[2]
            };
        }
    });

    return UWA.namespace('Controls/Flash', Flash, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, console
*/

/**
 * @module   UWA/Controls/Slider
 *
 *
 * @example
 * require(['UWA/Controls/Slider'], function (Slider) {
 *     var slider = new Slider({
 *         onChange: function (newValue){
 *             doSomething(newValue);
 *         }
 *     });
 * });
 */
define('UWA/Controls/Slider', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract'
], function (UWA, Utils, Client, Event, Element, Abstract) {
    'use strict';

    var Slider = Abstract.extend(/** @lends module:UWA/Controls/Slider.UWA.Controls.Slider# */{ // bypass

        name: "uwa-slider",

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: '',
            isTouch: Client.Features.touchEvents,
            value: 0,
            handleButton: false,
            handleDragTreshold: 40,
            slider: {
                html: [
                    {
                        tag: 'div',
                        'class': 'scrubber-wrapper',
                        html: {
                            tag: 'div',
                            'class': 'scrubber',
                            html: [
                                {
                                    tag: 'div',
                                    'class': 'progress'
                                },
                                {
                                    tag: 'div',
                                    'class': 'loaded'
                                },
                                {
                                    tag: 'div',
                                    'class': 'handle handle-hide'
                                }
                            ]
                        }

                    }
                ],
                // TODO Group this or remove class
                scrubberClass: 'scrubber',
                progressClass: 'progress',
                handleClass: 'handle',
                loadedClass: 'loaded'
            }
        },

        /**
         * Displays a slider with a handle.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onChange`       | Fired when slider value changes (by user interaction, not by calling setValue) |
         *
         * @example
         * require(['UWA/Controls/Slider'], function (Slider) {
         *     var slider = new Slider({
         *         onChange: function (newValue){
         *             doSomething(newValue);
         *         }
         *     });
         * });
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Element} [options.container=null] - Element used to wrap the control, if not provided, one will be created
         * @param {String}  [options.className=''] - CSS class name set to the container Element
         * @param {String}  [options.handleButton=false] - display/hide the handle button
         * @constructs UWA.Controls.Slider
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Slider
         */
        init: function (options) {
            options = options || {};
            this._parent(options);

            this.eventNames = {
                start: this.options.isTouch ? 'touchstart' : 'mousedown',
                move: this.options.isTouch ? 'touchmove' : 'mousemove',
                end: this.options.isTouch ? 'touchend' : 'mouseup'
            };

            this.body = options.body || document.body;
            this.bodyEvents = {};
            if (this.options.handleButton) {
                this.bodyEvents[this.eventNames.move] = this.onHandleDrag.bind(this);
                this.bodyEvents[this.eventNames.end] = this.onHandleDragEnd.bind(this);
            }
            this._buildSkeleton();
            this._attachEvents();
            this.reset();
        },

        /**
         * Reset slider progress and loaded values
         */
        reset: function () {
            var that = this;
            var elements = that.elements;

            that.loadedPercent = 0;

            elements.progress.setStyle('width', 0);
            that._updatePosition(0);
        },

        /**
         * Show the slider.
         */
        show: function () {
            this.container.show();
        },

        /**
         * Hide the slider.
         */
        hide: function () {
            this.container.hide();
        },

         /**
         * Update the slider value, without firing onChange event.
         *
         * @param {Number} value - An integer between 0 and 100
         */
        setValue: function (value) {
            if (value < 0 || value > 100) {
                console.log('The value should be an integer between 0 and 100'); // eslint-disable-line no-console
                return;
            }

            this.setOption('value', value);
            this._updatePosition(value);
        },

        /**
         * Update the slider's loaded value
         *
         * @param {Number} newLoadedValue - An integer between 0 and 100
         */
        setLoadedValue: function (newLoadedValue) {
            this.elements.loaded.setStyle('width', newLoadedValue + '%');
        },


        /* Group: Event methods */

        onInjected: function () {
            if (this.options.value > 0) {
                this._updatePosition(this.options.value);
            }
        },

        onHandleDragStart: function (event) {
            var handle = this.elements.handle,
                startX = Event.getPosition(event).x, //event.pageX || event.touches[0].pageX,
                delta = startX - handle.getPosition(document).x; // Detect drag using a larger area than 'handle' strict offsetWidth
            if (
                Math.abs(delta) <= this.options.handleDragTreshold
            ) {
                Event.stop(event);
                Element.addEvents.call(this.body, this.bodyEvents);
            }
        },

        onHandleDrag: function (event) {
            Event.stop(event);

            var currentCursor = Event.getPosition(event).x;
            // absolute left
            var handleLeft = this.elements.scrubber.getParent().getClientRects()[0].left;
            // relative left
            handleLeft = currentCursor - handleLeft;

            if (handleLeft < 0) {
                handleLeft = 0;
            } else if (handleLeft > this.elements.scrubber.offsetWidth) {
                handleLeft = this.elements.scrubber.offsetWidth;
            }

            this._updateValue(handleLeft);
        },

        onHandleDragEnd: function (event) {
            Event.stop(event);
            // Clean up drag events
            Element.removeEvents.call(this.body, this.bodyEvents);
            this.drag = null;
        },

        onProgressBarClick: function (event) {
            var offsetLeft,
                position = Event.getPosition(event);

            offsetLeft = position.x - this.elements.scrubber.getPosition(document).x;
            this._updateValue(offsetLeft);
        },


        /* Group: Private methods */

        /**
         * Create the slider HTML skeleton.
         */
        _buildSkeleton: function () {
            var container, getElement,
                that = this,
                options = that.options,
                sliderOptions = options.slider;
            if (options.container && UWA.is(options.container.getElement('.controls-slider'), 'element')) {
                container = options.container.getElement('.controls-slider');
                container.addClassName(this.getClassNames());
                container.addContent(options.slider.html);
            } else {
                container = UWA.createElement('div', {
                    'class': this.getClassNames(),
                    html: options.slider.html
                });
            }

            // Alias container.getElement
            getElement = container.getElement.bind(container);

            // Controls elements
            that.elements = {
                scrubber: getElement('.' + sliderOptions.scrubberClass),
                progress: getElement('.' + sliderOptions.progressClass),
                handle: getElement('.' + sliderOptions.handleClass),
                loaded: getElement('.' + sliderOptions.loadedClass)
            };

            if (options.handleButton) {
                that.elements.handle.removeClassName('handle-hide');
            }

            that.container = container;

            return that;
        },

        /**
         * Attach DOM events to slider skeleton.
         */
        _attachEvents: function () {

            var that = this,
                elements = that.elements,
                dispatchEvent = that.dispatchEvent.bind(that);
            if (that.options.handleButton) {
                that.container.addEvent(that.eventNames.start, that.onHandleDragStart.bind(that));
            }
            elements.scrubber.addEvent('click', dispatchEvent.bind(that, 'onProgressBarClick'));

            return this;
        },

        /**
         * Updating the slider value from a pixel position
         *
         * @param {Int} position - The pixel position of the progression
         */
        _updateValue: function (position) {
            var sliderWidth = this.elements.scrubber.offsetWidth;
            var value = Math.round(position * 100 / sliderWidth);

            this.setOption('value', value);
            this._updatePosition(value);
            this.dispatchEvent('onChange', value);
        },

        /**
         * Updating the pixel position of the slider handle and progress bar from a percentage value
         *
         * @param {Number} value - An integer between 0 and 100
         */
        _updatePosition: function (value) {
            if (!this.container || !this.container.isInjected()) {
                return;
            }

            var progressEl = this.elements.progress;
            var scrubberEl = this.elements.scrubber;
            var handleEl = this.elements.handle;

            var handleOffsetPercent = (handleEl.offsetWidth / 2) / scrubberEl.offsetWidth * 100;

            progressEl.setStyle('width', value + '%');
            handleEl.setStyle('left', (value - handleOffsetPercent) + '%');
        }
    });


    return UWA.namespace('Controls/Slider', Slider, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout, clearTimeout, document, window
*/

/**
 * @module   UWA/Controls/AudioPlayer
 *
 */
/*jshint maxparams: 8*/
define('UWA/Controls/AudioPlayer', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Controls/Flash',
    'UWA/Controls/Slider'
], function (UWA, Utils, Client, Event, Element, Abstract, Flash, Slider) {
    'use strict';

    var globalId = 0;
    var AudioPlayer = Abstract.extend(/** @lends module:UWA/Controls/AudioPlayer.UWA.Controls.AudioPlayer# */{ // bypass

        name: "uwa-audioplayer",

        /**
         * The default controls options.
         * @private
         */
        defaultOptions: {
            url: '',
            autoPlay: false,
            handleButton: true,
            closeButton: true,
            preload: 'none',
            className: '',
            isTouch: Client.Features.touchEvents,
            player: {

                html: [
                    {
                        tag: 'div',
                        'class': 'uwa-icon play-pause'
                    },
                    {
                        tag: 'div',
                        'class': 'controls-times',
                        html: [
                            {
                                tag: 'span',
                                'class': 'played',
                                text: '00:00'
                            },
                            {
                                tag: 'span',
                                'class': 'duration duration-hide',
                                text: '00:00'
                            }
                        ]
                    },
                    {
                        tag: 'div',
                        'class': 'controls-slider'
                    },
                    {
                        tag: 'div',
                        'class': 'controls-right',
                        html: {
                            tag: 'div',
                            'class': 'uwa-icon close close-hide'
                        }
                    }
                ],
                playPauseClass: 'play-pause',
                timeClass: 'time',
                durationClass: 'duration',
                playedClass: 'played',
                errorMessageClass: 'error-message',
                playingClass: 'playing',
                waitingClass: 'waiting',
                errorClass: 'error',
                closeClass: 'close'
            }
        },

        adapter: null,

        /**
         * Display an Audio player, uses Adobe Flash if audio tag is not supported.
         *
         * @example
         * var audioPlayer = new UWA.Controls.AudioPlayer();
         * audioPlayer.play('http://example.com/mysong.mp3');
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.url=''] - Url of the media to play
         * @param {String} [options.autoPlay=false] - Play automatically when media loaded
         * @param {String} [options.preload='none'] - Audio tag preload attribute ('auto'|'metadata'|'none')
         * @param {String} [options.className=''] - CSS class name set to the container Element
         * @param {String} [options.closeButton=true] - display/hide close button
         * @param {String} [options.handleButton=true] - display/hide handle Button
         *
         * @constructs UWA.Controls.AudioPlayer
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/AudioPlayer
         */
        init: function (options) {
            var that = this;
            this.id = globalId;
            globalId++;
            UWA.Controls.AudioPlayer.Instances['x' + this.id] = this;

            options = options || {};
            this._parent(options);

            this.eventNames = {
                start: this.options.isTouch ? 'touchstart' : 'mousedown',
                move: this.options.isTouch ? 'touchmove' : 'mousemove',
                end: this.options.isTouch ? 'touchend' : 'mouseup'
            };
            this.body = options.body || document.body;
            this.buildSkeleton();
            this.attachEvents();
            this.reset();

            if (this.options.url) {
                this[this.options.autoPlay ? 'play' : 'load']();
            }

            this.container.addEvent('resize', function () {
                var minSliderWidth = 30,
                    roughMarginForThree = 10,
                    roughMarginForTwo = 7,

                    els,
                    containerWidth,
                    playPauseWidth,
                    sliderWidth,
                    controlsTimesWidth,
                    controlsRightWidth,

                    totalContentWidth;

                els = that.elements;

                // Reset
                els.slider.show();
                els.controlsTimes.show();
                els.controlsRight.show();

                // Measurements
                containerWidth = that.container.getSize().width;

                playPauseWidth = els.playPause.getSize().width;
                sliderWidth = els.slider.getSize().width;
                controlsTimesWidth = els.controlsTimes.getSize().width;
                controlsRightWidth = els.controlsRight.getSize().width;

                // Removing elements to fit
                if (sliderWidth < minSliderWidth) {
                    // Slider
                    els.slider.hide();

                    totalContentWidth = playPauseWidth + controlsTimesWidth + controlsRightWidth;
                    if (totalContentWidth > containerWidth - roughMarginForThree) {
                        // Times
                        els.controlsTimes.hide();
                        totalContentWidth -= controlsTimesWidth;

                        if (totalContentWidth > containerWidth - roughMarginForTwo) {
                            // Close button
                            els.controlsRight.hide();
                        }
                    }
                }
            });
        },

        /**
         * Load Adapter.
         *
         * @param {String} file - Audio source url
         * @return {UWA.Controls.AudioPlayer.Adapter}
         */
        getAdapter: function (file) {

            var adapterName, adapter,
                adapters = UWA.Controls.AudioPlayer.Adapter;

            for (adapterName in adapters) {
                if (adapters.hasOwnProperty(adapterName)) {
                    if (!adapter && adapters[adapterName].isAvailable(file)) {
                        adapter = adapters[adapterName];
                    }
                }
            }

            if (!adapter) {
                window.open(file);
                //throw new Error('Unable to read file "' + file + '" using UWA.Controls.AudioPlayer.');
            } else {

                if (!this.adapter) {
                    this.adapter = adapter.build(this);
                }

                this.adapter.setUrl(file);

                return this.adapter;
            }
        },

        /**
         * Create the player HTML skeleton.
         */
        buildSkeleton: function () {

            var container, getElement,
                that = this,
                options = that.options,
                playerOptions = options.player;

            // Wrapper element
            container = UWA.createElement('div', {
                'class': this.getClassNames() ,
                html: options.player.html
            });

            // Alias container.getElement
            getElement = container.getElement.bind(container);

            // Controls elements
            that.elements = {
                playPause: getElement('.play-pause'),
                slider: null,
                controlsTimes: getElement('.controls-times'),
                controlsRight: getElement('.controls-right'),
                played: getElement('.' + playerOptions.playedClass),
                duration: getElement('.' + playerOptions.durationClass),
                play: getElement('.' + playerOptions.playPauseClass),
                close: getElement('.' + playerOptions.closeClass)
            };

            if (that.options.closeButton) {
                that.elements.close.removeClassName('close-hide');
            }

            that.container = container;

            return that;
        },

        /**
         * Attach DOM events to player skeleton.
         */
        attachEvents: function () {


            var that = this,
                elements = that.elements,
                dispatchEvent = that.dispatchEvent.bind(that);

            elements.play.addEvent('click', dispatchEvent.bind(that, 'onPlayPause'));
            if (this.options.closeButton) {
                elements.close.addEvent('click', dispatchEvent.bind(that, 'close'));
            }
            that.slider = new Slider({
                _root: false,
                container: that.container,
                events: {
                    'onChange': function (newValue) {
                        var currentTime = (newValue * that.adapter.getDuration()) / 100;
                        that.adapter.setCurrentTime(currentTime);
                        elements.played.setText(that.formatTime(currentTime));
                    }
                }
            });
            that.elements.slider = that.slider.elements.scrubber;

            return this;
        },

        /**
         * Reset.
         */
        reset: function () {

            var that = this,
                elements = that.elements;

            that.loadedPercent = 0;
            that.canPlay = false;
            that.shouldPlay = false;

            elements.duration.setText(that.formatTime(0));
            elements.played.setText(that.formatTime(0));

        },

        /**
         * Load an audio file.
         *
         * #TODO restore "title" argument
         *
         * @param {String} file - Audio source url
         * @param {String} title - Audio source title
         */
        load: function (file) {

            file = file || this.options.url;

            // Stop Previous song
            this.stop();

            this.reset();
            this.show();

            this.adapter = this.getAdapter(file);

            // iOS disallow to calling play() inside a timeout
            //setTimeout(this.adapter.play.bind(this.adapter), 0);
        },

        /**
         * Play an audio file.
         *
         * @param {String} file - Audio source url
         * @param {String} title - Audio source title
         */
        play: function (file, title) {

            this.load(file, title);
            this.adapter.play();

            this.shouldPlay = true;
        },

        /**
         * Pause current song.
         */
        pause: function () {
            if (this.adapter) {
                this.adapter.pause();
            }

            this.shouldPlay = false;
        },

        /**
         * Stop current song.
         */
        stop: function () {
            if (this.adapter) {
                this.adapter.stop();
                this.slider.reset();
            }
        },

        /**
         * Stop and hide the player.
         */
        close: function () {
            this.stop();
            this.slider.reset();
            this.hide();
        },

        /**
         * Toggle play/pause
         */
        onPlayPause: function () {
            if (this.adapter) {
                this.adapter[this.adapter.isPaused() ? 'play' : 'pause']();
            }
        },

        /**
         * HTML5 Media Event 'play'.
         */
        onPlay: function () {

            this.container.addClassName(this.options.player.playingClass).removeClassName('paused');

            if (!this.canPlay) {
                this.container.addClassName(this.options.player.waitingClass);
            }

            this.shouldPlay = true;
        },

        /**
         * HTML5 Media Event 'pause'.
         */
        onPause: function () {
            this.container.removeClassName(this.options.player.waitingClass)
                .removeClassName(this.options.player.playingClass)
                .addClassName('paused');

            this.shouldPlay = false;
        },

        /**
         * HTML5 Media Event 'canplay'.
         * This event is generated when enough data is available that the media
         * can be played.
         */
        onCanPlay: function () {

            // When `canplay` is fired, readyState might be 2, 3 or even 4.
            // Once we have data, we start tracking the load progress.
            if (this.options.preload || this.options.preload !== 'none') {
                this.trackLoadProgress();
            }

            this.container.removeClassName(this.options.player.waitingClass);
            this.canPlay = true;

            if (this.shouldPlay && this.adapter && this.adapter.isPaused()) {
                this.adapter.play();
            }
        },

        /**
         * HTML5 Media Event 'metadataloaded'.
         */
        onMetadataLoaded: function () {

            // The user agent has just determined the duration of the resource
            this.elements.duration.setText(this.formatTime(this.adapter.getDuration()));
        },

        /**
         * HTML5 Media Event 'timeupdate'.
         */
        onTimeUpdate: function () {
            this.elements.played.setText(this.formatTime(this.adapter.getCurrentTime()));
            var timePerCent = this.adapter.getCurrentTime() * 100 / this.adapter.getDuration();
            this.slider.setValue(timePerCent);
        },

        /**
         * HTML5 'progress' event.
         */
        trackLoadProgress: function () {

            if (this.loadTimer) {
                clearTimeout(this.loadTimer);
            }

            if (this.loadedPercent < 1) {
                // HTML5 'progress' event is buggy on chrome when loading from cache,
                // so we use timer
                this.loadTimer = setTimeout(function () {
                    this.onLoadProgress();
                    this.trackLoadProgress();
                }.bind(this), 400);
            }
        },

        onLoadProgress: function () {
            this.loadedPercent = this.adapter ? this.adapter.getLoadProgress() : 0;
            if (this.loadedPercent) {
                this.slider.setLoadedValue(this.loadedPercent);
            }
        },


        formatTime: function (seconds) {

            var rem = parseInt(seconds, 10),
                mins = Math.floor(rem / 60, 10),
                secs = rem - mins * 60;

            secs = !isNaN(secs) ? secs : 0;
            mins = !isNaN(mins) ? mins : 0;

            return mins + ':' + (secs < 10 ? '0' + secs : secs);
        }
    });

    /*
      Class: UWA.Controls.AudioPlayer.Instances

        Store all AudioPlayer Instances.
    */
    AudioPlayer.Instances = {};

    AudioPlayer.Adapter = {

        /*
          Class: UWA.Controls.Adapter.audio

            HTML5 Audio tag element Adapter.
        */
        audio: {

            audioTag: null,

            isAvailable: function (url) {

                var audio = document.createElement('audio');
                if (audio.canPlayType) {
                    return (/\.mp3$/.test(url) && '' !== audio.canPlayType('audio/mpeg')) ||
                           (/\.m4a$/.test(url) && '' !== audio.canPlayType('audio/x-m4a')) ||
                           (/\.ogg$/.test(url) && '' !== audio.canPlayType('audio/ogg; codecs="vorbis"'));
                }

                return false;
            },

            build: function (control) {

                // http://thebrowsereview.com/html5/html5-audio-tag-and-format-support/
                // http://playground.html5rocks.com/#audio_tag
                // http://html5doctor.com/native-audio-in-the-browser/
                this.audioTag = UWA.createElement('audio', {
                    id: 'uwa-audioplayer-audio-' + control.id,
                    preload: control.options.preload,
                    events: {
                        play: control.onPlay.bind(control),
                        pause: control.onPause.bind(control),
                        ended: function () {
                            control.pause();
                            control.elements.played.setText(control.formatTime(0));
                            control.slider.reset();
                        },
                        timeupdate: function () {
                            control.dispatchEvent('onTimeUpdate');
                            control.onLoadProgress();
                        },
                        loadedmetadata: control.onMetadataLoaded.bind(control),
                        canplay: control.dispatchEvent.bind(control, 'onCanPlay')
                    }
                }).setStyles({
                    position: 'absolute',
                    top: '-100000px'
                });

                this.audioTag.inject(control.container);

                return this;
            },

            isPaused: function () {
                return this.audioTag.paused;
            },

            play: function () {
                this.audioTag.play();
            },

            pause: function () {
                this.audioTag.pause();
            },

            stop: function () {
                this.audioTag.pause();
            },

            setCurrentTime: function (seconds) {
                try {
                    this.audioTag.currentTime = seconds;
                } catch (e) {
                    // Do nothing
                }
            },

            getCurrentTime: function () {
                return this.audioTag.currentTime;
            },

            getDuration: function () {
                return this.audioTag.duration;
            },

            getLoadProgress: function () {

                var percent = 0,
                    audioTag = this.audioTag;

                if (
                    audioTag &&
                        audioTag.buffered &&
                            audioTag.buffered.length > 0 &&
                                audioTag.buffered.end &&
                                    audioTag.duration
                ) {
                    percent = audioTag.buffered.end(0) / audioTag.duration;

                // Some browsers can not calculate audioTag.bufferered.end() to be anything other than 0.
                // If the bytes count is available we use this instead (e.g. FF3.6, Safari 5).
                } else if (
                    audioTag &&
                        audioTag.bytesTotal !== undefined &&
                            audioTag.bytesTotal > 0 &&
                            audioTag.bufferedBytes !== undefined
                ) {
                    percent = audioTag.bufferedBytes / audioTag.bytesTotal;
                }
                return percent * 100;
            },

            setVolume: function (volume) {
                this.audioTag.volume = parseFloat(volume / 200);
            },

            getVolume: function () {
                return this.audioTag.volume * 200;
            },

            setUrl: function (url) {

                this.audioTag.src = url;

                // Causes the element to reset and start selecting and loading a new media resource from scratch.
                // This is useful when audio src has changed
                this.audioTag.load();
            }
        },

        /*
          Class: UWA.Controls.Adapter.flash

            Adobe Flash Audio Player Adapter.
        */
        flash: {

            flashTag: null,

            isAvailable: function (url) {
                return Flash.prototype.detectFlashVersion().major !== 0 && /\.mp3$/.test(url);
            },

            build: function (control) {

                var FSCommandElement,
                    flashId = 'uwa-audioplayer-flash-' + control.id,
                    flash = new Flash({
                        _root: false,
                        id: flashId,
                        url: UWA.hosts.uwa + '/lib/UWA/assets/img/flash/player_mp3_js.swf',
                        width: 1,
                        height: 1,
                        flashVars: 'listener=UWA.Controls.AudioPlayer.Instances.x' + control.id + '.adapter.listener&interval=750&userexternalinterface=1',
                        allowScriptAccess: 'always'
                    });

                this.pendingVariables = [];

                this.control = control;

                this.listener = {

                    isPlaying: false,
                    ready: false,

                    onInit: this.onReady.bind(this),

                    onUpdate: function () {
                        control.onMetadataLoaded();
                        control.dispatchEvent('onTimeUpdate');
                        control.onLoadProgress();
                    }
                };

                this.flashTag = flash.getFlashContainer();

                // Hide Interface
                this.flashTag.setStyles({
                    position: 'absolute',
                    top: '-100000px'
                });

                // The flash.system package contains one package-level function, fscommand(), which facilitates communication between a SWF file and its container.
                // http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/system/package.html?filter_flash=cs5&filter_flashplayer=10.2&filter_air=2.6#fscommand%28%29
                // http://social.msdn.microsoft.com/Forums/en/iewebdevelopment/thread/4ae53961-bc40-4d9d-9bfa-bcec8384e6ab
                if (Client.Engine.ie) {
                    try {
                        FSCommandElement = document.createElement('<scr'
                            + 'ipt for='
                            + flashId
                            + ' event='
                            + 'FSCommand(command,args)'
                            + '></scr'
                            + 'ipt>');
                        FSCommandElement.text = 'eval(args);';
                        document.body.appendChild(FSCommandElement);

                    } catch (e) {
                        // Ignore error
                    }
                }

                this.flashTag.inject(control.container);

                return this;
            },

            SetVariable: function (name, value) {

                var that = this;

                if (!that.listener.ready) {
                    that.pendingVariables.push([name, value]);
                    return;
                }

                that.variableTimers = that.variableTimers || {};

                try {
                    clearTimeout(that.variableTimers[name]);
                    that.flashTag.SetVariable(name, value);

                // Handle possible IE error on undefined
                // Object tag properties.
                } catch (e) {
                    that.variableTimers[name] = setTimeout(function () {
                        that.flashTag.SetVariable(name, value);
                    }, 500);
                }
            },

            onReady: function () {
                this.listener.ready = true;
                this.pendingVariables.forEach(function (vars) {
                    this.SetVariable.apply(this, vars);
                }, this);
                this.control.dispatchEvent('onCanPlay');
            },

            isPaused: function () {
                return this.listener.isPlaying !== 'true';
            },

            play: function () {
                this.SetVariable('enabled', 'true');
                this.SetVariable('method:play');
                this.control.onPlay();
            },

            pause: function () {
                this.SetVariable('method:pause');
                this.control.onPause();
            },

            stop: function () {
                this.SetVariable('method:setPosition', 0);
                this.SetVariable('method:stop');
                this.control.onPause();
            },

            setCurrentTime: function (position) {
                this.SetVariable('enabled', 'false');
                this.SetVariable('method:setPosition', Math.round(position * 1000));
                this.SetVariable('enabled', 'true');
            },

            getCurrentTime: function () {
                return this.listener.position / 1000;
            },

            getDuration: function () {
                return this.listener.duration / 1000;
            },

            getLoadProgress: function () {

                var bytesPercent = this.listener.bytesPercent;

                return isNaN(bytesPercent) ? 100 : bytesPercent;
            },

            setVolume: function (volume) {
                volume = (!isNaN(volume) ? volume : 100);
                this.SetVariable('method:setVolume', volume);
            },

            getVolume: function () {
                return this.listener.volume;
            },

            setUrl: function (url) {
                this.SetVariable('method:setUrl', url);
            }
        }
    };

    return UWA.namespace('Controls/AudioPlayer', AudioPlayer, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/AutocompleteAdaptors/Abstract
 *
 */
define('UWA/Controls/AutocompleteAdaptors/Abstract', [
    'UWA/Core',
    'UWA/String',
    'UWA/Class',
    'UWA/Class/Options'
], function (UWA, UWAString, Class, Options) {
    'use strict';

    var Abstract;

    Abstract = Class.extend(Options, /** @lends module:UWA/Controls/AutocompleteAdaptors/Abstract.UWA.Controls.AutocompleteAdaptors.Abstract# */{

        /**
         * @param {Object} [options] - Options hash or a option/value pair.
         *
         * @abstract
         * @mixes UWA.Class.Options
         * @constructs UWA.Controls.AutocompleteAdaptors.Abstract
         * @memberof module:UWA/Controls/AutocompleteAdaptors/Abstract
         */
        init: function (options) {
            this.setOptions(options);
        },

        /**
         * Get suggestions for a given text and the caret position.
         * Should be overriden.
         *
         * Suggestion objects should either be "full" or "inline".
         *
         * Full suggestions are replacing a portion of the current input value with
         * another value. They contain the properties `fullValue`, `start` and `end`,
         * offsets of the portion to replace.
         *
         * Inline suggestions are appended to the right of the caret inside the input
         * value. They don't replace any portion of the current value: they only complete
         * it. They contain the property `inlineValue`
         *
         * Other properties are passed to the `renderSuggestion` method. The default
         * renderSuggestion uses the `displayValue` property to print the value to the
         * user.
         *
         * @example
         * var words = [ "foo", "bar" ];
         *
         * var FullAdaptor = AbstractAdaptor.extend({
         *
         *     getSuggestions: function (text, caret) {
         *         var start = text.slice(0, caret);
         *         var lastWord = /\w*$/.exec(start)[0];
         *         var re = new RegExp('^' + UWAString.escapeRegExp(lastWord), 'i');
         *         if (lastWord.length) {
         *             return words.filter(function (w) {
         *                 return re.test(w) && w !== lastWord;
         *             }).map(function (word) {
         *                 return {
         *                     displayValue: word,
         *                     start: caret - lastWord.length,
         *                     end: caret,
         *                     fullValue: word
         *                 };
         *             }, this);
         *         }
         *
         *         return [];
         *     }
         * });
         *
         * var InlineAdaptor = AbstractAdaptor.extend({
         *
         *     getSuggestions: function (text, caret) {
         *         var start = text.slice(0, caret);
         *         var lastWord = /\w*$/.exec(start)[0];
         *         var re = new RegExp('^' + UWAString.escapeRegExp(lastWord), 'i');
         *         if (lastWord.length) {
         *             return words.filter(function (w) {
         *                 return re.test(w) && w !== lastWord;
         *             }).map(function (word) {
         *                 return {
         *                     inlineValue: word.slice(lastWord.length),
         *                     displayValue: word
         *                 };
         *             }, this);
         *         }
         *
         *         return [];
         *     }
         * });
         *
         * @param {String} text the current input text
         * @param {Number} caret the caret offset inside the text
         * @return {Promise} resolved with an array of suggestion objects
         */
        getSuggestions: function (/*text, caret*/) {
            throw new Error('Not implemented');
        },

        /**
         * Render a list of suggestion objects. This will be used to populate the
         * suggestion dropdown.
         *
         * @param {Array} suggestions
         * @return {Any} anything supported by
         * {@link module:UWA/Element.UWA.Element#setContent|Element.setContent}
         */
        renderSuggestions: function (suggestions) {
            return {
                tag: 'div',
                'class': 'category uwa-icon magnifying-glass',
                html: suggestions.map(function (suggestion) {
                    return {
                        tag: 'div',
                        'class': 'suggestion',
                        html: this.renderSuggestion(suggestion)
                    };
                }, this)
            };
        },

        /**
         * Render a single suggestion object.
         *
         * @param {Object} suggestion
         * @return {Any} anything supported by
         * {@link module:UWA/Element.UWA.Element#setContent|Element.setContent}
         */
        renderSuggestion: function (suggestion) {
            return UWAString.escapeHTML(suggestion.displayValue || suggestion.fullValue || '\u00A0');
        }
    });

    return UWA.namespace('Controls/AutocompleteAdaptors/Abstract', Abstract, UWA);
});



/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/AutocompleteAdaptors/Data
 *
 */
define('UWA/Controls/AutocompleteAdaptors/Data', [
    'UWA/Core',
    'UWA/Controls/AutocompleteAdaptors/Abstract',
    'UWA/Json',
    'UWA/Data',
    'UWA/String',
    'UWA/Promise'
], function (UWA, AbstractAdaptor, Json, Data, UWAString, Promise) {
    'use strict';

    var DataAdaptor;

    DataAdaptor = AbstractAdaptor.extend( /** @lends module:UWA/Controls/AutocompleteAdaptors/Data.UWA.Controls.AutocompleteAdaptors.Data# */{

        options: {
            url: null,
            dataParser: null,
            format: '{name}',
            minLength: 1
        },

        /**
         * Cache of raw response for suggestUrl (key being the typed text).
         */
        dataCache: null,

        /**
         * @param {Object} [options] - Options hash or a option/value pair.
         *
         *
         * @extends UWA.Controls.AutocompleteAdaptors.Abstract
         * @constructs UWA.Controls.AutocompleteAdaptors.Data
         * @memberof module:UWA/Controls/AutocompleteAdaptors/Data
         */
        init: function (options) {
            this._parent(options);
            this.dataCache = {};
        },

        getSuggestions: function (text) {
            var finalUrl,
                that = this,
                dataCache = that.dataCache;

            return new Promise(function (resolve, reject) {
                if (text.length >= that.options.minLength) {

                    // Already in internal cache ?
                    if (dataCache[text]) {
                        resolve(dataCache[text]);

                    // Use external data
                    } else if (that.options.url) {

                        finalUrl = that.options.url.replace('{text}', text);

                        Data.request(finalUrl, {
                            method: 'GET',
                            type: 'text',
                            onComplete: function (data) {
                                data = that.dataParse(data);

                                if (data.length > 0) {
                                    dataCache[text] = data;
                                }

                                resolve(data);
                            },
                            onFailure: reject,
                            onTimeout: reject
                        });
                    }
                } else {
                    resolve([]);
                }
            });
        },

        renderSuggestion: function (item) {
            var label = item.fullValue;
            return this.options.format.replace(/\{(\w+)\}/g, function (m, i) {
                return UWAString.escapeHTML(item[i] || label);
            });
        },

        dataParse: function (data) {

            var prop, firstProp, found,
                customDataParser = this.options.dataParser;

            // Use provided parser
            if (UWA.is(customDataParser, 'function')) {

                data = customDataParser(data);

            // try to find first array that could be our items... not so reliable I guess
            } else {

                // Parse Json
                if (Json.isJson(data)) {
                    data = Json.decode(data);
                    found = true;

                // Parse XML
                } else {
                    data = Json.xmlToJson(data);

                    // get first entry in json object, because in XML there is a root container
                    for (prop in data) {
                        if (data.hasOwnProperty(prop)) {
                            data = data[prop];
                            break;
                        }
                    }
                }

                // get first array in json object
                for (prop in data) {
                    if (data.hasOwnProperty(prop)) {

                        if (!firstProp) {
                            firstProp = prop;
                        }

                        if (Array.isArray(data[prop])) {
                            data = data[prop];
                            found = true;
                            break;
                        }
                    }
                }

                // fallback when xml has NO array, but only one item, try to get the first entry
                if (!found && firstProp) {
                    data = [data[firstProp]];
                }
            }

            return Array.isArray(data) ? data : [];
        }

    });

    return UWA.namespace('Controls/AutocompleteAdaptors/Data', DataAdaptor, UWA);
});



/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/EnhancedTextarea
 *
 */
define('UWA/Controls/EnhancedTextarea', [
    'UWA/Core',
    'UWA/Class/Timed',
    'UWA/Controls/Input'
], function (UWA, Timed, Input) {
    'use strict';

    var EnhancedTextarea;

    EnhancedTextarea = Input.Text.extend(Timed, {
        name: 'uwa-enhanced-textarea',

        options: {
            autoGrow: false
        },

        _hiddenInput: true,

        buildInput: function () {
            return UWA.createElement('textarea');
        },

        buildSkeleton: function () {
            this._parent();
            var elements = this.elements;

            elements.input.removeClassName('uwa-input-text');

            elements.caret = UWA.createElement('span', {
                'class': this.getClassNames('-caret')
            });

            elements.input
                .addEvents({
                    scroll: this.syncScroll.bind(this),
                    mouseup: this.syncInput.bind(this),
                    paste: this.syncInput.bind(this)
                });

            elements.container
                .addClassName('uwa-input-text')
                // Put the input at the end
                .grab(elements.input);

            if (this.isAutoGrow()) {
                elements.container.addClassName('autogrow');
            }
        },

        getCaretElement: function () {
            return this.elements.caret;
        },

        isAutoGrow: function () {
            return this.options.autoGrow;
        },

        syncInput: function () {
            this.setAnimate('sync-input', function () {
                var elements = this.elements;

                elements.content.empty(true).addContent(
                    this.buildContentMimic(),
                    // The \u00A0 prevents the last line to be shrinked by the browser
                    '\u00A0'
                );

                if (this.isAutoGrow()) {
                    if (elements.content.offsetHeight !== elements.container.offsetHeight) {
                        elements.container.setStyle('height', elements.content.offsetHeight);
                        this.dispatchEvent('onResize');
                    } else {
                        this.syncScroll();
                        this._hideInputScroll();
                    }
                } else {
                    this.syncScroll();
                }
            });
        },

        buildContentMimic: function () {
            var elements = this.elements,
                value = this.getValue(),

                caretPosition = elements.input.selectionStart,
                startContent = value.slice(0, caretPosition),
                endContent = value.slice(caretPosition);

            return [
                startContent,
                elements.caret,
                endContent
            ];
        },

        _hideInputScroll: function () {
            if (this.isAutoGrow()) {
                var input = this.elements.input;
                // If the input is not scrolling, set overflow: hidden so it won't display
                // scrollbars before the input is sync'ed
                input.setStyles({overflow: input.offsetHeight === input.scrollHeight ? 'hidden' : null});
            }
        },

        syncScroll: function () {
            this.elements.content.scrollTop = this.elements.input.scrollTop;
        },

        onMouseDown: function () {
            // The parent method prevents default on event. Override it so it won't do
            // this.
        }
    });

    return UWA.namespace('Controls/EnhancedTextarea', EnhancedTextarea, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Autocomplete
 *
 */
define('UWA/Controls/Autocomplete', [
    'UWA/Core',
    'UWA/Array',
    'UWA/Class/Timed',
    'UWA/Promise',
    'UWA/Utils/Scroll',
    'UWA/Controls/AutocompleteAdaptors/Data',
    'UWA/Controls/Abstract',
    'UWA/Controls/EnhancedTextarea',
    'UWA/Controls/Input',
    'UWA/Controls/DropDown',
    'UWA/Controls/ThemedScroller',
    'UWA/Event'
], function (UWA, UWAArray, Timed, Promise, ScrollUtils, DataAdaptor, ControlsAbstract, EnhancedTextarea, Input, DropDown, ThemedScroller, Event) { // jshint ignore:line
    'use strict';

    var AutocompleteTextarea, Autocomplete;

    AutocompleteTextarea = EnhancedTextarea.extend({
        setInlineText: function (text) {
            this.elements.inlineText.setText(text);
        },

        getInlineText: function () {
            return this.elements.inlineText.getText();
        },

        buildSkeleton: function () {
            this._parent();
            this.elements.inlineText = UWA.createElement('span', {
                'class': this.getClassNames('-inline-text')
            });
        },

        buildContentMimic: function () {
            return [
                this._parent(),
                '\u200B', // Wrap if needed
                this.elements.inlineText
            ];
        }
    });

    Autocomplete = ControlsAbstract.extend(Timed, /** @lends module:UWA/Controls/Autocomplete.UWA.Controls.Autocomplete# */{

        /**
         * The control name
         *
         * @type {String}
         */
        name: 'uwa-autocomplete',

        /**
         * The default options values.
         */
        options: {
            typeDelay: 500,
            adaptor: null,
            adaptorOptions: {},
            inputOptions: {},
            multiline: false,
            floatingSuggestions: false,
            previewSuggestion: false,

            // Deprecated
            minLength: 1,
            suggestFormat: '{name}',
            suggestUrl: null,
            dataParser: null,
            placeholder: ''
        },

        /**
         * An autocompletion control.
         *
         * ##### Available Events
         *
         * UWA.Controls.Abstract events plus:
         *
         * | Event             | Description                                                                    |
         * | ----------------- | ------------------------------------------------------------------------------ |
         * | `onSubmit`        | Triggered when "return" is pressed in the input and a completion isn't running |
         * | `onSetSuggestion` | Triggered with the suggestion object when the user validate a suggestion       |
         * | `onChange`        | Triggered when the value changed, either on blur or when setting a suggestion  |
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.typeDelay=500] - debounce key strokes by a delay in millisecond
         * @param {AutocompleteAdaptors.Abstract} [options.adaptor=AutocompleteAdaptors.Data] - an adaptor to get and render suggestions
         * @param {Object} [options.adaptorOptions={}] - options passed to the specified adaptor
         * @param {Object} [options.inputOptions={}] - options passed to the input
         * @param {Boolean} [options.multiline=false] - display a textarea instead of a a
         * single line text input
         * @param {Boolean} [options.floatingSuggestions=false] - show suggestions in a
         * floating dropdown instead of below the input (only available for multiline input)
         * @param {Boolean} [options.previewSuggestion=false] - show the currently
         * highlighted suggestion inserted inside the input, selected. This may be
         * helpfull for complicated completions. This will disable the automatic selection
         * of the first suggestion.
         *
         * @example
         * var autocomplete = new UWA.Controls.Autocomplete({
         *     adaptorOptions: {
         *         url: "http://gd.geobytes.com/AutoCompleteCity?q={text}"
         *     }
         * }).inject(widget.body);
         *
         * @extends UWA.Controls.Abstract
         * @mixes UWA.Class.Timed
         * @constructs UWA.Controls.Autocomplete
         * @memberof module:UWA/Controls/Autocomplete
         */
        init: function (options) {
            this._parent(options);
        },

        /**
         * Test if this control has floating suggestions
         *
         * @return {Boolean} whether this control is floating or not
         */
        isFloating: function () {
            return this.options.multiline && this.options.floatingSuggestions;
        },

        /**
         * Ge the adaptor instance to use for this instance. The adaptor instance is built
         * lazily
         *
         * @return {AutocompleteAdaptors.Abstract} an adaptor instance
         */
        getAdaptor: function () {
            if (!this._adaptor) {
                var options = this.options,
                    adaptorType = UWA.typeOf(options.adaptor);

                this._adaptor =
                    adaptorType === 'class' ? new options.adaptor(options.adaptorOptions) :
                    adaptorType === 'object' ? options.adaptor :
                    new DataAdaptor(UWA.merge({
                        format: options.suggestFormat,
                        url: options.suggestUrl,
                        dataParser: options.dataParser,
                        minLength: options.minLength
                    }, options.adaptorOptions));
            }
            return this._adaptor;
        },

        /**
         * Returns control container.
         *
         * @return {HTMLelement} Control container.
         */
        getContent: function () {
            if (!this.elements.container) {
                this.buildSkeleton();
            }
            return this.elements.container;
        },

        /**
         * Get the control used to display the text input.
         *
         * @returns {Input.Text}
         */
        getInputControl: function () {
            if (!this.elements.input) {
                this.buildSkeleton();
            }
            return this.elements.input;
        },

        /**
         * Get the native text input
         *
         * @returns {DOMElement}
         */
        getInputElement: function () {
            return this.getInputControl().getInputElement();
        },

        /**
         * Build the control content. This method is called internally once by instance.
         *
         * @protected
         */
        buildSkeleton: function () {

            var that = this,
                options = that.options,
                elements = that.elements,
                inputOptions = UWA.clone(options.inputOptions),
                floating = this.isFloating();

            if (options.placeholder) {
                if (!inputOptions.attributes) {
                    inputOptions.attributes = {};
                }
                inputOptions.attributes.placeholder = options.placeholder;
            }

            inputOptions._root = false;

            elements.input = options.multiline ?
                new AutocompleteTextarea(inputOptions) :
                new Input.Text(inputOptions);

            if (options.multiline) {
                elements.input.addEvent('onResize', function () {
                    elements.dropdown.updatePosition();
                });
            }

            elements.input.addEvents({
                onKeyDown: this.dispatchEvent.bind(this, 'onKeyDown'),
                onChange: this.dispatchEvent.bind(this, 'onChange')
            });

            elements.input.getInputElement().addEvents({
                blur: function () {
                    this.elements.container.removeClassName('focus');
                    this.setDelayed('blur-hide-suggestions', this.hideSuggestions, 1);
                }.bind(this),
                focus: function () {
                    this.elements.container.addClassName('focus');
                    this.setDelayed('focus-update-suggestion', this.updateSuggestions, 400);
                }.bind(this)
            });

            if (floating) {
                elements.dropdown = new DropDown.Pointy({
                    _root: false,
                    target: elements.input.getCaretElement(),
                    className: this.getClassNames('-floating-dropdown'),
                    autoPosition: ['below-center', 'above-center'],
                    positionOptions: {
                        fit: 'resize-max'
                    }
                });
            } else {
                elements.dropdown = new DropDown({
                    _root: false,
                    className: this.getClassNames('-dropdown'),
                    position: function () {
                        return {x: 0, y: elements.input.getContent().getSize().height};
                    },
                    positionOptions: {
                        fit: 'resize-max',
                        relative: elements.container,
                        boundaryMargin: 4
                    }
                });
            }

            elements.suggestions = UWA.createElement('div', {
                'class': this.getClassNames('-suggestions'),
                events: {
                    mousedown: this._selectionMouseHandler.bind(this),
                    mouseover: this._selectionMouseHandler.bind(this)
                }
            });

            // Granted, the scroller/dropdown integration is far from easy. We shall
            // improve this in the future.

            elements.scroller = new ThemedScroller({ _root: false });
            elements.scroller.getInnerElement().setContent(elements.suggestions);
            elements.dropdown.getInnerElement().setContent(elements.scroller);

            elements.dropdown.addEvents({

                onHide: function () {
                    that.dispatchEvent('onHideSuggestions');
                },

                onPreUpdatePosition: function () {
                    // Resize the scroller to the same size of the suggestions, because by
                    // default the scroller size is null, so the dropdown can't compute
                    // its position.
                    elements.scroller.getContent().setStyle('height', Math.min(elements.suggestions.scrollHeight, 200));

                    // Reset max size setted by the setPosition resize-max fit trategy
                    var content = this.getContent();
                    content.setStyles({
                        'max-height': null,
                        'max-width': null
                    });
                },

                onShow: function () {

                    // Set the height of the scroller again, so it fits the maxHeight
                    // given by the setPositios resize-max fit strategy.
                    var maxHeight = Math.min(
                        elements.dropdown.getContent().getComputedSize('maxHeight'),
                        elements.suggestions.getSize().height,
                        200
                    );
                    elements.scroller.getContent().setStyle('height', maxHeight);

                    that.dispatchEvent('onShowSuggestions');
                }

            });

            elements.container = UWA.createElement('div', {
                'class': this.getClassNames() +
                    (floating ? ' floating' : ' not-floating') +
                    (options.multiline ? ' multiline' : ' singleline'),
                html: [
                    elements.input,
                    elements.dropdown
                ]
            });

        },

        /**
         * Update the suggestion dropdown. This will hide or display the suggestion
         * dropdown, populated with an up to date list of suggestions depending on the
         * current state of the input.
         *
         * @param {Object} [options]
         * @param {Boolean} [options.resetInput=true] reset the input to its previous value
         * @param {Boolean} [options.typeDelay] you may override the typeDelay option here
         * @return {Promise}
         */
        updateSuggestions: function (options) {
            var value = this.getValue();
            var result = Promise.deferred();
            var input = this.getInputElement();
            var start = input.selectionStart;
            var key = value + '-' + start;

            var resetInput = options && options.resetInput;
            var typeDelay = options && UWA.is(options.typeDelay) ? options.typeDelay : this.options.typeDelay;

            // Hide suggestions if the input is empty or not focused
            if (input.getDocument().activeElement !== input) {
                this.hideSuggestions({ resetInput: resetInput });
                this.clearDelayed('getSuggestions');
                result.resolve();
            } else if (!this._updateSuggestionRun || key !== this._updateSuggestionRun.key) {
                this._updateSuggestionRun = { promise: result.promise, key: key };

                this.setDelayed('hideSuggestionsIfGettingThemIsToSlow', function () {
                    this.hideSuggestions({ resetInput: resetInput, cancelUpdateSuggestions: false });
                }, 100);

                this.setDelayed('getSuggestions', function () {
                    this.getSuggestions(value, start)
                    .done(function (s) {
                        if (this._updateSuggestionRun && key === this._updateSuggestionRun.key) {
                            if (s.length) {
                                this.displaySuggestions(s);
                            } else {
                                this.hideSuggestions({ resetInput: false, cancelUpdateSuggestions: false });
                            }
                            this.clearDelayed('hideSuggestionsIfGettingThemIsToSlow');
                            result.resolve();
                        } else {
                            result.reject(new Error('Aborted by another call to updateSuggestion'));
                        }
                    }.bind(this));
                }, typeDelay);
            } else if (this._updateSuggestionRun) {
                this._updateSuggestionRun.promise.then(result.resolve, result.reject);
            }

            return result.promise;
        },

        /**
         * Get a suggestion list from the adaptor.
         * See {@link module:UWA/Controls/AutocompleteAdaptors/Abstract.UWA.Controls.AutocompleteAdaptors.Abstract#getSuggestions|Adaptor#getSuggestions}
         * for the format of suggestion objects.
         *
         * @param {String} text current text to get suggestions from
         * @param {Number} caret the caret position inside the text
         * @return {Promise} resolved with an Array of suggestions objects.
         */
        getSuggestions: function (text, caret) {
            return Promise.cast(this.getAdaptor().getSuggestions(text, caret)).then(function (suggestions) {
                return (suggestions || [])
                .map(function (s) {
                    return typeof s === 'string' ? { fullValue: s } : s;
                });
            });
        },

        /**
         * Check if the suggestion dropdown is shown
         *
         * @returns {Boolean}
         */
        areSuggestionsDisplayed: function () {
            return Boolean(this._displayedSuggestions);
        },

        /**
         * Opens the dropdown and displays a list of suggestions.
         * See {@link module:UWA/Controls/AutocompleteAdaptors/Abstract.UWA.Controls.AutocompleteAdaptors.Abstract#getSuggestions|Adaptor#getSuggestions}
         * for the format of suggestion objects.
         *
         * @param {Array} suggestions list of suggestions objects.
         */
        displaySuggestions: function (suggestions) {
            this._displayedSuggestions = suggestions;
            this._currentSuggestionIndex = null;
            var dropdown = this.elements.dropdown,
                container = this.elements.suggestions;

            container.setContent(this.getAdaptor().renderSuggestions(suggestions));

            dropdown.show();
            if (this._useFX) {
                container.setStyle('height', container.scrollHeight);
            }

            var firstSuggestion = suggestions[0];
            if (this._isInlineSuggestionAvailable(firstSuggestion) || !this.options.previewSuggestion) {
                this._highlightSuggestion(firstSuggestion);
            }
        },

        /**
         * Closes the dropdown.
         *
         * @param {Object} [options]
         * @param {Boolean} [options.resetInput=true] reset the input to its previous value
         * @param {Boolean} [options.cancelUpdateSuggestions=true] cancel the suggestion update
         */
        hideSuggestions: function (options) {
            this._resetSuggestion(!options || options.resetInput);

            if (!options || options.cancelUpdateSuggestions !== false) {
                this._updateSuggestionRun = null;
            }

            this._displayedSuggestions = null;

            if (this._useFX) {
                this.elements.suggestions.setStyle('height', 8);
            } else {
                this.elements.dropdown.hide();
            }
        },

        /**
         * Get current value from the input.
         *
         * @return {String}
         */
        getValue: function () {
            return this.getInputControl().getValue();
        },

        /**
         * Set the value. This will hide the suggestions dropdown.
         */
        setValue: function (value) {
            this.getInputControl().setValue(value);
            this.updateSuggestions({
                resetInput: false
            });
        },

        /**
         * Event handler for the mouse events on the dropdown
         *
         * @param {Event} event the mouse event
         * @protected
         */
        _selectionMouseHandler: function (event) {
            var suggestion,
                target = Event.findElement(event, '.suggestion');

            if (target) {
                suggestion = this._getSuggestion(target);
                if (suggestion) {
                    if (event.type === 'mousedown') {
                        this._setSuggestion(suggestion);
                    } else {
                        this._highlightSuggestion(suggestion);
                    }
                    Event.stop(event); // Prevent bluring the input
                }
            }
        },

        /**
         * Split the current value into three parts (before, between and after). The two
         * separator indexes are optional and defaults to the current caret positions.
         *
         * @param {Number} [start=caret start] first index to split the value
         * @param {Number} [end=caret end] second index to split the value
         * @return {Object} an object with the fields `before`, `between` and `after`
         *
         * @protected
         */
        _getParts: function (start, end) {
            var input = this.getInputElement();

            if (start === undefined) {
                start = input.selectionStart;
            }

            if (end === undefined) {
                end = input.selectionEnd;
            }

            return {
                before: input.value.slice(0, start),
                between: input.value.slice(start, end),
                after: input.value.slice(end)
            };
        },

        /**
         * Set the input value using an object specifying the content to put after, before
         * and inside (between) the caret.
         *
         * @param {Object} parts an object with the tree fields `before`, `between` and
         * `after`
         * @param {String} [caretPosition="end"] the position of the caret after the value
         * is set. Can be `"start"` (start of the content), `"end"` (end of the content)
         * or `"around"` (select the content)
         *
         * @protected
         */
        _setParts: function (parts, caretPosition) {
            var input = this.getInputElement();
            input.value = parts.before + parts.between + parts.after;
            var start = parts.before.length;
            var end = start + parts.between.length;

            switch (caretPosition) {
            case 'start':
                end = start;
                break;

            case 'end':
                start = end;
                break;

            // case 'around':
            }

            input.selectionStart = start;
            input.selectionEnd = end;
        },

        /**
         * Get the suggestion index (inside the currently displayed suggestions) from
         * either a suggestion object or a DOM element.
         * If the argument is omitted, the current selected sugestion index is returned.
         * If the argument is already a number, it will be returned.
         *
         * @param {Number/DOMElement/Object} [id=current id]
         * @return {Number/undefined} the index or undefined if it is not found
         *
         * @protected
         */
        _getSuggestionIndex: function (id) {
            if (!UWA.is(id)) {
                id = this._currentSuggestionIndex;
                if (!UWA.is(id)) {
                    return;
                }
            }
            if (id.nodeType) {
                id = this.elements.suggestions.getElements('.suggestion').indexOf(id);
            } else if (typeof id === 'object') {
                id = this._displayedSuggestions.indexOf(id);
            }
            return UWA.is(id, 'number') && id >= 0 ? id : undefined;
        },

        /**
         * Get the suggestion object from either an index or a DOM element.
         * If the argument is omitted, the current selected suggestion object is returned.
         * If the argument is already a suggestion object, it will be returned.
         *
         * @param {Number/DOMElement/Object} [id=current id]
         * @return {Object/undefined} the suggestion object or undefined if it is not
         * found
         *
         * @protected
         */
        _getSuggestion: function (id) {
            id = this._getSuggestionIndex(id);
            if (id === undefined) {
                return;
            }
            return this._displayedSuggestions ? this._displayedSuggestions[id] : undefined;
        },

        /**
         * Get the suggestion element from either a suggestion object or an index.
         * If the argument is omitted, the current selected suggestion DOM element is returned.
         * If the argument is a DOM element and is associated with a suggestion, it will
         * be returnerd.
         *
         * @param {Number/DOMElement/Object} [id=current id]
         * @return {DOMElement/undefined} the suggestion Element or undefined if it is not
         * found
         * @protected
         */
        _getSuggestionElement: function (id) {
            id = this._getSuggestionIndex(id);
            if (id === undefined) {
                return;
            }

            return this.elements.suggestions.getElements('.suggestion')[id];
        },

        /**
         * Remove currently selected suggestion.
         *
         * @param {Boolean} [resetInput=true] reset the input to its previous value
         * @protected
         */
        _resetSuggestion: function (resetInput) {
            var suggestion = this._getSuggestion();
            if (!suggestion) {
                return;
            }

            UWAArray.invoke(this.elements.suggestions.getElements('.current'), 'removeClassName', 'current');

            if (this.options.multiline) {
                this.elements.input.setInlineText('');
            }

            if (resetInput !== false && this.options.previewSuggestion) {
                var previousValue = this._previousValue || '';

                var splitted = this._getParts();
                splitted.between = previousValue;
                this._setParts(splitted, 'end');
            }

            this._previousValue = null;
            this._currentSuggestionIndex = null;
        },

        /**
         * Gets what should be inserted before, between and after the current input
         * selection for a given suggestion.
         * A fourth value is added, `previous`, representing the value that will be
         * replaced by the selection.
         *
         * @param {Object} suggestion
         * @return {Object} an object with fields `before`, `between`, `after` and
         * `previous`
         *
         * @protected
         */
        _getSuggestionParts: function (suggestion) {
            var input = this.getInputElement(),
                result;

            if (suggestion.inlineValue) {
                result = this._getParts();
                result.previous = result.between;
                result.between = suggestion.inlineValue;
            } else if (suggestion.fullValue) {
                result = this._getParts(
                    suggestion.start !== undefined ? suggestion.start : 0,
                    suggestion.end !== undefined ? suggestion.end : input.value.length + suggestion.fullValue.length
                );
                result.previous = result.between;
                result.between = suggestion.fullValue;
            }

            return result;
        },

        /**
         * Select a suggestion, displaying a preview in the input and highlighting it in
         * the dropdown.
         *
         * @param {Object/DOMElement/Number} suggestion any argument valid for
         * {@link module:UWA/Controls/Autocomplete.UWA.Controls.Autocomplete#_getSuggestion|getSuggestion}
         * @protected
         */
        _highlightSuggestion: function (suggestion) {
            suggestion = this._getSuggestion(suggestion);
            if (suggestion === undefined) {
                return;
            }

            this._resetSuggestion();

            this._currentSuggestionIndex = this._getSuggestionIndex(suggestion);

            var element = this._getSuggestionElement(suggestion),
                category = element.getParent('.category');

            element.addClassName('current');
            ScrollUtils.scrollToElement(element);

            if (category) {
                category.addClassName('current');
            }

            var parts = this._getSuggestionParts(suggestion);
            if (this._isInlineSuggestionAvailable(suggestion)) {
                this.elements.input.setInlineText(parts.between);
            } else if (this.options.previewSuggestion) {
                this._setParts(parts, 'around');
            }
            this._previousValue = parts.previous;
        },

        /**
         * Check if inline suggestion is available for a given suggestion
         *
         * @param {Object} suggestion
         * @protected
         */
        _isInlineSuggestionAvailable: function (suggestion) {
            var input = this.getInputElement();
            return suggestion.inlineValue && this.options.multiline && input.selectionStart === input.value.length;
        },

        /**
         * Validate a suggestion. Change the input value by adding the suggestion content
         * and close suggestions dropdown.

         * @param {Object/DOMElement/Number} suggestion any argument valid for
         * {@link module:UWA/Controls/Autocomplete.UWA.Controls.Autocomplete#_getSuggestion|getSuggestion}
         * @param {Object} [options]
         * @param {Boolean} [options.selectionAtStart=false] set the caret at the
         * beginning of the content
         * @protected
         */
        _setSuggestion: function (suggestion, options) {
            suggestion = this._getSuggestion(suggestion);
            if (!suggestion) {
                return;
            }

            this._resetSuggestion();

            this._setParts(this._getSuggestionParts(suggestion),
                           options && options.selectionAtStart ? 'start' : 'end');

            this.hideSuggestions();
            this.dispatchEvent('onSetSuggestion', [suggestion]);
            this.getInputControl()._dispatchOnChange();
        },

        /* Group: Events methods */

        /**
         * Invoked when the list of suggestions is hidden.
         */
        onHideSuggestions: function () {
            var elements = this.elements;
            elements.container.removeClassName('suggestions-displayed');
        },

        /**
         * Invoked when the list of suggestions is displayed.
         */
        onShowSuggestions: function () {
            var elements = this.elements;
            elements.container.addClassName('suggestions-displayed');
        },

        onClick: function () {
            this.elements.input.focus();
        },

        /**
         * Invoked when a key is typed in the autocomplete field.
         */
        onKeyDown: function (event) {

            var that = this,
                k = Event.whichKey(event),
                hasSuggestion = this._currentSuggestionIndex !== null,
                stopEvent = true;

            function key() {
                return Array.prototype.indexOf.call(arguments, k) >= 0;
            }

            function run() {
                that.setDelayed('updateSuggestions', that.updateSuggestions.bind(that, { resetInput: false }), 5);
            }

            function submit() {
                that.dispatchEvent('onSubmit', [that.getValue()]);
            }

            function next(direction) {
                var index = that._currentSuggestionIndex;
                var length = that._displayedSuggestions.length;
                if (index === null) {
                    index = direction < 0 ? length : -1;
                }
                that._highlightSuggestion(that._getSuggestion((index + direction + length) % length));
            }

            if (!this.areSuggestionsDisplayed()) {
                if (key('return') && this.hasEvent('onSubmit')) {
                    submit();
                } else {
                    run();
                    stopEvent = false;
                }
            } else if (key('up', 'shift+tab')) {
                next(-1);
            } else if (key('down', 'tab')) {
                next(1);
            } else if (key('return') && hasSuggestion) {
                this._setSuggestion(null, {selectionAtStart: key('left')});
            } else if (key('return') && this.hasEvent('onSubmit')) {
                this.hideSuggestions({ resetInput: false });
                submit();
            } else if (key('esc')) {
                this.hideSuggestions();
            } else if (!key('shift')) {
                run();
                stopEvent = false;
            }

            if (stopEvent) {
                Event.stop(event);
            }
        }
    });

    return UWA.namespace('Controls/Autocomplete', Autocomplete, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Calendar
 *
 */
define('UWA/Controls/Calendar', [
    'UWA/Core',
    'UWA/Date',
    'UWA/Event',
    'UWA/Controls/Abstract',
    'UWA/String'
], function (UWA, UWADate, Event, Abstract, UWAString) {
    'use strict';

    var _ = UWA.i18n,
        Calendar;

    function dateEquals(a, b) {
        var na = !a, nb = !b;
        return na === nb && (na || (
            a.getFullYear() === b.getFullYear() &&
                a.getMonth() === b.getMonth() &&
                    a.getDate() === b.getDate()
        ));
    }

    function incrementDate(date, unit, times) {
        var day = date.getDate();

        if (times === undefined) {
            times = 1;
        }

        if (unit === 'year') {
            times *= 12;
            unit = 'month';
        } else if (unit === 'week') {
            times *= 7;
            unit = 'day';
        }

        if (unit === 'month') {
            date.setDate(1); // first day of current month
            date.setMonth(date.getMonth() + times + 1); // first day of month after the target month
            date.setDate(0); // last day of target month
            if (day < date.getDate()) {
                date.setDate(day); // reset the correct date
            }
        } else if (unit === 'day') {
            date.setDate(day + times);
        } else {
            throw new Error('Unknown unit "' + unit + '"');
        }
    }

    Calendar = Abstract.extend(/** @lends module:UWA/Controls/Calendar.UWA.Controls.Calendar# */{ // bypass

        /**
         * @property {String} name - The Calendar name. Default: 'uwa-calendar'
         * @protected
         */
        name: 'uwa-calendar',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            view: 'month',
            weekFirstDay: 'monday',
            // date: undefined, // no date selected
            limit: {
                // min: undefined,
                // max: undefined
            }
        },

        /**
         * @property {Object} weekOffset - links a day name with its offset in the week,
         * starting at sunday.
         * @protected
        */
        weekOffset: {
            monday: 1,
            sunday: 0,
            saturday: 6
        },

        /**
         * Display a calendar with day/week/month views.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onDateChange`   | Fired when the selected date change    |
         * | `onDateSelect`   | Fired when the user click on a date    |
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className=''] - Control theme ('dark' for a dark theme)
         * @param {String} [options.date=undefined] - The initial date
         * @param {String} [options.view='month'] - Default view
         * @param {String} [options.weekFirstDay='monday'] - First day of the week
         *
         * @constructs UWA.Controls.Calendar
         * @extends module:UWA/Controls/Abstract.UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Calendar
         */
        init: function (options) {

            this._parent(options);

            this.buildSkeleton();

            this.bound = {
                refreshLimit: this.refreshLimit.bind(this)
            };

            this.setLimit(this.options.limit);
            this.setDate(this.options.date);
            this.displayView(this.options.view);
        },

        /**
         * Get the offset of the first day of the week given the current
         * option.
         * @return {Integer} the offset (0 = sunday, 6 = saturday)
         */
        getWeekOffset: function () {
            return this.weekOffset[this.options.weekFirstDay] || 0;
        },

        /**
         * Get the position of the first day of the current month in its week.
         *
         * @return {Number}
         */
        getMonthFirstDay: function () {
            var date = this.displayDate,
                dateTemp = new Date(date.getFullYear(), date.getMonth(), 1);
            return (dateTemp.getDay() - this.getWeekOffset() + 7) % 7;
        },

        /**
         * Get the day of the month of the first day of the week.
         *
         * @return {Number}
         */
        getWeekFirstDay: function () {
            var date = this.displayDate;
            return date.getDate() - (7 + date.getDay() - this.getWeekOffset()) % 7;
        },

        /**
         * Iterate over the current week
         *
         * @param {Function} iter - the callback function called with the index as
         *  first argument and the date as second argument.
         * @param {Object} context - the context used to call the callback
         * @return {this}
         */
        iterateWeek: function (iter, context) {
            var i,
                date = this.displayDate,
                startDate = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    this.getWeekFirstDay()
                ),
                day = startDate.getDate();

            for (i = 0; i < 7; i += 1) {
                var iterDate = new Date(startDate);
                iterDate.setDate(day + i);
                iter.call(context, i, iterDate);
            }
            return this;
        },

        /**
         * Display a given view
         *
         * @param {String} view - the view name
         * @return {this}
         */
        displayView: function (view) {

            if (['month', 'week'/*, 'day'*/].indexOf(view) < 0) {
                throw new Error('Unknown view ' + view + 'options');
            }

            if (view !== this.currentView) {

                this.container.setContent(this['build' + UWAString.ucfirst(view) + 'View']());

                this.currentView = view;

                this.dispatchEvent('onRefresh');
            }
            return this;
        },

        /**
         * Set the current date of the calendar. Two dates can be set:
         *  * the "select date" is the date shown as selected and the one
         *    returned by <getDate>.
         *  * the "display date" is used to draw the calendar around this
         *    date.
         * Typically, when the user will be navigating around with arrows to
         * change the displayed month, the display date will be updated but
         * not the select date.
         *
         * @param {Date} selectDate - the selected date (default to "today at midnight")
         * @param {Date} displayDate - the display date (default to selectDate value)
         * @return {this}
         */
        setDate: function (selectDate, displayDate) {

            if (!displayDate) {
                if (!selectDate) {
                    selectDate = new Date();
                    selectDate.setHours(0);
                    selectDate.setMinutes(0);
                    selectDate.setSeconds(0);
                    selectDate.setMilliseconds(0);
                }
                displayDate = selectDate;
            }

            var newSelectDate = !dateEquals(selectDate, this.selectDate);

            if (newSelectDate || !dateEquals(displayDate, this.displayDate)) {

                this.selectDate = selectDate;
                this.displayDate = displayDate;

                this.dispatchEvent('onRefresh');

                if (newSelectDate) {
                    this.dispatchEvent('onDateChange', [selectDate]);
                }
            }

            return this;
        },

        /**
         * Returns the selected date.
         * @return {Date|null} The selected date
         */
        getDate: function () {
            return this.selectDate || null;
        },

        /**
         * Set the calendar limit.
         *
         * @example
         * //Sync two calendars to select a date range
         * var start = new UWA.Controls.Calendar(),
         *    end = new UWA.Controls.Calendar();
         *
         * start.setLimit({ max: end });
         * end.setLimit({ min: start });
         *
         * @param {Object} limit - an object with the optional properties min and max
         *  Each of those properties can be either fixed dates or objects
         *  with a getTime or getDate method. Default: no limit.
         * @return {this}
         */
        setLimit: function (limit) {

            if (!limit) {
                limit = {};
            }

            var oldLimit = this.options.limit;
            this.options.limit = limit;

            [oldLimit.max, oldLimit.min, limit.max, limit.min]
                .forEach(function (l, i) {
                    if (l instanceof Calendar) {
                        l[i < 2 ? 'removeEvent' : 'addEvent'](
                            'onDateChange',
                            this.bound.refreshLimit
                        );
                    }
                }, this);

            this.refreshLimit();
            return this;
        },

        /**
         * Get the current limit.
         *
         * @return {Object} An object with the properties 'min' and 'max' as numbers
         *  (timestamp in millisecond). If there is no limit, the 'min' will
         *  be -Infinity, and the 'max' will be '+Infinity'.
         */
        getLimit: function () {

            var i, name, boundary,
                limit = this.options.limit || {},
                result = {};

            for (i = 0; i < 2; i += 1) {
                name = i ? 'max' : 'min';
                boundary = limit[name];
                result[name] = (boundary && new Date((boundary.getTime || boundary.getDate || boundary).call(boundary)).getTime()) ||
                    (i ? Infinity : -Infinity);
            }

            result.min -= 86400000;

            return result;
        },

        /**
         * Refresh the limit display. This will be called each time the
         * setLimit is called, and can call be called manually if the limit
         * changes (ea: the getTime or getDate of the limit value have
         * change).
         *
         * @return {this}
         */
        refreshLimit: function () {

            var computedLimit = this.getLimit();

            if (computedLimit.end < computedLimit.start) {
                throw new Error('Bad limit specified');
            }

            if (this.selectDate) {
                this.preventRefresh();
                this.setDate(new Date(Math.max(
                    Math.min(computedLimit.max, this.selectDate),
                    computedLimit.min
                )));
                this.allowRefresh();
            }

            return this.dispatchEvent('onRefresh');
        },

        /**
         * Calling this method will prevent the display to be refreshed. Each
         * call to <preventRefresh> have to be followed by an <allowRefresh>
         * call.
         *
         * @return {this}
         */
        preventRefresh: function () {
            this.doNotRefresh = this.doNotRefresh + 1 || 1;
            return this;
        },

        /**
         * Calling this method will allow the display to be refreshed. Each
         * call to <preventRefresh> have to be followed by an <allowRefresh>
         * call.
         *
         * @return {this}
         */
        allowRefresh: function () {
            this.doNotRefresh = this.doNotRefresh - 1 || 0;
            return this;
        },


        /*
          Group: DOM building methods
        */

        /**
         * Build the initial dom container.
         */
        buildSkeleton: function () {

            this.container = UWA.createElement('div', {
                'class': this.getClassNames(),
                events: {
                    click: this.onClick.bind(this),
                    // prevent content selection on double click
                    mousedown: Event.preventDefault
                }
            });
        },

        /**
         * Build the dom of the month view.
         *
         * @return {Element} The resulting dom
         */
        buildMonthView: function () {
            var trBody, row, td,
                result = UWA.createElement('div', {
                    'class': 'monthView'
                }),
                top = UWA.createElement('div', {
                    'class': 'top'
                }).inject(result),
                table = UWA.createElement('table').inject(result),
                body = UWA.createElement('tbody').inject(table),
                trHead = UWA.createElement('tr').inject(body);

            this.iterateWeek(function (i, date) {
                UWA.createElement('th', {
                    text: UWADate.strftime(date, '%a')[0]
                }).inject(trHead);
            });

            for (row = 0; row < 42; row += 1) {
                if (row % 7 === 0) {
                    trBody = UWA.createElement('tr').inject(body);
                }
                td = UWA.createElement('td').inject(trBody);

                UWA.createElement('div', {
                    'class': 'day'
                }).inject(td);
            }

            // TODO use  top.addContent([...])
            UWA.createElement('span', {'class': 'previous uwa-icon', 'data-icon': 'l'})
                .inject(top);
            UWA.createElement('span', {'class': 'title'}).inject(top);
            UWA.createElement('span', {'class': 'next uwa-icon', 'data-icon': 'm'})
                .inject(top);

            this.elements.monthView = result;

            return result;
        },

        /**
         * Build the dom of the week view.
         *
         * @return {Element} The resulting dom
         */
        buildWeekView: function () {
            var trBody, row,
                result = UWA.createElement('div', {
                    'class': 'weekView'
                }),
                top = UWA.createElement('div', {
                    'class': 'top'
                }).inject(result),
                table = UWA.createElement('table').inject(result),
                body = UWA.createElement('tbody').inject(table),
                trHead = UWA.createElement('tr').inject(body);

            this.iterateWeek(function (i, date) {
                UWA.createElement('th', {
                    text: UWADate.strftime(date, '%a')[0]
                }).inject(trHead);
            });

            for (row = 0; row < 7; row += 1) {
                if (row % 7 === 0) {
                    trBody = UWA.createElement('tr').inject(body);
                }

                UWA.createElement('td', {
                    html: {
                        tag: 'div',
                        'class': 'day'
                    }
                }).inject(trBody);
            }

            // TODO use  top.addContent([...])
            UWA.createElement('span', {'class': 'previous', text: '←'})
                .inject(top);
            UWA.createElement('span', {'class': 'title'}).inject(top);
            UWA.createElement('span', {'class': 'next', text: '→'})
                .inject(top);

            this.elements.weekView = result;

            return result;
        },

        /**
         * Refresh the display of the month view according to the display date.
         */
        refreshMonthView: function () {
            var i, l,
                date = this.displayDate,
                iterDate = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    -this.getMonthFirstDay()
                ),
                monthView = this.elements.monthView,
                days = monthView.getElements('.day');

            for (i = 0, l = days.length; i < l; i += 1) {
                iterDate.setDate(iterDate.getDate() + 1);
                days[i] = this.buildDay(days[i], iterDate);
            }

            // Hide the last line if it does not contain any current month day
            monthView.getElement('tbody').getElements('tr')[6][iterDate.getDate() > 6 ? 'hide' : 'show']();

            monthView.getElement('.title').setText(UWADate.strftime(date, _("%B %Y")));
        },

        /**
         * Refresh the display of the week view according to the display date.
         */
        refreshWeekView: function () {
            var i, l, endDay,
                date = this.displayDate,
                iterDate = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    this.getWeekFirstDay()
                ),
                firstDay = UWADate.strftime(iterDate, _("%e %B")),
                weekView = this.elements.weekView,
                days = weekView.getElements('.day');

            for (i = 0, l = days.length; i < l; i += 1) {
                days[i] = this.buildDay(days[i], iterDate);
                iterDate.setDate(iterDate.getDate() + 1);
            }
            iterDate.setDate(iterDate.getDate() - 1);
            endDay = UWADate.strftime(iterDate, _("%e %B %Y"));

            weekView.getElement('.title').setText(firstDay + ' - ' + endDay);
        },

        /**
         * Update a dom element representing a day.
         *
         * @param {Element} day - The element to update
         * @param {Date} iterDate - The current iterated date
         * @return {Element} The day element
         */
        buildDay: function (day, iterDate) {
            var today = new Date(),
                date = this.displayDate,
                limit = this.getLimit(),
                td = day.getClosest('td');

            td.toggleClassName('currentDay', dateEquals(iterDate, date))
                    .toggleClassName('selectDate', dateEquals(iterDate, this.selectDate))
                    .toggleClassName('today', dateEquals(iterDate, today))
                    .toggleClassName('currentMonth', iterDate.getMonth() === date.getMonth())
                    .toggleClassName('disabled', iterDate < limit.min || iterDate > limit.max);

            day.setText(iterDate.getDate());

            return day;
        },

        /* Group: Events methods */

        onRefresh: function () {
            var view = this.currentView;
            if (view && !this.doNotRefresh) {
                this['refresh' + UWAString.ucfirst(view) + 'View']();
            }
        },

        onClick: function (event) {

            var days,
                container = this.container,
                eventElement = Event.getElement(event),
                jump = eventElement.hasClassName('next') ? 1 : eventElement.hasClassName('previous') ? -1 : 0,
                newDate = new Date(this.displayDate);

            if (!eventElement.getClosest('.disabled')) {

                if (eventElement.hasClassName('day')) {

                    days = container.getElements('.day');
                    incrementDate(newDate, 'day',
                        days.indexOf(eventElement) -
                            days.indexOf(container.getElement('.currentDay .day'))
                        );

                    this.setDate(newDate);
                    this.dispatchEvent('onDateSelect', [newDate]);

                } else if (jump) {
                    incrementDate(newDate, this.currentView, jump);
                    this.setDate(this.selectDate, newDate);

                }
            }
        }
    });

    return UWA.namespace('Controls/Calendar', Calendar, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document
*/

/*jshint
    unused: false, maxparams: false
*/

/**
 * @module   UWA/Controls/Scroller
 *
 */
define('UWA/Controls/Scroller', [
    'UWA/Core',
    'UWA/Class/Timed',
    'UWA/Controls/Abstract',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Fx'
], function (UWA, Timed, Abstract, Client, Event, Element, Fx) {
    'use strict';

    var Scroller,
        tagNameRexpExp = /input|textarea|select/i,
        overflowRexpExp = /auto|scroll/i,

        // Alias
        Features = Client.Features,
        Platform = Client.Platform,
        isIOS5 = (Client.Engine.version >= 5.1 && !!Platform.ios);

    // Faster Math.round alternative
    function mround(r) {
        return r >> 0;
    }

    // Not click on input, textarea, select element
    function isValidElement(event) {

        var tagName, overflow,
            isValid = true,
            element = Event.getElement(event);

        if (element) {
            tagName = element.getTagName();
            overflow = element.getStyle('overflow');
            isValid = (tagName && !tagName.match(tagNameRexpExp)) &&
                        !overflow.match(overflowRexpExp);
        }

        return isValid;
    }

    // Is touchStart or left click
    function isValidClick(event) {
        return (event.type === 'touchstart' || Event.whichButton(event) === 0);
    }

    // Can scroll or has Bounce
    function isScrollable(scroller) {
        return (scroller.scroll.x || scroller.scroll.y || scroller.options.bounce);
    }

    // There is no other active scroller
    function isEnable(scroller) {
        return (!Scroller.activeScroller || Scroller.activeScroller === scroller);
    }

    // Get event type (e.g mouse/touch/pointer)
    function getEventInputType(event) {

        var eventType = event.type;

        return eventType.indexOf('mouse') !== -1 ? 'mouse' :
                  eventType.indexOf('touch') !== -1 ? 'touch' :
                        eventType.indexOf('ointer') !== -1 ? 'pointer' : 'none';
    }

    function handleDragEvents(state, element, eventHandler) {

        if (state === 'init') {

            Element.addEvents.call(element, {
                // Start
                'touchstart': eventHandler,
                'mousedown': eventHandler,
                'MSPointerDown': eventHandler
            });

        } else if (state === 'start') {

            Element.addEvents.call(element, {
                // Move
                'touchmove': eventHandler,
                'mousemove': eventHandler,
                'MSPointerMove': eventHandler,
                // Stop
                'touchend': eventHandler,
                'touchcancel': eventHandler,
                'mouseup': eventHandler,
                'MSPointerUp': eventHandler
            });

        } else if (state === 'stop') {

            Element.removeEvents.call(element, {
                // Move
                'touchmove': eventHandler,
                'mousemove': eventHandler,
                'MSPointerMove': eventHandler,
                // Stop
                'touchcancel': eventHandler,
                'touchend': eventHandler,
                'mouseup': eventHandler,
                'MSPointerUp': eventHandler
            });

        } else if (state === 'destroy') {

            Element.removeEvents.call(element, {
                // Start
                'touchstart': eventHandler,
                'mousedown': eventHandler,
                'MSPointerDown': eventHandler,
                // Move
                'touchmove': eventHandler,
                'mousemove': eventHandler,
                'MSPointerMove': eventHandler,
                // Stop
                'touchcancel': eventHandler,
                'touchend': eventHandler,
                'mouseup': eventHandler,
                'MSPointerUp': eventHandler
            });
        }
    }

    /*
     * Todo:
     * - http://stackoverflow.com/questions/4178725/ios-webkit-touchmove-touchstart-not-working-on-input-textarea/5798681#5798681
     * - http://stackoverflow.com/questions/15605085/webkit-overflow-scrolling-touch-causing-vertical-scrolling-problems-on-mobil
     */
    Scroller = Abstract.extend(Timed, /** @lends module:UWA/Controls/Scroller.UWA.Controls.Scroller# */{ // bypass



        /**
         * @property {Object} name - Controls identifier
         * @protected
         */
        name: 'uwa-scroller',

        /**
         * @property {Object} position - Last scheduled scroller position.
         * @protected
         */
        position: null,

        /**
         * @property {Object} direction - Last scroller direction.
         * @protected
         */
        direction: null,

        /**
         * @property {Object} scroll - hash or a key/value pair with scroller width/height and x/y axis state.
         * @protected
         */
        scroll: null,

        /**
         * @property {Object} maxScroll - axis/value pair with max scroll value.
         * @protected
         */
        maxScroll: null,

        /**
         * @property {Object} scroller - axis/value pair with scroller offset value.
         * @protected
         */
        scroller: null,

        /**
         * @property {Object} maxPage - axis/value pair with max page value.
         * @protected
         */
        maxPage: null,

        /**
         * @property {Object} scrollBars - axis/value pair with scrollBars instance.
         * @protected
         */
        scrollBars: null,

        /**
         * @property {Boolean} isScrolling - Define if scroller currently scrolling.
         * @protected
         */
        isScrolling: false,

        /**
         * @property {Boolean} isTracking - Whether a touch event sequence is in progress.
         * @protected
         */
        isTracking: false,

        /**
         * @property {Boolean} isDragging - Whether the user has moved by such a distance that we have enabled
         * @protected
         */
        isDragging: false,

        /**
         * @property {Boolean} isPulling - Define if scroller has moved out of boundaries.
         * @protected
         */
        isPulling: false,

        /**
         * @property {Boolean} enabled - Current scroller enable state.
         * @protected
         */
        enabled: true,

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: '',
            /*
            body: document.body,
            */
            width: '',
            height: '',
            bounce: false,
            momentum: false,
            snap: false,
            threshold: 6,
            lockDirection: true,
            scrollableX: true,
            scrollableY: true,
            scrollbarH: true,
            scrollbarV: true,
            scrollTime: 250,
            scrollSize: 40,
            scrollDrag: Features.dragAndDrop && !Platform.blackberry,
            useTransform: Features.transitionsCSS && !Platform.webos,
            useNative: Platform.blackberry,
            isTouch: Features.touchEvents,
            has3d: Features.cssMatrix,
            preventDefaultMouseWheel: false,
            debugPixel: false
        },



        /**
         * UWA.Controls.Scroller constructor.
         *
         * ##### Available Events
         *
         * | Event            |  Description                                                               |
         * | ---------------- | -------------------------------------------------------------------------- |
         * | `onScrollStart`  | Invoked when user starting to scroll content.                              |
         * | `onScrollMove`   | Invoked when user mouse or touch move on the scrollable area.              |
         * | `onScrollStop`   | Invoked when user mouse or touch up/end/cancel on the scrollable area.     |
         * | `onScrollEnd`    | Invoked when user stop to scroll content (after momentum or bounce ended). |
         * | `onScrollPull`   | Invoked when user start to scroll content out of boundaries.               |
         * | `onKeyDown`      | Invoked when user use keyboard key.                                        |
         * | `onMouseWheel`   | Invoked when user use mouse wheel.                                         |
         * | `onRefresh`      | Invoked when the content or the scroller container change or resize.       |
         *
         * @example
         * // Inject your long content that need scroller
         * var myContent = UWA.createElement('div', {
         * html: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
         *    + 'Fusce eu urna massa. Nullam mi odio, elementum ut viverra'
         *    + 'vitae, adipiscing eget est. Mauris massa neque, faucibus'
         *    + 'sed consequat non, congue ac diam. Donec in arcu nisi,'
         *    + 'sit amet scelerisque mauris. Quisque facilisis urna in'
         *    + 'ligula sodales ut adipiscing velit tempor. Vivamus ac felis'
         *    + 'mi. Sed hendrerit velit vel lacus aliquet ac gravida urna'
         *    + 'rhoncus. Ut semper, ligula et ultrices fermentum, magna'
         *    + 'augue vulputate odio, in pharetra arcu enim vel nisl.'
         *    + 'Etiam vulputate viverra ante sit amet congue. Mauris'
         *    + 'rutrum, lacus a luctus ullamcorper, magna lorem aliquam'
         *    + 'eros, ac iaculis orci neque in urna.'
         * }).inject(widget.body);
         *
         * // Init Scroller with content as first argument and needed options
         * var myScroller = new UWA.Controls.Scroller(myContent, {
         *     height: 50,
         *     bounce: true,
         *     events: {
         *         onScrollStart: function () {
         *             myContent.setStyle('background-color', 'blue');
         *         },
         *         onScrollPull: function () {
         *             myContent.setStyle('background-color', 'red');
         *         },
         *         onScrollEnd: function () {
         *             myContent.setStyle('background-color', 'green');
         *         }
         *     }
         * });
         *
         * @param {Object} element - Element arround the scroller wil be injected
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @param {String}  [options.height=''] - Height of the scroller viewport
         * @param {String}  [options.width=''] - Width of the scroller viewport
         * @param {Boolean} [options.bounce=false] - Enable scroller bounce
         * @param {Boolean} [options.momentum=false] - Enable momentum effect
         * @param {Boolean} [options.scrollDrag=false] - Enable scroller drag (mouse or touch)
         * @param {Boolean} [options.useNative=false] - Force native scroller usage
         * @param {Boolean} [options.snap=false] - Enable snap gesture
         * @param {Boolean} [options.lockDirection=true] - Force Scroller to move in one direction at the time
         * @param {Boolean} [options.scrollableX=true] - X axis scrolling is enable
         * @param {Boolean} [options.scrollableY=true] - Y axis scrolling is enable
         * @param {Boolean} [options.scrollbarH=true] - Horizontal scrollbar is enable
         * @param {Boolean} [options.scrollbarV=true] - Vertical scrollbar is enable
         * @param {Number}  [options.scrollTime=300] - Scrolling duration for keyboard and nousewheel
         * @param {Number}  [options.scrollSize=40] - Scroll offset for keyboard and nousewheel
         * @param {Boolean} [options.useTransform=true] - Use CSS Transform instead of UWA.FX (default: `UWA.Client.Features.cssTransitions`)
         * @param {Boolean} [options.isTouch=true] - Enable touch events support instead of mouse (default: `UWA.Client.Features.touchEvents`)
         * @param {Boolean} [options.has3d=true] - Enable 3D acceleration on momentum effect (default: `UWA.Client.Features.cssMatrix`)
         *
         * @constructs UWA.Controls.Scroller
         * @extends UWA.Controls.Abstract
         * @mixes UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Scroller
         */
        init: function (element, options) {

            var that = this;

            that._parent(options);

            // Get right options value with default
            options = that.options;

            UWA.extend(that, {
                position: {
                    x: 0,
                    y: 0
                },

                direction: {
                    x: 0,
                    y: 0
                },

                scroll: {
                    x: false,
                    y: false,
                    width: 0,
                    height: 0
                },

                maxScroll: {
                    x: 0,
                    y: 0
                },

                scroller: {
                    width: 0,
                    height: 0
                },

                page: {
                    x: 0,
                    y: 0
                },

                maxPage: {
                    x: 0,
                    y: 0
                },

                scrollBars: {
                    x: null,
                    y: null
                }
            });

            if (!options.useNative) {
                that.buildSkeleton(element);
            } else {
                that.buildNative(element);
            }

            that.initEvents();

            // Set default position
            that.setPosition(0, 0, 0, true);
        },

        /**
         * Destroy scroller instance and remove wrapper arround element.
         */
        destroy: function () {

            // TODO remove document events

            var that = this,
                elements = that.elements,
                element = elements.element,
                scroller = elements.scroller,
                wrapper = elements.wrapper,
                scrollerParent = elements.scrollerParent,
                eventHandler = that.eventHandler;

            if (Scroller.activeScroller === that) {
                delete Scroller.activeScroller;
            }

            if (element) {
                Element.removeEvent.call(element, 'resize', eventHandler);
                Element.inject.call(element, scroller, 'before');
            }

            if (scrollerParent) {
                Element.removeEvent.call(scrollerParent, 'resize', eventHandler);
            }

            handleDragEvents('destroy', scroller, that.eventHandler);

            Element.removeEvents.call(scroller, {
                keydown: eventHandler,
                mousewheel: eventHandler
            });

            scroller.destroy();
            wrapper.destroy();
        },

        /**
         * Set options, automatically adds events when passed in options.
         *
         * @param {Object} options - options hash or a option/value pair.
         *
         * @returns {this} - this instance
         */
        setOptions: function (options) {
            this._parent(options);
            options = this.options;
            var snap = options.snap;
            options.snap =
                snap === true ? { x: null, y: null } :
                        typeof snap === 'number' ? { x: snap, y: snap } :
                                snap;
            return this;
        },

        /**
         * Build main dom elements using native scroller.
         *
         * @param {DOMElement} element - element to wrap with the scroller.
         */
        buildNative: function (element) {

            // More info about overflowScrolling support:
            // See: http://barrow.io/overflow-scrolling

            var that = this,
                overflow = (Platform.android || Platform.blackberry || isIOS5 ? 'scroll' : 'auto'),
                options = that.options,
                elements = that.elements = {
                    element: element,
                    scroller: UWA.createElement('div', {
                        'class': that.getClassNames('', '-native'),
                        styles: {
                            overflow: overflow,
                            overflowScrolling: 'touch',
                            zIndex: '0',
                            position: 'relative',
                            height: options.height || '100%',
                            width: options.width || '100%',
                            userSelect: 'none',
                            zoom: '1' // IE
                        }
                    }),
                    wrapper: UWA.createElement('div', {
                        'class': options.className + '-wrapper'
                    }),
                    ghost: UWA.createElement('div', {
                        styles: {
                            height: '10px',
                            width: '10px',
                            background: '#000',
                            position: 'absolute',
                            zIndex: '1',
                            opacity: options.debugPixel ? 1 : 0
                        },
                        events: {
                            click: function (event) {
                                Event.stop(event);
                                return false;
                            }
                        }
                    })
                };

            elements.scroller.style.webkitOverflowScrolling = 'touch';

            // Init Body
            that.body = options.body === false ?
                    elements.scroller :
                        options.body || document.body;

            // Create Skeleton
            elements.scroller.inject(element, 'before');
            elements.wrapper.inject(elements.scroller);
            elements.ghost.inject(elements.scroller);
            element.inject(elements.wrapper);

            // Store scroller Parent
            elements.scrollerParent = elements.scroller.getParent();

            // Add onScroll event
            elements.scroller.addEvent('scroll', function () {

                // Update last position
                that.position = that.getPosition();

                that.setAnimate('onScroll', function () {
                    that.triggerOnScroll();
                    that.triggerOnScrollEnd();
                });
            });

            // Set Skeleton and Scroller size
            that.onRefresh();
        },

        /**
         * Build main dom elements used by scroller.
         *
         * @param {DOMElement} element - element to wrap with the scroller.
         */
        buildSkeleton: function (element) {

            var that = this,
                options = that.options,
                scrollBars = that.scrollBars,
                elements = that.elements = {
                    element: element,
                    scroller: UWA.createElement('div', {
                        'class': that.getClassNames('', '-fake'),
                        tabindex: '0',
                        styles: {
                            overflow: 'hidden',
                            position: 'relative',
                            userSelect: 'none',
                            outline: 0,
                            zoom: '1' // IE
                        }
                    }),
                    wrapper: UWA.createElement('div', {
                        'class': options.className + '-wrapper',
                        styles: {
                            width: '100%',
                            height: '100%',
                            position: 'relative'
                        }
                    }),
                    ghost: UWA.createElement('div', {
                        styles: {
                            height: '10px',
                            width: '10px',
                            background: '#000',
                            position: 'absolute',
                            zIndex: '1',
                            opacity: options.debugPixel ? 1 : 0
                        },
                        events: {
                            click: function (event) {

                                Event.stop(event);

                                that.updateGhostPosition({
                                    y: 0,
                                    x: 0
                                });
                            }
                        }
                    })
                };

            // Init Body events, by default on window expect for ie that does not like it
            that.body = options.body || Client.Engine.ie ? document.body : window;

            // Create Skeleton
            elements.scroller.addContent([
                elements.wrapper,
                elements.ghost
            ]).inject(element, 'before');

            element.inject(elements.wrapper);

            // Store scroller Parent
            elements.scrollerParent = elements.scroller.getParent();

            // Add horizontal Scrollbar
            scrollBars.x = options.scrollableX && options.scrollbarH && new Scroller.Scrollbar(UWA.extend({
                dir: 'horizontal'
            }, options.scrollbar), that);

            // Add vertical Scrollbar
            scrollBars.y = options.scrollableY && options.scrollbarV && new Scroller.Scrollbar(UWA.extend({
                dir: 'vertical'
            }, options.scrollbar), that);

            // Set Skeleton and Scroller size
            that.onRefresh();
        },

        /**
         * Init scroller events.
         */
        initEvents: function () {

            var eventHandler,
                that = this,
                options = that.options,
                elements = that.elements;

            // Init eventHandler
            eventHandler = that.eventHandler = that.handleEvent.bind(that);

            // Add scroller keydown and mousewheel Events
            elements.scroller.addEvents({
                keydown: eventHandler,
                mousewheel: eventHandler
            });

            // Avoid conflict betzeen with native
            if (options.scrollDrag) {

                // Add scroller Events
                handleDragEvents('init', elements.scroller, that.eventHandler);

                // Init cursor
                that.setCursor('grab');

                // Prevent the whole screen to scroll when dragging elements outside of the scroller (ie:header/footer).
                // If you want to use scroller in a portion of the screen and still be able to use the native scrolling,
                // do *not* preventDefault on touchmove.
                elements.scroller.addEvents({
                    mousemove: Event.preventDefault,
                    touchmove: Event.preventDefault
                });
            }

            // Add element Events
            elements.element.addEvent('resize', eventHandler);

            // Add scroller parent Events
            elements.scrollerParent.addEvent('resize', eventHandler);
        },

        /**
         * Handle scroller events.
         *
         * @returns {Boolean} - false if event should not propagate.
         */
        handleEvent: function (event) {

            var result,
                that = this,
                eventType = event.type;

            switch (eventType) {
            case 'touchstart':
            case 'mousedown':
            case 'MSPointerDown':
                result = that.dispatchEvent('onScrollInit', [event]);
                break;

            case 'touchmove':
            case 'mousemove':
            case 'MSPointerMove':
                result = that.dispatchEvent('onScrollMove', [event]);
                break;

            case 'touchend':
            case 'touchcancel':
            case 'mouseup':
            case 'MSPointerUp':
                result = that.dispatchEvent('onScrollStop', [event]);
                break;

            case 'DOMMouseScroll':
            case 'onmousewheel':
            case 'mousewheel':
                result = that.dispatchEvent('onMouseWheel', [event]);
                break;

            case 'keydown':
                result = that.dispatchEvent('onKeyDown', [event]);
                break;

            case 'DOMSubtreeModified':
            case 'orientationchange':
            case 'resize':
                result = that.dispatchEvent('onRefresh', [event]);
                break;
            }

            return result;
        },



        /**
         * Scroll to coordinate.
         *
         * @param {Number} x - Target on X axis
         * @param {Number} y - Target on Y axis
         * @param {Number} runtime - Scroll duration (default is options.scrollTime)
         */
        scrollTo: function (x, y, runtime) {

            var snap,
                that = this,
                options = that.options;

            // require for Math.max
            runtime = !isNaN(runtime) ? runtime : options.scrollTime;

            // Handle Snap
            if (that.options.snap) {
                snap = that.snap(x, y);
                x = snap.x;
                y = snap.y;
                runtime = Math.min(snap.time, runtime);
            }

            that.setPosition(x, y, runtime);
        },

        /**
         * Scroll to page coordonate.
         *
         * @param {Number} pageX - Page target on X axis
         * @param {Number} pageY - Page target on Y axis
         * @param {Number} runtime - Scroll duration (default is options.scrollTime)
         */
        scrollToPage: function (pageX, pageY, runtime) {

            var that = this,
                options = that.options,
                page = that.getPage(),
                position = that.position, // Use last scheduled scroller position.
                snap = that.getSnapSize();

            if (!options.snap) {
                page.x = -mround(position.x / snap.x);
                page.y = -mround(position.y / snap.y);
            }

            if (pageX === 'next') {
                pageX = ++page.x;
            } else if (pageX === 'prev') {
                pageX = --page.x;
            }

            if (pageY === 'next') {
                pageY = ++page.y;
            } else if (pageY === 'prev') {
                pageY = --page.y;
            }

            pageX = pageX !== false ? -pageX * snap.x : position.x;
            pageY = pageY !== false ? -pageY * snap.y : position.y;

            // require for Math.max
            runtime = !isNaN(runtime) ? runtime : options.scrollTime;

            // Use Snap
            //UWA.log('scrollToPage:snap');
            snap = that.snap(pageX, pageY);
            pageX = snap.x;
            pageY = snap.y;
            runtime = Math.min(snap.time, runtime);

            that.setPosition(pageX, pageY, runtime);
        },

        /**
         * Scroll until the element is shown.
         *
         * @param {HTMLElement} el - the element to show
         * @param {String} [where] - 'start', 'center', 'end', or an object
         *  with properties 'x' and 'y' with one of those value: try to put
         *  the element in the beginning, the center or the end of the
         *  scrollable zone. Default to 'center'.
         */
        scrollToElement: function (element, where, runtime) {

            if (typeof where === 'string') {
                where = {
                    x: where,
                    y: where
                };

            } else if (where === undefined) {
                where = {
                    x: 'center',
                    y: 'center'
                };
            }

            var i, axis, measure, max,
                that = this,
                scroll = that.scroll,
                maxScroll = that.maxScroll,
                position = Element.getPosition.call(element, that.elements.wrapper),
                dimensions = Element.getDimensions.call(element),
                snap = that.getSnapSize(),
                scrollSize = {
                    x: scroll.width,
                    y: scroll.height
                },
                result = {};

            dimensions = {
                x: dimensions.outerWidth,
                y: dimensions.outerHeight
            };

            for (i = 0; i < 2; i += 1) {

                axis = i ? 'x' : 'y';
                if (scroll[axis]) {
                    measure = -position[axis];
                    if (where[axis] === 'center') {
                        measure += (scrollSize[axis] - dimensions[axis]) / 2;
                    } else if (where[axis] === 'end') {
                        measure += scrollSize[axis] - dimensions[axis];
                    }
                } else {
                    measure = 0;
                }

                // if the element in on the last page, got to the max we can
                // without worirying about page limits
                max = measure < maxScroll[axis];
                measure = measure > 0 ? 0 : max ? maxScroll[axis] : measure;

                if (!max && that.options.snap) {
                    measure = Math[i ? 'floor' : 'round'](measure / snap[axis]) * snap[axis];
                }

                if (measure < maxScroll[axis]) {
                    measure = maxScroll[axis];
                }

                result[axis] = measure;
            }

            that.setPosition(result.x, result.y, runtime);
        },

        /**
         * Scroll to position and handle scrollbar position/display.
         *
         * @param {Number} x - New x position axis position
         * @param {Number} y - New y position axis position
         * @param {Number} runtime - Position translation duration
         * @param {Boolean} hideScrollBars - Hide scrollbar during scroll
         */
        setPosition: function (x, y, runtime, hideScrollBars) {

            var delta, newPosition,
                that = this,
                options = that.options,
                scrollBars = that.scrollBars,
                scroll = that.scroll,
                maxScroll = that.maxScroll,
                position = that.getPosition();

            runtime = !isNaN(runtime) ? runtime : options.scrollTime;

            //UWA.log('setPosition: x:' + position.x + '->' + x + ' y:' + position.y + '->' + y + ' t:' + runtime);

            // Update last scheduled scroller position.
            newPosition = {
                x: x,
                y: y
            };

            if (!options.bounce) {

                // Bounce Effect: Slow down if outside of the boundaries
                newPosition = that.bounce(newPosition);
            }

            delta = {
                x: position.x - newPosition.x,
                y: position.y - newPosition.y
            };

            // Update last scheduled scroller direction.
            that.direction = {
                x: delta.x === 0 ? 0 : (delta.x > 0 ? -1 : 1),
                y: delta.y === 0 ? 0 : (delta.y > 0 ? -1 : 1)
            };

            if (delta.x !== 0 || delta.y !== 0) {


                // Scroll to position
                that.scrollToPosition(newPosition, runtime);

                if (scrollBars.x && scroll.x && delta.x !== 0) {
                    scrollBars.x.setPosition(newPosition.x, runtime, hideScrollBars);
                }

                if (scrollBars.y && scroll.y && delta.y !== 0) {
                    scrollBars.y.setPosition(newPosition.y, runtime, hideScrollBars);
                }

                // Trigger onScrollPull event if out reset
                if (
                    !that.isPulling && (
                        (that.isMaxPosition('x') && delta.x !== 0) ||
                        (that.isMaxPosition('y') && delta.y !== 0)
                    )
                ) {
                    that.dispatchEvent('onScrollPull');
                }
            }
        },

        /**
         *  Stop current scroll animation.
         */
        stopScroll: function () {
            this.scrollToPosition(this.getPosition(true), 0);
        },

        /**
         * Scroll to position.
         *
         * @param {Object} newPosition - Position axis/value pair
         * @param {Number} runtime - Scroll duration
         */
        scrollToPosition: function (newPosition, runtime) {

            runtime = runtime || 0;

            var fx, styles,
                that = this,
                elements = that.elements,
                scroller = elements.scroller,
                wrapper = elements.wrapper,
                options = that.options;

            //UWA.log('scrollToPosition: x:' + newPosition.x + ' y:' + newPosition.y + ' t:' + runtime);

            // Trigger OnScrollStart only if required
            that.triggerOnScrollStart();

            // Update last scheduled scroller position.
            that.position = newPosition;

            if (options.useNative) {

                scroller.scrollTop = -newPosition.y;
                scroller.scrollLeft = -newPosition.x;

                that.triggerOnScroll();
                that.triggerOnScrollEnd();

            } else if (options.useTransform) {

                // Remove previous transitionEnd
                wrapper.removeEvent('transitionEnd');

                // TransitionEnd does not trigger if transitionDuration is 0 on
                // somes platform or TransitionEnd append to fast with 0ms let's
                // trigger onScrollEnd manualy after transition.
                if (runtime > 0) {

                    // Add a new transitionEnd
                    wrapper.addEvent('transitionEnd', function () {
                        wrapper.removeEvent('transitionEnd');
                        that.triggerOnScrollEnd();
                    });
                }

                styles = {
                    transformOrigin: '0 0',
                    transform: 'translateZ(0)',
                    fontSmoothing: 'antialiased',
                    perspective: 800,
                    transformStyle: 'preserve-3d',
                    transitionDelay: '0ms',
                    transitionDuration: runtime + 'ms',
                    transitionProperty: wrapper.getStyleName('transform', true),
                    transitionTimingFunction: 'cubic-bezier(0.33, 0.66, 0.66, 1)'
                };

                if (options.has3d) {
                    styles.transform = 'translate3d(' + newPosition.x + 'px,' + newPosition.y + 'px, 0)';
                } else {
                    styles.transform = 'translate(' + newPosition.x + 'px,' + newPosition.y + 'px)';
                }

                wrapper.setStyles(styles);

                // Trigger onScrollEnd manualy after transition.
                if (runtime === 0) {
                    that.triggerOnScrollEnd();
                }

            } else {

                fx = that.fx = that.fx || new Fx(wrapper, {
                    transition: 'cubicOut',
                    wait: false,
                    events: {
                        onComplete: function () {
                            that.triggerOnScrollEnd();
                        },
                        onAnimate: function () {
                            that.triggerOnScroll();
                        }
                    }
                });

                fx.setOptions({
                    duration: runtime
                });

                fx.start({
                    top: newPosition.y,
                    left: newPosition.x
                });
            }
        },

        /**
         * TODO.
         */
        triggerOnScrollStart: function () {

            var that = this,
                options = that.options,
                wasScrolling = that.isScrolling;

            function onScroll() {
                that.triggerOnScroll();
                that.setAnimate('onScroll', onScroll);
            }

            // Reset delayed onScrollEnd
            that.clearDelayed('onScrollEnd');

            // If not scrolling dispacht onScrollStart
            if (!wasScrolling) {

                that.dispatchEvent('onScrollStart');

                if (options.useNative || options.useTransform) {
                    that.setAnimate('onScroll', onScroll);
                }
            }

            that.dispatchEvent('onScroll');
        },

        /**
         * TODO.
         */
        triggerOnScroll: function () {

            this.dispatchEvent('onScroll');
        },

        /**
         * TODO.
         */
        triggerOnScrollEnd: function () {

            var that = this,
                options = that.options;

            // Debounce onScrollEnd
            that.setDelayed('onScrollEnd', function () {

                if (options.useNative || options.useTransform) {
                    that.clearAnimate('onScroll');
                }

                that.dispatchEvent('onScrollEnd');

            }, 100);
        },



        /**
         * Get current scroller position.
         *
         * > Note:
         * > Using WebKitCSSMatrix feature detectiom when using CSS transform.
         *
         * @param {Boolean} round - Round position to integer instead of float
         * @return {Object} Position axis/value pair.
         */
        getPosition: function (round) {

            var matrix, position, CssMatrix,
                that = this,
                isMatrix3d = false,
                options = that.options,
                elements = that.elements;

            if (options.useNative) {

                position = {
                    y: -elements.scroller.scrollTop,
                    x: -elements.scroller.scrollLeft
                };

            } else if (options.useTransform) {

                // Set default position
                position = {
                    y: 0,
                    x: 0
                };

                matrix = Element.getStyle.call(elements.wrapper, 'transform', true);

                if (matrix && matrix !== 'none') {

                    if (Features.matrixCSS) {

                        try {

                            CssMatrix = window.WebKitCSSMatrix || window.MSCSSMatrix || window.MOZCSSMatrix || window.CSSMatrix;
                            matrix = new CssMatrix(matrix);

                            position = {
                                y: matrix.f,
                                x: matrix.e
                            };

                        } catch (error) {
                            // May CSSMatrix fails...
                        }

                    } else {

                        // Very lame general purpose alternative to CSSMatrix
                        isMatrix3d = matrix.indexOf('matrix3d') === 0;
                        matrix = matrix.replace(/[^0-9-.,]/g, '').split(',');

                        position = {
                            y: +matrix[isMatrix3d ? 13 : 5],
                            x: +matrix[isMatrix3d ? 12 : 4]
                        };
                    }
                }

                // Round position
                if (round) {
                    position = {
                        x: mround(position.x),
                        y: mround(position.y)
                    };
                }

            } else {

                // Round position using parseInt/parseFloat for perf on IE to
                // avoid double manipulation.
                position = {
                    y: (round ? parseInt : parseFloat)(elements.wrapper.style.top || 0, 10),
                    x: (round ? parseInt : parseFloat)(elements.wrapper.style.left || 0, 10)
                };
            }

            if (isNaN(position.x) || isNaN(position.y)) {
                throw new Error('Invalid scroller position');
            }

            return position;
        },

        /**
         * Get postion inside boundaries.
         *
         * @returns {Object} - position axis/value pair.
         *
         * Note:
         * * Used after scrollEnd when bounce options is enable to
         * restore position to the edges.
         */
        getResetPosition: function () {

            var that = this,
                scroll = that.scroll,
                position = that.getPosition(),
                maxScroll = that.maxScroll,
                resetX = position.x,
                resetY = position.y;

            // Reset x if overflow
            if (position.x >= 0 || !scroll.x) {
                resetX = 0;
            } else if (position.x < maxScroll.x) {
                resetX = maxScroll.x;
            }

            // Reset y if overflow
            if (position.y > 0 || !scroll.y) {
                resetY = 0;
            } else if (position.y < maxScroll.y) {
                resetY = maxScroll.y;
            }

            // Round results to avoid weird halt pixel on fonts
            // and layer that can cause blury rendering.
            return {
                x: mround(resetX),
                y: mround(resetY)
            };
        },



        /**
         * Check if the element is visible in the scroller viewport.
         *
         * @param {Element} element - The element to check visibility
         * @param {Boolean} partially - If any part of the element is visible in the viewport or only entirely visible
         * @param {String} [axis] - Optionnal specific axis to check ('x' or 'y') (default: both)
         * @return {Boolean} `true` if the element is in the scroller viewport else `false`.
         */
        isInViewport: function (element, partially, axis) {

            // Alias
            var viewport = this.elements.wrapper,

                getOffsets = Element.getOffsets,
                getDimensions = Element.getDimensions,

                // Positions
                viewportPosition = getOffsets.call(viewport, true),
                elementPosition = getOffsets.call(element),
                viewportDimensions = getDimensions.call(viewport),
                elementDimensions = getDimensions.call(element),
                scrollerPosition = this.getPosition(),

                // Dimensions
                viewportHeight = viewportDimensions.outerHeight,
                viewportWidth = viewportDimensions.outerWidth,
                width = elementDimensions.width,
                height = elementDimensions.height,
                top = elementPosition.y,
                left = elementPosition.x,
                visibilityX,
                visibilityY;

            viewportPosition.y = viewportPosition.y - scrollerPosition.y;
            viewportPosition.x = viewportPosition.x - scrollerPosition.x;

            if (partially) {
                visibilityX = left < (viewportPosition.x + viewportWidth) &&
                    (left + width) > viewportPosition.x;

                visibilityY = top < (viewportPosition.y + viewportHeight) &&
                    (top + height) > viewportPosition.y;
            } else {
                visibilityX = left >= viewportPosition.x &&
                    (left + width) <= (viewportPosition.x + viewportWidth);

                visibilityY = top >= viewportPosition.y &&
                    (top + height) <= (viewportPosition.y + viewportHeight);
            }

            return (axis === 'x') ?
                    visibilityX : (axis === 'y') ?
                        visibilityY : visibilityX && visibilityY;
        },

        /**
         * Whether or not the position reach the edge of scroller on the given axis.
         *
         * @param {String} axis - 'x' or 'y'
         * @param {Object} position
         * @param {Object} direction
         * @return {Boolean} `true` if scroller reach the edge of scroller on the given axis else `false`.
         */
        isMaxPosition: function (axis, position, direction) {

            position = position || this.getPosition();
            direction = direction || this.direction[axis];

            var that = this,
                maxScroll = that.maxScroll;

            return (direction > 0 ? (position[axis] >= 0) : (position[axis] <= maxScroll[axis]));
        },

        /**
         * Whether or not the scroller needs a scrollbar on the given axis.
         *
         * @param {String} axis - 'x' or 'y'
         * @return {Boolean} `true` if scroller has overflow on the given axis else `false`.
         */
        hasOverflow: function (axis) {

            var hasOverflow,
                that = this,
                scroll = that.scroll,
                scroller = that.scroller,
                overflowX = scroll.width < scroller.width,
                overflowY = scroll.height < scroller.height;

            if (axis === 'x') {
                hasOverflow = overflowX;
            } else if (axis === 'y') {
                hasOverflow = overflowY;
            } else {
                hasOverflow = overflowX || overflowY;
            }

            return hasOverflow;
        },

        /**
         * Change scroller dimensions.
         *
         * @example
         * scroller.setSize({height: '800px'});
         *
         * @param {Object} size - The width and/or the height to setup
         */
        setSize: function (size) {

            var that = this,
                options = that.options,
                needRefresh = false;

            if (options.width !== size.width) {
                needRefresh = true;
                this.setOption('width', size.width);
            }

            if (options.height !== size.height) {
                needRefresh = true;
                this.setOption('height', size.height);
            }

            if (needRefresh) {
                this.dispatchEvent('onRefresh');
            }
        },

        /**
         * Change scroller cursor.
         *
         * @example
         * scroller.setCursor('grabbing');
         *
         * @param {String} cursor - New scroller cursor (e.g: grab, grabbing, col-resize, row-resize)
         */
        setCursor: function (cursor) {

            var that = this,
                scroll = that.scroll;

            // Display move cusror during move
            if (
                cursor === 'grabbing' &&
                    (!scroll.x || !scroll.y)
            ) {
                cursor = scroll.x ? 'col-resize' : 'row-resize';
            }

            that.elements.scroller.setStyle('cursor', cursor);
        },

        /**
         * Set the focus to the scroller. When the scroller has the focus, it
         * can be scrolled with the keyboard arrows.
         *
         * @return {Scroller} this instance
         */
        focus: function () {

            if (this.elements.scroller) {
                this.elements.scroller.focus();
            }

            return this;
        },

        /**
         * Update Ghost pixel position that is used to avoid bad click events.
         *
         * @param {Object} position - position axis/value pair.
         */
        updateGhostPosition: function (position) {

            var that = this,
                cursorOffset = 5,
                elements = that.elements,
                scrollerPosition = elements.scroller.getOffsets();

            if (that.options.useNative) {
                scrollerPosition.y -= elements.scroller.scrollTop;
                scrollerPosition.x -= elements.scroller.scrollLeft;
            }

            elements.ghost.setStyles({
                top: position.y - scrollerPosition.y - cursorOffset,
                left: position.x - scrollerPosition.x - cursorOffset
            });
        },

        /**
         * Create Ghost pixel position that is used to avoid bad click events.
         *
         * @param {Object} position - position axis/value pair.
         * @param {String} color - pixel color.
         * @param {String} msg - debug color.
         * @param {Bool} clear - if true will remove previous pixel.
         */
        createDebugPixel: function (position, color, msg, clear) {

            var scrollerPosition,
                that = this,
                cursorOffset = 2,
                elements = that.elements;

            if (that.options.debugPixel) {

                // Buffers
                that.debugPixels = that.debugPixels || [];

                // Remove previous pixel if requested
                if (clear) {
                    that.debugPixels.forEach(function (debugPixel) {
                        debugPixel.remove();
                    });
                }

                scrollerPosition = elements.scroller.getOffsets();

                if (that.options.useNative) {
                    scrollerPosition.y -= elements.scroller.scrollTop;
                    scrollerPosition.x -= elements.scroller.scrollLeft;
                }

                that.debugPixels.push(UWA.createElement('div', {
                    title: (msg || '') + ' x:' + position.x + ' y:' + position.y,
                    styles: {
                        height: '4px',
                        width: '4px',
                        background: color || 'red',
                        position: 'absolute',
                        zIndex: '1',
                        top: position.y - scrollerPosition.y - cursorOffset,
                        left: position.x - scrollerPosition.x - cursorOffset
                    }
                }).inject(elements.scroller));
            }
        },

        /**
         * Get current axis pages offset.
         *
         * @return {Object} Pages axis/value pair.
         */
        getPage: function () {

            var measure, i, axis,
                that = this,
                position = that.getPosition(),
                snap = that.getSnapSize(),
                maxScroll = that.maxScroll,
                page = {};

            for (i = 0; i < 2; i++) {

                axis = i ? 'x' : 'y';

                measure = (position[axis] / snap[axis]);

                page[axis] = -measure;
                measure *= snap[axis];

                if (isNaN(measure) || measure > 0) {
                    page[axis] = 0;
                } else if (measure < maxScroll[axis]) {
                    page[axis] = that.maxPage[axis];
                }
            }

            return page;
        },

        /**
         * Get current axis snap size.
         *
         * @return {Object} Snap size axis/value pair.
         */
        getSnapSize: function () {

            var snap = this.options.snap,
                scroll = this.scroll;

            return {
                x: (snap && snap.x) || scroll.width,
                y: (snap && snap.y) || scroll.height
            };
        },

        /**
         * Get current axis scroll size.
         *
         * @return {Object} Scroll size axis/value pair.
         */
        getScrollSize: function () {

            var options = this.options,
                snap = options.snap;

            return {
                x: (snap && snap.x) || options.scrollSize,
                y: (snap && snap.y) || options.scrollSize
            };
        },



        /**
         * Calculate new position and transition duration for bounce options.
         *
         * @param {Number} newPosition - next position.
         *
         * @returns {Object} - position axis/value pair.
         */
        bounce: function (newPosition) {

            var i, axis,
                that = this,
                maxScroll = that.maxScroll;

            for (i = 0; i < 2; i += 1) {
                axis = i ? 'x' : 'y';

                if (newPosition[axis] >= 0 || newPosition[axis] < maxScroll[axis]) {
                    newPosition[axis] = newPosition[axis] >= 0 || maxScroll[axis] >= 0 ? 0 : maxScroll[axis];
                }
            }

            return newPosition;
        },

        /**
         * Calculate new position and transition duration for momentum options.
         *
         * @param {Number} x - new x position axis position.
         * @param {Number} y - new y position axis position.
         * @param {Object} startPosition - start position axis/value pair.
         * @param {Object} endPosition - end position axis/value pair.
         * @param {Number} duration - duration of transition from startPosition to endPosition.
         *
         * @returns {Object} - position axis/value pair.
         *
         * Note:
         * - http://code.google.com/mobile/articles/webapp_fixed_ui.html#momentum
         * - http://physics.stackexchange.com/questions/33323/end-position-of-movement-factoring-in-deceleration
         */
        momentum: function (x, y, startPosition, endPosition, duration) {

            var i, axis, dimensions,
                speed, dist, outsideDist, size,
                newDist, maxDistUpper, maxDistLower,
                that = this,
                maxDuration = 350,      // max time that disable momentum
                maxSpeed = 1.9,         // pixel/ms max speed
                deceleration = 0.0006,  // deceleration factor
                bouceDeceleration = 6,  // outside of the boundaries deceleration
                scroll = that.scroll,
                scroller = that.scroller,
                newPosition = {
                    x: x,
                    y: y
                },
                newTime = {
                    x: 0,
                    y: 0
                },
                momentum = {
                    x: +newPosition.x,
                    y: +newPosition.y,
                    time: duration
                };

            for (i = 0; i < 2; i++) {

                axis = i ? 'x' : 'y';
                dimensions = i ? 'width' : 'height';
                dist = endPosition[axis] - startPosition[axis];

                if (
                    scroll[axis] &&
                            duration <= maxDuration &&
                                dist !== 0
                ) {

                    speed = Math.min(Math.abs(dist) / duration, maxSpeed);
                    newDist = (speed * speed) / (2 * deceleration);
                    size = scroll[dimensions];

                    // Outside of the boundaries
                    maxDistUpper = -newPosition[axis];
                    maxDistLower = scroller[dimensions] - scroll[dimensions] + newPosition[axis];
                    outsideDist = size / (bouceDeceleration / (newDist / speed * deceleration));

                    // Proportinally reduce speed if we are outside of the boundaries
                    if (dist > 0 && newDist > maxDistUpper) {

                        maxDistUpper = maxDistUpper + outsideDist;
                        speed = speed * maxDistUpper / newDist;
                        newDist = maxDistUpper;

                    } else if (dist < 0 && newDist > maxDistLower) {
                        maxDistLower = maxDistLower + outsideDist;
                        speed = speed * maxDistLower / newDist;
                        newDist = maxDistLower;
                    }

                    // Round results to avoid weird halt pixel on fonts
                    // and layer that can cause blury rendering.
                    momentum[axis] = mround(newPosition[axis] + newDist * (dist < 0 ? -1 : 1));
                    newTime[axis] = speed / deceleration;
                }
            }

            // The minimum animation length must be 1ms
            momentum.time = Math.max(newTime.y, newTime.x);

            //UWA.log('momentum:' + duration + '<=' +  maxDuration + ':' + (duration <= maxDuration));
            //UWA.log('momentum: x:' + newPosition.x + '->' +  momentum.x + ' y:' + newPosition.y + '->' + momentum.y);

            return momentum;
        },

        /**
         * Calculate new position and transition duration for snap options.
         *
         * @param {Number} x - new x position axis position.
         * @param {Number} y - new y position axis position.
         * @param {Object} position - last position axis/value pair (default is <position> property value).
         *
         * @returns {Object} - position axis/value pair.
         */
        snap: function (x, y, position) {

            var measure, i, axis, delta, direction,
                that = this,
                page = that.getPage(),
                snap = that.getSnapSize(),
                maxScroll = that.maxScroll,
                result = {
                    x: x,
                    y: y
                };

            position = position || that.position;

            delta = {
                x: position.x - x,
                y: position.y - y
            };

            direction = {
                x: delta.x === 0 ? 0 : (delta.x > 0 ? -1 : 1),
                y: delta.y === 0 ? 0 : (delta.y > 0 ? -1 : 1)
            };

            for (i = 0; i < 2; i++) {

                axis = i ? 'x' : 'y';

                // Does not snap if does not move
                if (delta[axis] !== 0) {

                    measure = Math[
                        direction[axis] < 0 ? 'floor' : direction[axis] ? 'ceil' : 'round'
                    ](result[axis] / snap[axis]);

                    page[axis] = -measure;
                    measure *= snap[axis];

                    if (isNaN(measure) || measure > 0) {
                        measure = page[axis] = 0;
                    } else if (measure < maxScroll[axis]) {
                        page[axis] = that.maxPage[axis];
                        measure = maxScroll[axis];
                    }

                    result[axis] = measure;
                }
            }

            // Snap with constant speed (proportional duration)
            result.time = mround(Math.max(
                Math.abs(position.x - result.x) / snap.x * 500,
                Math.abs(position.y - result.y) / snap.y * 500
            ));

            return result;
        },



        /**
         * Invoked when user click on left button or touch the scrollable area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollInit: function (event) {

            //UWA.log('onScrollInit');

            var initialPosition, eventInputType, eventPosition, eventTime,
                that = this,
                options = that.options;

            // Stop on first test fail to improve performance on nested scroller.
            // PreventDefault prevents scrolling in native, keep it like that.
            if (
                !Event.isDefaultPrevented(event) &&
                    isEnable(that) &&
                        isScrollable(that) &&
                             isValidClick(event) &&
                                isValidElement(event)
            ) {

                eventInputType = getEventInputType(event);
                eventPosition = Event.getPosition(event);
                eventTime = event.timeStamp;

                initialPosition = that.getPosition(true);

                // Update active scroller
                Scroller.activeScroller = that;

                // Prevent text selection and native scroll
                if (eventInputType === 'mouse') {
                    Event.stop(event);
                }

                // Debug pixel
                that.createDebugPixel(eventPosition, 'green', 'onScrollInit', true);

                // Reset tracking flag to the current event type
                that.isTracking = eventInputType;

                // Add scrollMove and scrollStop events on body
                handleDragEvents('start', that.body, that.eventHandler);

                if (that.isPulling || that.isScrolling) {
                    that.updateGhostPosition(eventPosition);
                }

                // Update scrollStart
                that.scrollStart = {
                    time: eventTime,
                    position: initialPosition,
                    event: eventPosition
                };

                // Update scrollMove
                that.scrollMove = {
                    time: eventTime,
                    direction: false,
                    event: eventPosition
                };

                // Clearing data structure
                that.positions = [];

                // Handle stop scrolling on mousedown/touchstart.
                if (options.momentum && that.isScrolling) {

                    // If, 100ms after the onScrollInit, the position is
                    // different but not dragging consider (mouse|touch)hold
                    that.setDelayed('stopOnScrollInit', function () {

                        var position = that.getPosition(true);

                        if (
                            that.isDragging === false &&
                                (
                                    position.x !== initialPosition.x ||
                                        position.y !== initialPosition.y
                                )
                        ) {
                            that.setPosition(initialPosition.x, initialPosition.y, 0);

                            // Debug pixel
                            that.createDebugPixel(eventPosition, 'purple', 'stopOnScrollInit');
                        }

                    }, 150);
                }

                // If, immediately after the onScrollInit, the currently
                // focused element is outside the scroller, set the focus on
                // the scroller.
                that.setDelayed('focusOnScrollInit', function () {

                    var scroller = that.elements.scroller,
                        activeElement = scroller.getDocument().activeElement;

                    if (
                        !activeElement ||
                            !Element.isInjected.call(activeElement, scroller)
                    ) {
                        that.focus();
                    }
                }, 75);

                // Update cursor
                that.setCursor('grabbing');
            }
        },

        /**
         * Invoked when user mouse or touch move on the scrollable area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollMove: function (event) {

            /*jshint maxstatements: 47*/

            //UWA.log('onScrollMove');

            var position, maxScroll, scroll,  scrollMove, scrollStart, eventTime,
                deltaX, deltaY, distanceX, distanceY, directionX, directionY,
                that = this,
                options = that.options,
                positions = that.positions,
                eventPosition = Event.getPosition(event),

                // Calculate minimumTrackings
                minimumTrackingForScroll = options.lockDirection ? options.threshold : 0,
                minimumTrackingForDrag = options.threshold;

            // Ignore event when tracking is not enabled (event might be outside of element)
            // And not the same eventInputType than the isTracking.
            if (that.isTracking === getEventInputType(event)) {

                Event.stop(event);

                // Update ghost pixel that prevent click
                that.updateGhostPosition(eventPosition);

                // Clear (mouse|touch)hold detection
                that.clearDelayed('stopOnScrollInit');

                // Are we already is dragging mode?
                if (that.isDragging) {

                    scrollMove = that.scrollMove;
                    maxScroll = that.maxScroll;
                    position = UWA.clone(that.position); //that.getPosition();
                    eventTime = event.timeStamp;

                    deltaY = eventPosition.y - scrollMove.event.y;
                    deltaX = eventPosition.x - scrollMove.event.x;
                    directionX = deltaX === 0 ? 0 : (deltaX > 0 ? -1 : 1);
                    directionY = deltaY === 0 ? 0 : (deltaY > 0 ? -1 : 1);

                    if (that.enableScrollX) {

                        position.x += deltaX;

                        if (position.x < maxScroll.x || position.x > 0) {

                            // Slow down on the edges
                            if (options.bounce) {
                                position.x -= (deltaX / 2);

                            } else if (position.x < maxScroll.x) {
                                position.x = maxScroll.x;

                            } else {
                                position.x = 0;
                            }
                        }
                    }

                    // Compute new vertical scroll position
                    if (that.enableScrollY) {

                        position.y += deltaY;

                        if (position.y < maxScroll.y || position.y > 0) {

                            // Slow down on the edges
                            if (options.bounce) {

                                // Decelerate if out of boundaries
                                position.y -= (deltaY / 2);

                                // Support pull-to-refresh (only when only y is scrollable)
                                // TODO

                            } else if (position.y < maxScroll.y) {
                                position.y = maxScroll.y;

                            } else {
                                position.y = 0;
                            }
                        }
                    }

                    // Keep list from growing infinitely (holding min 10, max 20 measure points)
                    if (positions.length > 60) {
                        positions.splice(0, 30);
                    }

                    // Track scroll movement for decleration
                    positions.push(position.x, position.y, eventTime);

                    // Set Position
                    that.setPosition(position.x, position.y, 0);

                    // Detect direction change
                    if (
                        that.scrollMove.direction &&
                            (
                                (
                                    that.enableScrollX &&
                                        scrollMove.direction.x !== 0 &&
                                            scrollMove.direction.x !== directionX
                                ) || (
                                    that.enableScrollY &&
                                        scrollMove.direction.y !== 0 &&
                                            scrollMove.direction.y !== directionY
                                )
                            )
                    ) {

                        // Debug pixel
                        that.createDebugPixel(eventPosition, 'yellow', 'onScrollMove:directionChange');

                        // Update scrollStart
                        that.scrollStart = {
                            time: eventTime,
                            position: position,
                            event: eventPosition
                        };

                    } else {

                        // Debug pixel
                        that.createDebugPixel(eventPosition, 'orange', 'onScrollMove:isDragging');
                    }

                    // Update scrollMove
                    that.scrollMove = {
                        time: eventTime,
                        direction: {
                            x: directionX,
                            y: directionY
                        },
                        position: position,
                        event: eventPosition
                    };

                // Otherwise figure out whether we are switching into dragging mode now.
                } else {

                    scroll = that.scroll;
                    scrollStart = that.scrollStart;

                    // Get pointer moving distance
                    distanceX = Math.abs(eventPosition.x - scrollStart.event.x);
                    distanceY = Math.abs(eventPosition.y - scrollStart.event.y);

                    that.enableScrollX = scroll.x && distanceX >= minimumTrackingForScroll;
                    that.enableScrollY = (scroll.y || (!scroll.x && !scroll.y)) && distanceY >= minimumTrackingForScroll;

                    that.isDragging = (that.enableScrollX || that.enableScrollY) &&
                                            (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);

                    // Required to avoid that the scroll jump
                    if (that.isDragging && that.isScrolling) {
                        that.stopScroll();
                    }

                    // Debug pixel
                    that.createDebugPixel(eventPosition, 'red', 'onScrollMove:notDragging');
                }
            }
        },

        /**
         * Invoked when user mouse or touch up/end/cancel on the scrollable area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollStop: function (event) {

            //UWA.log('onScrollStop');

            var newPosition, momentum, snap,
                scrollEnd, scrollStart,
                eventPosition, eventTime,
                that = this,
                options = that.options,
                newDuration = options.scrollTime;

            // Ignore event when tracking is not enabled (no touchstart event on element)
            // This is required as this listener ('touchmove') sits on the document and not on the element itself.
            // And not the same eventInputType than the isTracking.
            if (that.isTracking === getEventInputType(event)) {

                // Not touching anymore (when two finger hit the screen there are two touch end events)
                that.isTracking = false;

                // Disable scroller
                if (Scroller.activeScroller === that) {
                    delete Scroller.activeScroller;
                }

                // Remove events
                handleDragEvents('stop', that.body, that.eventHandler);

                // Get reset position
                eventPosition = Event.getPosition(event);

                // Get event info
                newPosition = that.getResetPosition(true);
                eventTime = event.timeStamp;

                // Debug pixel
                that.createDebugPixel(eventPosition, 'blue', 'onScrollMove');

                // Restore cursor
                that.setCursor('grab');

                // Be sure to reset the dragging flag now. Here we also detect whether
                // the finger has moved fast enough to switch into a deceleration animation.
                if (that.isDragging) {

                    // Reset dragging flag
                    that.isDragging = false;

                    // Alias scrollStart that will be use for momentum.
                    scrollStart = that.scrollStart;

                    // Update scrollEnd that will be use for momentum.
                    that.scrollEnd = scrollEnd = {
                        time: eventTime,
                        position: newPosition,
                        event: eventPosition
                    };

                    // Stop event
                    Event.stop(event);

                    // If the mousedown target is the same as the mouseup target, a
                    // click event will be fired. We should prevent it.
                    that.updateGhostPosition(eventPosition);

                    // Prevent slingshot momentum effect (long slow move)
                    if (
                        scrollEnd.event.x !== scrollStart.event.x ||
                            scrollEnd.event.y !== scrollStart.event.y
                    ) {

                        // Handle Momentum
                        if (options.momentum) {

                            //UWA.log('onScrollStop:momentum');
                            momentum = that.momentum(
                                newPosition.x,
                                newPosition.y,
                                scrollStart.event,
                                scrollEnd.event,
                                scrollEnd.time - scrollStart.time
                            );

                            newPosition = momentum;
                            newDuration = Math.max(newPosition.time, newDuration);
                        }

                        // Handle Snap
                        if (options.snap) {

                            //UWA.log('onScrollStop:snap');
                            snap = that.snap(
                                newPosition.x,
                                newPosition.y,
                                scrollStart.position
                            );

                            newPosition = snap;
                            newDuration = Math.max(newPosition.time, newDuration);
                        }
                    }
                }

                // If this was a slower move it is per default non decelerated, but this
                // still means that we want snap back to the bounds which is done here.
                // This is placed outside the condition above to improve edge case stability
                // e.g. touchend fired without enabled dragging. This should normally do not
                // have modified the scroll positions or even showed the scrollbars though.
                // TODO

                // Update position
                that.setPosition(
                    newPosition.x,
                    newPosition.y,
                    newDuration,
                    false
                );

                // Fully cleanup list
                that.positions.length = 0;
                that.scrollStart = null;
                that.scrollMove = null;
                that.scrollEnd = null;

                // Reset ghost position
                that.setDelayed('resetGhostPosition', function () {
                    that.updateGhostPosition({
                        x: 0,
                        y: 0
                    });
                }, 500);
            }
        },

        /**
         * Invoked when scroller starting to scroll content.
         */
        onScrollStart: function () {

            //UWA.log('onScrollStart');

            var that = this;

            // Start scrolling
            that.isScrolling = true;
        },

        /**
         * Invoked when scroller scroll content.
         */
        onScroll: function () {

            //UWA.log('onScroll');
        },

        /**
         * Invoked when scroller stop to scroll content.
         */
        onScrollEnd: function () {

            //UWA.log('onScrollEnd');

            var that = this,
                options = that.options;

            // Remove transitionEnd is useTransform
            // and reset isScrolling state.
            if (that.isScrolling) {

                //UWA.log('onScrollEnd:scrolling');

                // Stop scrolling
                that.isScrolling = false;

                // Remove transitionEnd Event on wrapper if using Transform only if moved
                if (options.useTransform) {
                    that.elements.wrapper.removeEvent('transitionEnd', that.eventHandler);
                }
            }

            // Do not reset Position or hide scrollbar if has tracking,
            // that is reseted by onScrollStop
            if (!that.isTracking) {

                // Stop Pulling
                that.isPulling = false;

                // Reset position, scrollBars state and handle snap position.
                that.setAnimate('onResetPosition', function () {

                    var snap,
                        reset = that.getResetPosition(),
                        position = that.getPosition(),
                        scrollBars = that.scrollBars;

                    // Handle Snap
                    if (that.options.snap) {
                        snap = that.snap(reset.x, reset.y);
                        reset.x = snap.x;
                        reset.y = snap.y;
                    }

                    // Will scroll only if overflow but require to reset this.direction
                    if (position.x !== reset.x || position.y !== reset.y) {
                        that.setPosition(reset.x, reset.y);

                    // Hide the scrollbars
                    } else {

                        if (scrollBars.x) {
                            scrollBars.x.onScrollEnd();
                        }

                        if (scrollBars.y) {
                            scrollBars.y.onScrollEnd();
                        }
                    }
                });
            }
        },

        /**
         * Invoked when user start to scroll content out of boundaries.
         */
        onScrollPull: function () {

            this.isPulling = true;
        },

        /**
         * Invoked when user use keyboard key.
         *
         * @param {Event} event - a standart DOM event.
         *
         * Notes:
         * * http://unixpapa.com/js/key.html
         */
        onKeyDown: function (event) {

            var that = this,
                position = that.position, // Use last scheduled scroller position.
                scroll = that.scroll,
                scrollSize = that.getScrollSize(),
                keyCode = event.keyCode,
                isUp = keyCode === 40,
                isDown = keyCode === 38,
                isLeft = keyCode === 37,
                isRight = keyCode === 39,
                axis = (isUp || isDown ? 'y' : isRight || isLeft ? 'x' : false),
                delta = (isDown || isLeft ? 1 : -1),
                element = Event.getElement(event),
                newPosition = {
                    x: position.x,
                    y: position.y
                };

            if (
                scroll[axis] &&
                    isValidElement(element) &&
                        !that.isMaxPosition(axis, position, delta)
            ) {

                Event.stop(event);

                newPosition[axis] += delta * scrollSize[axis];

                that.scrollTo(newPosition.x, newPosition.y);
            }
        },

        /**
         * Invoked when user use mouse wheel.
         *
         * @param {Event} event - a standart DOM event.
         */
        onMouseWheel: function (event) {

            var that = this,
                options = that.options,
                position = that.position, // Use last scheduled scroller position.
                scroll = that.scroll,
                axis = (scroll.x && !scroll.y) || Event.whichKey(event) === 'shift' ? 'x' : 'y',
                scrollSize = that.getScrollSize(),
                delta = Event.wheelDelta(event),
                newPosition = {
                    x: position.x,
                    y: position.y
                };

            // If delta is nonzero, handle it.
            // Basically, delta is now positive if wheel was scrolled up,
            // and negative, if wheel was scrolled down.
            if (
                delta &&
                    scroll[axis] &&
                        !that.isMaxPosition(axis, position, delta)
            ) {

                Event.stop(event);

                newPosition[axis] += delta * scrollSize[axis];

                that.scrollTo(newPosition.x, newPosition.y);

            } else if (options.preventDefaultMouseWheel) {
                Event.stop(event);
            }
        },

        /**
         * Invoked when the content or the scroller container change or resize.
         */
        onRefresh: function () {

            // Do not trigger refresh if not injected
            if (!this.elements.scroller.isInjected() || this.isScrolling) {
                return false;
            }

            var reset, scroll, scroller, maxScroll, styles,
                that = this,
                options = that.options,
                elements = that.elements,
                position = that.position,
                scrollBars = that.scrollBars,
                elementScrolls = Element.getScrolls.call(elements.element),
                scrollerDimensions = Element.getDimensions.call(elements.scrollerParent);

            // Set Scroller Dimensions
            scroller = {
                width: elementScrolls.width,
                height: elementScrolls.height
            };

            // Set scroll Dimensions
            scroll = {
                width: (options.width || scrollerDimensions.innerWidth),
                height: (options.height || scrollerDimensions.innerHeight)
            };

            // Update only if required
            if (
                (scroll.width !== that.scroll.width || scroll.height !== that.scroll.height) ||
                    (scroller.width !== that.scroller.width || scroller.height !== that.scroller.height)
            ) {
                // Set the scroller width or height (only if axis is scrollable)
                styles = {};

                if (options.scrollableX !== false) {
                    styles.width = scroll.width;
                }

                if (options.scrollableY !== false) {
                    styles.height = scroll.height;
                }

                elements.scroller.setStyles(styles);

                scroll.x = options.scrollableX && scroll.width < elementScrolls.width;
                scroll.y = options.scrollableY && scroll.height < elementScrolls.height;

                // Update maxScroll Position
                maxScroll = that.maxScroll = {
                    x: scroller.width < scroll.width ? 0 : scroll.width - scroller.width,
                    y: scroller.height < scroll.height ? 0 : scroll.height - scroller.height
                };

                // Update maxPage
                that.maxPage = {
                    x: Math.ceil(scroller.width  / scroll.width),
                    y: Math.ceil(scroller.height / scroll.height)
                };

                // Save Values
                that.scroll = scroll;
                that.scroller = scroller;

                // Update horizontal scrollbar
                if (scrollBars.x) {
                    scrollBars.x.setSize(scroll.width, scroller.width);
                }

                // Update vertical scrollbar
                if (scrollBars.y) {
                    scrollBars.y.setSize(scroll.height, scroller.height);
                }

                // Reset Overflow only if not moved
                reset = that.getResetPosition();
                if (!that.moved && (reset.x !== position.x || reset.y !== position.y)) {
                    that.setPosition(reset.x, reset.y, 0, true);
                }

                // Add custom Classes
                elements.scroller.toggleClassName('scrollable', scroll.y || scroll.x);
                elements.scroller.toggleClassName('scrollable-x', scroll.x);
                elements.scroller.toggleClassName('scrollable-y', scroll.y);
            } else {

                // Do not trigger refresh if not require
                return false;
            }
        }
    });

    /*
      Class: UWA.Controls.Scroller.Scrollbar

      Parameters:
        * Object options: options hash or a option/value pair.

      Available Options:
        > TODO

      Example:
        (start code)
        TODO
        (end code)

      TODO:
       - Calculate ScrollBar Size on shrink
    */
    Scroller.Scrollbar = Abstract.extend({

        /**
         * @property {Object} name - Controls identifier
         * @protected
         */
        name: 'uwa-scroller-scrollbar',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: '',
            barColor: '#555',
            bgColor: '#EEE',
            opacity: 1,
            dir: 'vertical',
            padding: 2,
            width: 6,
            roundCorder: true,
            autoHide: true,
            draggable: true,
            elastic: false,
            debugPixel: false
        },

        /**
         * @property {Object} position - ScrollBar "x" and "y" current positions.
         * @protected
         */
        position: {
            x: 0,
            y: 0
        },

        /**
         * @property {Object} scroller - Instance of UWA.Controls.Scroller linked to the
         * current Scrollbar.
         * @protected
         */
        scroller: null,

        /**
         * @property {Boolean} visible - current visibility Scrollbar status.
         * @protected
         */
        visible: true,

        /**
         * Set the options to the current controls instance, creates observers and elements object
         *
         * @param {Object} options - options hash or a option/value pair.
         */
        init: function (options, scroller) {

            this._parent(options);

            this.scroller = scroller;

            this.buildSkeleton();
            this.initEvents();

            if (this.options.autoHide) {
                this.hide();
            }
        },

        /**
         * Destroy scrollbar instance.
         */
        destroy: function () {
            this.elements.wrapper.remove();
        },

        /**
         * Create Ghost pixel position that is used to avoid bad click events.
         *
         * @param {Object} position - position axis/value pair.
         * @param {String} color - pixel color.
         * @param {String} msg - debug color.
         * @param {Bool} clear - if true will remove previous pixel.
         */
        createDebugPixel: function (position, color, msg, clear) {

            var scrollerPosition,
                that = this,
                cursorOffset = 2,
                isHorizontal = that.isHorizontal,
                elements = that.elements;

            if (that.options.debugPixel) {

                // Buffers
                that.debugPixels = that.debugPixels || [];

                // Remove previous pixel if requested
                if (clear) {
                    that.debugPixels.forEach(function (debugPixel) {
                        debugPixel.remove();
                    });
                }

                scrollerPosition = elements.wrapper.getOffsets();

                that.debugPixels.push(UWA.createElement('div', {
                    title: (msg || '') + ' x:' + position.x + ' y:' + position.y,
                    styles: {
                        height: '2px',
                        width: '4px',
                        background: color || 'red',
                        position: 'absolute',
                        zIndex: '11',
                        top: !isHorizontal ? position.y - scrollerPosition.y - cursorOffset : 0,
                        left: isHorizontal ? position.x - scrollerPosition.x - cursorOffset : 0
                    }
                }).inject(that.scroller.elements.scroller));
            }
        },

        /**
         * Build main dom elements.
         */
        buildSkeleton: function () {

            var bar, wrapper,
                that = this,
                options = that.options,
                scrollerOptions = that.scroller.options,
                isHorizontal = options.dir === 'horizontal',
                scrollerPadding = parseInt(options.padding, 10),
                scrollerWidth = parseInt(options.width, 10),
                cornerWidth = options.roundCorder ? mround(((options.width / 2) * 100) / 100) : 0,
                scroller = that.scroller.elements.scroller;

            // Set orientation and axis
            that.isHorizontal = isHorizontal;
            that.axis = isHorizontal ? 'x' : 'y';
            that.reverseAxis = isHorizontal ? 'y' : 'x';

            // Create ScrollBar wrapper
            that.elements.wrapper = wrapper = UWA.createElement('div', {
                'class': that.getClassNames('', '-' + options.dir),
                styles: {
                    zIndex: '10',
                    position: 'absolute',
                    overflow: 'hidden',
                    opacity: options.opacity
                }
            }).inject(scroller);

            if (options.bgColor) {
                wrapper.setStyle('background', options.bgColor);
            }

            // ScrollBar wrapper Design
            if (isHorizontal) {
                wrapper.setStyles({
                    bottom: scrollerPadding + 'px',
                    left: scrollerPadding + 'px',
                    height: scrollerWidth + 'px'
                });
            } else {
                wrapper.setStyles({
                    top: scrollerPadding + 'px',
                    right: scrollerPadding + 'px',
                    width: scrollerWidth + 'px'
                });
            }

            // Create ScrollBar element
            that.elements.bar = bar = UWA.createElement('div', {
                styles: {
                    background: options.barColor,
                    zIndex: '10',
                    position: 'absolute',
                    top: 0,
                    left: 0
                }
            }).inject(wrapper);

            // TODO Wtf ?
            if (Client.Engine.ie < 7) {
                bar.setHTML('&nbsp;&nbsp;&nbsp;');
            }

            // ScrollBar Design
            if (isHorizontal) {
                bar.setStyles({
                    borderRadius: cornerWidth + 'px ' + cornerWidth + 'px',
                    width: scrollerWidth + 'px',
                    minWidth: (scrollerWidth + 1) + 'px',
                    minHeight: scrollerWidth + 'px'
                });
            } else {
                bar.setStyles({
                    borderRadius: cornerWidth + 'px ' + cornerWidth + 'px',
                    height: scrollerWidth + 'px',
                    minWidth: scrollerWidth + 'px',
                    minHeight: (scrollerWidth + 1) + 'px'
                });
            }

            // Init Transform
            if (options.useTransform) {

                // Enable hardware acceleration
                bar.setStyles({
                    transformOrigin: '0 0',
                    transform: 'translateZ(0)'
                });

                if (scrollerOptions.has3d) {

                    bar.setStyles({
                        perspective: 800,
                        transformStyle: 'preserve-3d'
                    });
                }
            }
        },

        /**
         * Init main dom events.
         */
        initEvents: function () {

            var eventHandler,
                that = this,
                options = that.options,
                elements = that.elements;

            // Init eventHandler
            eventHandler = that.eventHandler = that.handleEvent.bind(that);

            // Handle scrollDrag options
            if (options.draggable) {

                // Add scrollbar Events
                handleDragEvents('init', elements.bar, that.eventHandler);

                // Change the cursor during the drag
                elements.bar.setStyle('cursor', 'grab');
            }

            if (options.autoHide) {
                elements.wrapper.addEvents({
                    mouseenter: function () {
                        that.focused = true;
                        that.show();
                    },
                    mouseleave: function () {
                        that.focused = false;
                        that.hide();
                    }
                });
            }
        },

        /**
         * Handle scroller events.
         *
         * @returns {Boolean} - false if event should not propagate.
         */
        handleEvent: function (event) {

            ////UWA.log('handleEvent ' + event.type);

            var result,
                that = this;

            switch (event.type) {
            case 'touchstart':
            case 'mousedown':
                result = that.dispatchEvent('onScrollInit', [event]);
                break;

            case 'touchmove':
            case 'mousemove':
                result = that.dispatchEvent('onScrollMove', [event]);
                break;

            case 'touchend':
            case 'touchcancel':
            case 'mouseup':
                result = that.dispatchEvent('onScrollStop', [event]);
                break;
            }

            return result;
        },

        /**
         * Change scrollbar dimensions according to scroller.
         *
         * @param {Number} scroll - the width or the height of scroller offset.
         * @param {Number} size - the width or the height of scroller.
         */
        setSize: function (scroll, size) {

            var that = this,
                options = that.options,
                scrollerScroll = that.scroller.scroll,
                isHorizontal = that.isHorizontal,
                hasReverseScroll = isHorizontal ? scrollerScroll.y : scrollerScroll.x,
                scrollerWidth = parseInt(options.width, 10),
                scrollerPadding = parseInt(options.padding, 10);

            // if size of content is less of equal than sroll
            // hide the scrollbar
            if (size <= scroll) {

                that.hide(true);

            } else {

                if (!options.autoHide) {
                    that.show();
                }

                // Create scrollbar mask
                that.maxSize = mround(scroll - (scrollerPadding * 2) - (hasReverseScroll ? scrollerWidth : 0));
                that.minSize = scrollerWidth;

                that.size = Math.min(Math.max(that.maxSize * that.maxSize / size, scrollerWidth * 3), that.maxSize);

                that.maxScroll = that.maxSize - that.size;
                that.minScroll = 0;

                that.toWrapperProp = that.maxScroll / (scroll - size);
                that.toPropWrapper = size / that.maxSize;

                that.elements.wrapper.setStyle(isHorizontal ? 'width' : 'height', that.maxSize + 'px');
                that.elements.bar.setStyle(isHorizontal ? 'width' : 'height', that.size + 'px');
            }
        },



        /**
         * Invoked when user click on left button or touch the scrollbar area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollInit: function (event) {

            Event.stop(event);

            var that = this,
                cursor = 'grabbing',
                scroller = that.scroller,
                eventPosition = Event.getPosition(event);

            // Debug pixel
            that.createDebugPixel(eventPosition, '#7FFF00', true);

            // Add scrollMove and scrollStop events on body
            handleDragEvents('start', scroller.body, that.eventHandler);

            // Init scrollStart
            that.scrollStart = {
                x: eventPosition.x,
                y: eventPosition.y
            };

            // Init scrollMove
            that.scrollMove = {
                x: eventPosition.x,
                y: eventPosition.y
            };

            // Update cursor
            that.elements.bar.setStyle('cursor', cursor);
            scroller.setCursor(cursor);

            // Update Scroller state
            scroller.isTracking = true;
            scroller.isDragging = true;
        },

        /**
         * Invoked when user mouse or touch move on the scrollbar area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollMove: function (event) {

            Event.stop(event);

            var that = this,
                axis =  that.axis,
                toPropWrapper =  that.toPropWrapper,
                scroller = that.scroller,
                maxScroll = scroller.maxScroll,
                scrollMove = that.scrollMove,
                isHorizontal = that.isHorizontal,
                position = scroller.position,
                eventPosition = Event.getPosition(event),
                delta = {
                    x: isHorizontal ? (eventPosition.x - scrollMove.x) * toPropWrapper : 0,
                    y: isHorizontal ? 0 : (eventPosition.y - scrollMove.y) * toPropWrapper
                },
                newPosition = {
                    x: position.x - delta.x,
                    y: position.y - delta.y
                };

            if (
                newPosition[axis] > maxScroll[axis] &&
                    newPosition[axis] < 0
            ) {
                // Debug pixel
                that.createDebugPixel(eventPosition, 'orange');

                // Update scroller position
                scroller.setPosition(newPosition.x, newPosition.y, 0);

                // Update scrollMove
                that.scrollMove = {
                    x: eventPosition.x,
                    y: eventPosition.y
                };

            } else {

                // Debug pixel
                that.createDebugPixel(eventPosition, 'red');
            }
        },

        /**
         * Invoked when user mouse or touch up/end/cancel on the scrollbar area.
         *
         * @param {Event} event - a standart DOM event.
         */
        onScrollStop: function (event) {

            Event.stop(event);

            var that = this,
                cursor = 'grab',
                scroller = that.scroller,
                eventPosition = Event.getPosition(event),
                position = scroller.getResetPosition();

            // Debug pixel
            that.createDebugPixel(eventPosition, '#00CED1');

            // Update scroller position and scrollbar state
            scroller.setPosition(position.x, position.y, NaN, false, true);

            // Remove scrollMove and scrollStop events on body
            handleDragEvents('stop', that.scroller.body, that.eventHandler);

            // Hide scrolbar if autohide and not focused
            if (!that.focused) {
                that.hide();
            }

            // Restore cursor
            that.elements.bar.setStyle('cursor', cursor);
            that.scroller.setCursor(cursor);

            // Reset scrollMove
            that.scrollMove = null;
            that.scrollStart = null;

            // Update Scroller state
            scroller.isTracking = false;
            scroller.isDragging = false;
        },

        /**
         * Scroll scrollbar to position and handle scrollbar position/display.
         *
         * @param {Number} x - new scroll position axis position.
         * @param {Number} runtime - scroll duration.
         * @param {Boolean} hideScrollBars - hide scrollbar during scroll.
         */
        setPosition: function (scroll, runtime, hideScrollBar) {

            var fx, tmpPosition, styles, dimensionProperty, newDimension,
                that = this,
                bar = that.elements.bar,
                scroller = that.scroller,
                size = that.size,
                axis = that.axis,
                dimension = that.dimension,
                maxSize = that.maxSize,
                minSize = that.minSize,
                position = that.position,
                maxScroll = that.maxScroll,
                minScroll = that.minScroll,
                options = that.options,
                scrollerOptions = scroller.options,
                newPosition = {
                    y: 0,
                    x: 0
                };

            tmpPosition = that.toWrapperProp * scroll;

            // Update right position
            if (that.isHorizontal) {
                dimensionProperty = 'width';
            } else {
                dimensionProperty = 'height';
            }

            // Avoid the the scrollbar go outside of viewport
            if (tmpPosition < 0) {

                if (options.elastic) {
                    newDimension = Math.max(size + tmpPosition, minSize);
                    newPosition[axis] = minScroll;
                } else {
                    newPosition[axis] = minScroll;
                }

            } else if (tmpPosition > maxScroll) {

                if (options.elastic) {
                    newDimension = Math.max(size - (tmpPosition - maxScroll), minSize);
                    newPosition[axis] = Math.min(tmpPosition, maxScroll + size - minSize);
                } else {
                    newPosition[axis] = maxScroll;
                }

            } else {
                newDimension = size;
                newPosition[axis] = tmpPosition;
            }

            // Only update scrollbar if needed
            if (
                newPosition.x !== position.x ||
                    newPosition.y !== position.y ||
                        dimension !== newDimension
            ) {
                if (!hideScrollBar) {
                    that.show();
                } else {
                    runtime = 0;
                }

                // Avoid float that may cause bug on some browsers
                newPosition = {
                    x: newPosition.x,
                    y: newPosition.y
                };

                if (scrollerOptions.useTransform) {

                    styles = {
                        transitionDelay: '0ms',
                        transitionDuration: runtime + 'ms',
                        transitionProperty: [bar.getStyleName('transform', true)].concat([dimensionProperty]).join(','),
                        transitionTimingFunction: 'cubic-bezier(0.33, 0.66, 0.66, 1.0)'
                    };

                    // Handle scrollbar size bounce
                    if (newDimension && options.elastic) {
                        styles[dimensionProperty] = newDimension + 'px';
                    }

                    if (options.has3d) {
                        styles.transform = 'translate3d(' + newPosition.x + 'px,' + newPosition.y + 'px, 0)';
                    } else {
                        styles.transform = 'translate(' + newPosition.x + 'px,' + newPosition.y + 'px)';
                    }

                    bar.setStyles(styles);

                } else {

                    fx = that.fx = that.fx || new Fx(bar, {
                        transition: 'cubicOut',
                        wait: false
                    });

                    fx.setOptions({
                        duration: runtime
                    });

                    styles = {
                        top: [position.y, newPosition.y],
                        left: [position.x, newPosition.x]
                    };

                    // Handle scrollbar size bounce
                    if (newDimension && options.elastic) {
                        styles[dimensionProperty] = [size, newDimension];
                    }

                    fx.start(styles);
                }
            }

            that.position = newPosition;
            that.dimension = newDimension;
        },

        /**
         * Invoked when scrollbar start moving.
         */
        onScrollStart: function () {
            this.show();
        },

        /**
         * Invoked when scrollbar stop moving.
         */
        onScrollEnd: function () {
            this.hide();
        },

        /**
         * Display scrollbar.
         */
        show: function () {

            var styles,
                that = this;

            if (!that.visible) {

                styles = {
                    opacity: that.options.opacity
                };

                // Do not use display due transform conflict
                if (that.scroller.options.useTransform) {
                    UWA.merge(styles, {
                        transitionProperty: 'opacity',
                        transitionDelay: '0ms',
                        transitionDuration: '50ms'
                    });
                }

                that.elements.wrapper.setStyles(styles);
                that.visible = true;
            }
        },

        /**
         * Hide scrollbar.
         */
        hide: function (force) {

            var styles,
                that = this;

            if (
                that.visible &&
                    !that.focused &&
                        !that.scrollMove &&
                            (that.options.autoHide || force)
            ) {

                styles = {
                    opacity: 0
                };

                // Do not use display due transform conflict
                if (that.scroller.options.useTransform) {
                    UWA.merge(styles, {
                        transitionProperty: 'opacity',
                        transitionDelay: force ? '0ms' : '300ms',
                        transitionDuration: force ? '0ms' : '150ms'
                    });
                }

                that.elements.wrapper.setStyles(styles);
                that.visible = false;
            }
        }
    });

    return UWA.namespace('Controls/Scroller', Scroller, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Carousel
 *
 */
define('UWA/Controls/Carousel', [
    'UWA/Core',
    'UWA/Class/Timed',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Controls/Scroller'
], function (UWA, Timed, Client, Event, Element, Abstract, Scroller) { // jshint ignore:line
    'use strict';

    var Carousel = Abstract.extend(Timed, /** @lends module:UWA/Controls/Carousel.UWA.Controls.Carousel# */{ // bypass

        /**
         * The default controls options.
         * @private
         */
        defaultOptions: {
            className: 'uwa-carousel',
            // Control orientation
            orientation: 'horizontal',
            // Number of items to scroll
            scrollSize: 3,
            // Scroller options
            scrollerOptions: {
                lockDirection: true,
                momentum: false,
                scrollbarH: false,
                scrollbarV: false,
                scrollDrag: Client.Features.touchEvents
            },
            // Scroll backward button
            nextButton: null,
            // Scroll forward button
            previousButton: null,
            // Scroll button CSS class name
            scrollButtonClassName: 'uwa-carousel-button',
            // Scroll animation duration (in ms)
            scrollDuration: 300,
            // Pressed delay before autoscrolling start (in ms)
            autoScrollPressedDelay: 500,
            // Items CSS selector
            itemSelector: 'li'
        },

        /**
         * UWA.Controls.Carousel constructor.
         *
         * @param {Element} element - Parent HTML element of items to scroll (e.g. <UL>).
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className='uwa-carousel'] - Control CSS class
         *
         * @constructs UWA.Controls.Carousel
         * @extends UWA.Controls.Abstract
         * @mixes UWA.Controls.Timed
         * @memberof module:UWA/Controls/Carousel
         */
        init: function (element, options) {

            this._parent(options);
            this.element = UWA.extendElement(element);

            // Global wrapper for scroll buttons injection
            this.elements.container = UWA.createElement('div', {'class': this.options.className})
                .inject(this.element, 'before').grab(this.element);

            // Create scroll buttons
            this.initEvents();

            // Enable scroll on the appropriate axis
            this.options.scrollerOptions.scrollableY = this.isVertical();
            this.options.scrollerOptions.scrollableX = !this.options.scrollerOptions.scrollableY;

            // Create scroller
            this.scroller = new Scroller(element, UWA.merge({ _root: false }, this.options.scrollerOptions));
            this.scroller.addEvent('onMouseWheel', this.updateScrollButtonsDisabledState.bind(this));
            this.scroller.addEvent('onScrollEnd', this.updateScrollButtonsDisabledState.bind(this));

            // Listen to Scroller 'resize' events and dispatch to onRefresh
            this.scroller.addEvent('onRefresh', this.dispatchEvent.bind(this, 'onRefresh'));
        },

        /**
         * Scroll to the first item.
         *
         * @param {Number} duration - Animation duration (optional)
         *
         * Returns:
         * * Nothing.
         */
        scrollHead: function (duration) {
            this.scrollToItem(this.element.firstChild, duration);
        },

        /**
         * Scroll to the last item.
         *
         * @param {Number} duration - Animation duration (optional)
         */
        scrollTail: function (duration) {
            this.scrollToItem(this.element.lastChild, duration);
        },

        /**
         * Scroll the carousel forward.
         *
         * @param {Number} numItems - The number of items to scroll (optional)
         */
        scrollNext: function (numItems) {
            this.scrollTo('next', numItems);
        },

        /**
         * Scroll the carousel backward.
         *
         * @param {Number} numItems - The number of items to scroll (optional)
         */
        scrollPrevious: function (numItems) {
            this.scrollTo('previous', numItems);
        },

        /**
         * Scroll carousel to the specified item element.
         *
         * @param {HTMLElement} item - The item element to scroll
         * @param {Number} duration - Animation duration (optional)
         */
        scrollToItem: function (item, duration) {

            var where, items, visibleItems, itemIndex, firstVisibleItemIndex;

            if (this.hasDelayed('onRefresh')) {
                // Before scrolling, make sure we dont'have a pending update
                // timeout which may mess out the animation
                // In that case, clear the timeout and update immediately

                this.clearDelayed('onRefresh');
                this.onRefreshNoDelay();
            }

            if (isNaN(duration)) {
                duration = this.options.scrollDuration;
            }

            // Detect the direction to scroll
            if (this.element.firstChild === item) {
                where = 'start';
            } else if (this.element.lastChild === item) {
                where = 'end';
            } else {
                items = this.getItems();
                visibleItems = this.getVisibleItems(true);
                itemIndex = items.indexOf(item);
                firstVisibleItemIndex = items.indexOf(visibleItems[0]);

                where = itemIndex > firstVisibleItemIndex ? 'end' : 'before';
            }

            this.scroller.scrollToElement(item, where, duration);
        },

        /**
         * Scroll carousel to the specified item element index.
         *
         * @param {String} direction - TODO
         * @param {Number} numItems - TODO
         * @param {Number} duration - Animation duration (optional)
         */
        scrollTo: function (direction, numItems, duration) {

            var toIndex, where,
                children = this.getItems();

            numItems = numItems || this.options.scrollSize;

            if (isNaN(duration)) {
                duration = this.options.scrollDuration;
            }

            if (direction === 'next') {
                toIndex = children.indexOf(this.getLastItemVisible()) + numItems;
                where = 'end';

            } else if (direction === 'previous') {
                toIndex = children.indexOf(this.getFirstItemVisible()) - numItems;
                where = 'start';
            }

            // Limit toIndex value to not be out of bound
            toIndex = Math.min(children.length - 1, Math.max(0, toIndex));

            // Scroll to element
            this.scroller.scrollToElement(children[toIndex], where, duration);

            // Update buttons state in case we reached tail or head
            this.updateScrollButtonsDisabledState();
        },

        /**
         * Whether or not the tab item is fully visible.
         *
         * @param {HTMLElement} item - The item element to test visibility
         * @param {Boolean} partially - False to exclude if partially visible. Default: True
         * @return {Boolean}
         */
        isItemVisible: function (item, partially) {
            var axis = this.isVertical() ? 'y' : 'x';
            return this.scroller.isInViewport(item, partially !== false, axis);
        },

        /**
         * Returns the first item element strictly visible.
         *
         * @return {HTMLElement}
         */
        getFirstItemVisible: function () {

            var item, i, l,
                items = this.getItems();

            for (i = 0, l = items.length; i < l; i += 1) {
                item = items[i];

                if (this.isItemVisible(item, false)) {
                    return item;
                }
            }

            return null;
        },

        /**
         * Returns the last item element strictly visible.
         *
         * @return {HTMLElement}
         */
        getLastItemVisible: function () {
            var visibleItems = this.getVisibleItems(false);
            // TODO: use UWA.Array.getLast when available
            return visibleItems.length ? visibleItems[visibleItems.length - 1] : null;
        },

        /**
         * Returns all items elements currently visible (not overflow hidden).
         *
         * @param {Boolean} partially - `true` to also return items partially visible
         * @return {Array} An array of HTMLElement.
         */
        getVisibleItems: function (partially) {

            var isVisible, previousIsVisible, finished;

            return this.getItems().filter(function (item) {

                if (finished !== true) {
                    isVisible = this.isItemVisible(item, partially);

                    // For performance reasons, if the previous item was visible
                    // and not this one, we can return false for all remaining elements
                    finished = (isVisible === false && previousIsVisible === true);
                    previousIsVisible = isVisible;

                } else {
                    isVisible = false;
                }

                return isVisible;

            }, this);
        },

        /**
         * Returns the Scroll forward button.
         *
         * @return {HTMLElement}
         */
        nextButton: function () {
            if (!this.elements.nextButton) {
                this.elements.nextButton = this._createScrollButton('next');
            }
            return this.elements.nextButton;
        },

        /**
         * Returns the Scroll backward button.
         *
         * @return {HTMLElement}
         */
        previousButton: function () {

            if (!this.elements.previousButton) {
                this.elements.previousButton = this._createScrollButton('previous');
            }

            return this.elements.previousButton;
        },

        /**
         * Initialize UI events.
         */
        initEvents: function () {

            var button,
                hasTouch = Client.Features.touchEvents,
                events = {};

            events[hasTouch ? 'touchstart' : 'mousedown'] = this.onScrollButtonDown.bind(this);
            events[hasTouch ? 'touchend' : 'mouseup'] = this.onScrollButtonUp.bind(this);
            events.click = this.onScrollButtonClick.bind(this);

            button = this.nextButton();
            if (button) {
                button.addEvents(events);
                button.setAttribute('data-scroll', 'next');
            }

            button = this.previousButton();
            if (button) {
                button.addEvents(events);
                button.setAttribute('data-scroll', 'previous');
            }
        },

        /**
         * Click event on scroll buttons.
         */
        onScrollButtonClick: function (event) {

            // Autoscrolling has been stopped
            if (!this.stopScroll()) {

                var eventTimeStamp = (event.timeStamp || Date.now());

                if (this.lastClickTime && (eventTimeStamp - this.lastClickTime <= 300)) {

                    delete this.lastClickTime;
                    this.onScrollButtonDblClick(event);

                } else {

                    Event.preventDefault(event);

                    this.lastClickTime = eventTimeStamp;

                    this.scrollTo(
                        this.getScrollButtonFromEvent(event).getAttribute('data-scroll'),
                        this.options.scrollSize
                    );
                }
            }
        },

        /**
         * Double click event on scroll buttons.
         */
        onScrollButtonDblClick: function (event) {

            Event.stop(event);

            // Scroll all visible items forward or backward
            this.scrollTo(
                this.getScrollButtonFromEvent(event).getAttribute('data-scroll'),
                this.getVisibleItems(true).length
            );
        },

        onScrollButtonDown: function (event) {
            this.setDelayed(
                'pressedTimeout',
                this.autoScroll.bind(this, this.getScrollButtonFromEvent(event).getAttribute('data-scroll')),
                this.options.autoScrollPressedDelay
            );
        },

        onScrollButtonUp: function () {
            this.stopScroll();
        },

        /**
         * Performs a continuous scroll forward until stopScroll() is called.
         */
        autoScrollNext: function () {
            this.autoScroll('next');
        },

        /**
         * Performs a continuous scroll backward until stopScroll() is called.
         */
        autoScrollPrevious: function () {
            this.autoScroll('previous');
        },

       /**
         * Performs a continuous scroll backward until stopScroll() is called.
         */
        autoScroll: function (direction) {

            this.stopScroll();

            this.setPeriodical('scrollTimer', function () {

                var position = this.scroller.getPosition(),
                    axis = this.isVertical() ? 'y' : 'x';

                if (direction === 'previous') {
                    position[axis] += 20;
                } else if (direction === 'next') {
                    position[axis] -= 20;
                }

                this.scroller.setPosition(position.x, position.y, 0);

            }.bind(this), 20);
        },

        /**
         * Stop dragScroll if started.
         * Stop autoScrolling if started.
         * @return {Boolean} `true` of autoScrolling has been stopped.
         */
        stopScroll: function () {

            this.clearDelayed('pressedTimeout');

            // TODO stoped by onScrollButtonUp
            // if the feature is to stop scroll if
            // autoScroll inited it fail.
            var stopped = this.hasPeriodical('scrollTimer');

            this.clearPeriodical('scrollTimer');

            // If a dragScroll has been started, stop it
            if (this.scroller.dragScrolling) {

                // Setting the flag above to false will cause the scroller
                // to call onScrollStop on next Mouse Event
                this.scroller.dragScrolling = false;
            }

            return stopped;
        },

        /**
         * Same than onRefresh()
         */
        onRefresh: function () {
            this.setDelayed('onRefresh', this.onRefreshNoDelay.bind(this), 50);
        },

        onRefreshNoDelay: function () {

            // Avoid useless sizes calculation if we are off-DOM
            if (this.isInjected()) {

                var deltaScroll,
                    axis = this.isVertical() ? 'y' : 'x',
                    maxScroll = this.scroller.maxScroll[axis];

                // For the very first call, make sure overflow attribute exists
                // as it affects computed styles and therefore dimensions
                if (!this.elements.container.hasAttribute('overflow')) {
                    this._updateOverflowStatus();
                }

                this._updateOverflowStatus();

                // Refresh Scroller
                this.scroller.dispatchEvent('onRefresh');

                // Amount of pixels the scroll size has changed (negative value if decreased)
                deltaScroll = Math.abs(maxScroll) - Math.abs(this.scroller.maxScroll[axis]);

                this.dispatchEvent('onScrollerResize', [{
                    // Amount of pixels the scroll size has changed (negative value if decreased)
                    deltaScroll: deltaScroll
                }]);

                this.updateScrollButtonsDisabledState();
            }
        },

        /**
         * Enable/disable scroll buttons.
         */
        updateScrollButtonsDisabledState: function () {

            var disabled, attrName,
                that = this,
                elements = that.elements,
                axis = that.isVertical() ? 'y' : 'x';

            [elements.nextButton, elements.previousButton].forEach(function (el, i) {

                if (el) {

                    disabled = that.scroller.isMaxPosition(axis, false, i * 2 - 1);
                    el.toggleClassName('disabled', disabled);

                    attrName = 'max-scroll-' + el.getAttribute('data-scroll');

                    if (disabled) {
                        elements.container.setAttribute(attrName, 'true');
                    } else {
                        elements.container.removeAttribute(attrName);
                    }
                }
            });
        },

        /**
         * Whether or not carousel has its content in overflow.
         */
        hasOverflow: function () {
            return this.elements.container.getAttribute('overflow') === 'true';
        },

        /**
         * Whether or not carousel orientation is vertical.
         */
        isVertical: function () {
            return this.options.orientation === 'vertical';
        },

        /**
         * Returns all scrollable child elements.
         *
         * @return {Array} An array of HTML elements.
         */
        getItems: function () {
            return this.element.getElements(this.options.itemSelector);
        },

        /**
         * Whether or not carousel is injected into document.
         *
         * @return {Boolean}
         */
        isInjected: function () {

            if (this.injected !== true) {
                this.injected = this.elements.container && this.elements.container.isInjected();
            }

            return this.injected;
        },

        /**
         * Helper method to retrieve the scroll button instance from a Browser event.
         *
         * @param {Event} e - Browser event
         * @return {Tab} Closest scroll button on which event happened.
         */
        getScrollButtonFromEvent: function (e) {
            return UWA.Event.getElement(e).getClosest('.' + this.options.scrollButtonClassName);
        },

        /**
         * Private method for nextButton() / previousButton()
         */
        _createScrollButton: function (direction) {

            var options = this.options,
                buttonProp = direction + 'Button',
                buttonEl = false;

            // If option false is passed, don't attempt to create a button
            if (options[buttonProp] !== false) {

                // If a function config is passed, use it to create button
                if (UWA.is(options[buttonProp], 'function')) {
                    buttonEl = options[buttonProp](this.elements.container);

                // If an option Element is passed, grab its reference
                } else if (UWA.is(options[buttonProp], 'element')) {
                    buttonEl = options[buttonProp];

                // Otherwise, create default button
                } else {
                    buttonEl = UWA.createElement('a', {
                        'class': options.scrollButtonClassName +  ' ' + options.scrollButtonClassName + '-' + direction
                    }).grab(UWA.createElement('span')).inject(this.elements.container);
                }

                // Extend element in case of
                buttonEl = UWA.extendElement(buttonEl);
            }

            return buttonEl;
        },

        _updateOverflowStatus: function () {

            var axis = this.isVertical() ? 'y' : 'x',
                overflow = this.scroller.hasOverflow(axis);

            this.elements.container.setAttribute('overflow', String(overflow));

            this.scroller.setOptions({
                preventDefaultMouseWheel: overflow
            });
        }
    });

    return UWA.namespace('Controls/Carousel', Carousel, UWA);

});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, setTimeout
*/

/**
 * @module   UWA/Controls/Picker
 *
 */
define('UWA/Controls/Picker', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Event',
    'UWA/Class/Timed',
    'UWA/Controls/Input',
    'UWA/Controls/DropDown',
    'UWA/Element'
], function (UWA, Utils, Event, Timed, Input, DropDown, Element) {  // jshint ignore:line
    'use strict';

    /**
     * Abstract Picker component to build simple picker inputs.
     *
     * ##### Available Events
     *
     * | Event               |  Description                                          |
     * | ------------------- | ----------------------------------------------------- |
     * | `onNavigationClick` | Triggered when the user clicks on a navigation button |
     * | `onOpen`            | Triggered when the dropdown opens                     |
     * | `onClose`           | Triggered when the dropdown closes                    |
     *
     *
     * @example <caption>Extend the Picker to provide three choices</caption>
     * var ThreeChoicesPicker = UWA.Controls.Picker.extend({
     *     options: {
     *         choices: ['a', 'b', 'c']
     *     },
     *     buildContent: function () {
     *         var picker = this;
     *         return this.options.choices.map(function (choice) {
     *             return UWA.createElement('input', {
     *                 type: 'button',
     *                 value: choice,
     *                 events: {
     *                     click: function () {
     *                         picker.setValue(choice);
     *                         picker.dispatchEvent('onChange', [choice]);
     *                         picker.toggle(`false`);
     *                     }
     *                 }
     *            });
     *        });
     *     }
     * });
     *
     * var picker = new ThreeChoicesPicker();
     * picker.inject(container);
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {Object} [options.navigation] - Set the initial navigation menu. See setNavigation
     * @param {Element} [options.button] - If defined, use this DOM element or descriptor to display a button
     * @param {String} [options.button] - Type of input to print the value. For now, it can
     *  be 'text' to display the value as text, or a falsy value to hide the value.
     * @param {Object} [options.dropdownOptions] - Options passed to construct the <UWA.Controls.DropDown.Pointy> instance
     * @param {Element} [options.dropdownContainer] - Where to inject the dropdown. Defaults to this control container
     *
     * @class UWA.Controls.Picker
     * @extends module:UWA/Controls/Input.UWA.Controls.Input
     * @memberof module:UWA/Controls/Picker
     */
    var Picker = Input.extend(Timed, /** @lends module:UWA/Controls/Picker.UWA.Controls.Picker# */{

        /**
         * The input name. Default: 'uwa-picker'.
         *
         * @type {String}
         */
        name: 'uwa-picker',

        /**
         * The default controls options.
         * @private
         */
        options: {
            navigation: null,
            button: null,
            valueInput: 'text',
            dropdownOptions: {
                global: true
            },
            dropdownContainer: null
        },

        /**
         * Overrides UWA.Controls.Input.buildSkeleton.
         */
        buildSkeleton: function () {
            var options = this.options,
                elements = this.elements;

            this._parent();

            if (options.valueInput && options.button) {
                elements.content.addClassName(this.getClassNames('-split'));
            } else if (options.button) {
                elements.container.addClassName('button-only');
            } else if (options.valueInput) {
                elements.container.addClassName('value-only');
            }

            if (options.valueInput) {
                elements.content.setContent(elements.value = UWA.createElement('div', {
                    'class': this.getClassNames('-value')
                }));
                if (options.valueInput === 'text') {
                    elements.value.addClassName(this.getClassNames('-text'));
                }
            }

            if (options.button) {
                elements.content.addContent(
                    elements.button = UWA.createElement('div', {
                        'class': this.getClassNames('-button'),
                        html: options.button
                    })
                );
            }
        },

        /**
         * Build the dropdown content. To override.
         *
         * @return {Element} The dropdown content.
         */
        buildContent: function () {
            // To override
        },

        /**
         * Build the navigation menu.
         *
         * @return {Element} Element or Element descriptor. The navigation menu.
         */
        buildNavigation: function (navigation) {
            return Utils.splat(navigation).map(function (item) {
                return UWA.is(item, 'element') ? item : this.buildNavigationItem(item);
            }, this);
        },

        /**
         * Build one navigation item.
         *
         * @param {Object} item - The navigation descriptor
         * @return {Element} Element or Element descriptor. The navigation item.
         */
        buildNavigationItem: function (item) {
            var self = this;
            return UWA.createElement('div', {
                text: item.label,
                'class': this.getClassNames('-navigationlink'),
                events: {
                    click: function (e) {
                        self.dispatchEvent('onNavigationClick', [e, item]);
                    }
                }
            });
        },

        /**
         * Overrides <UWA.Controls.Input.buildSkeleton>
         */
        syncInput: function () {
            var value = this.elements.value;
            if (value !== this.elements.input) {
                value.setText(this.getValue());
            }
        },

        /* Group: Accessors methods */

        /**
         * @return {Boolean} `true` if the dropdown is open.
         */
        isOpen: function () {
            return Boolean(this.elements.dropdown && this.elements.dropdown.isOpen());
        },

        /**
         * Overrides <UWA.Controls.Input.focus>
         */
        focus: function (y) {
            var that = this,
                parent = that._parent;

            setTimeout(function () {
                var active = document.activeElement,
                    dropdown = that.elements.dropdown;

                function blur() {
                    Element.removeEvent.call(active, 'blur', blur);
                    that.focus(false);
                }

                if (active && dropdown && Element.isInjected.call(active, dropdown.getInnerElement())) {
                    Element.addEvent.call(active, 'blur', blur);

                } else {
                    parent.call(that, y);
                    if (y === false) {
                        that.toggle(y);
                    }
                }
            }, 0);
        },

        /**
         * Open the dropdown
         *
         * @return {this}
         */
        open: function () {
            return this.toggle(true);
        },

        /**
         * Close the dropdown
         *
         * @return {this}
         */
        close: function () {
            return this.toggle(false);
        },

        /**
         * Toggle the dropdown
         *
         * @param {Boolean} f - If defined, opens (true) or closes (false) the dropdown
         * @return {this}
         */
        toggle: function (f) {
            var elements = this.elements,
                options = this.options;

            if ((f === true || f === undefined) && !elements.dropdown) {
                var dropdownOptions = UWA.extend({
                    target: elements.button || elements.content,
                    autoPosition: ['below-end', 'right-start', 'above-end', 'left-start']
                }, options.dropdownOptions);

                dropdownOptions._root = false;
                dropdownOptions.className = this.getClassNames('-dropdown') + " " + (dropdownOptions.className || "");

                elements.dropdown = new DropDown.Pointy(dropdownOptions).addEvents({
                    onShow: this.dispatchEvent.bind(this, 'onOpen'),
                    onHide: this.dispatchEvent.bind(this, 'onClose')
                });
                if (options.navigation) {
                    elements.navigation = UWA.createElement('div', {
                        'class': this.getClassNames('-navigation'),
                        html: this.buildNavigation(this.options.navigation)
                    });
                }
                elements.dropdown.getInnerElement()
                    .addEvent('mousedown', Event.stopPropagation)
                    .addEvent('click', Event.stopPropagation)
                    .addContent({
                        tag: 'div',
                        'class': this.getClassNames('-selector'),
                        html: this.buildContent()
                    }, elements.navigation);
                elements.dropdown.inject(options.dropdownContainer || elements.container);
            }

            if (elements.dropdown) {
                elements.dropdown.toggle(f);
            }
        },

        /* Group: Default event handler */

        /**
         * Default onClick handler
         */
        onClick: function () {
            /* When the picker is in a <label>, the click event may occure twice: once on
             * the input, and once on the container. Let's debounce this */
            this.setDelayed('debounced-toggle', this.toggle, 1);
        },

        /**
         * Default onOpen handler
         */
        onOpen: function () {
            this.elements.container.addClassName('open');
        },

        /**
         * Default onClose handler
         */
        onClose: function () {
            this.elements.container.removeClassName('open');
        },

        /**
         * Default onNavigationClick handler
         */
        onNavigationClick: function (e, item) {
            this.setValue(item.value);
        }

    });

    return UWA.namespace('Controls/Picker', Picker, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Controls/ColorPicker
 *
 */
define('UWA/Controls/ColorPicker', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Color',
    'UWA/Controls/Picker',
    'UWA/Controls/Drag',
    'UWA/Controls/Input'
], function (UWA, Event, Color, Picker, Drag, Input) {
    'use strict';

    var cleanRgbValue = function (rgb, allowIncomplete) {
        var match = rgb && rgb.match(allowIncomplete ?
                                     /^\s*#?([0-9a-f]{0,6})/i :
                                     /^\s*#?(|[0-9a-f]{3}|[0-9a-f]{6})\s*$/i);
        return match ? match[1] : '';
    };

    var AreaPickerDrag = Drag.extend({
        defaultOptions: {
            touchSnap: 0,
            mouseSnap: 0
        },

        start: function (position) {
            this.move(position, {
                distance: 0,
                x: 0,
                y: 0
            });
        },

        move: function (position, delta) {
            var elementOffset = this.element.getOffsets(),
                elementSize = this.element.getSize();

            var localPosition = {
                x: position.x - elementOffset.x,
                y: position.y - elementOffset.y
            };

            localPosition.x = Math.max(0, Math.min(elementSize.width, localPosition.x));
            localPosition.y = Math.max(0, Math.min(elementSize.height, localPosition.y));

            var normalizedPosition = {
                x: localPosition.x / elementSize.width,
                y: localPosition.y / elementSize.height
            };

            this.options.pickCallback(normalizedPosition, localPosition);

            // Hide cursor
            if (this.options.hideCursorWhileDragging && delta.distance > 0 && !this.injectedStylesheet) {
                this.injectedStylesheet = UWA.createElement('style', {
                    html: '* { cursor: none !important; }'
                }).inject(document.body);
            }
        },

        reset: function () {
            if (this.injectedStylesheet) {
                this.injectedStylesheet.remove();
                this.injectedStylesheet = null;
            }

            this._parent();
        }
    });

    var ColorPicker = Picker.extend(/** @lends module:UWA/Controls/ColorPicker.UWA.Controls.ColorPicker# */{

        /**
         * @property {String} name - The color picker name. Default: 'uwa-colorpicker'
         * @protected
         */
        name: 'uwa-colorpicker',

        /**
         * @property {Number} previouslyDisplayedHue - The previously selected hue, to know when to update the SL picker.
         * @protected
         */
        previouslyDisplayedHue: null,

        /**
         * @property {Object} options - The default options of the control
         * @protected
         */
        options: {
            button: {'tag': 'div', 'class': 'uwa-colorpicker-well'},
            dropdownOptions: {},

            defaultValue: null
        },

        /**
         * The ColorPicker component lets the user pick a color, either using a hue/saturation/lightness picker, or by inputting a hex code.
         *
         * ##### Available Events
         *
         * | Event            | Description                                                                                        |
         * | ---------------- | -------------------------------------------------------------------------------------------------- |
         * | `onChange`       | Triggered when a color has been selected by the user. The color is passed as a hexadecimal string. |
         *
         *
         * ##### Examples
         *
         * __Example__: Setup a color picker
         *
         * ```
         * var colorPicker = new UWA.Controls.ColorPicker({
         *     value: '8136b3',
         *     defaultValue: 'ffffff'
         * }).addEvent('onChange', function (color) {
         *     someElement.setStyle('background', '#' + color);
         * }).inject(container);
         * ```
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.defaultValue=null] - A default color; if defined, the ColorPicker displays a button to revert to the default color
         *
         * @class UWA.Controls.ColorPicker
         * @extends module:UWA/Controls/Picker.UWA.Controls.Picker
         * @memberof module:UWA/Controls/ColorPicker
         */
        init: function (options) {
            this._parent(options);

            if (/\bdark\b/.test(this.options.className) &&
                !this.options.dropdownOptions.className) {

                this.options.dropdownOptions.className = 'dark';
            }

            this.elements.well = this.elements.button.getElement('.uwa-colorpicker-well');
            this._updateWell();
            this.syncInput();
        },

        /**
         * Get the color as an UWA.Color.
         *
         * @protected
         * @return {Object} UWA.Color
         */
        _getColor: function () {
            var value = this.getValue() || this.options.defaultValue || 'ffffff';

            if (this._color) {
                // If the input value changed for any reason (not with the setValue
                // method), let's reset the stored hsl value.
                var newValue = Color.parse(value);
                var currentValue = this._color;
                if (!UWA.equals(currentValue.toRGBString(), newValue.toRGBString())) {
                    this._color = null;
                } else {
                    return this._color;
                }
            }

            return Color.parse(value);
        },

        /**
         * Set the color with a HSL object.
         *
         * @protected
         * @param {Object} color - an UWA.Color object
         */
        _setColor: function (color) {
            this.setValue(color.toHSLString());
        },

        /**
         * Overrides {@link module:UWA/Controls/Input.UWA.Controls.Input#setValue|UWA.Controls.Input#setValue}
         *
         * @param {String / Object} value - A color string or an UWA.Color
         */
        setValue: function (value) {
            // If the value is a string
            if (typeof(value) === 'string') {
                value = Color.parse(value);
            }

            if (!value) {
                return;
            }

            this._color = value;
            this._parent(value.toHexString().substring(1));
        },

        /**
         * Overrides {@link module:UWA/Controls/Picker.UWA.Controls.Picker#buildContent|UWA.Controls.Picker#buildContent}
         */
        buildContent: function () {
            var self = this,
                darkTheme = /\bdark\b/.test(this.options.className);

            var content = UWA.createElement('div', {
                html: [
                    this.elements.slPicker = UWA.createElement('div', {
                        'class': this.getClassNames('-sl-picker'),
                        html: [
                            this.elements.slPickerCanvas = UWA.createElement('canvas', {
                                'class': this.getClassNames('-sl-picker-canvas'),
                                width: 220,
                                height: 220
                            }),
                            this.elements.slPickerCursor = UWA.createElement('div', {
                                'class': this.getClassNames('-sl-picker-cursor')
                            })
                        ]
                    }),
                    this.elements.huePicker = UWA.createElement('div', {
                        'class': this.getClassNames('-hue-picker'),
                        html: [
                            this.elements.huePickerArrows = UWA.createElement('div', {
                                'class': this.getClassNames('-hue-picker-arrows')
                            }),
                            this.elements.huePickerCanvas = UWA.createElement('canvas', {
                                'class': this.getClassNames('-hue-picker-canvas'),
                                width: 26,
                                height: 220
                            })
                        ]
                    }),
                    this.elements.hexField = UWA.createElement('div', {
                        'class': this.getClassNames('-hex-field'),
                        html: [
                            this.elements.hexFieldInput = new Input.Text({
                                _root: false,
                                'className': this.getClassNames('-hex-field-input')
                            }),
                            UWA.createElement('span', {
                                'class': this.getClassNames('-hex-field-icon'),
                                text: '#'
                            })
                        ]
                    }),
                    this.elements.clearButton = UWA.createElement('div', {
                        'class': this.getClassNames('-clear-button') + ' uwa-icon',
                        'data-icon': 'p',
                        events: {
                            mousedown: function (event) {
                                Event.preventDefault(event);
                            },
                            click: function (event) {
                                Event.preventDefault(event);

                                self.setValue(self.options.defaultValue);
                            }
                        }
                    }),
                    new Input.Button({
                        _root: false,
                        'value': 'Done',
                        'className': this.getClassNames('-done-button') + (darkTheme ? ' extra-dark-grey' : ' dark-grey'),
                        'events': {
                            onMouseDown: function (event) {
                                Event.preventDefault(event);
                            },
                            onClick: function () {
                                self.toggle(false);
                            }
                        }
                    })
                ]
            });

            new AreaPickerDrag({
                element: this.elements.slPicker,
                hideCursorWhileDragging: true,
                pickCallback: function (normalizedPosition) {
                    var normalizedPickedS = normalizedPosition.x,
                        normalizedPickedV = (1 - normalizedPosition.y);

                    // Convert from HSV (which is what the picker exposes) to HSL
                    var l = (2 - normalizedPickedS) * normalizedPickedV;
                    var s;

                    if (normalizedPickedV > 0) {
                        s = normalizedPickedS * normalizedPickedV;
                        s /= l <= 1 ? l : 2 - l;
                        s = s || 0;
                        l /= 2;
                    } else {
                        s = normalizedPosition.x;
                    }

                    l *= 100;
                    s *= 100;

                    self._setColor(self._getColor().cloneWith({ l: l, s: s }));
                }
            });

            new AreaPickerDrag({
                element: this.elements.huePicker,
                pickCallback: function (normalizedPosition) {
                    self._setColor(self._getColor().cloneWith({ h: (1 - normalizedPosition.y) * 360 }));
                }
            });

            this.elements.hexField.getElement('.uwa-input-hex-field input').addEvents({
                keyup: function () {
                    self._readInputFieldValue();
                },
                input: function () {
                    self._readInputFieldValue();
                },
                change: function () {
                    self._readInputFieldValue();
                }
            });

            this.elements.dropdown.elements.inner.addEvent('mousedown', function (event) {
                if (event.target === this) {
                    Event.preventDefault(event);
                }
            });

            this._renderHuePicker();
            this.syncInput();

            return content;
        },

        /**
         * Renders the hue picker element's background.
         * @protected
         */
        _renderHuePicker: function () {
            var stopCount = 37;

            var canvas = this.elements.huePickerCanvas,
                context = this.elements.huePickerCanvas.getContext('2d');

            var hueGradient = context.createLinearGradient(0, 0, 0, canvas.height);

            for (var stopIndex = 0; stopIndex < stopCount; stopIndex++) {
                var stopPosition = stopIndex / (stopCount - 1);
                var stopColor = Color.parse('hsl(' + ((1 - stopPosition) * 360) + ', ' + 100 + '%, ' + 50 + '%)');
                hueGradient.addColorStop(stopPosition, stopColor.toHSLString());
            }

            context.fillStyle = hueGradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
        },

        /**
         * Updates the color well element.
         * @protected
         */
        _updateWell: function () {
            this.elements.well.setStyle('background', this._getColor().toHSLString());
        },

        /**
         * Updates the saturation/lightness picker element.
         * @protected
         */
        _updateSlPicker: function () {
            var canvas = this.elements.slPickerCanvas;
            var context = this.elements.slPickerCanvas.getContext('2d');
            var color = this._getColor();
            var colorObj = color.toObject();

            // Colors
            if (this.previouslyDisplayedHue !== colorObj.h) {
                this.previouslyDisplayedHue = colorObj.h;
                // // Horizontal (white to color) gradient
                var horizontalGradient = context.createLinearGradient(0, 0, canvas.width, 0);
                var pureColor = Color.parse('hsl(' + colorObj.h + ', ' + 100 + '%, ' + 50 + '%)');

                horizontalGradient.addColorStop(0, 'white');
                horizontalGradient.addColorStop(1, pureColor.toHSLString());

                context.fillStyle = horizontalGradient;
                context.fillRect(0, 0, canvas.width, canvas.height);

                // / Vertical (transparent to black) gradient
                var verticalGradient = context.createLinearGradient(0, 0, 0, canvas.height);

                verticalGradient.addColorStop(0, 'transparent');
                verticalGradient.addColorStop(1, 'black');

                context.fillStyle = verticalGradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Cursor
            var cursorElement = this.elements.slPickerCursor,
                tempV, tempS,
                cursorX, cursorY;

            // // Convert our HSL to the picker's HSV
            tempV = colorObj.l / 100 * 2;
            tempS = colorObj.s / 100 * ((tempV <= 1) ? tempV : 2 - tempV);
            cursorY = (tempV + tempS) / 2;

            if (tempV > 0) {
                cursorX = (2 * tempS) / (tempV + tempS);
            } else {
                cursorX = colorObj.s / 100;
            }

            cursorX = Math.round(cursorX * this.elements.slPickerCanvas.width);
            cursorY = Math.round((1 - cursorY) * this.elements.slPickerCanvas.height);

            cursorElement.setStyle('left', cursorX + 'px');
            cursorElement.setStyle('top', cursorY + 'px');
            cursorElement.setStyle('background', color.toHexString());
        },

        /**
         * Updates the hue picker element.
         * @protected
         */
        _updateHuePicker: function () {
            var arrows = this.elements.huePickerArrows;
            var hue = (360 - this._getColor().toObject().h) / 360;
            var arrowPosition = hue * this.elements.huePickerCanvas.height;

            arrows.setStyle('top', Math.round(arrowPosition) + 'px');
        },

        /**
         * Updates the hex color field.
         * @protected
         */
        _updateHexField: function () {
            var input = this.elements.hexFieldInput;
            if (this.getValue()) {
                var newValue = this._getColor();
                var currentValue = Color.parse(input.getValue());
                if (!currentValue || !UWA.equals(newValue.toRGBString(), currentValue.toRGBString())) {
                    input.setValue(newValue.toHexString().substring(1));
                }
            } else {
                input.setValue('');
            }
        },

        /**
         * Updates the “revert to default color” button.
         * @protected
         */
        _updateDefaultButton: function () {
            this.elements.clearButton.toggle(UWA.is(this.options.defaultValue) && this.options.defaultValue !== this.getValue());
        },

        /**
         * Overrides {@link module:UWA/Controls/Picker.UWA.Controls.Picker#syncInput|UWA.Controls.Picker#syncInput}
         */
        syncInput: function () {
            if (this.elements.well) {
                this._updateWell();
            }
            if (this.elements.slPicker) {
                this._updateSlPicker();
                this._updateHuePicker();
                this._updateHexField();
                this._updateDefaultButton();
            }
            if (this.elements.value) {
                var value = this.getValue();
                value = value ? value.toLowerCase() : '';
                this.elements.value.setText(value);
            }
        },

        /**
         * Updates the selected color based on what has been entered in the hex color field.
         * @protected
         */
        _readInputFieldValue: function () {
            var fieldValue = this.elements.hexFieldInput.getValue();
            // Clean up the value a bit
            var cleanedValue = cleanRgbValue(fieldValue, true);

            // If it's changed, update the field
            if (cleanedValue !== fieldValue) {
                this.elements.hexFieldInput.setValue(cleanedValue);
            }

            // Update the rest now
            if (cleanedValue.length === 3 || cleanedValue.length === 6) {
                var sanitizedValue = cleanedValue.replace(/\-/g, 'Z');
                var newColor = Color.parse(sanitizedValue);
                this.setValue(newColor);
            }
        },

        /**
         * Overrides <UWA.Controls.Picker.toggle>
         */
        toggle: function (y) {
            this._parent.apply(this, arguments);
            if (y === false) {
                this._dispatchOnChange();
            }
        }
    });

    return UWA.namespace('Controls/ColorPicker', ColorPicker, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/DataGrid
 *
 */
define('UWA/Controls/DataGrid', [
    'UWA/Core',
    'UWA/Event',
    'UWA/String',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Controls/Scroller'
], function (UWA, Event, UWAString, Element, Abstract, Scroller) {
    'use strict';

    /**
     * Create a new header cell
     *
     * @param {Object} options options hash
     * @param {String} [options.tag='th'] element tag name
     * @param {String} [options.dataIndex=''] element index
     * @param {String} [options.text=''] element content
     * @param {Boolean} [options.isSorted=false] if this column is sorted
     * @param {Boolean} [options.sortReverse=false] if this column is sorted in reverse
     * order
     * @param {String} [options.className=''] custom class name for the element
     * @param {Boolean} [options.isFirst=false] if this element is a first an element close
     * to a border
     * @param {Boolean} [options.sortable=false] if this column can be sorted
     * @param {String} [options.color=false] element color
     *
     * @return {HTMLElement}
     */
    function createHeaderCell(options) {
        var result = UWA.createElement(options.tag || 'th', {
            'class': options.dataIndex,
            html: {
                tag: 'span',
                html: options.text
            }
        });

        if (options.sortable) {
            var sort = UWA.createElement('span', {
                'class': 'sort',
                'text': ''
            }).inject(result);

            result.addClassName('sortable');

            if (options.isSorted) {
                sort.setText(options.sortReverse ? 'D' : 'E');
            }
        } else {
            result.addClassName('no-sortable');
            if (!options.text) {
                result.addClassName('empty');
            }
        }

        if (options.className) {
            result.addClassName(options.className);
        }

        if (options.isFirst) {
            result.addClassName('first');
        }

        if (options.color) {
            result.setStyles({
                'background-color': options.color,
                'color': '#FFFFFF'
            });
        }

        return result;
    }

    /**
     * Create a new cell to display a data
     *
     * @param {Object} options options hash
     * @param {Object} [options.tag='td'] element tag name
     * @param {String} [options.dataIndex=''] element index
     * @param {String} [options.itemId=''] element id
     * @param {Function} [options.format] function used to format the text
     * @param {Any} [options.text=''] element data
     * @param {String} [options.className=''] custom class name for the element
     * @param {Boolean} [options.isFirst=false] if this element is a first an element close
     * to a border
     * @param {String} [options.color=false] element color
     */
    function createDataCell(options) {

        var result = UWA.createElement(options.tag || 'td', {
            'class': options.dataIndex,
            'data-itemId': options.itemId,
            'html': options.format ? options.format(options.text) : options.text
        });

        if (options.className) {
            result.addClassName(options.className);
        }

        if (options.isFixed) {
            result.addClassName('is-fixed');
        }

        if (options.isFirst) {
            result.addClassName('first');
        } else {
            result.addClassName('grid-data');
        }

        if (options.color) {
            var color = UWAString.hexToRgb(options.color, true);
            result.setStyle('background-color', 'rgba(' + color.toString() + ',0.2)');
        }

        return result;
    }


    var DataGrid = Abstract.extend(/** @lends module:UWA/Controls/DataGrid.UWA.Controls.DataGrid# */{ // bypass

       /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            className: '',
            data: null,
            columns: null,
            sortable: false,
            orderBy: '',
            sortReverse: false,
            scrollerOptions: {}
        },

        /**
         * @property {String} name - control name. Defaults to 'uwa-datagrid'
         * @protected
         */
        name: 'uwa-datagrid',

        /**
         * @property {Array} dataGrid - List of data
         * @protected
         */
        dataGrid: null,

        /**
         * @property {Array} columns - List of columns
         */
        columns: null,

        /**
         * Display a Data Grid.
         *
         * ##### Example
         *
         * ```
         * var dataGrid = new UWA.Controls.DataGrid({
         * className: 'table',
         * columns: [
         *    {
         *        text: 'Birthday',
         *        dataIndex: 'date',
         *        format: function (value) {
         *            return UWADate.strftime(value, '%X');
         *        },
         *        sortKey: function (value) {
         *            return value.getTime();
         *        }
         *    },
         *    {
         *        text: 'Name',
         *        dataIndex: 'name',
         *        sortKey: function (value) {
         *            return value.split(' ').slice(1).join(' ');
         *        }
         *    }
         * ],
         * data:[
         *    { 'date': new Date(), 'users': 'Foo Bar'}
         * ],
         * sortable: `true`
         * }).inject(widget.body);
         * `
         *
         * Output HTML:
         * ```html
         * <div class="uwa-datagrid table">
         * <table class="uwa-datagrid-table">
         *    <thead>
         *        <tr>
         *            <th>Birthday</th>
         *            <th>Name</th>
         *        </tr>
         *    </thead>
         *    <tbody>
         *        <tr>
         *            <td>2012 07 06</td>
         *            <td>Foo Bar</td>
         *        </tr>
         *    </tbody>
         * </table>
         * </div>
         * ```
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className=''] - The DataGrid CSS class for theming
         * @param {String} [options.data=null] - Grid data
         * @param {Object} [options.columns=null] - Grid columns
         * @param {Boolean} [options.sortable=false] - The DataGrid is sortable belong the columns
         * @param {Object} [options.scrollerOptions={}] - Options for scroller
         *
         * @constructs UWA.Controls.DataGrid
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/DataGrid
         */
        init: function (options) {
            this._parent(options);

            this.dataGrid = options.data;
            this.columns = options.columns;

            this.buildSkeleton();
            this.fillGrid();
            this.initEvents();
        },

        /**
         * Build main dom elements
         * @protected
         */
        buildSkeleton: function () {
            var options = this.options,
                elements = this.elements;

            elements.container = UWA.createElement('div', {
                'class': this.getClassNames()
            });

            elements.grid = UWA.createElement('table', {
                'class': this.getClassNames('-table')
            }).inject(elements.container);

            if (options.sortable) {
                elements.grid.addClassName('sortable');
            }
        },

        /**
         * Register an Event delegation for all dataGrid click events.
         * @protected
         */
        initEvents: function () {
            this.elements.container.addEvent('click', this.handleEvent.bind(this));
        },

        /**
         * Implements EventHandler interface (DOM2).
         *
         * @protected
         * @param {UIEvent} e - Browser event
         */
        handleEvent: function (e) {
            var elm = Event.getElement(e).getClosest('th');

            if (this.options.sortable && elm && !elm.hasClassName('no-sortable')) {
                this.onOrderColumn(elm.className.split(' ')[0]);
            }
        },

        /**
         * Fill grid with data
         */
        fillGrid: function () {
            this.fillHeader();
            this.fillBody();
        },

        /**
         * Fill header of grid
         */
        fillHeader: function () {
            var i, l, tr,
                elements = this.elements,
                cm = this.columns;

            elements.grid.empty();

            tr = UWA.createElement('tr').inject(elements.grid);

            for (i = 0, l = cm.length; i < l; i++) {
                createHeaderCell({
                    isSorted: this.options.orderBy === cm[i].dataIndex,
                    sortReverse: this.options.sortReverse,
                    className: cm[i].className,
                    dataIndex: cm[i].dataIndex,
                    text: cm[i].text,
                    isFirst: cm[i].isFirst,
                    sortable: this.options.sortable && !cm[i].noSortable,
                    color: cm[i].color
                }).inject(tr);
            }
        },

        /**
         * Fill body of grid
         */
        fillBody: function () {
            var i, l, j, k, tr,
                elements = this.elements,
                options = this.options,
                cm = this.columns,
                data = this.dataGrid;

            if (options.sortable && options.orderBy) {
                data = this.sortData();
            }

            for (i = 0, l = data.length; i < l; i++) {
                tr = UWA.createElement('tr').inject(elements.grid);

                for (j = 0, k = cm.length; j < k; j++) {
                    var dataCell = data[i][cm[j].dataIndex];
                    createDataCell({
                        text: dataCell,
                        isFixed: data[i].isFixed || cm[j].isFixed,
                        className: (data[i].className || '') + ' ' + (cm[j].className || ''),
                        dataIndex: cm[j].dataIndex,
                        itemId: UWA.is(dataCell, 'object') && dataCell.itemId,
                        format: cm[j].format,
                        isFirst: cm[j].isFirst,
                        color: cm[j].color
                    }).inject(tr);
                }
            }
        },

        /**
         * sort Data
         *
         * @return {Array} data.
         */
        sortData: function () {
            var options = this.options,
                data = this.dataGrid,
                cm = this.columns.filter(function (item) { return item.dataIndex === options.orderBy; })[0];

            data.sort(function (a, b) {
                var valueA, valueB;
                valueA = cm.sortKey ? cm.sortKey(a[options.orderBy]) : a[options.orderBy];
                valueB = cm.sortKey ? cm.sortKey(b[options.orderBy]) : b[options.orderBy];

                if (valueA < valueB) {
                    return (!options.sortReverse) ? -1 : 1;
                }
                if (valueA > valueB) {
                    return (!options.sortReverse) ? 1 : -1;
                }

                return 0;
            });

            return data;
        },

        /**
         * Order column
         *
         * @param {String} column - Column selected
         */
        onOrderColumn: function (column) {
            var options = this.options;

            if (options.orderBy === column) {
                options.sortReverse = !options.sortReverse;
            } else {
                options.sortReverse = false;
            }

            options.orderBy = column;

            this.fillGrid();

            if (this.scroller) {
                this.scroller.updateFixedHeaders(this.elements.grid);
            }

            this.dispatchEvent('updateSortOptions', options);
        },

        /**
         * Update data of the grid
         *
         * @param {Array} columns - Columns.
         * @param {Array} data - Data
         */
        updateData: function (columns, data) {
            this.dataGrid = data;
            this.columns = columns;
            this.fillGrid();

            if (this.scroller) {
                this.updateScroller();
            }
        },

        /**
         * Add Scroller
         */
        addScroller: function () {
            this.scroller = new DataGrid.GridScroller(this.elements.grid, UWA.extend({
                _root: false
            }, this.options.scrollerOptions));
        },

        /**
         * Update Scroller
         */
        updateScroller: function () {
            if (this.scroller) {
                this.scroller.destroy();
            }
            this.addScroller();
        }
    });

    /**
     * @class UWA.Controls.DataGrid.GridScroller
     * @classdesc rovides Add a scroller with fixed positions.
     * @extends UWA.Controls.Scroller
     * @memberof module:UWA/Controls/DataGrid
     */
    DataGrid.GridScroller = Scroller.extend(/** @lends module:UWA/Controls/DataGrid.UWA.Controls.DataGrid.GridScroller# */{ // bypass
        defaultOptions: {
            lockDirection: false
        },

        init: function (container) {
            this._parent.apply(this, arguments);
            this.updateFixedHeaders(container);
        },

        _buildFixedHeaders: function (table) {
            var fixedHeaders = this._getFixedHeadersSize(table),
                top = fixedHeaders.top,
                left = fixedHeaders.left;

            if (fixedHeaders.left) {
                fixedHeaders.left = this._buildFixedHeader(table, fixedHeaders.left, Infinity);
            }
            if (fixedHeaders.bottom) {
                fixedHeaders.bottom = this._buildFixedHeader(table, Infinity, -fixedHeaders.bottom);
            }
            if (fixedHeaders.right) {
                fixedHeaders.right = this._buildFixedHeader(table, -fixedHeaders.right, Infinity);
            }
            if (fixedHeaders.top) {
                fixedHeaders.top = this._buildFixedHeader(table, Infinity, fixedHeaders.top);
                if (fixedHeaders.left) {
                    fixedHeaders.topLeft = this._buildFixedHeader(table, left, top);
                }
            }

            this._fixedHeaders = fixedHeaders;
        },

        _isHeaderCell: function (el) {
            return Element.getTagName.call(el) === 'th' || Element.hasClassName.call(el, 'is-fixed');
        },

        _getFixedHeadersSize: function (table) {
            var fixedColumns = { top: 0, bottom: 0, left: Infinity, right: Infinity },
                tableStarting = true,
                that = this;

            Element.getElements.call(table, 'tr').forEach(function (tr) {
                var left = 0,
                    right = 0,
                    rowStarting = true;
                Element.getChildren.call(tr).forEach(function (child) {
                    if (that._isHeaderCell(child)) {
                        if (rowStarting) {
                            left++;
                        }
                        right++;
                    } else {
                        rowStarting = false;
                        right = 0;
                    }
                });
                fixedColumns.left = Math.min(fixedColumns.left, left);
                fixedColumns.right = Math.min(fixedColumns.right, right);
                if (rowStarting) {
                    if (tableStarting) {
                        fixedColumns.top++;
                    }
                    fixedColumns.bottom++;
                } else {
                    tableStarting = false;
                    fixedColumns.bottom = 0;
                }
            });
            return fixedColumns;
        },

        _buildFixedHeader: function (table, width, height) {
            function slice(list, size) {
                return size < 0 ? list.slice(size) : list.slice(0, size);
            }
            var result,
                content = {
                    tag: 'tbody',
                    html: []
                },
                fullSize = { width: 0, height: 0 },
                firstLine = true;

            slice(Element.getElements.call(table, 'tr'), height).forEach(function (tr) {
                var line = {
                        tag: 'tr',
                        html: []
                    },
                    dimensions = Element.getDimensions.call(tr);
                fullSize.height += dimensions.outerHeight;
                content.html.push(line);
                slice(Element.getChildren.call(tr), width).forEach(function (cell) {
                    var dimensionsCell = Element.getDimensions.call(cell),
                        clone = cell.cloneNode(true);
                    Element.setStyles.call(clone, {
                        width: dimensionsCell.innerWidth,
                        height: dimensionsCell.innerHeight
                    });
                    if (firstLine) {
                        fullSize.width += dimensionsCell.outerWidth;
                    }
                    line.html.push(clone);
                });
                firstLine = false;
            });

            result = table.cloneNode();
            Element.set.call(result, {
                html: content,
                styles: fullSize
            });
            Element.addClassName.call(result, 'fixed-column');

            this.elements.scroller.grab(result);
            return result;
        },

        _updateHeaderPositions: function (newPosition) {
            var fixedHeaders = this._fixedHeaders;
            if (fixedHeaders.top) {
                Element.setPosition.call(fixedHeaders.top, { y: 0, x: newPosition.x});
            }
            if (fixedHeaders.left) {
                Element.setPosition.call(fixedHeaders.left, { y: newPosition.y, x: 0 });
            }
            if (fixedHeaders.right) {
                Element.setPosition.call(fixedHeaders.right, {
                    y: newPosition.y,
                    x: this.scroll.width - Element.getSize.call(fixedHeaders.right).width
                });
            }
            if (fixedHeaders.bottom) {
                Element.setPosition.call(fixedHeaders.bottom, {
                    x: newPosition.x,
                    y: this.scroll.height - Element.getSize.call(fixedHeaders.bottom).height
                });
            }
            if (fixedHeaders.topLeft) {
                Element.setPosition.call(fixedHeaders.topLeft, { y: 0, x: 0 });
            }
        },

        updateFixedHeaders: function (container) {
            var name;
            if (this._fixedHeaders) {
                for (name in this._fixedHeaders) {
                    if (this._fixedHeaders[name]) {
                        Element.destroy.call(this._fixedHeaders[name]);
                    }
                }
            }
            this._buildFixedHeaders(container);
            this._updateHeaderPositions(this.position);
        },

        onScroll: function () {
            this._parent.apply(this, arguments);
            this._updateHeaderPositions(this.getPosition(true));
        }
    });

    return UWA.namespace('Controls/DataGrid', DataGrid, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout
*/

/**
 * @module   UWA/Controls/DatePicker
 *
 */
define('UWA/Controls/DatePicker', [
    'UWA/Core',
    'UWA/Date',
    'UWA/Event',
    'UWA/Controls/Calendar',
    'UWA/Controls/Abstract',
    'UWA/Controls/Picker'
], function (UWA, UWADate, Event, Calendar, Abstract, Picker) {
    'use strict';

    var DatePicker;

    /**
     * The DatePicker component is designed to provide date or date range picker control.
     *
     * ##### Available Events
     *
     * | Event            |  Description                           |
     * | ---------------- | -------------------------------------- |
     * | `onDateSelect`   | Triggered when a Date has been selected by the user (argument is the Date object) |
     * | `onChange`       | Triggered when a Date has been selected by the user (argument is the value of the input) |
     *
     *
     * ##### Examples
     *
     * __Example 1__: Setup a date picker
     *
     * ```
     * var datePicker = new UWA.Controls.DatePicker({
     *     type: 'date',
     *     format: '%e %b %Y'
     * }).addEvent('onDateSelect', function (date) {
     *     // Do someting with date
     * }).inject(container);
     * ```
     *
     * __Example 2__: Setup a date picker from an existing input element
     *
     * ```
     * var datePicker = new UWA.Controls.DatePicker({element: input}).inject(form);
     *
     * // Do something on form submit
     * // (you can alternatively handle the 'onDateSelect' DatePicker event)
     * form.addEvent('submit', function (e) {
     *     var timestamp = input.value;
     *     // ...
     *     UWA.Event.preventDefault(e);
     * });
     * ```
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {String} [options.format=''] - Date format to use to display the current date value
     * @param {String} [options.calendarOptions=''] - Calendar options such as 'limit'
     * @param {Element} [options.button] - A DOM element or descriptor to display the button
     * @param {Boolean} [options.time] - hether the datepicker should ask for the time after setting the date
     * @param {String} [options.utc=''] - Whether ask for an UTC date or a local date.
     *
     * @class UWA.Controls.DatePicker
     * @extends module:UWA/Controls/Picker.UWA.Controls.Picker
     * @memberof module:UWA/Controls/DatePicker
     */
    DatePicker = Picker.extend(/** @lends module:UWA/Controls/DatePicker.UWA.Controls.DatePicker# */{ // bypass

        /**
         * @property {String} name - The Calendar name. Default: 'uwa-datepicker'
         * @protected
         */
        name: 'uwa-datepicker',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        options: {
            //date: undefined,
            format: '%x',
            calendarOptions: { },
            button: { 'tag': 'div', 'class': 'uwa-icon uwa-icon-only calendar' },
            time: false,
            utc: false
        },

        setOptions: function (options) {
            if (!options) {
                options = {};
            }
            if (options.date) {
                options.value = options.date / 1000;
            }
            return this._parent(options);
        },

        syncInput: function () {
            var elements = this.elements,
                date = this.getDate();

            if (elements.value) {
                elements.value.setText(date ? UWADate.strftime(date, this.options.format) : '');
            }
            if (elements.calendar) {
                elements.calendar.setDate(date);
            }
            if (elements.time && date) {
                elements.time.getElement('.value').setText(UWADate.strftime(date, '%x'));
                elements.time.getElements('input').forEach(function (input) {
                    input.value = date['get' + input.getAttribute('data-action')]() || '';
                });
            }
        },

        onChange: function () {
            this.dispatchEvent('onDateSelect', [this.getDate()]);
        },

        onOpen: function () {
            this._parent();
            var elements = this.elements;
            elements.calendar.refreshLimit();
            if (elements.time) {
                elements.time.hide();
                elements.calendar.show();
            }
        },

        buildContent: function () {
            var that = this,
                timeChange;

            function dateSelectListener(newDate) {
                var date = that.getDate();
                if (date) {
                    date.setDate(newDate.getDate());
                    date.setMonth(newDate.getMonth());
                    date.setFullYear(newDate.getFullYear());
                } else {
                    date = newDate;
                }

                that.setDate(date);

                if (that.options.time) {
                    that.elements.calendar.hide();
                    that.elements.time.show().getElement('input').select();
                    that.elements.dropdown.updatePosition();
                } else {
                    that.toggle(false);
                    that.dispatchEvent('onChange', [that.getValue()]);
                }
            }

            timeChange = function (e) {
                var input = this,
                    key = Event.whichKey(e);

                if (key.length === 1 && isNaN(key)) {
                    Event.preventDefault(e);
                }

                // Waits until the value is set
                setTimeout(function () {
                    var inputs, nextIndex,
                        date = that.getDate() || new Date();

                    date['set' + input.getAttribute('data-action')](input.value);
                    that.setDate(date);

                    if (input.value.length >= 2) {
                        inputs = that.elements.time.getElements('input');
                        nextIndex = (inputs.indexOf(input) + 1) % inputs.length;

                        inputs[nextIndex].select();
                    }
                }, 1);
            };

            that.elements.content = UWA.createElement('div', {
                html: [

                    that.elements.calendar = new Calendar(UWA.extend({ _root: false }, that.options.calendarOptions))
                        .setDate(this.getDate())
                        .addEvent('onDateSelect', dateSelectListener),

                    that.elements.time = that.options.time && UWA.createElement('div', {
                        'class': that.getClassNames('-time'),
                        html: [{
                            tag: 'div',
                            'class': 'value'
                        }, {
                            tag: 'input',
                            type: 'text',
                            'class': that.getClassNames('-text'),
                            'data-action': 'Hours',
                            events: {
                                keydown: timeChange
                            }
                        }, ':', {
                            tag: 'input',
                            type: 'text',
                            'class': that.getClassNames('-text'),
                            'data-action': 'Minutes',
                            events: {
                                keydown: timeChange
                            }
                        }]
                    }).hide()
                ]
            });

            return that.elements.content;
        },

        /**
         * Overrides <UWA.Controls.Picker.buildNavigationItem>
         */
        buildNavigationItem: function (item) {
            if (item.date) {
                item.value = item.date / 1000;
            }
            return this._parent(item);
        },

        /**
         * Set current date.
         *
         * @param {Date} date
         * @return {this}
         */
        setDate: function (date) {
            if (date && this.options.utc) {
                date = date.getTime() - date.getTimezoneOffset() * 60000;
            }
            return this.setValue(date / 1000 || '');
        },

        /**
         * Get the current date.
         *
         * @return {Date}
         */
        getDate: function () {
            var value = this.getValue();
            if (value) {
                if (this.options.utc) {
                    value = Number(value) + new Date().getTimezoneOffset() * 60;
                }
                return new Date(value * 1000);
            }
        },

        /*
          Method; setLimit

            Set the calendar limit. See <UWA.Controls.Calendar.setLimit>

          Parameters:
            * Object limit: an object with two optional properties 'min' and
              'max'. See Calendar limit documentation.

          Returns:
            * this
        */
        setLimit: function (limit) {
            if (this.elements.calendar) {
                this.elements.calendar.setLimit(limit);
            } else {
                this.setOptions({calendarOptions: {limit: limit}});
            }
            return this;
        }

    });

    return UWA.namespace('Controls/DatePicker', DatePicker, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Ellipsis
 *
 */
define('UWA/Controls/Ellipsis', [
    'UWA/Core',
    'UWA/Controls/Abstract'
], function (UWA, Abstract) {
    'use strict';

    var Ellipsis = Abstract.extend(/** @lends module:UWA/Controls/Ellipsis.UWA.Controls.Ellipsis# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            reference: null, // element to use to check the size limit (default to the element passed in contructor)
            refreshOn: [], // auto refresh on specified events (example: resize, update)
            ellipsis: '&#8230;', // could be any html element / descriptive object / string
            spaces: /[\s,.:]+/g // a regular expression that match every spaces in a string
        },

        /**
         * Display a web content through an iframe.
         *
         * @param {Element} element - The target element who contains a string to cut.
         * Should be overflow: hidden; to avoid flashing effect when computing.
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.reference=null] - Element to use to check
         * the size limit (default to the element passed in contructor)
         * @param {String} [options.refreshOn='100%'] - Auto refresh
         * on specified events (example: resize, update)
         * @param {String} [options.ellipsis='&#8230;']
         *
         * @constructs UWA.Controls.Ellipsis
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Ellipsis
         */
        init: function (element, options) {

            this._parent(options);

            options = this.options;

            this.element = element;
            this.ellipsis = UWA.createElement('span', {
                html: this.options.ellipsis
            });
        },

        /**
         * Destroy this instance
         */
        destroy: function () {
            this.ellipsis.destroy();
        },

        /**
         * Refresh the ellipsis posisition.
         *
         * @return {Ellipsis} this Ellipsis
         */
        onRefresh: function () {

            var count, inc, diff, oldDiff, maxAttempt,
                element = this.element,
                options = this.options,
                reference = options.reference || element;

            if (element.offsetWidth) {

                this.dispatchEvent('onPreRefresh');

                // Calculate the total words once TODO recalculate if content changes
                if (!this.totalWords) {
                    this.totalWords = this.computeData(element);
                }

                count = Math.floor(this.totalWords / 2);
                inc = Math.ceil(count / 2) || 1;

                // Append the ellipsis element
                element.appendChild(this.ellipsis);

                // Try to find the closest word count that the element can contain.
                for (maxAttempt = 10; maxAttempt > 0; maxAttempt -= 1) {
                    this.setWordCount(element, count);
                    // tolerate one pixel more, because of a webkit bug
                    diff = reference.offsetHeight + 1 < reference.scrollHeight;

                    // Element can contain everything
                    if (count >= this.totalWords && !diff) {
                        element.removeChild(this.ellipsis);
                        break;
                    }

                    // We are close to the limit
                    if (inc === 1) {
                        // We crossed the limit !
                        if (oldDiff !== undefined && oldDiff !== diff) {
                            break;
                        }
                        oldDiff = diff;
                    }

                    count += diff ? -inc : inc;
                    inc = Math.ceil(inc / 2);
                }

                // The limit where crossed from left to right, so there is one
                // extra word.
                if (diff) {
                    this.setWordCount(element, count - 1);
                }

                this.dispatchEvent('onPostRefresh');
            }

            return this;
        },

        /**
         * Set the number of words to display in an element.
         *
         * @param {Element} element - Targeted element
         * @param {Integer} count - Maximum number of words to set
         * @return {Number} Number of words set
         */
        setWordCount: function (element, count) {
            var childrenLength, text, spaces, spacesLength, i, child,
                localCount = count;

            // Ignore the ellipsis element
            if (element === this.ellipsis) {
                return 0;
            }

            // Hide or display element
            if (element !== this.element) {
                element.style.display = count ? '' : 'none';
            }

            if (count || element === this.element) {

                childrenLength = element.childNodes.length;

                // Empty elements count as one word (<br>, <img>, <span></span>...)
                if (!childrenLength) {
                    localCount = count - 1;

                } else {
                    // Else we compute the total of the children words
                    for (i = 0; i < childrenLength; i += 1) {
                        child = element.childNodes[i];

                        if (child.nodeType === 3) { // text node
                            spaces = element.ellipsisData[i].spaces;
                            text = element.ellipsisData[i].original;
                            spacesLength = spaces.length;

                            child.data =
                                // If there is 0 words to set, put a blank string
                                !localCount ? '' :
                                // If the string has one or 'count' words, put the
                                // whole string
                                        !spacesLength || spacesLength + 1 <= localCount ?
                                                text :
                                // Else, put 'count' words of the string
                                                        text.substr(0, spaces[localCount - 1] || 0);

                            localCount -= Math.min(localCount, spacesLength + 1);

                        } else if (child.nodeType === 1) { // element
                            localCount -= localCount -
                                this.setWordCount(child, localCount);
                        }
                    }
                }
            }
            return localCount;
        },

        /**
         * Cache the words positions and the original text in the element tree
         *
         * @param {DOMElement} element - The root element
         * @return {Number} The total count of words
         */
        computeData: function (element) {
            var ic, lc, i, l, child, spaceLength,
                spaces, text, index,
                data = element.ellipsisData = [],
                children = element.childNodes,
                result = 0;

            for (ic = 0, lc = children.length; ic < lc; ic += 1) {
                child = children[ic];
                if (child.nodeType === 3) { // text node

                    data[ic] = {
                        // Store the original text
                        original: text = child.data,
                        // Retrive the spaces
                        spaces: spaces = text.match(this.options.spaces) || []
                    };

                    // Replace blanks by their indexes in the string
                    for (i = 0, l = spaces.length; i < l; i += 1) {
                        index = text.indexOf(spaces[i],
                                             i ? index + spaceLength : 0);
                    // console.log(text.substring(i ? spaces[i-1] + spaceLength : 0, index)); // bypass
                        spaceLength = spaces[i].length;
                        spaces[i] = index;
                    }
                    // console.log(text.substring(i ? index + spaceLength : 0)); // bypass

                    // If the string terminates by a space, merge it with the
                    // last word
                    if (spaces[l - 1] + spaceLength === text.length) {
                        spaces.pop();
                    }

                    // If the string starts with a space, merge it with the first
                    // word
                    if (spaces[0] === 0) {
                        spaces.shift();
                    }
                    result += spaces.length + 1;
                } else if (child.nodeType === 1) { // element
                    result += this.computeData(child);
                }
            }
            return result;
        }
    });

    return UWA.namespace('Controls/Ellipsis', Ellipsis, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Controls/ToolTip
 *
 */
define('UWA/Controls/ToolTip', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Controls/Abstract',
    'UWA/Element',
    'UWA/Class/Timed',
    'UWA/Utils/Client',
    'UWA/Controls/DropDown'
], function (UWA, Event, Abstract, Element, Timed, Client, DropDown) {
    'use strict';

    var dropdownOriginalClassNames;

    /**
     * The cached object containing the pointy DropDown object used in the ToolTip
     *
     * @type {Object}
     */
    var cachedDropdown = new DropDown.Pointy({
        autoPosition: ['below-start', 'right-start', 'left-start', 'above-start'],
        margin: 20,
        positionOptions: {
            relative: document.querySelector('body') // the position we'll set is relative to the full page
        }
    });

    var cachedTimed = new Timed();

    var ToolTip = Abstract.extend(/** @lends module:UWA/Controls/ToolTip.UWA.Controls.ToolTip# */{

            /**
             * @property {String} name - The toolTip name. Default: 'uwa-toolTip'
             * @protected
             */
            name: 'uwa-tooltip',

            /*
              Property: content
                *String*: The current tooltip content.
             */
            content: '',

            /*
              Property: defaultOptions
                *Object*: The default controls options.
             */
            defaultOptions: {
                id: 'uwa-tooltip',
                className: '',
                width: 'auto',
                delay: 800,
                showOver: true,
                root: null
            },


            mousePosition: {},

            /*
             * Todo:
             * - Touch position
             */

            /**
             * Add a tool tip to an element on mouseover.
             *
             * The tooltip, if used in an iFramed widget, will be constrained inside it,
             * "smartly" positionned.
             *
             * If a DOM element has a "uwa-tooltip" attribute containing some HTML, a
             * tooltip will be displayed when the user hover it with the mouse.
             *
             * ##### Available Events
             *
             * | Event            |  Description                           |
             * | ---------------- | -------------------------------------- |
             * | `onShowTooltip`  | Invoked when tooltip appear            |
             * | `onHideTooltip`  | Invoked when tooltip disappear         |
             * | `onMoveTooltip`  | Invoked when tooltip move              |
             *
             *
             * ##### Available CSS Classes
             *
             * | Class name       |  Description                           |
             * | ---------------- | -------------------------------------- |
             * | `light-grey`     | Dark text on light background          |
             * | `dark-grey`      | White text on grey background          |
             *
             *
             * @example
             * var myTooltipedLink = widget.createElement('a',{
             *     text: "my Tooltiped Link"
             * }).inject(widget.body),
             *
             * myTooltipContent = 'this is a tooltip with <span class="color: red;">html</span>', // Use UWA.String.stripTags() to remove HTML
             *
             * myTooltip = new UWA.Controls.ToolTip(myTooltipedLink, myTooltipContent, {
             *     className: 'dark-grey',
             *     delay: 200,
             *     width: 200
             * });
             *
             * // Display Tooltip on the top left corner of tooltiped element
             * myTooltip.show({
             *     x: '0',
             *     y: '0'
             * });
             *
             *
             * var anotherTooltipedLink = widget.createElement('a', {
             *     'data-tooltip': 'Hello <strong>World!</strong>'
             * });
             *
             * @param {Element} element - Element which will attached to tooltip position
             * @param {String} content - Text writted in the tooltip
             * @param {Object} options -  Options hash or a option/value pair
             * @param {String} [options.className=''] - Tooltip container className
             * @param {Number} [options.delay=800] - Delay before tooltip is shown
             * @param {Number} [options.width='auto'] - Width of tooltip in pixel
             * @param {Boolean} [options.showOver=true] - Display tooltip when mouse is over tooltiped element
             * @param {Element} [options.root] - The element that will contains the tooltip
             * (default: element offsetParent)
             *
             * @constructs UWA.Controls.ToolTip
             * @extends UWA.Controls.Abstract
             * @memberof module:UWA/Controls/ToolTip
             */
            init: function (element, content, options) {

                // Call parent init
                this._parent(options);

                // Set content value
                this.content = content || '';

                // Store tooltipped element
                this._tooltipped = UWA.extendElement(element);

                // Add initial event
                this._attachEvents();
            },

            destroy: function () {
                this.hide();
                this._detachEvents();
                this._parent();
            },

            _attachEvents: function () {
                if (!this._events) {
                    var events = this._events = {
                        tooltipped: {},
                        tooltippedOnShown: {},
                        bodyOnShown: {}
                    };

                    if (this.options.showOver) {
                        events.tooltipped.mouseover = this.dispatchAsEventListener('onShowTooltip');
                        events.tooltippedOnShown.mouseout = this.dispatchAsEventListener('onHideTooltip');
                        events.tooltippedOnShown.click = this.dispatchAsEventListener('onHideTooltip');
                        // Make sure we hide the tooltip when the cursor is moved
                        // anywhere on the body
                        events.bodyOnShown.mousemove = this.dispatchAsEventListener('onMoveTooltip');
                    }
                }

                this._tooltipped.addEvents(this._events.tooltipped);
            },

            _detachEvents: function () {
                if (this._events) {
                    this._tooltipped.removeEvents(this._events.tooltipped);
                    this._tooltipped.removeEvents(this._events.tooltippedOnShown);
                    Element.removeEvents.call(document.querySelector('body'), this._events.bodyOnShown, true);
                }
            },

            /**
             * Build main dom elements
             */
            buildSkeleton: function () {

                var tooltip,
                    that = this,
                    options = that.options,
                    document = Element.getDocument.call(that._tooltipped),
                    root = that.getRootNode(),
                    rootChildren = Element.getChildren.call(root),
                    tooltipId = options.id,
                    count = 0;

                while (true) {
                    tooltip = document.getElementById(options.id);
                    // This id is not taken, or the tooltip is at a good place
                    if (!tooltip || rootChildren.indexOf(tooltip) >= 0) {
                        break;
                    } else {
                        // Increment id
                        options.id = tooltipId + '-' + count++;
                    }
                }

                // only one tooltip at the time
                if (!tooltip) {
                    tooltip = cachedDropdown.getContent();
                    tooltip.id = options.id;

                    if (dropdownOriginalClassNames === undefined) {
                        dropdownOriginalClassNames = tooltip.className;
                    }
                    tooltip.set('class', dropdownOriginalClassNames + ' ' + this.getClassNames());
                    tooltip.setStyle('width', options.width);
                    tooltip.inject(root);
                }

                // Store tooltip Element
                that._tooltip = tooltip;

                return tooltip;
            },

            /**
             * Check if the element focused by the tooltip is currently visible and hover
             * by the mouse
             *
             * @protected
             * @return {Boolean}
             */
            _tooltippedIsActive: function () {
                var tooltipped = this._tooltipped;

                function isVisible(el) {
                    var styles = el.getStyles(['visibility', 'opacity']);
                    return styles.visibility !== 'hidden' && styles.opacity > 0.5;
                }

                var visible = isVisible(tooltipped) && tooltipped.getParents().every(isVisible);
                var clientScrolls = Client.getScrolls();
                var elementUnderCursor = document.elementFromPoint(
                    this.mousePosition.x - clientScrolls.x,
                    this.mousePosition.y - clientScrolls.y
                );
                var hover = Element.isInjected.call(elementUnderCursor, tooltipped) || elementUnderCursor === tooltipped;

                return visible && hover;
            },

            /**
             * Show tooltip.
             *
             * @param {Object|String} position - Object with x and y property in pixel or String width value center/top/left/right
             *
             * @return {this}
             */
            show: function (position, centered) {

                var i, axis, dimensions, positionOptions, tooltipSize,
                    that = this,
                    is = UWA.is,
                    tooltip = that._tooltip,
                    tooltipped = that._tooltipped;

                if (!position && !this._tooltippedIsActive()) {
                    return;
                }

                if (!tooltip) {
                    tooltip = that.buildSkeleton();
                }
                cachedDropdown.getInnerElement().setContent(that.content);
                tooltip.show();

                // If no position display at element current position
                if (!is(position)) {
                    position = that.mousePosition;
                    positionOptions = { relative: document.querySelector('body') };
                } else if (
                    is(position, 'string') || (is(position, 'object') && is(position.x, 'string') && is(position.y, 'string'))
                ) {
                    position = tooltipped.getPosition(false, position);
                    positionOptions = { relative: this._tooltipped.getOffsetParent() };

                    // If position of tooltip should be centered remove half of size from position
                    if (centered) {
                        tooltipSize = tooltip.getDimensions();

                        for (i = 0; i < 2; i += 1) {
                            axis = i ? 'x' : 'y';
                            dimensions = i ? 'width' : 'height';
                            position[axis] = position[axis] - (tooltipSize[dimensions] / 2);
                        }
                    }
                }

                tooltip.addClassName('show');
                cachedDropdown.setPosition(position, positionOptions);
                that.visible = true;

                return that;
            },

            /**
             * Hide tooltip.
             */
            hide: function () {

                var that = this,
                    tooltip = that._tooltip;

                if (that.visible) {
                    tooltip.removeClassName('show');
                    tooltip.hide();
                }

                cachedTimed.clearDelayed();

                // Set Visible
                that.visible = false;

                return that;
            },

            /**
             * Toggle visibility of tooltip.
             */
            toggle: function () {

                var that = this;

                if (that.visible) {
                    that.hide();
                } else {
                    that.show();
                }
            },

            /**
             * Put a delay before showing tooltip
             */
            setDelay: function () {
                var that = this,
                    options = that.options,
                    delay = options.delay;

                if (!that.visible) {
                    cachedTimed.setDelayed('tooltip', function () {
                        that.show();
                    }, delay);
                }
            },

            /**
             * Invoked when tooltip appear.
             *
             * @param {Event} event - A mouse-related DOM event
             */
            onShowTooltip: function (event) {

                var that = this;

                that.mousePosition = Event.getPosition(event);

                this._tooltipped.addEvents(this._events.tooltippedOnShown);
                Element.addEvents.call(document.querySelector('body'), this._events.bodyOnShown, null, null, true);

                if (this.options.delay) {
                    that.setDelay();
                } else {
                    that.show();
                }
            },

            /**
             * Invoked when tooltip move.
             *
             * @param {Event} event - A mouse-related DOM event
             */
            onMoveTooltip: function (event) {
                var that = this,
                    options = that.options,
                    delay = options.delay;

                that.mousePosition = Event.getPosition(event);

                if (delay > 0) {
                    that.hide();
                    that.setDelay();
                } else {
                    cachedDropdown.setPosition(that.mousePosition);
                }
            },

            /**
             * Invoked when tooltip disappear.
             */
            onHideTooltip: function () {
                this._tooltipped.removeEvents(this._events.tooltippedOnShown);
                Element.removeEvents.call(document.querySelector('body'), this._events.bodyOnShown, true);

                this.hide();
            },

            getRootNode: function () {
                return this.options.root || this._tooltipped.getOffsetParent();
            }
        });

        Event.onDomReady(function () {
            // Don't show the tooltip on touch devices
            var isTouch = Client.Features.touchEvents;
            if (isTouch) {
                return;
            }
            Element.addEvent.call(document.querySelector('body'), 'mouseover [uwa-tooltip]', function (overEvent) {
                var target = Event.getElement(overEvent);
                if (!target || !target.getAttribute("uwa-tooltip")) {
                    return;
                }

                target.set('title', '');

                var tooltip = new ToolTip(target, target.getAttribute('uwa-tooltip'), {
                    root: document.querySelector('body'),
                    delay: Number(target.getAttribute('uwa-tooltip-delay')) || 800,
                    showOver: false
                });

                tooltip.dispatchEvent('onShowTooltip', [overEvent]);

                var events = {
                    'mousemove [uwa-tooltip]': function (e) {
                        tooltip.dispatchEvent('onMoveTooltip', [e]);
                    },
                    'mouseout [uwa-tooltip]': function (e) {
                        tooltip.dispatchEvent('onHideTooltip', [e]);
                        Element.removeEvents.call(document.querySelector('body'), events);
                    }
                };

                Element.addEvents.call(document.querySelector('body'), events);
            });
        });

    return UWA.namespace('Controls/ToolTip', ToolTip, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/EmbedToolTip
 *
 */
define('UWA/Controls/EmbedToolTip', [
    'UWA/Core',
    'UWA/Class/Timed',
    'UWA/Event',
    'UWA/Controls/ToolTip',
    'UWA/Element'
], function (UWA, Timed, Event, Tooltip, Element) {
    'use strict';

    /**
     * Add a tool tip to an element on mouseover, that embeds the tooltipped element.
     *
     * ##### Available Events
     *
     * | Event            |  Description                           |
     * | ---------------- | -------------------------------------- |
     * | `onShowTooltip`  | Invoked when tooltip appears           |
     * | `onHideTooltip`  | Invoked when tooltip disappears        |
     *
     * @example
     * var myElement = UWA.createElement({
     *     text: 'My Tooltip element'
     * }).inject(widget.body);
     *
     * var myEmbedTooltip = new UWA.Controls.EmbedToolTip(
     *     myElement,
     *     'my custom tooltip text',
     *     {width: 200}
     * );
     *
     * @param {Element} element - Element which will attached to tooltip position
     * @param {String} htmlText - Text writted in the tooltip
     * @param {Object} options - Options hash or a option/value pair
     * @param {String} [options.className='uwa-embedToolTip'] - Tooltip container className
     * @param {Number} [options.width=100] - Width of tooltip in pixel
     *
     * @class UWA.Controls.EmbedToolTip
     * @extends UWA.Controls.Tooltip
     * @mixes UWA.Class.Timed
     * @memberof module:UWA/Controls/EmbedToolTip
     */
    var EmbedToolTip = Tooltip.extend(Timed, /** @lends module:UWA/Controls/EmbedToolTip.UWA.Controls.EmbedToolTip# */ { // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
        */
        defaultOptions: {
            id: 'uwa-embedToolTip',
            className: 'uwa-embedToolTip',
            width: 100,
            overDelay: 1000,
            margin: 5
        },

        show: function () {
            var parent = this._parent,
                zIndex;

            if (!this._tooltip) {
                this.buildSkeleton();
            }

            // Delay the CSS computation and show call
            this.setDelayed('showEmbedToolTip', function () {
                // Store tooltipped size
                this._tooltippedSize = Element.getSize.call(this._tooltipped);
                // Store original tooltipped style
                this._originalStyle = Element.getStyles.call(this._tooltipped, ['z-index', 'position']);

                // Compute new zIndex
                zIndex = (parseInt(this._originalStyle['z-index'], 10) + 100) || 1000;

                // Set zIndex on tooltipped
                Element.setStyles.call(this._tooltipped, {
                    zIndex: String(zIndex),
                    position: 'relative'
                });

                // Set zIndex + some style from tooltipped on tooltip element
                Element.setStyles.call(this._tooltip, {
                    zIndex: String(zIndex - 1),
                    paddingBottom: this._tooltippedSize.height + this.options.margin,
                    width: Math.max(this.options.width, this._tooltippedSize.width)
                });

                parent.call(this);
                this._tooltip.show();
                this.setPosition();
            }, this.options.overDelay);
        },

        hide: function () {
            this._parent();
            this.clearDelayed('showEmbedToolTip');
            if (!this.options.fx) {
                // Restore the original tooltipped style
                Element.setStyles.call(this._tooltipped, this._originalStyle);
            } // else, restore style in fxComplete handler

        },

        setPosition: function () {
            this._tooltip.setPosition({
                x: -this.options.margin,
                y: -this._tooltip.getSize().height +
                    (this._tooltippedSize ? this._tooltippedSize.height : this._tooltipped.getSize().height) +
                    this.options.margin
            }, {relative: this._tooltipped});
        },

        fxCompleted: function () {
            this._parent();
            if (this.options.fx && !this.visible) {
                Element.setStyles.call(this._tooltipped, this._originalStyle);
            }

        }
    });

    return UWA.namespace('Controls/EmbedToolTip', EmbedToolTip, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Controls/FeedView
 *
 */
define('UWA/Controls/FeedView', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Event',
    'UWA/String',
    'UWA/Controls/Abstract',
    'UWA/Controls/Ellipsis',
    'UWA/Controls/Scroller',
    'UWA/Controls/Pager'
], function (UWA, Class, Event, UWAString, Abstract, Ellipsis, Scroller, Pager) { // jshint ignore:line
    'use strict';

    /*
      Class: UWA.Controls.FeedView

        TODO description.

      Todo:
        - Support ltr and rtl class on upper level (http://www.w3.org/TR/html4/struct/dirlang.html see widget.setDir)
        - add rtl support (widget.setDir('rtl'))
        - add doc + examples

      Extends:
        <UWA.Controls.Abstract>

      Available Options:
        > Options             Description                       Default value
        >  TODO

      Available Events:
        > Options             Description
        >  TODO

      Example:
        (start code)
        TODO
        (end code)
    */
    var FeedView = Abstract.extend({

        defaultOptions: {

            nbItems: 10,
            showDate: true,

            messages: {
                noItem: "There is no news in this feed.",
                loadMore: "Load more news.",
                websiteLink: "Go to website",
                readMore: "Read more"
            },

            images: {
                loader: UWA.hosts.uwa + UWA.paths.css + 'base/img/loader.gif',
                image: UWA.hosts.uwa + UWA.paths.css + 'base/img/article.png'
            },

            scroller: {
                //useNative: true,
                lockDirection: true,
                momentum: true,
                bounce: true
            },

            pager: {
                type: 0,
                showMoreLink: true
            }
        },

        pagerPosition: 'bottom',
        scrollPosition: 'top',

        itemPerPage: 0,

        init: function (options) {

            this._parent(options);

            this.itemsEllipsis = [];

            this.itemsImages = {
                loaded: [],
                loading: [],
                waiting: [],
                maxLoading: 2
            };

            this.buildSkeleton();
        },

        buildSkeleton: function () {

            var that = this,
                pagerPosition = that.pagerPosition;

            that.container = UWA.createElement('div', {
                'class': 'uwa-feedview content uwa-feedview-' +
                    that.viewName.replace(/ /g, ' uwa-feedview-'),
                events: {
                    resize: this.dispatchAsEventListener('onResize'),
                    mousedown: this.dispatchAsEventListener('onMouseDown')
                }
            });

            // Create Items list
            this.buildItems();

            // Create Scroller
            that.buildScroller();

            // Create pager
            if (pagerPosition) {

                if (['top', 'both'].indexOf(pagerPosition) !== -1) {
                    that.buildPager('top');
                }

                if (['bottom', 'both'].indexOf(pagerPosition) !== -1) {
                    that.buildPager('bottom');
                }
            }

            return that.container;
        },

        buildItems: function () {

            var that = this,
                options = that.options,
                messages = options.messages,
                elements = that.elements;

            elements.item = [];

            // Create itemlist
            elements.items = UWA.createElement('div', {
                'class': 'items'
            });

            elements.itemsActions = UWA.createElement('div', {
                'class': 'actions',
                html: [
                    {
                        tag: 'div',
                        'class': 'loadMore action',
                        html: {
                            tag: 'a',
                            href: '#',
                            text: UWA.i18n(messages.loadMore)
                        },
                        styles: {
                            display: 'none'
                        }
                    },
                    {
                        tag: 'div',
                        'class': 'noItem action',
                        text: UWA.i18n(messages.noItem),
                        styles: {
                            display: 'none'
                        }
                    },
                    {
                        tag: 'div',
                        'class': 'websiteLink action',
                        html: {
                            tag: 'a',
                            href: '#',
                            text: UWA.i18n(messages.websiteLink)
                        },
                        styles: {
                            display: 'none'
                        }
                    }
                ]
            }).inject(elements.items);

            // Injct pager into main container
            elements.items.inject(that.container);

            return elements.items;
        },

        buildScroller: function () {

            var that = this,
                elements = that.elements,
                scrollerOptions = UWA.merge({
                    events: {
                        onRefresh: function () {
                            that.refreshPager();
                            that.loadItemsImages();
                        },
                        onScrollEnd: function () {
                            that.loadItemsImages();
                        }
                    }
                }, that.options.scroller);

            // Create scrollarea has itemlist parent
            elements.scrollarea = UWA.createElement('div', {
                'class': 'scrollarea'
            }).grab(elements.items).inject(that.container, 'top');

            // Put a scroller arround itemlist
            that.scroller = new Scroller(
                that.elements.items,
                scrollerOptions
            );
        },

        setScrollerHeight: function (height) {

            if (this.pager) {
                height -= this.pager.getContent().getDimensions().outerHeight;
            }

            if (this.elements.top) {
                height -= this.elements.top.getDimensions().outerHeight;
            }

            if (this.elements.scrollarea) {
                this.elements.scrollarea.setStyle('height', height + 'px');
            } else {
                this.container.setStyle('height', height + 'px');
            }

            this.refreshScroller();
        },

        refreshScroller: function () {

            var that = this,
                scroller = that.scroller;

            if (scroller) {

                scroller.dispatchEvent('onRefresh');
            }
        },

        buildPager: function (position) {

            var that = this,
                pagerOptions = UWA.merge({
                    _root: false,
                    events: {
                        onOffsetChange: function (offset) {
                            var items = that.options.source.getItems();
                            that.showItem(items[offset]);
                        }
                    }
                }, that.options.pager);

            that.pager = new Pager(pagerOptions);

            // Inject pager into main container
            that.pager.inject(that.container, position);
        },

        refreshPager: function () {

            var items, itemIndex, itemsPerPage,
                that = this,
                pager = that.pager,
                options = that.options,
                source = options.source;

            if (pager) {

                items = source.getItems();
                itemsPerPage = that.getItemsPerPage();
                itemIndex = items.indexOf(that.currentItem);

                // Update More link
                pager.options.moreLink = source.getLink();

                // Update offsets
                pager.setLength(items.length);
                pager.setLimit(itemsPerPage);
                pager.setOffset(
                    itemIndex === -1 ? 0 : itemIndex
                );

                pager.dispatchEvent('onRefresh');
            }
        },

        getItemsPerPage: function () {

            var i, l,
                that = this,
                size = 0,
                items = that.elements.item;

            for (i = 0, l = items.length; i < l; i++) {
                if (that.scroller.isInViewport(items[i])) {
                    size++;
                }
            }

            that.itemPerPage = size;

            return that.itemPerPage;
        },

        buildItem: function (item) {

            var itemContainer,
                options = this.options,
                isRead = options.source.isItemRead(item),
                relativeDate = options.showDate && item.date ? UWAString.parseRelativeTime(item.date.toString()) : false;

            itemContainer = UWA.createElement('div', {
                'class': 'item ' + (isRead ? 'read' : 'unread'),
                html: {
                    tag: 'div',
                    'class': 'content',
                    html: {
                        tag: 'div',
                        'class': 'infos',
                        html: [
                            {
                                tag: 'div',
                                'class': 'title',
                                html: [
                                    {
                                        tag: 'a',
                                        'class': 'link ellipsis',
                                        href: item.link,
                                        html: UWAString.stripTags(item.title)
                                    },
                                    {
                                        tag: 'div',
                                        'class': 'separator'
                                    }
                                ]
                            },
                            relativeDate && {
                                tag: 'div',
                                'class': 'date',
                                html: [
                                    {
                                        tag: 'span',
                                        html: relativeDate
                                    },
                                    {
                                        tag: 'div',
                                        'class': 'separator'
                                    }
                                ]
                            }
                        ]
                    }
                },
                events: {
                    click: this.dispatchAsEventListener('onItemClick', item)
                }
            });

            // add ellipsised element
            this.addEllipsis({
                reference: itemContainer.getElement('.content'),
                element: itemContainer.getElement('.ellipsis')
            });

            // Add external links handler
            itemContainer.setData('href', item.link);
            itemContainer.setData('item-index', item.index);

            return itemContainer;
        },

        getItem: function (item) {

            var index = item.index,
                elements = this.elements.item;

            if (!elements[index]) {
                elements[index] = this.buildItem(item);
            }

            return elements[index];
        },

        getItems: function (items) {
            return items.map(this.getItem, this);
        },

        refreshItems: function () {

            var that = this,
                options = that.options,
                source = options.source,
                items = source.getItems();

            that.injectItems(items);
        },

        injectItems: function (items) {

            var that = this,
                itemsElements = that.getItems(items),
                nbItemsElements = itemsElements.length,
                elements = that.elements,
                options = that.options,
                source = options.source,
                nbItems = source.getItems().length,
                hasMore = source.hasMore(elements.items.length);

            // Update itemsActions
            elements.itemsActions.getElement('.loadMore').toggle(hasMore);
            elements.itemsActions.getElement('.noItem').toggle(!nbItems);

            /*
            elements.itemsActions.getElement('.websiteLink').toggle(!!websiteLink)
                .getElement('a').setAttribute('href', websiteLink);
            */

            itemsElements = itemsElements.splice(0, options.nbItems); // Keep only the first options.nbItems items

            // Inject itemsActions at the end
            itemsElements.push(elements.itemsActions);

            itemsElements.forEach(function (itemElement, itemIndex) {

                if (itemIndex === 0) {
                    itemElement.addClassName('first');
                } else if (itemIndex === (nbItemsElements - 1)) {
                    itemElement.addClassName('last');
                }

                itemElement.addClassName(itemIndex % 2 === 0 ? 'odd' : 'even');
            });

            // Add new itemsElements into itemList
            elements.items.addContent(itemsElements);

            if (!that.currentItem && items[0]) {
                that.showItem(items[0]);
            }
        },

        showItem: function (item) {

            var that = this,
                currentItem = that.currentItem,
                options = that.options,
                source = options.source;

            if (currentItem !== item) {

                // Remove previous active
                if (currentItem) {
                    that.getItem(currentItem)
                        .removeClassName('active');
                }

                // Set as read and active
                that.getItem(item)
                        .removeClassName('unread')
                        .addClassName('read')
                        .addClassName('active');

                // Set item has read
                source.setItemRead(item);

                // Save current item
                that.currentItem = item;

                // Scroll to item
                if (that.scroller) {
                    that.scroller.scrollToElement(
                        that.getItem(item),
                        that.scrollPosition
                    );
                }
            }
        },

        loadMore: function (nbItems) {

            var that = this,
                options = that.options,
                items = options.source.getLoaded();

            nbItems = nbItems || options.nbItems;

            this.injectItems(items.splice(that.elements.items.length, nbItems));
        },

        destroy: function () {
            if (this.container) {
                this.container.destroy();
            }

            /*
            if (this.scroller) {
                this.scroller.destroy();
            }

            if (this.pager) {
                this.pager.destroy();
            }
            */
        },

        // Ellipsis

        addEllipsis: function (ellipsis) {
            this.itemsEllipsis.push(ellipsis);
        },

        loadEllipsis: function () {

            var i, l, ellipsis,
                that = this,
                itemsEllipsis = that.itemsEllipsis;

            for (i = 0, l = itemsEllipsis.length; i < l; i++) {

                ellipsis = itemsEllipsis[i];

                if (
                    !ellipsis.ellipsis
                ) {
                    ellipsis.ellipsis = new Ellipsis(ellipsis.element, {
                        _root: false,
                        reference: ellipsis.element.getParent()
                    });
                }
            }

            that.refreshEllipsis();
        },

        refreshEllipsis: function () {

            var i, l, ellipsis,
                itemsEllipsis = this.itemsEllipsis;

            for (i = 0, l = itemsEllipsis.length; i < l; i++) {

                ellipsis = itemsEllipsis[i];

                if (ellipsis.ellipsis) {
                    ellipsis.ellipsis.dispatchEvent('onRefresh');
                }
            }
        },

        // Images

        resizeItemImage: function (imageContainer) {

            var styles, imageDimensions, parentDimensions, imageRatio, parentRatio,
                imageElement = imageContainer && imageContainer.getElement('img');

            imageContainer = imageElement && imageElement.getParent();

            if (
                imageContainer &&
                    imageContainer.offsetWidth > 0 &&
                        imageContainer.isInjected()
            ) {
                styles = {
                    width: 'auto',
                    height: 'auto',
                    marginTop: 0,
                    marginLeft: 0
                };

                imageElement.setStyles(styles);

                imageDimensions = {
                    width: imageElement.offsetWidth,
                    height: imageElement.offsetHeight
                };

                parentDimensions = {
                    width: imageContainer.offsetWidth,
                    height: imageContainer.offsetHeight
                };

                parentRatio = parentDimensions.width / parentDimensions.height;
                imageRatio = imageDimensions.width / imageDimensions.height;

                // Do not resize Loader if image is small
                if (
                    this.options.images.loader === imageElement.src &&
                        (parentDimensions.width > imageDimensions.width ||
                            parentDimensions.height > imageDimensions.height)
                ) {

                    styles.marginLeft = (parentDimensions.width / 2) - (imageDimensions.width / 2) + 'px';
                    styles.marginTop = (parentDimensions.height / 2) - (imageDimensions.height / 2) + 'px';

                } else if (parentRatio < imageRatio) {

                    styles.height = '100%';
                    styles.marginLeft = (-(parentDimensions.height * imageRatio -
                                           parentDimensions.width) / 2) + 'px';
                } else {
                    styles.width = '100%';
                    styles.marginTop = (-((parentDimensions.width / imageRatio) -
                                          parentDimensions.height) / 2) + 'px';
                }

                imageElement.setStyles(styles);
            }
        },

        buildItemImage: function (item, type) {

            var that = this,
                imageDefaultUrls = that.options.images,
                imageDefaultUrl = imageDefaultUrls[type],
                imageUrl = item[type] || imageDefaultUrl,
                image = UWA.createElement('img'),
                imageContainer = UWA.createElement('div', {
                    'class': 'image',
                    html: {
                        tag: 'a',
                        title: UWAString.stripTags(item.title),
                        href: item.link,
                        html: image
                    }
                }),
                resizeImage = that.resizeItemImage.bind(that, imageContainer);

            this.addItemImage({
                item: item,
                container: imageContainer,
                src: imageUrl,
                onLoad: function () {
                    image.setAttribute('src', imageUrl);
                    resizeImage();
                },
                onError: function () {
                    image.setAttribute('src', imageDefaultUrl);
                    resizeImage();
                },
                onLoading: function () {
                    image.setAttribute('src', imageDefaultUrls.loader);
                    resizeImage();
                }
            });

            return imageContainer;
        },

        addItemImage: function (image) {
            this.itemsImages.waiting.push(image);
        },

        loadItemsImages: function () {

            var i, l, image,
                that = this,
                nextImages = [],
                itemsImages = that.itemsImages;


            for (i = 0, l = itemsImages.waiting.length; i < l; i++) {
                image = itemsImages.waiting[i];

                if (
                    image.item === that.currentItem ||
                        that.scroller.isInViewport(image.container, true)
                ) {
                    nextImages.push(image);
                }
            }

            for (i = 0, l = nextImages.length; i < l; i++) {
                that.loadItemImage(nextImages[i]);
            }
        },

        loadItemImage: function (image) {

            var index,
                that = this,
                itemsImages = that.itemsImages,
                loadItemsImages = function () {

                    var i, l, index, imageWait,
                        nextImages = [];

                    // Remove image from loading
                    index = itemsImages.loading.indexOf(image);
                    if (index !== -1) {
                        itemsImages.loading.splice(index, 1);
                    }

                    // Add image to loaded
                    index = itemsImages.loaded.indexOf(image);
                    if (index === -1) {

                        itemsImages.loaded.push(image);

                        // Load similare images
                        for (i = 0, l = itemsImages.waiting.length; i < l; i++) {
                            imageWait = itemsImages.waiting[i];

                            if (
                                image.src === imageWait.src
                            ) {
                                nextImages.push(imageWait);
                                itemsImages.loaded.push(imageWait);
                            }
                        }

                        for (i = 0, l = nextImages.length; i < l; i++) {
                            that.loadItemImage(nextImages[i]);
                        }
                    }
                };

            // Remove image from waiting
            index = itemsImages.waiting.indexOf(image);
            if (index !== -1) {
                itemsImages.waiting.splice(index, 1);
            }

            // Is loaded ?
            if (itemsImages.loaded.indexOf(image) !== -1) {
                image.onLoad();
                loadItemsImages();
            } else {

                image.onLoading();
                itemsImages.loading.push(image);

                UWA.createElement('img', {
                    styles: {
                        display: 'none'
                    },
                    events: {
                        load: function () {
                            image.onLoad();
                            this.destroy();
                            loadItemsImages();
                        },
                        error: function () {
                            image.onError();
                            this.destroy();
                            loadItemsImages();
                        }
                    }
                }).inject(document.body).setAttribute('src', image.src);
            }
        },

        // Events

        onPostInject: function () {
            this.refreshItems();
        },

        onResize: function () {

            this.itemPerPage = 0;

            this.refreshScroller();

            //this.loadEllipsis();
        },

        onItemClick: function (event, item) {

            var that = this;

            if (item && that.showItem(item)) {
                Event.stop(event);
            }

            that.refreshPager();
        },

        onMouseDown: function (event) {
            Event.preventDefault(event);
        }
    });

    /*
      Class: UWA.Controls.FeedView.Full

        TODO.

      Example:
        (start code)
        TODO
        (end code)
    */
    FeedView.Full = FeedView.extend({

        buildItem: function (item) {

            var descContainer,
                itemContainer = this._parent(item),
                itemContent = itemContainer.getElement('.content');

            // Insert item description
            descContainer = UWA.createElement('div', {
                'class': 'description ellipsis',
                html: {
                    tag: 'div',
                    html: UWAString.stripTags(item.content)
                }
            }).inject(itemContent);

            // add ellipsised element
            this.addEllipsis({
                reference: descContainer,
                element: descContainer.getElement('div')
            });

            // Insert item thumbnail
            this.buildItemImage(item, 'image').inject(itemContainer, 'top');

            return itemContainer;
        }
    });

    /*
      Class: UWA.Controls.FeedView.Presentable

        TODO.

      Example:
        (start code)
        TODO
        (end code)
    */
    FeedView.Presentable = FeedView.Full.extend({

        presentedItem: null,

        buildSkeleton: function () {
            return this._parent().grab(this.buildItemTop(), 'top');
        },

        buildItemTop: function () {

            this.elements.top = UWA.createElement('div', {
                'class': 'top',
                html: {
                    tag: 'div',
                    'class': 'actions',
                    html: {
                        tag: 'div',
                        'class': 'readMore action',
                        html: {
                            tag: 'a',
                            text: UWA.i18n(this.options.messages.readMore)
                        }
                    }
                }
            });

            return this.elements.top;
        },

        showItem: function (item) {

            var itemElement,
                itemTop = this.elements.top;

            this._parent(item);

            if (
                !this.presentedItem ||
                    this.presentedItem.getData('item-index') !== item.index
            ) {
                // Remove previous presentedItem
                if (this.presentedItem) {
                    this.presentedItem.remove();
                }

                // Inject new item into top
                itemElement = this.buildItem(item);
                itemElement.inject(itemTop, 'top');

                // Set topItem readMore
                itemTop.getElement('.readMore').getElement('a')
                    .setAttribute('href', item.link);

                // Set current presentedItem
                this.presentedItem = itemElement;

                this.loadItemsImages();

                return true;
            }
        }
    });

    FeedView.Adapter = {};

    /*
      Class: UWA.Controls.FeedView.Adapter.Abstract

        TODO.

      Example:
        (start code)
        TODO
        (end code)
    */
    FeedView.Adapter.Abstract = Class.extend({

        init: function (object) {
            this.object = object;
        },

        hasMore: function () {
            return false;
        },

        isItemRead: function (/*item*/) {
            return false;
        },

        setItemRead: function (/*item*/) {
            return false;
        },

        getItems: function () {
            return [];
        },

        getLink: function () {
            return null;
        }
    });

    /*
      Class: UWA.Controls.FeedView.Adapter.Abstract

        TODO.

      Example:
        (start code)
        TODO
        (end code)
    */
    FeedView.Adapter.Feed = FeedView.Adapter.Abstract.extend({

        getItems: function () {
            return this.object.getItems();
        },

        isItemRead: function (item) {
            return this.object.isItemRead(item.index);
        },

        setItemRead: function (item) {
            return this.object.setItemRead(item.index);
        },

        getLink: function () {
            return this.object.getLink();
        }
    });

    return UWA.namespace('Controls/FeedView', FeedView, UWA, true);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Carousel', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Carousel.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView.Presentable>
    */
    var Carousel = FeedView.Presentable.extend({

        viewName: 'carousel',

        scrollPosition: 'center',

        getItemsPerPage: function () {

            var i, l,
                that = this,
                size = 0,
                items = that.elements.item;

            if (!that.itemPerPage) {

                for (i = 0, l = items.length; i < l; i++) {
                    if (that.scroller.isInViewport(items[i], true)) {
                        size++;
                    }
                }

                that.itemPerPage = size;
            }

            return that.itemPerPage;
        },

        onResize: function () {

            this._parent();

            var elements = this.elements.items.getChildren(),
                scrollerWidth = 0;

            elements.forEach(function (element) {
                scrollerWidth += element.offsetWidth;
            });

            this.elements.items.setStyle('width', scrollerWidth + 'px');
        }
    });

    return UWA.namespace('Controls/FeedView_Carousel', Carousel, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Channel', [
    'UWA/Core',
    'UWA/String',
    'UWA/Controls/FeedView/Carousel',
    'UWA/Controls/Pager',
    'UWA/Event'
], function (UWA, UWAString, Carousel, Pager, Event) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Channel.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView_Carousel>

      Parameters:
        * Object options: options hash or a option/value pair.

      Available Options:
        > Options             Description                           Default value
        >  nbItems             Nb item to display
        >  source              Feed source url
        >  enableShare         Display share button                  false
        >  shareFunction       Customized container classname        null
        >  enableDragAndFollow Display dragAndFollow button          false

      Example:
        (start code)
        FeedView.view = new UWA.Controls['FeedView_SampleChannel']({
            nbItems: 7,
            source: new UWA.Controls.FeedView.Adapter.Feed('http://www.nytimes.com/services/xml/rss/nyt/International.xml'),
            enableShare: true,
            enableDragAndFollow: true,
            shareFunction: function () {}
        }).inject(widget.body.empty());
        (end code)
    */
    var Channel = Carousel.extend({

        eltMargin: 20,
        displayPager: false,

        viewName: 'carousel channel',

        showItem: function (item) {
            var itemElement;

            this._parent(item);

            if (this.presentedItem) {
                this.presentedItem.remove();
            }
            // Set current presentedItem
            this.presentedItem = itemElement;

            this.loadItemsImages();

        },
        buildItemImage: function (item, type) {

            var that = this,
                options = that.options,
                imageDefaultUrls = options.images,
                imageUrl = item[type] || "",
                image = UWA.createElement('img'),
                description = '',
                imageContainer = UWA.createElement('div', {
                    'class': 'hentry'
                }),
                itemImage = UWA.createElement('div', {
                    'class': 'entry-image',
                    html: image
                }),
                itemTitle = UWA.createElement('div', {
                    'class': 'entry-title',
                    html: {
                        tag: 'span',
                        'class': 'title',
                        html: item.title ? UWAString.stripTags(item.title) : ''
                    }
                }),
                itemShare = UWA.createElement('div', {
                    'class': 'entry-share'
                }),
                itemDate = UWA.createElement('div', {
                    'class': 'item-date',
                    text: item.date ? UWAString.parseRelativeTime(item.date.toString()) : ''
                }),
                itemDragAndFollow = UWA.createElement('div', {
                    'class': 'item-dragAndFollow'
                }),
                itemDescription = '', // used if the item has not image
                resizeImage = that.resizeItemImage.bind(that, imageContainer),
                maxlengthDescription = 125,
                nameClassNoImage = 'no-image';

            description = item.description || item.content || '';

            if (!item[type]) { // If the item has not the type (type = image)
                itemShare.addClassName(nameClassNoImage);
                itemTitle.addClassName(nameClassNoImage);

                description = UWAString.stripTags(description);
                description = UWAString.cut(description, maxlengthDescription);

                itemDescription = UWA.createElement('span', {
                    'class': 'entry-description',
                    text: description
                });
                itemTitle.appendChild(itemDescription);
            }

            if (options.enableShare) {
                if (options.shareFunction) {
                    itemShare.addEvent('click', this.share.bind(this));
                }
                itemImage.appendChild(itemShare);
            }

            imageContainer.appendChild(itemImage);
            itemImage.appendChild(itemTitle);
            imageContainer.appendChild(itemDate);

            if (options.enableDragAndFollow) {
                imageContainer.appendChild(itemDragAndFollow);
            }


            this.addItemImage({
                item: item,
                container: imageContainer,
                src: imageUrl,
                onLoad: function () {
                    image.setAttribute('src', imageUrl);
                    resizeImage();
                },
                onError: function () {
                    image.destroy();
                    //resizeImage();
                },
                onLoading: function () {
                    image.setAttribute('src', imageDefaultUrls.loader);
                    resizeImage();
                }
            });

            return imageContainer;
        },
        onResize: function () {

            this._parent();

            var elements = this.elements.items.getChildren(),
                scrollerWidth = 0;

            // Scroller width taking items margin into account
            elements.forEach(function (element) {
                scrollerWidth += element.offsetWidth + this.eltMargin;  // add Margin
            }, this);

            this.elements.items.setStyle('width', scrollerWidth + 'px');

            // need Refresh to get ready to scroll
            this.refreshScroller();
            if (this.pager) {
                this.refreshPager();
            }
        },
        buildPager: function (position) {
            if (this.displayPager) {
                var that = this,
                    pagerOptions = UWA.merge({
                        _root: false,
                        events: {
                            onOffsetChange: function (offset) {
                                var items = that.options.source.getItems();
                                that.showItem(items[offset]);
                            }
                        }
                    }, that.options.pager);

                that.pager = new Pager(pagerOptions);

                // Inject pager into main container
                that.pager.inject(that.container, position);
            }
        },
        share: function (e) {
            Event.stopPropagation(e);
            this.options.shareFunction();
        }
    });

    return UWA.namespace('Controls/FeedView_Channel', Channel, UWA);

});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Gallery', [
    'UWA/Core',
    'UWA/Controls/FeedView/Carousel'
], function (UWA, Carousel) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Gallery.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView_Carousel>
    */
    var Gallery = Carousel.extend({

        viewName: 'carousel gallery'

    });

    return UWA.namespace('Controls/FeedView_Gallery', Gallery, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Headline', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Headline.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView_Normal>
    */
    var Headline = FeedView.Full.extend({

        viewName: 'headline'
    });

    return UWA.namespace('Controls/FeedView_Headline', Headline, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Magazine', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Magazine.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView.Presentable>
    */
    var Magazine = FeedView.Presentable.extend({

        viewName: 'magazine'
    });

    return UWA.namespace('Controls/FeedView_Magazine', Magazine, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Normal', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Normal.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView.Full>
    */
    var Normal = FeedView.Full.extend({

        // Inherits scoop style for itemlist
        viewName: 'normal'
    });

    return UWA.namespace('Controls/FeedView_Normal', Normal, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/Scoop', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Scoop.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView.Presentable>
    */
    var Scoop = FeedView.Presentable.extend({

        viewName: 'scoop normal'
    });

    return UWA.namespace('Controls/FeedView_Scoop', Scoop, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

define('UWA/Controls/FeedView/SimpleList', [
    'UWA/Core',
    'UWA/Controls/FeedView'
], function (UWA, FeedView) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_SimpleList.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView>
    */
    var SimpleList = FeedView.extend({

        // Inherits scoop style for itemlist
        viewName: 'simplelist'
    });

    return UWA.namespace('Controls/FeedView_SimpleList', SimpleList, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, setTimeout
*/

define('UWA/Controls/FeedView/Ticker', [
    'UWA/Core',
    'UWA/String',
    'UWA/Controls/FeedView',
    'UWA/Controls/Flash'
], function (UWA, UWAString, FeedView, Flash) {
    'use strict';

    /*
      Class: UWA.Controls.FeedView_Ticker.

        FeedView Design Extentions.
        TODO better description.

      Extends:
        <UWA.Controls.FeedView>
    */
    var Ticker = FeedView.extend({

        viewName: 'ticker',

        color: 'blank',

        colors: {
            blue:         ['014446', '6eb8bd', '1fd3e3', '6EB8BD'],
            green:        ['232908', '787F57', 'B6D800', '787F57'],
            red:          ['5B0000', 'D5827C', 'E9440B', 'D5827C'],
            orange:       ['440121', 'C57C9A', 'FE4792', 'C57C9A'],
            white:        ['343434', '8E8D8D', 'FFFFFF', '8E8D8D'],
            yellow:       ['502200', 'BF934E', 'FCBC13', 'BF934E'],
            blank:        ['transparent', '8E8D8D', '333333', '333333'],
            borderless:   ['transparent', '8E8D8D', '333333', '333333']
        },

        buildSkeleton: function () {

            var flash,
                colors = this.colors,
                color = this.color,
                options = this.options;

            this.container = UWA.createElement('div', {
                'class': 'uwa-feedview content uwa-feedview-' + this.viewName
            });

            flash = new Flash({
                _root: false,
                url: UWA.hosts.uwa + UWA.paths.img + 'flash/ticker.swf',
                height: 80,
                width: '100%',
                allowScriptAccess: 'always',
                flashVars: {
                    background: colors[color][0],
                    arrow: colors[color][1],
                    text: colors[color][2],
                    subtext: colors[color][3],
                    shareLabel: UWA.i18n('Share'),
                    direction: options.direction,
                    share: (options.displayShare ? '1' : '0')
                }
            }).inject(this.container);

            this.elements.flash = flash.getFlashContainer();

            this.registerOnFlashLoad();

            return this.container;
        },

        registerOnFlashLoad: function () {

            var self = this;

            function isFlashLoaded() {
                if (!self.onFlashLoad()) {
                    setTimeout(isFlashLoaded, 500);
                }
            }

            setTimeout(isFlashLoaded, 1000);
        },

        onFlashLoad: function () {

            var i, l, item,
                options = this.options,
                items = options.source.getItems(),
                flashObject = this.elements.flash;

            if (typeof flashObject.addItem === 'function') {

                for (i = 0, l = items.length; i < l; i++) {
                    item = items[i];
                    flashObject.addItem(
                        i,
                        UWAString.stripTags(item.title),
                        options.showDate ? UWAString.parseRelativeTime(item.date) : ''
                    );
                }

                flashObject.start();

                return true;
            }

            return false;
        },

        onResize: function () {
            // Nothing to do...
        },

        refreshItems: function () {
            // Nothing to do...
        }
    });

    return UWA.namespace('Controls/FeedView_Ticker', Ticker, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document
*/

/**
 * @module   UWA/Controls/FlashPlayer
 *
 *
 * @example
 * var flashPlayer = new UWA.Controls.FlashPlayer(playerContainer);
 *
 * flashPlayer.show('http://video.google.com/googleplayer.swf?docId=39288702201978303');
 * flashPlayer.toogleFullScreenMode(true);
 */
define('UWA/Controls/FlashPlayer', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/String',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Controls/Flash'
], function (UWA, Utils, UWAString, Client, Event, Element, Abstract, Flash) { // jshint ignore:line
    'use strict';

    var FlashPlayer = Abstract.extend(/** @lends module:UWA/Controls/FlashPlayer.UWA.Controls.FlashPlayer# */{ // bypass

        /* Group: Properties */

        /**
         * @property {String} className - Classname assigned to the parent element of the control.
         * @protected
         * @deprecated
         */
        className: 'uwa-flashplayer',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            flashVars: '',
            flashUrl: '',
            width: '',
            height: '',
            wmode: 'opaque',
            aspectRatio: 1.3,
            showToolbar: true,
            showFullScreenLink: true
        },

        isFullScreen: false,

        /**
         * Flash player with full screen capabilities. Currently used by video widgets.
         *
         * @example
         * var flashPlayer = new UWA.Controls.FlashPlayer(playerContainer);
         *
         * flashPlayer.show('http://video.google.com/googleplayer.swf?docId=39288702201978303');
         * flashPlayer.toogleFullScreenMode(true);
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.flashVars=''] - Custom flashvars
         * @param {String} [options.flashUrl=''] - Url of the flash content
         * @param {Number} [options.width=''] - Width in pixels of the flash container
         * @param {Number} [options.height=''] - Height in pixels of the flash container
         * @param {String} [options.wmode='opaque'] - Flash parameter to control layering
         * and transparency of the content in the browser
         * ({@link http://helpx.adobe.com/flash/kb/flash-object-embed-tag-attributes.html#main_Browser_support_for_Window_Mode__wmode__values|wmode reference)
         * @param {String} [options.aspectRatio=1.3] - Ratio between width and height
         * @param {String} [options.showToolbar=true] - Display toolbar containing controls and possibly a link to media
         * @param {Boolean} [options.showFullScreenLink=true] - Display full screen toggle
         * @param {String} [options.mediaLinkUrl=null] - Url of the link that can be displayed in toolbar if showToolbar is `true`
         * @param {String} [options.mediaLinkText=null] - Text of the link that can be displayed in toolbar if showToolbar is `true`
         *
         * @constructs UWA.Controls.FlashPlayer
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/FlashPlayer
         */
        init: function (options) {

            this._parent(options);

            this.buildSkeleton();
        },

        buildSkeleton: function () {

            var elements = this.elements;

            elements.container = UWA.createElement('div', {
                'class': this.className,
                align: 'center'
            });

            elements.container.hide();
        },

        buildLinks: function (linkUrl, linkText) {

            var options = this.options,
                elements = this.elements;

            // Create links container
            elements.links = UWA.createElement('p', {
                align: 'center'
            });

            // Create the fullscreen link
            if (options.showFullScreenLink) {

                UWA.createElement('a', {
                    href: '#flashPlayer-FullScreen',
                    text: UWA.i18n('Full screen'),
                    events: {
                        click: function (event) {
                            Event.stop(event);
                            this.toogleFullScreenMode(true);
                        }.bind(this)
                    }
                }).inject(elements.links);

                elements.links.appendText(' | ');
            }

            // Create the external link
            if (linkUrl && linkText) {

                UWA.createElement('a', {
                    href: linkUrl,
                    rel: 'external',
                    html: UWAString.stripTags(linkText)
                }).inject(elements.links);

                elements.links.appendText(' | ');
            }

            // Create Close link
            UWA.createElement('a', {
                href: '#flashPlayer-Close',
                html: '<strong>' + UWA.i18n('Close Video') + '</strong>',
                events: {
                    click: function (event) {
                        Event.stop(event);
                        this.hide();
                    }.bind(this)
                }
            }).inject(elements.links);

            // add links container
            elements.links.inject(elements.container);
        },

        toogleFullScreenMode: function (force) {

            force = (force ? true : false);

            var availableSpace = Client.getSize(),
                elements = this.elements;

            if (force) {

                this.isFullScreen = true;

                window.scrollTo(0, 0);

                // Enable Body hidden overflow
                Element.setStyle.apply(document.body, ['overflow', 'hidden']);

                elements.fullScreenContainer = UWA.createElement('div', {
                    align: 'center',
                    styles: {
                        backgroundColor: '#000',
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: availableSpace.width + 'px',
                        height: availableSpace.height + 'px'
                    }
                }).inject(document.body);

                elements.flashObject.inject(elements.fullScreenContainer);

                this.buildCloseFullScreenButton();

            } else {

                this.isFullScreen = false;

                elements.flashObject.inject(elements.flashContainer, 'top');
                elements.fullScreenCloseButton.remove();
                elements.fullScreenContainer.remove();

                // Disable Body hidden overflow
                Element.setStyle.apply(document.body, ['overflow', '']);
            }

            this.onResize();
        },

        buildCloseFullScreenButton: function () {

            var elements = this.elements;

            elements.fullScreenCloseButton = UWA.createElement('input', {
                type: 'button',
                value: UWA.i18n('Close FullScreen'),
                styles: {
                    position: 'absolute',
                    top: '2px',
                    right: '2px'
                }
            }).inject(elements.fullScreenContainer);

            // Fix for IE7 only: width required
            if (Client.Engine.ie && Client.Engine.version > 6) {
                elements.fullScreenCloseButton.style.width = (elements.fullScreenCloseButton.value.length) + 'em';
            }

            elements.fullScreenCloseButton.addEvent('click', function (event) {
                Event.stop(event);
                this.toogleFullScreenMode(false);
            }.bind(this));
        },

        /* Group: Events */

        show: function (flashUrl, flashVars, options) {

            if (options) {
                this.setOptions(options);
            }

            options = this.options;

            var elements = this.elements;

            if (flashUrl || flashVars) {
                options.flashUrl = flashUrl;
                options.flashVars = flashVars;
            }
            // Handle flv video files
            if (/\.flv$/.test(options.flashUrl)) {
                options.flashVars = 'flv=' + encodeURIComponent(options.flashUrl) + '&showplayer=autohide&autoplay=1&showvolume=1&showtime=1';
                options.flashUrl =  UWA.hosts.uwa + UWA.paths.img + 'flash/player_flv.swf';
            }

            // Force cache refresh for IE
            if (Client.Engine.ie && options.flashUrl.indexOf('?') !== -1) {
                options.flashUrl += ('&' + Utils.random(100));
            }

            // Clear Container
            elements.container.empty();

            elements.flashControl = new Flash({
                _root: false,
                url: options.flashUrl,
                width: options.width,
                height: options.height,
                flashVars: options.flashVars,
                wmode: options.wmode,
                styles: {
                    width: options.width,
                    height: options.height
                }
            }).inject(elements.container);

            elements.flashContainer = elements.flashControl.elements.container;
            elements.flashObject = elements.flashControl.getFlashContainer();

            if (options.showToolbar) {
                this.buildLinks(options.mediaLinkUrl, options.mediaLinkText);
            }

            elements.container.show();

            this.onResize();
        },

        hide: function () {

            var elements = this.elements;

            if (elements.container) {

                // Needed for IE in order to stop playing
                elements.container.empty();
                elements.container.hide();
            }
        },

        onResize: function () {

            var parentDimensions, height, width,
                elements = this.elements,
                options = this.options,
                availableSpace = Client.getSize();

            if (this.isFullScreen) {
                elements.fullScreenContainer.setStyles({
                    height: availableSpace.height + 'px',
                    width: (availableSpace.width - Client.getScrollbarWidth()) + 'px',
                    'z-index': 1
                });
            }

            if (elements.flashObject) {

                parentDimensions = elements.flashObject.getParent().getDimensions();

                if (options.width) {
                    width = options.width;
                } else {
                    width = parentDimensions.innerWidth;
                }

                if (options.height) {
                    height = options.height;
                } else {
                    height = Math.min(availableSpace.height, width / options.aspectRatio);
                }




                elements.flashObject.setStyles({
                    height: height + 'px',
                    width: width + 'px'
                });

                // #5977 on dashboard, set dimensions on object element attributes
                elements.flashObject.setAttribute('height', height);
                elements.flashObject.setAttribute('width', width);
            }
        }
    });

    return UWA.namespace('Controls/FlashPlayer', FlashPlayer, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Overlay
 *
 *
 * @example
 * var myOverlay = new UWA.Controls.Overlay();
 *
 * myOverlay.inject(widget.body);
 * myOverlay.open();
 */
define('UWA/Controls/Overlay', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Fx',
    'UWA/Controls/Abstract',
    'UWA/Class/Timed'
], function (UWA, Event, Fx, Abstract, Timed) {
    'use strict';

    var overlays = new WeakMap();
    var managedElements = new WeakMap();

    var Overlay = Abstract.extend(Timed, /** @lends module:UWA/Controls/Overlay.UWA.Controls.Overlay# */{

        /**
         * Class name assigned to the parent element of the control.
         * @type {String}
         */
        name: 'uwa-overlay',

        /**
         * The default controls options.
         * @private
         */
        defaultOptions: {
            exclusive: true,
            exclusiveWith: function (other) {
                return other.name === this.name;
            },
            closeable: true,
            fxOptions: {},
            resizeParent: false
        },

        /**
         * The Overlay control is designed to create modal with custom content inside
         * that fade when you close it.
         *
         * ##### Available Events
         *
         * | Event            |  Description                                       |
         * | ---------------- | -------------------------------------------------- |
         * | `onPreOpen`      | Triggered when the container is about to be opened |
         * | `onOpen`         | Triggered when the container is fully visible      |
         * | `onPreClose`     | Triggered when the container is about to be closed |
         * | `onClose`        | riggered when the container is fully hidden        |
         *
         *
         * @example
         * var myOverlay = new UWA.Controls.Overlay();
         *
         * myOverlay.inject(widget.body);
         * myOverlay.open();
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Boolean} [options.exclusive=true] - Close the other overlays before opening itself
         * @param {Function} [options.exclusiveWith] - Customized check to see if another
         * modal should be exclusive with this one. The function will be called with
         * another modal as argument, and if it returns `true`, the other modal will be
         * claused. By default, `name` properties are compared.
         * @param {Boolean} [options.closeable=true] - Close the overlay by clicking on it
         * @param {Object} [options.fxOptions={}] - Custom fx options for open / close
         * @param {Boolean} [options.resizeParent=false] - Resize the first positionned parent
         * element with the same height of the content if necessary.
         *
         * @constructs UWA.Controls.Overlay
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Overlay
         */
        init: function (options) {
            this._parent(options);

            this.buildSkeleton();

            this.fx = new Fx(this.elements.container, UWA.merge({
                wait: false,
                events: {
                    onComplete: this.onFxComplete.bind(this)
                }
            }, this.options.fxOptions));
        },

        /**
         * Build main dom elements
         * @private
         */
        buildSkeleton: function () {

            var container = this.elements.container = UWA.createElement('div', {
                'class': this.getClassNames(),
                styles: {
                    display: 'none',
                    opacity: 0
                }
            });

            overlays.set(container, this);

            if (this.options.closeable) {
                container.addClassName('closeable')
                    .addEvent('click', function (e) {
                        if (Event.getElement(e) === container) {
                            this.close();
                        }
                    }.bind(this));
            }
        },

        /**
         * Close all overlays present in any level of the parent element of this
         * overlay.
         *
         * @param {Function} [cb] called when all overlays are closed
         */
        closeOverlays: function (cb) {
            var closingCount = 1;

            function onClose() {
                closingCount -= 1;
                if (closingCount === 0) {
                    cb();
                }
            }

            if (this.options.exclusive) {
                var parent = this.elements.container && this.elements.container.getParent();
                if (parent) {
                    parent.getElements('.uwa-overlay').forEach(function (el) {
                        var other = overlays.get(el);
                        if (other && this !== other && other.isOpen() &&
                            this.options.exclusiveWith.call(this, other)) {

                            closingCount += 1;
                            other.addEventOnce("onClose", onClose);
                            other.close();
                        }
                    }, this);
                }
            }

            onClose();
        },

        /* Group: Events */

        /**
         * Triggered when the fx is complete.
         */
        onFxComplete: function () {
            var y = this.opening,
                container = this.elements.container;

            if (!y) {
                container.setStyle('display', 'none');
                this.resize(true);
            }

            this.dispatchEvent((y ? 'onOpen' : 'onClose'), [container]);
            this.opening = null;
        },

        /* Group: Public methods */

        /**
         * Check the state of this overlay.
         *
         * @return {Boolean} `true` if the overlay is open.
         */
        isOpen: function () {
            var container = this.elements.container;
            return container.getParent() && container.getStyle('display') !== 'none' && this.opening !== false;
        },

        /**
         * Open the overlay.
         *
         * @return {this}
         */
        open: function () {
            this.setPeriodical('needResize', this.resize, 500);
            return this.toggle(true);
        },

        /**
         * Close the overlay.
         *
         * @return {this}
         */
        close: function () {
            this.clearPeriodical('needResize');
            return this.toggle(false);
        },

        /**
         * Toggle the overlay.
         *
         * @param {Boolean} [y] - Force the overlay to open or close
         * @return {this}
         */
        toggle: function (y) {

            var container = this.elements.container,
                isOpen = this.isOpen();

            if (y === undefined) {
                y = !isOpen;
            } else if (y === isOpen) {
                return;
            }

            this.dispatchEvent((y ? 'onPreOpen' : 'onPreClose'), [container]);
            this.opening = y;

            container.setStyle('display', 'block');

            if (this.fx) {
                this.fx.fade((y ? 'in' : 'out'));
            }

            if (y) {
                this.closeOverlays(function () {
                    this.resize();
                }.bind(this));
            }

            if (!this.fx) {
                this.onFxComplete();
            }

            return this;
        },

        /**
         * Resize the first positionned parent element with the same height
         * of the content if necessary.
         *
         * @param {Boolean} reset - `true` to reset parent to its initial height
         */
        resize: function (reset) {
            if (this.options.resizeParent) {
                var previous = managedElements.get(this);
                var content = this.getContent();
                var offsetParent = content.getOffsetParent();

                // If we already have a managed parent, but no current parent or a
                // different parent than the managed one, reset the managed parent
                if (previous && (!offsetParent || previous !== offsetParent)) {
                    previous.setStyle('height', '');
                    managedElements['delete'](this);
                }

                if (offsetParent) {
                    if (reset) {
                        offsetParent.setStyle('height', '');
                        managedElements['delete'](this);
                    } else if (content.scrollHeight > offsetParent.offsetHeight) {
                        offsetParent.setStyle('height', content.scrollHeight);
                        managedElements.set(this, offsetParent);
                    }
                }
            }
        },

        onRemoved: function () {
            this.resize(true);
        },

        onInjected: function () {
            this.resize();
        },

        destroy: function () {
            this.resize(true);
            this._parent();
        }
    });

    return UWA.namespace('Controls/Overlay', Overlay, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Lightbox
 *
 *
 * @example
 * var myControl = new UWA.Controls.Lightbox();
 *
 * myControl.inject(widget.body);
 * myControl.addContent('Oh hi!');
 * myControl.open();
 */
define('UWA/Controls/Lightbox', [
    'UWA/Core',
    'UWA/Controls/Overlay'
], function (UWA, Overlay) {
    'use strict';

    /**
     * The Lightbox control is designed to create modal with custom content inside
     * that fade when you close it.
     *
     * ##### Available Events
     *
     * | Event            |  Description                                       |
     * | ---------------- | -------------------------------------------------- |
     * | `onPreOpen`      | Triggered when the container is about to be opened |
     * | `onOpen`         | Triggered when the container is fully visible      |
     * | `onPreClose`     | Triggered when the container is about to be closed |
     * | `onClose`        | riggered when the container is fully hidden        |
     *
     * @example
     * var myControl = new UWA.Controls.Lightbox();
     *
     * myControl.inject(widget.body);
     * myControl.addContent('Oh hi!');
     * myControl.open();
     *
     * @param {Object} options - Options hash or a option/value pair.
     * @param {Boolean} [options.exclusive=true] - Close the other overlays before opening itself
     * @param {Boolean} [options.closeable=true] - Close the overlay by clicking on it
     * @param {String} [options.className=''] - Customized classname
     * @param {Object} [options.fxOptions={}] - Custom fx options for open / close
     *
     * @class UWA.Controls.Lightbox
     * @extends UWA.Controls.Overlay
     * @memberof module:UWA/Controls/Lightbox
     */
    var Lightbox = Overlay.extend(/** @lends module:UWA/Controls/Lightbox.UWA.Controls.Lightbox# */{ // bypass

        /**
         * Return DOM element to use when adding or updating content
         * of the lightbox with `addContent` or `setContent`.
         *
         * @return {HTMLelement}
         */
        getInnerElement: function () {
            return this.elements.container;
        },

        /**
         * Set lightbox content (removing any existing content).
         *
         * @param {String|HTMLelement} - New content
         * @return {this}
         */
        setContent: function (content) {
            this.getInnerElement().setContent(content);
            return this;
        },

        /**
         * Add content to the lightbox.
         *
         * @param {String|HTMLelement} - New content
         * @return {this}
         */
        addContent: function (content) {
            this.getInnerElement().addContent(content);
            return this;
        }
    });

    return UWA.namespace('Controls/Lightbox', Lightbox, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, google, document
*/

/**
 * @module   UWA/Controls/Map
 *
 */
define('UWA/Controls/Map', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Array',
    'UWA/Controls/Abstract',
    'UWA/Class/Timed'
], function (UWA, Utils, UWAArray, Abstract, Timed) {
    'use strict';

    var Map = Abstract.extend(Timed, /** @lends module:UWA/Controls/Map.UWA.Controls.Map# */{ // bypass

        /**
         * @property {Number} id - Instance unique id.
         * @protected
         */
        id: null,

        /**
         * @property {Object} api - The current google.maps object.
         * @protected
         */
        api: null,

        /**
         * @property {Object} map - The current google.maps.Map instance.
         * @protected
         */
        map: null,

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            width: 320,
            height: 240,
            className: 'uwa-map',
            googleApiKey: null,
            api: {
                zoom: 15
            }
        },

        /**
         * Display a Google Map.
         *
         *
         * ##### Available Events
         *
         * | Event             | Description                             |
         * | ----------------- | ----------------------------------------|
         * | `onPreInject`     | Triggered before inject                 |
         * | `onPostInject`    | Triggered after inject                  |
         * | `onResize`        | Invoked when control needs to resize    |
         * | `onLoad`          | Invoked when the map is loaded   |
         *
         * @example
         * var onMapLoad = function() {
         *     MyMap.setPosition({
         *         coords: {
         *             latitude: 42.123,
         *             longitude: 42.123
         *         }
         *     });
         * };
         *
         * var MyMap = new UWA.Controls.Map({
         *     events: {
         *         onLoad: onMapLoad
         *     }
         * });
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.className='uwa-map'] - Customized container classname
         * @param {Number} [options.width=320] - Map width in pixel
         * @param {Number} [options.height=240] - Map height in pixel
         * @param {Object} [options.api={zoom:15}] - Google map options
         *
         * @constructs UWA.Controls.Map
         * @extends UWA.Controls.Abstract
         * @mixes UWA.Classes.Timed
         * @memberof module:UWA/Controls/Map
         */
        init: function (options) {

            this._parent(options);

            this.id = Utils.random(100000);
            this.apiCallbacks = [];

            if (!Map.States.apiLoading && !Map.States.apiLoaded) {
                Map.States.apiLoading = true;

                var googleMapSrc = 'https://maps.google.com/maps/api/js?callback=UWA.Controls.Map.onApiLoad';
                if (this.options.googleApiKey) {
                    googleMapSrc += '&key=' + this.options.googleApiKey;
                }

                // TODO use UWA.Json.request
                UWA.createElement('script', {
                    type: 'text/javascript',
                    src: googleMapSrc
                }).inject(document.body);
            }

            // wait until google map api is loaded
            this.setPeriodical('checkLoad', function () {
                if (Map.States.apiLoaded) {
                    this.clearPeriodical('checkLoad');
                    this.onApiReady();
                }
            }, 100);

            this.buildSkeleton();
        },

        /**
         * Build main dom elements
         * @private
         */
        buildSkeleton: function () {

            var options = this.options,
                elements = this.elements;

            elements.container = UWA.createElement('div', {
                id: 'map_canvas' + this.id,
                'class': options.className,
                styles: {
                    height: options.height + 'px',
                    width: options.width + 'px'
                },
                events: {
                    resize: this.dispatchEvent.bind(this, 'onResize')
                }
            });
        },

        /**
         * To be sure the google map api is loaded, you must wrap all your calls in this method
         * if the api is not loaded, this method will try a bit later
         *
         * @param {Function} callback - Executed once the api is fully loaded
         */
        callApi: function (callback) {

            if (!Map.States.apiLoaded) {
                this.apiCallbacks.push(callback);
            } else {
                callback.call(this, this.api, this.map);
            }
        },

        /**
         * Set Center of the Map to a position.
         *
         * @param {Object} position - A position object with coords object attribute with longitude and latitude
         */
        setPosition: function (position) {
            // TODO asynchronous call
            this.callApi(function () {
                this.map.setCenter(new this.api.LatLng(position.coords.latitude, position.coords.longitude));
            }.bind(this));
        },

        /**
         * Add a marker on the Map to a position.
         *
         * @param {Object} position - A position object with coords object attribute with longitude and latitude
         * @param {String} title - Marker title
         * @param {String} content - Marker content (could contain HTML)
         */
        addMarker: function (position, title, content) {

            var that = this;

            this.callApi(function () {

                var api = that.api,
                    map = that.map,
                    infowindow = new api.InfoWindow({
                        content: content
                    });

                that.marker = new api.Marker({
                    position: new api.LatLng(position.coords.latitude, position.coords.longitude),
                    map: map,
                    title: title
                });

                api.event.addListener(that.marker, 'click', function () {
                    infowindow.open(map, that.marker);
                });
            });
        },


        /**
         * Invoked when google Api is loaded
         */
        onApiReady: function () {

            var options = this.options,
                elements = this.elements;

            this.api = google.maps;

            this.map = new this.api.Map(elements.container, UWA.extend({
                mapTypeControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
                },
                navigationControl: true,
                navigationControlOptions: {
                    style: google.maps.NavigationControlStyle.SMALL
                },
                mapTypeId: google.maps.MapTypeId.HYBRID
            }, options.api));

            this.dispatchEvent('onLoad');

            if (this.apiCallbacks.length) {
                UWAArray.invoke(this.apiCallbacks, 'call', this, this.api, this.map);
                this.apiCallbacks.length = 0;
            }
        },

        /**
         * Triggered after google Api is loaded
         */
        onLoad: function () {
        },

        /**
         * Invoked when control needs to resize
         */
        onResize: function () {
            this.setDelayed('resize', function () {
                if (this.map && this.api) {
                    this.api.event.trigger(this.map, 'resize');
                }
            }, 500);
        }
    });

    /**
     * static booleans to manage Google Maps Api loading
     * @static
     * @alias States
     * @type {Object}
     * @memberof module:UWA/Controls/Map
     */
    Map.States = {
        apiLoading: false,
        apiLoaded: false
    };

    /**
     * static function called only once, when Api is loaded
     * @function
     * @static
     * @alias onApiLoad
     * @memberof module:UWA/Controls/Map
     */
    Map.onApiLoad = function () {
        Map.States.apiLoading = false;
        Map.States.apiLoaded = true;
    };

    return UWA.namespace('Controls/Map', Map, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/Notify
 *
 */
define('UWA/Controls/Notify', [
    'UWA/Core',
    'UWA/Controls/Abstract',
    'UWA/Event',
    'UWA/Fx'
], function (UWA, Abstract, Event, Fx) {
    'use strict';

    var Notify = Abstract.extend(/** @lends module:UWA/Controls/Notify.UWA.Controls.Notify# */{ // bypass

        /**
         * The default controls options.
         * @private
         */
        defaultOptions: {
            className: '',
            showOnInject: true,
            closeOnClick: true,
            transition: 'quadOut',
            duration: 500,
            fx: true,
            from: 'top',
            to: 'bottom',
            max: 0
        },

        /**
         * The messages queue.
         *
         * @type {Array}
         */
        messages: null,

        /**
         * Display messages boxes.
         *
         * @example
         * var myControl = new UWA.Controls.Notify();
         *
         * myControl.inject(myControlContainer);
         * // OR
         * myControlContainer.appendChild(myControl.getContent());
         *
         * myControl.addMessage('Hello');
         *
         * @constructs UWA.Controls.Notify
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Notify
         */
        init: function (options) {

            var that = this;

            // Init message queue
            that.messages = [];

            // Init parent && options
            that._parent(options);

            if (that.options.messages) {
                that.addMessage(that.options.messages);
            }

            that.buildSkeleton();
        },

        buildSkeleton: function () {

            var that = this,
                elements = that.elements,
                options = that.options;

            // Init container
            elements.container = UWA.createElement('div', {
                'class': 'uwa-notify',
                events: {
                    resize: that.dispatchAsEventListener('onResize')
                }
            });

            if (options.className) {
                elements.container.addClassName(options.className);
            }
        },

        /* Group: Message methods */

        showMessage: function (message) {

            var item,
                that = this,
                newMessage,
                messages = that.messages;

            // Take next message if no message requested (and remove from queue)
            if (!message) {
                newMessage = messages.shift();

            // Take existing message (and remove from queue)
            } else {
                newMessage = messages.indexOf(message);

                if (newMessage > -1) {
                    newMessage = messages.splice(newMessage, 1)[0];
                } else {
                    newMessage = false;
                }
            }

            // Inject message if exist
            if (newMessage) {
                item = that.injectItem(newMessage);
            }

            return item;
        },

        addMessage: function (message, showMessage) {

            this.messages.push(message);

            if (showMessage) {
                this.showMessage(message);
            }
        },

        addMessages: function (messages) {

            var that = this;

            messages.forEach(function (message) {
                that.messages.push(message);
            });
        },

        /* Group: Items methods */

        getItems: function () {
            return this.getContent().getElements('.uwa-notify-item');
        },

        injectItem: function (message) {

            var fx, position, dimensions, item,
                that = this,
                options = that.options,
                container = that.getContent(),
                items = that.getItems(),
                offsetParent = container.getOffsetParent(),
                offsetParentDimensions = offsetParent.getDimensions(),
                offsetDimensions = 0,
                origin = {},
                target = {};

            item = UWA.createElement('div', {
                'class': 'uwa-notify-item',
                html: {
                    tag: 'div',
                    'class': 'uwa-notify-msg',
                    html: [
                        {
                            tag: 'div',
                            'class': 'uwa-notify-header'
                        },
                        {
                            tag: 'a',
                            'class': 'uwa-notify-close',
                            text: '\u00D7',
                            href: '#close'
                        },
                        {
                            tag: 'div',
                            'class': 'uwa-notify-body',
                            html: message
                        },
                        {
                            tag: 'div',
                            'class': 'uwa-notify-footer'
                        }
                    ]
                },
                styles: {
                    visibility: 'hidden',
                    zIndex: String(100 - items.length)
                }
            });

            // Add Events
            item.addEvent('click', function (event) {

                var eventElement = Event.getElement(event),
                    eventName = 'onClick';

                if (eventElement.hasClassName('uwa-notify-close')) {
                    eventName = 'onClose';
                }

                that.dispatchEvent(eventName, [event, item]);
            });

            // Get offsetDimensions
            items.forEach(function (item) {
                offsetDimensions += item.getDimensions().outerHeight;
            });

            // Inject message
            item.inject(container);

            // Update other messages position
            that.updateItems();

            // Get positions
            position = item.getPosition();
            dimensions = item.getDimensions();

            if (options.to === 'top') {
                target.top = offsetDimensions + 'px';
            } else if (options.to === 'bottom') {
                target.top = (offsetParentDimensions.innerHeight - dimensions.outerHeight - offsetDimensions) + 'px';
            }

            if (options.from === 'top') {
                origin.top = (-dimensions.outerHeight) + 'px';
            } else {
                origin.top = (dimensions.outerHeight + offsetParentDimensions.outerHeight) + 'px';
            }

            // Set default sttle
            item.setStyles({
                left: ((offsetParentDimensions.innerWidth / 2) - (dimensions.width / 2)) + 'px',
                visibility: 'visible'  // Set message to visible but out of bounce
            });

            if (options.fx) {

                if (options.fade) {
                    origin.opacity = 0;
                    target.opacity = 1;
                }

                // Set origin
                item.setStyles(origin);

                // Animate to target
                fx = new Fx(item, {
                    transition: options.transition,
                    duration: options.duration,
                    events: {
                        onStart: function () {
                            item.addClassName('moving');
                        },
                        onComplete: function () {
                            item.removeClassName('moving');
                        }
                    }
                }).start(target);

            } else {

                // Set target
                item.setStyles(target);
            }

            return item;
        },

        updateItems: function () {

            var that = this,
                options = that.options,
                container = that.getContent(),
                items = that.getItems(),
                offsetParent = container.getOffsetParent(),
                offsetParentDimensions = offsetParent.getDimensions(),
                offsetDimensions = 0;

            items.forEach(function (item) {

                var newPosition,
                    dimensions = item.getDimensions();

                if (options.to === 'top') {
                    newPosition = offsetDimensions;
                } else if (options.to === 'bottom') {
                    newPosition = (offsetParentDimensions.innerHeight - dimensions.outerHeight - offsetDimensions);
                }

                offsetDimensions += dimensions.outerHeight;

                // Do not move one that moving
                if (!item.hasClassName('moving')) {
                    item.setStyles({
                        left: ((offsetParentDimensions.innerWidth / 2) - (dimensions.width / 2)) + 'px',
                        top: newPosition + 'px'
                    });
                }
            });
        },

        /* Group: Events methods */

        onPostInject: function () {

            if (this.options.showOnInject) {
                this.showMessage();
            }
        },

        onResize: function () {

            // Update item position
            this.updateItems();
        },

        onClose: function (event, item) {

            var fx,
                that = this;

            Event.stop(event);

            // Do not close one that closing
            if (!item.hasClassName('closing')) {

                // Remove item
                fx = new Fx(item, {
                    events: {
                        onStart: function () {
                            item.addClassName('closing');
                        },
                        onComplete: function () {

                            // Remove current item
                            item.destroy();

                            // Update item position
                            that.updateItems();
                        }
                    }
                }).fade('out');
            }
        },

        onClick: function (event, item) {

            var that = this,
                eventElement = Event.getElement(event);

            if (
                that.options.closeOnClick ||
                    eventElement.hasClassName('uwa-notify-close')
            ) {
                that.dispatchEvent('onClose', [event, item]);
            }
        }
    });

    return UWA.namespace('Controls/Notify', Notify, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, setTimeout
*/

/**
 * @module   UWA/Controls/Popup
 *
 */
define('UWA/Controls/Popup', [
    'UWA/Core',
    'UWA/Controls/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /*
     * Todo:
     * - Check HTML5 Dialog specs
     * - Implement fallback width UWA.Controls.LightBox and UWA.Controls.Web
     * - Implement HTML support using window.document.write OR appendChild
     */
    var Popup = Abstract.extend(/** @lends module:UWA/Controls/Popup.UWA.Controls.Popup# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            url: 'about:blank',
            status: false,
            toolbar: false,
            location: false,
            menubar: false,
            resizable: false,
            scrollbars: false,
            fullscreen: true,
            width: 320,
            height: 240,
            left: 160,
            top: 120
        },

        /**
         * Display a web content through a popup.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onOpen`         | Invoked when Popup opened              |
         * | `onClose`        | Invoked when Popup closed              |
         * | `onBlocked`      | Invoked when Popup blocked             |
         *
         * @example
         * var myControl = new UWA.Controls.Popup({
         * url: 'http://netvibes.com'
         * });
         *
         * myControl.open();
         *
         * // OR
         *
         * var myControl = new UWA.Controls.Popup();
         * myControl.open('http://netvibes.com');
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.url='about:blank'] - Web Content url
         * @param {String} [options.status=null] - The status bar at the bottom of the window.
         * @param {String} [options.toolbar=null] - The standard browser toolbar, with buttons such as Back and Forward.
         * @param {String} [options.location=null] - The Location entry field where you enter the URL.
         * @param {String} [options.menubar=null] - The menu bar of the window
         * @param {String} [options.directories=null] - The standard browser directory buttons, such as What's New and What's Cool
         * @param {Boolean} [options.resizable=null] - Allow/Disallow the user to resize the window.
         * @param {Boolean} [options.scrollbars=null] - Enable the scrollbars if the document is bigger than the window
         * @param {Number} [options.height=null] - Specifies the height of the window in pixels.
         * @param {Number} [options.width=null] - Specifies the width of the window in pixels.
         *
         * @constructs UWA.Controls.Popup
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Popup
         */
        init: function (options) {

            var that = this;

            that._parent(options);
        },

        /**
         * Open the popup with web content url.
         *
         * @param {String} url - Web Content url
         */
        open: function (url) {

            var that = this;

            that.close();

            if (!that.elements.popup) {
                that.buildSkeleton(url);
            }
        },

        /**
         * Close the popup.
         */
        close: function () {

            var that = this;

            if (that.elements.popup) {
                that.elements.popup.close();
                that.elements.popup = null;

                that.dispatchEvent('onClose');
            }
        },

        /**
         * Set the popup position.
         */
        setPosition: function (left, top) {
            if (this.elements.popup) {
                this.elements.popup.moveBy(
                    parseInt(left, 10),
                    parseInt(top, 10)
                );
            }
        },

        /**
         * Focus the popup.
         */
        focus: function () {
            if (this.elements.popup) {
                this.elements.popup.focus();
            }
        },

        /**
         * Build main dom elements.
         */
        buildSkeleton: function (url) {

            var popup,
                that = this,
                options = that.options,
                windowOptions = ['dependent=yes'],
                popupOptions = [
                    'width',
                    'height',
                    'status',
                    'toolbar',
                    'location',
                    'menubar',
                    'personalbar',
                    'resizable',
                    'scrollbars',
                    'fullscreen'
                ];

            popupOptions.forEach(function (option, index) {
                if (index < 2 && options[option]) {
                    windowOptions.push(option + '=' + parseInt(options[option], 0));
                } else if (index > 1) {
                    windowOptions.push(option + '=' + (options[option] ? 'yes' : 'no'));
                }
            });

            url = url || options.url;

            // If a popup blocker blocks the window, we do nothing.  The user will
            // need to approve the popup, then click again to open the window.
            // Note that because we don't call window.open until the user has clicked
            // something the popup blockers *should* let us through.
            popup = window.open(url, '_blank', windowOptions.join(','));

            // Safari/IE/FF with popup blocker... leaves the popup window handle undefined
            // Chrome will leave window handle moveBy method undefined
            if (!popup || !popup.moveBy) {
                that.dispatchEvent('onBlocked');
            } else {

                // Register popup
                that.elements.popup = popup;

                // Poll every 100ms to check if the window has been closed
                that.timer = window.setInterval(that.checkClosed.bind(that), 100);

                setTimeout(function () {

                    that.focus();

                    that.setPosition(options.left, options.top);

                    that.dispatchEvent('onOpen');

                }, 100);
            }
        },

        checkClosed: function () {

            var that = this,
                popup = that.elements.popup;

            if ((!popup) || popup.closed) {
                that.handleApproval();
            }
        },

        // Called when we recieve an indication the user has approved access, either
        // because they closed the popup window or clicked an "I've approved" button.
        handleApproval: function () {

            var that = this;

            if (that.timer) {
                window.clearInterval(that.timer);
                that.timer = null;
            }

            that.close();
        }
    });

    return UWA.namespace('Controls/Popup', Popup, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/SchemaFormInputs
 *
 * @requires UWA/Core
 */
define('UWA/Controls/SchemaForm/Inputs', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Controls/Abstract',
    'UWA/Controls/Input'
], function (UWA, Utils, Abstract, Input) {
    'use strict';

    var SchemaFormInputs;

    SchemaFormInputs = {
        'uwa-text': Input.Text,
        'uwa-select': Input.Select,
        'uwa-radiogroup': Abstract.extend({
            name: 'uwa-schemaform-radiogroup',

            init: function (options) {
                this._parent(options);
                if (this.options.value) {
                    this.setValue(this.options.value);
                }
                this.radioGroupName = 'schema-form-' + Utils.getUniqueId();
            },

            getContent: function () {
                var self = this;

                if (!this.elements.container) {
                    this.elements.container = UWA.createElement('div', {
                        'class': this.getClassNames()
                    });

                    this.elements.radios = [];
                    this.options.options.forEach(function (option, index) {
                        var radio = new Input.Radio({
                            attributes: {
                                name: self.radioGroupName,
                                value: index
                            }
                        });

                        var labelText = UWA.createElement('span', {
                            'class': self.getClassNames('-label'),
                            text: option.label
                        });

                        UWA.createElement('label', {
                            html: [radio, labelText]
                        }).inject(self.elements.container);

                        self.elements.radios.push(radio);
                    });
                }

                return this.elements.container;
            },

            getValue: function () {
                var checkedRadio = this.elements.container.getElement(':checked');
                return checkedRadio ? this.options.options[checkedRadio.value].value : null;
            },

            setValue: function (value) {
                this.getContent();
                this.options.options.forEach(function (option, index) {
                    if (UWA.equals(value, option.value)) {
                        this.elements.radios[index].check(true);
                    }
                }, this);
            }
        }),
        'uwa-checkbox': Input.Checkbox.extend({
            getValue: function () {
                return this.isChecked();
            },

            setValue: function (value) {
                this.check(Boolean(value));
            }
        }),
        'uwa-checkboxgroup': Abstract.extend({
            name: 'uwa-schemaform-checkboxgroup',

            init: function (options) {
                this._parent(options);
                if (this.options.value) {
                    this.setValue(this.options.value);
                }
            },

            getContent: function () {
                var self = this;

                if (!this.elements.container) {
                    this.elements.container = UWA.createElement('div', {
                        'class': this.getClassNames()
                    });

                    this.elements.checkboxes = [];
                    this.options.options.forEach(function (option) {
                        var checkbox = new Input.Checkbox();

                        var labelText = UWA.createElement('span', {
                            'class': self.getClassNames('-label'),
                            text: option.label
                        });

                        UWA.createElement('label', {
                            html: [checkbox, labelText]
                        }).inject(self.elements.container);

                        self.elements.checkboxes.push(checkbox);
                    });
                }

                return this.elements.container;
            },

            getValue: function () {
                var result = [];

                this.elements.checkboxes.forEach(function (checkbox, index) {
                    if (checkbox.isChecked()) {
                        var value = this.options.options[index].value;
                        if (result.indexOf(value) === -1) {
                            result.push(value);
                        }
                    }
                }, this);

                return result;
            },

            setValue: function (value) {
                this.getContent();
                // Uncheck everything
                this.elements.checkboxes.forEach(function (checkbox) {
                    checkbox.check(false);
                });

                // Check appropriate checkboxes
                if (value && value.forEach) {
                    value.forEach(function (checkedValue) {
                        this.elements.checkboxes.forEach(function (checkbox, index) {
                            var checkboxValue = this.options.options[index].value;
                            if (checkboxValue === checkedValue) {
                                checkbox.check(true);
                            }
                        }, this);
                    }, this);
                }
            }
        })
    };

    return UWA.namespace('Controls/SchemaForm/Inputs', SchemaFormInputs, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/SchemaFormSanitizers
 *
 * @requires UWA/Core
 */
define('UWA/Controls/SchemaForm/Sanitizers', [
    'UWA/Core'
], function (UWA) {
    'use strict';

    var SchemaFormSanitizers;

    SchemaFormSanitizers = {
        'uwa-trim': function (value) {
            return (value || '').trim();
        },
        'uwa-normalize-number': function (value) {
            if (typeof(value) === "string") {
                return value === "" ? undefined : Number(value.replace(',', '.').replace(' ', ''));
            } else {
                return Number(value);
            }
        }
    };

    return UWA.namespace('Controls/SchemaForm/Sanitizers', SchemaFormSanitizers, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/SchemaFormValidators
 *
 * @requires UWA/Core
 */
define('UWA/Controls/SchemaForm/Validators', [
    'UWA/Core'
], function (UWA) {
    'use strict';

    var SchemaFormValidators;

    SchemaFormValidators = {
        'uwa-integer': function(value) {
            var castValue = Number(value);
            if (Math.round(castValue) !== castValue) {
                throw Error(UWA.i18n("“{0}” is not an integer.").format(value));
            }
        },
        'uwa-number': function(value) {
            var castValue = Number(value);
            if (!isFinite(castValue)) {
                throw Error(UWA.i18n("“{0}” is not a number.").format(value));
            }
        },
        'uwa-stringlength': function(value, options) {
            if (!value || value.length < options.min) {
                if (options.min > 1) {
                    throw Error(UWA.i18n("Please enter at least {0} characters.").format(options.min));
                } else {
                    throw Error(UWA.i18n("Please enter at least {0} character.").format(options.min));
                }
            } else if (value.length > options.max) {
                if (options.max > 1) {
                    throw Error(UWA.i18n("Please enter at most {0} characters.").format(options.max));
                } else {
                    throw Error(UWA.i18n("Please enter at most {0} character.").format(options.max));
                }
            }
        },
        'uwa-arraylength': function(value, options) {
            if (!value || value.length < options.min) {
                if (options.min > 1) {
                    throw Error(UWA.i18n("Please select at least {0} options.").format(options.min));
                } else {
                    throw Error(UWA.i18n("Please select at least {0} option.").format(options.min));
                }
            } else if (value.length > options.max) {
                if (options.max > 1) {
                    throw Error(UWA.i18n("Please select at most {0} options.").format(options.max));
                } else {
                    throw Error(UWA.i18n("Please select at most {0} option.").format(options.max));
                }
            }
        },
        'uwa-twitterusername': function(value) {
            if (!/^@\w+$/.test(value)) {
                throw Error(UWA.i18n("“{0}” is not a valid Twitter username.").format(value));
            }
        }
    };

    return UWA.namespace('Controls/SchemaForm/Validators', SchemaFormValidators, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/SchemaForm
 *
 */
define('UWA/Controls/SchemaForm', [
    'UWA/Core',
    'UWA/Array',
    'UWA/Class',
    'UWA/Promise',
    'UWA/Controls/Abstract',
    'UWA/Controls/SchemaForm/Inputs',
    'UWA/Controls/SchemaForm/Sanitizers',
    'UWA/Controls/SchemaForm/Validators',
    'UWA/Controls/Input'
], function (UWA, UWAArray, Class, Promise, Abstract, Inputs, Sanitizers, Validators, Input) { /* jshint ignore:line */
    'use strict';

    var SchemaForm, Field;

    SchemaForm = Abstract.extend(/** @lends module:UWA/Controls/SchemaForm.UWA.Controls.SchemaForm# */{

        /**
         * @property {String} name - The form name. Default: 'uwa-schemaform'
         * @protected
         */
        name: 'uwa-schemaform',

        /**
         * @property {Array} fields - The form's Field objects.
         * @protected
         */
        fields: null,

        /**
         * @property {Boolean} onChangePaused - Whether or not the onChange event can be sent right now. Used in
         * setValue and clearValue.
         * @protected
         */
        onChangePaused: false,

        /**
         * @property {Boolean} isPropagatingChanges - Whether or not a field value change is curently being propagated.
         * @protected
         */
        isPropagatingChanges: false,

        /**
         * @property {Object} options - The default options of the control
         * @protected
         */
        options: {
            schema: null,
            initialValue: {},

            inputs: Inputs,
            sanitizers: Sanitizers,
            validators: Validators,

            submitButton: true,
            clearButton: false,

            data: null,

            baseInputOptions: {}
        },

        /* jshint ignore:start */
        /**
         * The SchemaForm component lets you create forms by providing a schema that defines the fields of the form.
         * For each field, the schema contains the type of input to use, and optional validators and sanitizers.
         * A number of common inputs, validators and sanitizers are built in, listed in the tables below; however, you can easily create
         * your own if need custom behavior.
         *
         * The *inputs* are automatically built when the form is built, and optionally initialized using the values in the `initialValue`
         * option if it is provided.
         *
         * The *sanitizers* are run on the user-supplied values whenever you get them using getValue(), and are also applied to these values
         * when passed to the validators. However, the values displayed by the inputs are never altered; only what you programmatically retrieve
         * is affected by sanitization.
         *
         * The *validators* are run whenever you call isValid(); they are fed the sanitized field values. Because validation can potentially
         * require network access, isValid() returns a Promise. Where appropriate, you must take care of displaying some kind of activity
         * indicator to the user while validation occurs.
         *
         * Calling getValue() returns the current sanitized values of the form's fields. If you want to make sure the values pass
         * validation, you should use getValidatedValue() instead, which returns a Promise that only resolves if all fields validate.
         *
         * To use custom inputs, validators or sanitizers, you must pass them using the `inputs`, `sanitizers` and `validators` options.
         *
         * ##### Built-in inputs, validators and sanitizers
         *
         * | Input name          | Description
         * | ------------------- | ------------------------------------------------------------------------------------------------
         * | `uwa-text`          | A text input. Exposes the entered string. See UWA.Input.Text for available options.
         * | `uwa-select`        | A list of strings presented as a dropdown. Exposes the array of the selected options' values. See UWA.Input.Select for available options.
         * | `uwa-radiogroup`    | A group of radio buttons. Exposes the selected option's value. Accepts an `options` option, which is an array of available choices. Each `option` is a map with a `value` of any type and a `label` string.
         * | `uwa-checkbox`      | A single choice presented as a checkbox. Exposes a boolean that indicates whether the checkbox is checked. See UWA.Input.Checkbox for available options.
         * | `uwa-checkboxgroup` | A group of checkboxes. Exposes the array of the selected checkboxes' values. Accepts an `options` option, which is an array of available choices. Each `option` is a map with a `value` of any type and a `label` string.
         *
         * | Validator name        | Description
         * | --------------------- | -----------------------------------------------------------------------------------------------
         * | `uwa-integer`         | Passes if the value is an integer-like.
         * | `uwa-number`          | Passes if the value is a finite number-like.
         * | `uwa-stringlength`    | Passes if the value has a length greater or equal to the `min` option if specified, and has a length smaller or equal to the `max` option if specified. The failure messages of this validator refer to the number of *entered characters* in the value.
         * | `uwa-arraylength`     | Passes if the value has a length greater or equal to the `min` option if specified, and has a length smaller or equal to the `max` option if specified. The failure messages of this validator refer to the number of *selected options* in the value.
         * | `uwa-twitterusername` | Passes if the value is a string that fits Twitter's username syntax rules.
         *
         * | Sanitizer name         | Description
         * | ---------------------- | ----------------------------------------------------------------------------------------------
         * | `uwa-trim`             | Acts on strings. Trims leading and trailing whitespace.
         * | `uwa-normalize-number` | Acts on number-likes. Replaces any comma with a period, and returns the value as a number.
         *
         * ##### Available Events
         *
         * | Event            | Description
         * | ---------------- | ----------------------------------------------------------------------------------------------------
         * | `onChange`       | Triggered when the user changes an input's value. The form's (unvalidated, but sanitized) value is passed as the first argument.
         * | `onSubmit`       | Triggered when the user clicks the Submit button.
         *
         *
         * ##### Examples
         *
         * __Example__: Setup a beta signup form
         *
         * ```
         * var betaSignupForm = new UWA.Controls.SchemaForm({
         *     schema: {
         *         fields: {
         *             'username': {
         *                 title: 'Your Twitter username (we\'ll send you a DM)',
         *                 input: {
         *                     id: 'uwa-text',
         *                     options: {}
         *                 },
         *                 sanitizer: {id: 'uwa-trim'},
         *                 validator: {id: 'uwa-twitterusername'}
         *             },
         *             'games': {
         *                 title: 'Games you\'re interested in helping test',
         *                 input: {
         *                     id: 'uwa-checkboxgroup',
         *                     options: {
         *                         options: [
         *                             {
         *                                 value: 'hots',
         *                                 label: 'Humans of the Salvation'
         *                             },
         *                             {
         *                                 value: 'underlisten',
         *                                 label: 'Underlisten'
         *                             },
         *                             {
         *                                 value: 'aprils-fools',
         *                                 label: 'HL3'
         *                             }
         *                         ]
         *                     }
         *                 },
         *                 validator: {
         *                     id: 'uwa-arraylength',
         *                     options: {max: 2}
         *                 }
         *             }
         *         }
         *     },
         *     initialValue: {
         *         games: ['hots']
         *     }
         * }).addEvent('onSubmit', function (value) {
         *     // process the data
         * }).inject(container);
         * ```
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Object} [options.schema] - A schema that describes your form's fields.
         * @param {Object} [options.initialValue] - A map of values to be used as initial values for the fields.
         * @param {Object} [options.inputs] - A map of extra input classes you want to be able to use in the Form.
         * @param {Object} [options.sanitizers] - A map of extra sanitizer functions you want to be able to use in the Form.
         * @param {Object} [options.validators] - A map of extra validator classes you want to be able to use in the Form.
         * @param {Boolean} [options.submitButton=true] - Whether or not the Submit button should be displayed.
         * @param {Boolean} [options.submitButton=false] - Whether or not the Clear button should be displayed.
         * @param {Object} [options.baseInputOptions] - A map of default options to be used when creating the field inputs, and the Submit and Clear buttons. The input options defined in the schema individually override these default options.
         *
         * @class UWA.Controls.SchemaForm
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/SchemaForm
         */
         /* jshint ignore:end */
        init: function (options) {
            this._parent(options);

            this._initFields();
        },

        /**
         * Initializes all the Field objects.
         * @protected
         */
        _initFields: function () {
            this.fields = {};

            Object.keys(this.options.schema.fields).forEach(function (fieldName) {
                var fieldDefaultValue = this.options.initialValue && this.options.initialValue[fieldName];
                this.fields[fieldName] = new Field(this, fieldName, this.options.schema.fields[fieldName], fieldDefaultValue);
            }, this);
        },

        /**
         * Overrides <UWA.Controls.Abstract.getContent>
         */
        getContent: function () {
            if (!this.elements.container) {
                this._buildContent();
            }
            return this.elements.container;
        },

        buildNotice: function (text, icon, fieldName) {
            // TODO Create Documentation
            icon = icon ? icon : 'tooltip';
            if (!this.notices[fieldName]) {
                this.notices[fieldName] = UWA.createElement('div', {
                    'class': this.getClassNames('-notice uwa-icon ' + icon),
                    html: text
                });
            } else {
                this.notices[fieldName].innerHTML = text;
            }
            this.notices[fieldName].inject(fieldName ? this.fields[fieldName].getContent() : this.elements.container);
        },

        /**
         * Builds the form HTML, including the field inputs.
         * @protected
         */
        _buildContent: function () {
            var self = this;

            // Container
            this.elements.container = UWA.createElement('div', {
                'class': this.getClassNames()
            });

            this.notices = {};
            if (this.options.schema.notice) {
                this.buildNotice(this.options.schema.notice.text, this.options.schema.notice.icon);
            }

            // Fields
            Object.keys(this.fields).forEach(function (fieldName) {
                this.elements.container.addContent(this.fields[fieldName].getContent());
                if (this.fields[fieldName].schema.input.options && this.fields[fieldName].schema.input.options.hidden) {
                    this.fields[fieldName].getContent().hide();
                }
            }, this);

            // this.updateValidityMessages();

            // Submit and clear buttons
            if (this.options.submitButton || this.options.clearButton) {
                this.elements.buttonContainer = UWA.createElement('div', {
                    'class': this.getClassNames('-buttons')
                }).inject(this.elements.container);

                if (this.options.clearButton) {
                    this.elements.clearButton = new Input.Button(UWA.merge({
                        _root: false,
                        value: 'Clear',
                        events: {
                            onClick: function () {
                                self.clearValue();
                            }
                        }
                    }, this.options.baseInputOptions)).inject(this.elements.buttonContainer);
                }

                if (this.options.submitButton) {
                    this.elements.submitButton = new Input.Button(UWA.merge({
                        _root: false,
                        value: 'Submit',
                        events: {
                            onClick: function () {
                                self.isValid().then(function () {
                                    self.dispatchEvent('onSubmit', [{value: self.getValue()}]);
                                });
                            }
                        }
                    }, this.options.baseInputOptions)).inject(this.elements.buttonContainer);
                }
            }

            return this.elements.container;
        },

        /**
         * Gets the current value of all fields, sanitized, and returned in a map. The returned map can be used as argument for
         * setValue() without conversion; this is for instance useful when restoring the state of a SchemaForm you've destroyed
         * and are re-creating.
         * The values are not guaranteed to be valid; if validation is necessary, use the Promise-returning getValidatedValue() instead.
         *
         * @example
         * alert('Hello, ' + form.getValue().username + '!');
         *
         * @return {Object} A map of field names to field values.
         */
        getValue: function () {
            var result = {};

            Object.keys(this.fields).forEach(function (fieldName) {
                result[fieldName] = this.fields[fieldName].getValue() || null;
            }, this);

            return result;
        },

        getDisplayValue: function () {
            var result = {};

            Object.keys(this.fields).forEach(function (fieldName) {
                result[fieldName] = this.fields[fieldName].getDisplayValue();
            }, this);

            return result;
        },

        /**
         * Gets the current value of the named field, sanitized.
         * The value is not guaranteed to be valid; if validation is necessary, use the
         * Promise-returning getValidatedFieldValue() instead.
         *
         * @example
         * alert('Hello, ' + form.getFieldValue('username') + '!');
         *
         * @param {Object} fieldName - The name of the field of which to retrieve the value.
         *
         * @return {Any} The named field's value
         */
        getFieldValue: function (fieldName) {
            var field = this.fields[fieldName];
            return field ? field.getValue() : null;
        },

        setFieldValue: function (fieldName, value) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].setValue(value);
                this._onFieldChanged(fieldName);
            }
        },

        setFieldTitle: function (fieldName, title) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].setTitle(title);
            }
        },

        /**
         * Returns a Promise carrying the current value of all fields, sanitized, validated, and returned in a map. The Promise fails
         * if not all fields are valid. If you need a synchronous method, use the non-validating getValue() instead.
         *
         * @example
         * form.getValidatedValue().then(function (validatedValue) {
         *     alert('Your account has been successfully created, ' + validatedValue.username + '!');
         * }, function (error) {
         *     alert('The value for `' + error.fieldName + '` is invalid:' + error.message);
         * });
         *
         * @return {Object} A map of field names to field values.
         */
        getValidatedValue: function () {
            var currentValue = this.getValue();

            return this.isValid().then(function () {
                return currentValue;
            });
        },

        /**
         * Returns a Promise carrying the current value of the named field, sanitized and validated. The Promise fails
         * if the field isn't valid. If you need a synchronous method, use the non-validating getFieldValue() instead.
         *
         * @example
         * form.getValidatedFieldValue('username').then(function (validatedFieldValue) {
         *     alert('Your account has been successfully created, ' + validatedFieldValue + '!');
         * }, function (error) {
         *     alert('The value is invalid:' + error.message);
         * });
         *
         * @param {Object} fieldName - The name of the field of which to retrieve the value.
         *
         * @return {Promise} A Promise carrying the field's value, that fails if the value is invalid
         */
        getValidatedFieldValue: function (fieldName) {
            var field = this.fields[fieldName];
            return field.isValid().then(function () {
                return field.getValue();
            });
        },

        /**
         * Sets the value of multiple fields at once. Does not trigger the onChange event. Fields not included in the map
         * are not affected. The return value of getValue() can be used as argument for setValue() without conversion;
         * this is for instance useful when restoring the state of a SchemaForm you've destroyed and are re-creating.
         *
         * @example
         * form.setValue({
         *     username: 'alligator_on_a_stick',
         *     favoriteAnimal: 'yeti',
         *     subscribedToNewsletter: false
         * });
         *
         * @param {Object} value - A map of field names to field values.
         */
        setValue: function (value) {
            this.onChangePaused = true;

            value = value || {};
            Object.keys(this.fields).forEach(function (fieldName) {
                if (value.hasOwnProperty(fieldName)) {
                    this.fields[fieldName].setValue(value[fieldName]);
                }
            }, this);
            this.updateValidityMessages();

            this.onChangePaused = false;
        },

        /**
         * Empties all inputs.
         */
        clearValue: function () {
            this.onChangePaused = true;

            Object.keys(this.fields).forEach(function (fieldName) {
                this.fields[fieldName].setValue(null);
            }, this);
            this.updateValidityMessages();

            this.onChangePaused = false;
        },

        /**
         * Returns a Promise that resolves or fails according to whether all fields are valid.
         *
         * @return {Object} A promise that resolves if all fields are valid.
         */
        isValid: function () {
            return Promise.allSettled(Object.keys(this.fields).map(function (fieldName) {
                return this.fields[fieldName].isValid().fail(function (message) {
                    return Promise.reject(Object.assign(message, {
                        fieldName: fieldName
                    }));
                });
            }, this)).then(function (response) {
                var errors = {};
                response.forEach(function (field) {
                    if (field.state === 'rejected') {
                        errors[field.reason.fieldName] = field.reason;
                    }
                });
                if (Object.keys(errors).length !== 0) {
                    throw Object.assign(new Error("There is an error within a field"), {
                        fieldErrors: errors
                    });
                }
            });
        },

        /**
         * Sanitizes all input and updates the validation messages. This is performed automatically for any input type that
         * emits onChange events, so this is only necessary to call if you are using custom inputs that don't emit onChange.
         */
        updateValidityMessages: function () {
            Object.keys(this.fields).forEach(function (fieldName) {
                this.fields[fieldName].updateValidityMessage({forceValidation: true});
            }, this);
        },

        getSchemaformData: function () {
            return this.options.data;
        },

        /**
         * Creates a context object for the specified field.
         * This method is called once per field, when its Field instance is initialized.
         *
         * @param {Object} field - The field for which to create a context object.
         *
         * @return {Object} The context object
         */
        _createContextForField: function (/* field */) {
            var context = {
                getFieldValue: this.getFieldValue.bind(this),
                setFieldValue: this.setFieldValue.bind(this),
                getValidatedFieldValue: this.getValidatedFieldValue.bind(this),
                getSchemaformData: this.getSchemaformData.bind(this),
                hideField: this.hideField.bind(this),
                showField: this.showField.bind(this),
                buildNotice: this.buildNotice.bind(this),
                addValidityMessage: this.addValidityMessage.bind(this),
                hideValidityMessage: this.hideValidityMessage.bind(this),
                setFieldTitle: this.setFieldTitle.bind(this)
            };

            return context;
        },

        addValidityMessage: function (fieldName, error) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].addValidityMessage(error);
            }
        },

        hideValidityMessage: function (fieldName) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].hideValidityMessage();
            }
        },

        hideField: function (fieldName) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].getContent().hide();
            }
        },

        showField: function (fieldName) {
            if (this.fields[fieldName]) {
                this.fields[fieldName].getContent().show();
            }
        },

        /**
         * Runs a schema-specified (set of) sanitizer(s) on the supplied value.
         *
         * @param {Object} schemaObjectParent - The schema object potentially containing sanitizers.
         * @param {Object} context - The context to pass to the sanitizers.
         * @param {Any} value - The value to sanitize.
         *
         * @return {Any} The sanitized value.
         */
        _executeSanitizers: function (schemaObjectParent, context, value) {
            var self = this;
            var result = value;

            var sanitizers = this._getSanitizersFor(schemaObjectParent);
            sanitizers.forEach(function (sanitizer) {
                var sanitizerOptions = self._evaluateOptions(sanitizer, context),
                    sanitizerFunction = self.options.sanitizers[sanitizer.id];

                result = sanitizerFunction(result, sanitizerOptions);
            });

            return result;
        },

        /**
         * Runs a schema-specified (set of) validator(s) on the supplied value.
         *
         * @param {Object} schemaObjectParent - The schema object potentially containing validators.
         * @param {Object} context - The context to pass to the validators.
         * @param {Any} value - The value to validate.
         *
         * @return {Promise} A Promise carrying the validation result.
         */
        _executeValidators: function (schemaObjectParent, context, value) {
            var self = this;
            var result;

            var validators = this._getValidatorsFor(schemaObjectParent);
            result = Promise.all(validators.map(function (validator) {
                var validatorOptions = self._evaluateOptions(validator, context),
                    validatorFunction = self.options.validators[validator.id],
                    boundValidator = validatorFunction.bind(null, value, validatorOptions, schemaObjectParent);

                return Promise.resolve().then(boundValidator);
            }));

            return result;
        },

        /**
         * Returns a schema object's sanitizers in an array, if any.
         *
         * @param {Object} schemaObject - The schema object potentially containing sanitizers.
         *
         * @return {Array} An array containing the potential sanitizers.
         */
        _getSanitizersFor: function (schemaObject) {
            return schemaObject.sanitizers ? schemaObject.sanitizers :
                schemaObject.sanitizer ? [schemaObject.sanitizer] :
                [];
        },

        /**
         * Returns a schema object's validators in an array, if any.
         *
         * @param {Object} schemaObject - The schema object potentially containing validators.
         *
         * @return {Array} An array containing the potential validators.
         */
        _getValidatorsFor: function (schemaObject) {
            return schemaObject.validators ? schemaObject.validators :
                schemaObject.validator ? [schemaObject.validator] :
                [];
        },

        /**
         * Computes the current value of the options of a schema object
         *
         * @param {Object} schemaObject - The schema object with (potentially) options.
         * @param {Object} context - The context to pass to sanitizers.
         *
         * @return {Any} The computed options.
         */
        _evaluateOptions: function (schemaObject, context) {
            var result;

            if (schemaObject.computedOptions) {
                // Compute options
                result = {};

                var optionDescriptions = schemaObject.computedOptions;
                for (var optionName in optionDescriptions) {
                    if (optionDescriptions.hasOwnProperty(optionName)) {
                        var optionDescription = optionDescriptions[optionName],
                            sourceFieldName = optionDescription.sourceFieldName,
                            computedValue = this.getFieldValue(sourceFieldName);

                        computedValue = this._executeSanitizers(optionDescription, context, computedValue);

                        result[optionName] = computedValue;
                    }
                }

                // And merge in the static options
                if (schemaObject.options) {
                    result = UWA.merge(result, schemaObject.options);
                }
            } else if (schemaObject.options) {
                // Simply read options
                result = schemaObject.options;
            } else {
                // Just return an empty options object
                result = {};
            }

            result = UWA.merge(result, {context: context});

            return result;
        },

        /**
         * Returns the list of the names of the fields referenced in the provided schemaObject.
         * Right now, this means finding all the sourceFieldName parameters in computedOptions objects.
         *
         * @param {Object} schemaObject - The schema object to search.
         *
         * @return {Array} The dependency names.
         */
        _findDependencies: function (schemaObject) {
            if (!schemaObject) {
                return [];
            }

            var result = [];

            if (schemaObject.computedOptions) {
                var optionDescriptions = schemaObject.computedOptions;
                for (var optionName in optionDescriptions) {
                    if (optionDescriptions.hasOwnProperty(optionName)) {
                        // For each computed option
                        var optionDescription = optionDescriptions[optionName],
                            optionSanitizers = this._getSanitizersFor(optionDescription);

                        if (typeof(optionDescription.sourceFieldName) === 'string' && optionDescription.sourceFieldName !== '') {
                            result.push(optionDescription.sourceFieldName);
                        }

                        if (optionSanitizers) {
                            for (var s = 0; s < optionSanitizers.length; s++) {
                                // For each sanitizer
                                var sanitizer = optionSanitizers[s],
                                    sanitizerOptionsDependencies = this._findDependencies(sanitizer);

                                result = result.concat(sanitizerOptionsDependencies);
                            }
                        }
                    }
                }
            }

            return result;
        },

        /**
         * Reacts to a field onChange event. Starts the change propagation process if one isn't running already,
         * then emits an onChange event.
         *
         * @param {String} changedFieldName - The name of the changed field.
         * @protected
         */
        _onFieldChanged: function (changedFieldName) {
            if (this.isPropagatingChanges) {
                return;
            }

            this._propagateChanges([changedFieldName]);

            if (!this.onChangePaused) {
                this.dispatchEvent('onChange', [{value: this.getValue()}]);
            }
        },

        /**
         * Propagates a field value change by telling all other fields about it. If a field or more change in response,
         * we propagate these new changes too, and so on.
         *
         * @param {Array} changedFieldNames - The name of the changed fields.
         * @protected
         */
        _propagateChanges: function (changedFieldNames) {
            this.isPropagatingChanges = true;

            var iterationCount = 0;
            while (changedFieldNames.length) {
                var nextChangedFieldNames = [];

                for (var f = 0; f < Object.keys(this.fields).length; f++) {
                    var fieldName = Object.keys(this.fields)[f],
                        field = this.fields[fieldName],
                        thisFieldChangedToo = field.onFieldsChanged(changedFieldNames);

                        if (thisFieldChangedToo) {
                            nextChangedFieldNames.push(fieldName);
                        }
                }

                changedFieldNames = nextChangedFieldNames;

                if (++iterationCount > 500) {
                    throw new Error('I reckon there might be some good old cyclical references in your computedOptions, partner.');
                }
            }

            this.isPropagatingChanges = false;
        },

        destroy: function () {
            Object.keys(this.fields).forEach(function (fieldName) {
                this.fields[fieldName].destroy();
            }, this);
            this._parent();
        }
    });

    Field = Class.extend({
        host: null,
        schema: null,

        elements: null, // {container, title, inputWrapper, control, validityMessage}

        fallbackValue: undefined,

        context: null,

        dependencies: null, // {input, sanitizer, validator}

        validationCacheIsFor: null,
        cachedValidationPromise: null,

        init: function (hostSchemaForm, fieldName, schemaField, initialValue) {
            var self = this;

            this.host = hostSchemaForm;
            this.schema = schemaField;
            this.name = fieldName;

            this.elements = {};

            this.fallbackValue = initialValue;

            this.context = hostSchemaForm._createContextForField(this);

            function findDependenciesForAll(schemaObjects) {
                var result = [];
                schemaObjects.forEach(function (schemaObject) {
                    result = result.concat(self.host._findDependencies(schemaObject));
                });
                return result;
            }

            this.dependencies = {
                input: this.host._findDependencies(this.schema.input),
                sanitizer: findDependenciesForAll(this.host._getSanitizersFor(this.schema)),
                validator: findDependenciesForAll(this.host._getValidatorsFor(this.schema))
            };
        },

        getContent: function () {
            if (!this.elements.container) {
                this._buildContent();
            }

            return this.elements.container;
        },

        _buildContent: function () {
            this.elements.container = UWA.createElement('div', {
                'class': this.host.getClassNames('-field') + ' input-' + this.schema.input.id
            });

            // Validity message
            this.elements.validityMessage = UWA.createElement('div', {
                'class': this.host.getClassNames('-field-validity-message')
            }).inject(this.elements.container);

            // Title
            this.elements.title = UWA.createElement('div', {
                'class': this.host.getClassNames('-field-title'),
                text: this.schema.title
            }).inject(this.elements.container);

            // Input
            this.elements.inputWrapper = UWA.createElement('div', {
                'class': this.host.getClassNames('-field-wrapper')
            }).inject(this.elements.container);
            this._buildInput();

            if (this.schema.notice) {
                this.context.buildNotice(this.schema.notice.text, this.schema.notice.icon, this.name);
            }


        },

        setTitle: function (title) {
            if (this.elements.title) {
                this.elements.title.setText(title);
           }
        },

        _buildInput: function () {
            // If the control exist, we save its value and destroy it
            if (this.elements.control) {
                this.elements.control.destroy();
                this.elements.inputWrapper.empty();
            }

            // Make the new control
            var InputClass = this.host.options.inputs[this.schema.input.id];

            var inputOptions = UWA.clone(this.host._evaluateOptions(this.schema.input, this.context));
            Object.assign(inputOptions, this.host.options.baseInputOptions, {
                _root: false,
                context: this.context,
                schema: this.schema,
                name: this.name // Only use to hideField / showField, find alternative
            });

            if (this.fallbackValue) {
                Object.assign(inputOptions, {
                    value: this.fallbackValue
                });
            }

            this.elements.control = new InputClass(inputOptions).inject(this.elements.inputWrapper);

            // onChange
            if (this.elements.control.addEvent) {
                this.elements.control.addEvent('onChange', function () {
                    this.fallbackValue = this.elements.control.getValue();
                    this.updateValidityMessage();
                    this.host._onFieldChanged(this.name);
                }, this);
            }
        },

        _isValidationCacheUpToDate: function () {
            return (this.cachedValidationPromise && this.validationCacheIsFor === this._getRawValue());
        },

        getValue: function () {
            return this._sanitize(this._getRawValue());
        },

        getDisplayValue: function () {
            if (this.elements.control && this.elements.control.getDisplayValue) {
                return this.elements.control.getDisplayValue();
            } else {
                return this._getRawValue();
            }
        },

        _getRawValue: function () {
            if (this.elements.control) {
                return this.elements.control.getValue();
            } else {
                return this.fallbackValue;
            }
        },

        _sanitize: function (value) {
            return this.host._executeSanitizers(this.schema, this.context, value);
        },

        setValue: function (value) {
            if (this.elements.control) {
                this.elements.control.setValue(value);
            } else {
                this.fallbackValue = value;
            }
        },

        isEmpty: function () {
            if (this.elements.control) {
                return this.elements.control.isEmpty();
            }
            return true;
        },

        isValid: function () {
            // for inputs with one-of validators, force run validation check
            var forceRun = this.host._getValidatorsFor(this.schema).filter(function (validator) {
                return validator.id === 'one-of';
            }).length;

            // If no up-to-date validation result in cache, validate
            if (!this._isValidationCacheUpToDate() || forceRun) {
                this.validationCacheIsFor = this._getRawValue();
                this.cachedValidationPromise = this.host._executeValidators(this.schema, this.context, this.getValue());
            }

            // Return validation result
            return this.cachedValidationPromise;
        },

        updateValidityMessage: function (options) {
            var self = this;

            if (this.fallbackValue !== undefined || (options && options.forceValidation)) {
                this.isValid().then(function () {
                    self.hideValidityMessage();
                }, function (message) {
                    self.addValidityMessage(message);
                });
            }
        },

        addValidityMessage: function (message) {
            if (this.elements.validityMessage) {
                this.elements.validityMessage.textContent = message.message;
                this.elements.container.addClassName('invalid');
            }
        },

        hideValidityMessage: function () {
            if (this.elements.validityMessage) {
                this.elements.validityMessage.textContent = '';
                this.elements.container.removeClassName('invalid');
            }
        },

        onFieldsChanged: function (changedFieldNames) {
            var self = this;
            var valueMayHaveChanged = false;

            function partDoesDepend(part) {
                var partDependencies = self.dependencies[part];
                return changedFieldNames.some(function (changedFieldName) {
                    return partDependencies.indexOf(changedFieldName) > -1;
                });
            }

            if (partDoesDepend('input') && this.elements.container) {
                valueMayHaveChanged = true;
                this._buildInput();
            }

            if (partDoesDepend('sanitizer')) {
                valueMayHaveChanged = true;
            }

            if (partDoesDepend('validator')) {
                this.validationCacheIsFor = null;
                this.updateValidityMessage();
            }

            return valueMayHaveChanged;
        },

        destroy: function () {
            if (this.elements.container) {
                this.elements.container.destroy();
                if (this.elements.control.destroy) {
                    this.elements.control.destroy();
                }
            }
        }
    });

    return UWA.namespace('Controls/SchemaForm', SchemaForm, UWA, 'replace');
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/SearchForm
 *
 */
define('UWA/Controls/SearchForm', [
    'UWA/Core',
    'UWA/Utils/Client',
    'UWA/Json',
    'UWA/Event',
    'UWA/Class/Timed',
    'UWA/Controls/Abstract'
], function (UWA, Client, Json, Event, Timed, Abstract) {
    'use strict';

    /*
      Class: UWA.Controls.SearchForm

        Display a Search Form.

      Available Options:
        > Options             Description                       Default value
        >  className
        >  showCheckbox
        >  showHistory
        >  allowEmpty
        >  dir
        >  limit

      Available Events:
        > Options             Description
        >  onResetSearch        Invoked when the user reset search of submit an empty search.
        >  onSubmitSearch       Invoked when user submit search.
        >  onToggleSearch       Invoked when user change the checkbox state.
        >  onFocusSearch        Invoked when focus event is trigger on the search field.
        >  onBlurSearch         Invoked when blur event is trigger on the search field.
        >  onClickSearch        Invoked when user click on the search field.
        >  onSearchKeyPress     Invoked when key is press and search field is focused.

      Example:
        (start code)
        var searchForm = new UWA.Controls.SearchForm({
            showCheckbox: true,
            showHistory: true,
            events: {
                onSubmitSearch: function (searchText, checked) {

                },
                onResetSearch: function (searchText, checked) {

                },
                onToggleSearch: function (searchText, checked) {

                }
            }
        }).inject(widget.body);
        (end code)
    */
    var SearchForm = Abstract.extend(Timed, {



        name: 'uwa-searchform',

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            searchText: '',
            faviconUrl: '',
            submitButton: 'button',
            className: 'nv-search',
            showCheckbox: false,
            showHistory: false,
            allowEmpty: false,
            dir: 'ltr',
            limit: 10
        },



        /**
         * Set the options to the current controls instance, creates observers and elements object.
         *
         * @param {Object} options - options hash or a option/value pair.
         */
        init: function (options) {

            this.historyList = [];

            this._parent(options);

            this.buildSkeleton();

            if (this.options.faviconUrl) {
                this.setFavicon(options.faviconUrl);
            }

            if (this.options.searchText) {
                this.setSearchText(options.searchText);
            }
        },

        setOptions: function (options) {

            options = options || {};

            // Deprecated options support
            if (options.searchHistory) {
                options.showHistory = true;
            }

            this._parent(options);
        },

        // kept for backward compatibility
        setInitialState: function (faviconUrl, searchText) {

            var that = this;

            that.setFavicon(faviconUrl);
            that.setSearchText(searchText);
            that.setCheckboxState(searchText);
        },

        /**
         * Build main dom elements.
         */
        buildSkeleton: function () {

            var container, form, submitButton,
                i18n = UWA.i18n,
                that = this,
                options = that.options,
                elements = that.elements;

            // Container
            container = UWA.createElement('div', {
                'class': 'search ' + this.getClassNames()
            });

            // Form
            elements.form = UWA.createElement('form', {
                events: {
                    submit: this.dispatchAsEventListener('onSubmitByHistoryLink')
                }
            }).inject(container);

            // Icon
            elements.favicon =  UWA.createElement('img', {
                'class': 'favicon',
                src: UWA.hosts.uwa + UWA.paths.css + 'base/img/s.gif',
                width: 16,
                height: 16,
                styles: {
                    display: 'none'
                }
            }).inject(elements.form);

            // Input Search
            elements.inputSearch = UWA.createElement('input', {
                'class': 'search',
                type: 'text',
                value: '',
                events: {
                    focus: this.dispatchAsEventListener('onFocusSearch'),
                    blur: this.dispatchAsEventListener('onBlurSearch'),
                    click: this.dispatchAsEventListener('onClickSearch'),
                    keypress: this.dispatchAsEventListener('onSearchKeyPress')
                }
            }).inject(elements.form);

            // Reset Button
            elements.resetButton = UWA.createElement('img', {
                'class':  'clear',
                alt: i18n('Clear'),
                title: i18n('Clear'),
                src: UWA.hosts.uwa + UWA.paths.css + 'base/img/clear.gif',
                events: {
                    click: this.dispatchAsEventListener('onResetSearch')
                },
                styles: {
                    display: 'none'
                }
            }).inject(elements.form);

            // Submit Button
            if (!options.submitButton || typeof (options.submitButton) === "string") {
                if (options.submitButton === "icon") {
                    submitButton = UWA.createElement('a', {
                        'data-icon': 'U',
                        'class': 'uwa-icon uwa-icon-only',
                        alt: UWA.i18n('Search'),
                        events: {
                            click: this.dispatchAsEventListener('onSubmitByHistoryLink')
                        }
                    });
                } else {
                    submitButton = UWA.createElement('input', {
                        type: 'submit',
                        value: UWA.i18n('Search')
                    });
                }
            } else {
                submitButton = options.submitButton;
            }

            elements.form.addContent(submitButton);
            elements.form.lastChild.addClassName('submit');

            // Input Checkbox
            if (options.showCheckbox) {

                elements.checkbox = UWA.createElement('input', {
                    'class': 'check',
                    type: 'checkbox',
                    title: options.checkboxTitle || '',
                    value: '',
                    events: {
                        click: this.dispatchAsEventListener('onToggleSearch')
                    }
                }).inject(elements.form);

                if (options.dir === 'rtl') {
                    elements.checkbox.setStyle('left', '5px');
                } else {
                    elements.checkbox.setStyle('right', '5px');
                }
            }

            // kept for backward compatibility
            that.inputSearch = elements.inputSearch;
            that.form = elements.form;

            this.container = container;
        },

        buildHistoryBox: function () {

            this.hideHistory();

            var that = this,
                elements = that.elements,
                inputSearch = elements.inputSearch,
                inputSearchSize = inputSearch.getSize(),
                searchText = that.getSearchText(),
                historyList = that.historyList,
                historyBox = UWA.createElement('ul', {
                    'class': 'uwa-popup-menu',
                    events: {
                        click: function (event) {

                            Event.stop(event);

                            var eventElement = UWA.Event.getElement(event),
                                query = eventElement.getText();

                            that.setSearchText(query);

                            that.dispatchEvent('onSubmitByHistoryLink', [event]);
                        }
                    }
                });

            historyList.forEach(function (query) {
                if (searchText !== query) {
                    that.getHistoryBoxItem(query).inject(historyBox);
                }
            });

            UWA.createElement('li', {
                'class': 'uwa-popup-menu-item action',
                html: {
                    tag: 'a',
                    text: UWA.i18n('Clear recent searches'),
                    events: {
                        click: function (event) {
                            Event.stop(event);
                            that.clearHistory();
                        }
                    }
                }
            }).inject(historyBox);

            historyBox.inject(elements.form);

            historyBox.setStyles({
                width: (inputSearchSize.width - inputSearch.getComputedSize('borderWidth')) + 'px'
            });

            historyBox.setPosition(
                {
                    x: 0,
                    y: inputSearchSize.height - inputSearch.getComputedSize('borderWidth')
                },
                {
                    relative: inputSearch
                }
            );

            elements.historyBox = historyBox;
        },

        getHistoryBoxItem: function (query) {

            return UWA.createElement('li', {
                'class': 'uwa-popup-menu-item',
                html: {
                    tag: 'a',
                    href: '#history:' + query,
                    html: {
                        tag: 'span',
                        text: query
                    }
                }
            });
        },

        /**
         * The the current favicon near the search field.
         *
         * @param {String} url - the URL of the favicon.
         * @param {String} title - the title of the favicon.
         */
        setFavicon: function (url, title) {

            var favicon = this.elements.favicon;

            favicon.src = url;
            favicon.alt = favicon.title = title;
            favicon[url && url.length ? 'show' : 'hide']();
        },

        /**
         * Set the current search string.
         *
         * @param {String} searchText - the current search string.
         */
        setSearchText: function (searchText) {

            var that = this,
                elements = that.elements,
                inputSearch = elements.inputSearch,
                resetButton = elements.resetButton;

            inputSearch.value = searchText || '';
            resetButton[searchText && searchText.length ? 'show' : 'hide']();

            that.addHistory(searchText);
        },

        /**
         * Get the current search string.
         *
         * @returns {String} - the current search string.
         */
        getSearchText: function () {

            return this.elements.inputSearch.value;
        },

        /**
         * Set the current checkbox state.
         *
         * @param {Boolean} checked - true if checked else false.
         */
        setCheckboxState: function (checked) {

            var checkbox = this.elements.checkbox;

            if (checkbox) {
                if (checked) {
                    checkbox.setAttribute('checked', 'checked');
                    checkbox.defaultChecked = true; // for IE
                } else {
                    checkbox.setAttribute('checked', '');
                    checkbox.defaultChecked = false; // for IE
                }
            }
        },

        /**
         * Get the current checkbox state.
         *
         * @returns {Boolean} - true if checked else false.
         */
        getCheckboxState: function () {

            var checkbox = this.elements.checkbox;

            return checkbox && checkbox.getAttribute('checked') === 'checked';
        },

        /**
         * Add entries into search history.
         *
         * @param {Void} searchHistory - TODO.
         */
        setHistoryString: function (searchHistory) {
            var that = this,
                entries = [];

            if (UWA.is(searchHistory, 'string')) {
                try {
                    searchHistory = Json.decode(searchHistory) || searchHistory;
                } catch (e) {
                }
            }

            if (UWA.is(searchHistory, 'array')) {
                entries = searchHistory;
            } else if (UWA.is(searchHistory)) {
                // Handle legacy encoding
                entries = String(searchHistory).split(':');
            }

            entries.forEach(that.addHistory, that);
        },

        /**
         * Get entries into search history.
         */
        getHistoryString: function () {
            return Json.encode(this.historyList);
        },

        /**
         * Add entry into search history.
         *
         * @param {Void} query - TODO.
         */
        addHistory: function (query) {

            var that = this,
                historyList = that.historyList,
                queryIndex = historyList.indexOf(query);

            if (
                UWA.is(query, 'string') &&
                    query.length > 0
            ) {

                if (queryIndex > -1) {
                    historyList.splice(queryIndex, 1);
                }

                historyList.unshift(query);

                if (historyList.length > that.options.limit) {
                    historyList.pop();
                }

                that.dispatchEvent('updateHistory');
            }
        },

        /**
         * Clear search history.
         */
        clearHistory: function () {

            var that = this;

            that.historyList = [];

            that.dispatchEvent('updateHistory');

            that.hideHistory();
        },

        /**
         * Hide search history popup menu.
         */
        hideHistory: function () {

            var that = this;

            if (that.elements.historyBox) {
                that.elements.historyBox.destroy();
            }

            that.elements.historyBox = null;
        },

        /**
         * Show search history popup menu.
         */
        showHistory: function () {

            var that = this,
                historyList = that.historyList,
                searchText = that.getSearchText();

            // Disabled searchHistory
            if (
                that.options.showHistory &&
                    (
                        (historyList.length > 1) ||
                        (historyList.length === 1 && historyList[0] !== searchText)
                    )
            ) {
                that.buildHistoryBox();
            }
        },

        /**
         * Toggle search history popup menu visibility.
         */
        toggleHistory: function () {

            var that = this;

            // Disabled searchHistory
            if (that.options.showHistory) {
                if (!that.elements.historyList) {
                    that.showHistory();
                } else {
                    that.hideHistory();
                }
            }
        },



        /**
         * Invoked when user submit search.
         *
         * @param {String} searchText - TODO.
         * @param {Boolean} checked - TODO.
         */
        onSubmitSearch: function (searchText, checked) {

            var that = this;

            that.hideHistory();

            that.setSearchText(searchText);

            // kept for backward compatibility
            that.dispatchEvent('submit', [searchText, checked]);
        },

        /**
         * Invoked when user submit search by clicking on previous search link in history list.
         *
         * @param {String} searchText - TODO.
         * @param {Boolean} checked - TODO.
         */
        onSubmitByHistoryLink: function (event) {
            Event.stop(event);

            var query = this.getSearchText(),
                eventName = 'onSubmitSearch';

            // Handle allowEmpty == false option that
            // trigger onResetSearch if search is empty
            if (
                query.trim().length === 0 &&
                    !this.options.allowEmpty
            ) {
                eventName = 'onResetSearch';
            }

            this.dispatchEvent(eventName, [query, this.getCheckboxState()]);
        },

        /**
         * Invoked when the user reset search of submit an empty search.
         *
         * @param {String} searchText - TODO.
         * @param {Boolean} checked - TODO.
         */
        onResetSearch: function () {

            var that = this;

            that.hideHistory();

            that.setSearchText('');

            // kept for backward compatibility
            that.dispatchEvent('reset');
        },

        /**
         * Invoked when user change the checkbox state.
         *
         * @param {String} searchText - TODO.
         * @param {Boolean} checked - TODO.
         */
        onToggleSearch: function () {

            // kept for backward compatibility
            this.dispatchEvent('toggle');
        },

        /**
         * Invoked when focus event is trigger on the search field.
         */
        onFocusSearch: function () {

            // kept for backward compatibility
            this.dispatchEvent('focus');

            this.clearDelayed('onBlurSearch');
        },

        /**
         * Invoked when blur event is trigger on the search field.
         * Blur event mean loses focus.
         */
        onBlurSearch: function () {

            if (this.options.showHistory) {
                this.setDelayed('onBlurSearch', this.hideHistory, 500, false, this);
            }

            // kept for backward compatibility
            this.dispatchEvent('blur');
        },

        /**
         * Invoked when user click on the search field.
         */
        onClickSearch: function () {

            if (this.options.showHistory) {
                this.toggleHistory();
            }
        },

        /**
         * Invoked when key is press and search field is focused.
         */
        onSearchKeyPress: function () {

            if (this.options.showHistory) {
                this.hideHistory();
            }
        }
    });

    return UWA.namespace('Controls/SearchForm', SearchForm, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Controls/StackedColumn
 *
 */
define('UWA/Controls/StackedColumn', [
    'UWA/Core',
    'UWA/String',
    'UWA/Element',
    'UWA/Controls/Segmented',
    'UWA/Controls/ToolTip'
], function (UWA, UWAString, Element, Segmented, ToolTip) {
    'use strict';

    var StackedColumn = Segmented.extend(/** @lends module:UWA/Controls/StackedColumn.UWA.Controls.StackedColumn# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @protected
         */
        defaultOptions: {
            spacer: 0.5,
            showText: true,
            hoverColors: null,
            minHeight: 10,
            className: 'uwa-stackedColumn'
        },

        /**
         * Displays a horizontal bar-type chart.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onClick`        | Fired when item is clicked (params: itemName, item, itemElement)        |
         * | `onMouseOver`    | Fired when mouse is over item (params: itemName, item, itemElement)     |
         * | `onMouseOut`     | Fired when mouse goes out of item (params: itemName, item, itemElement) |
         *
         * @example
         * var myControl =  new UWA.Controls.StackedColumn({
         *     data: {
         *         option_a: {text: 'a', background: 'red', value: 10},
         *         option_bb: {text: 'bb', background: 'blue', value: 30},
         *         option_ccc: {text: 'ccc', background: 'green', value: 25},
         *         option_dddd: {text: 'dddd', background: 'yellow', value: 12}
         *     },
         *     hoverColors:{
         *         'red': 'darkRed',
         *         'blue': 'darkBlue',
         *         'green': 'darkGreen',
         *         'yellow': 'gold'
         *     }
         * });
         *
         * myControl.inject(myControlContainer);
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.spacer=0.5] - The percentage equivalent of width to use as a margin on the right of each part
         * @param {Boolean} [options.showText=true] - If `false`, the text of each data item will not be displayed
         * @param {Number} [options.minHeight=10] - Minimum height of items in pixels used when showText is `false`
         * @param {String} [options.hoverColors=null] - A set of color values (hex or name) to display for each item
         * onMouseOver depending on items orginal color (ex:{'blue': 'black', 'green': 'white'} )
         * @param {String} [options.className='uwa-stackedColumn'] - Classname assigned to the parent element of the control
         * @param {String} [options.toolTip=null] - An UWA.Controls.Tooltip configuration to display a toolTip
         *
         * @constructs UWA.Controls.StackedColumn
         * @extends UWA.Controls.Segmented
         * @memberof module:UWA/Controls/StackedColumn
         */
        init: function (options) {
            this.total = 0;
            this._parent(options);
            if (this.options.hoverColors) {
                this.baseEvents();
            }
        },

        addItem: function (name, itemData) {

            var tooltip,
                self = this;

            this._parent(name, itemData);
            this.total += itemData.value;
            this.updatePourcents();
            this.elements.items[name].addEvent('click', function () {
                self.dispatchEvent('onClick', [name, itemData, this]);
            });

            Element.addEvent.call(
                this.elements.items[name],
                'mouseenter',
                function () {
                    self.dispatchEvent('onMouseOver', [name, itemData, this]);
                }
            );

            Element.addEvent.call(
                this.elements.items[name],
                'mouseleave',
                function () {
                    self.dispatchEvent('onMouseOut', [name, itemData, this]);
                }
            );


            if (this.options.toolTip && this.options.toolTip.formatter) {
                tooltip = new ToolTip(
                    this.elements.items[name],
                    this.options.toolTip.formatter(itemData.raw, itemData.raw.type),
                    {
                        width: this.options.toolTip.width || 120,
                        fx: false
                    }
                );
            }
        },

        updatePourcents: function () {
            var itemName,
                items = this.elements.items;
            for (itemName in items) {
                if (items.hasOwnProperty(itemName)) {
                    this.updateItem(itemName, items[itemName]);
                }
            }
        },

        updateItem: function (itemName, item) {

            var itemConfig = this.options.data[itemName],
                itemPourcent = itemConfig.value / this.total * 100,
                width = itemPourcent,
                tpl = '<p>{0}<span class="pourcent">{1}%</span></p>';

            item.setStyle('background-color', itemConfig.background);
            if (!item.hasClassName(this.options.className + '-item-last')) {
                item.setStyle('margin-right', this.options.spacer + '%');
            }

            width = itemPourcent - this.options.spacer;
            item.setStyle('width', width + '%');
            item.empty();
            if (this.options.showText) {
                item.setHTML(UWAString.format(tpl, itemConfig.text, Math.round(itemPourcent)));
            } else {
                item.setStyle('height', this.options.minHeight + 'px');
            }
        },

        updateItemColor: function (itemName, background) {
            if (this.options.data[itemName]) {
                this.options.data[itemName].background = background;
                this.elements.items[itemName].setStyle('background-color', background);
            }
        },

        toggleItemColor: function (name, color) {
            if (this.elements.items[name].getStyle('background-color').toLowerCase() === this.options.data[name].background.toLowerCase()) {
                this.elements.items[name].setStyle('background-color', color);
            } else {
                // revert to the original color
                this.elements.items[name].setStyle('background-color', this.options.data[name].background);
            }
        },

        getItemInfo: function (name) {
            return ({
                config: this.options.data[name],
                dom: this.elements.items[name]
            });
        },

        baseEvents: function () {
            this.addEvents({
                'onMouseOver': this.toggleBgColors,
                'onMouseOut': this.toggleBgColors
            });
        },

        toggleBgColors: function (name) {

            var config = this.options.data[name],
                color = this.findColor(config);

            if (color) {
                this.updateItemColor(name, color);
            }
        },

        findColor: function (config) {

            var color, colorMatch,
                colors = this.options.hoverColors;

            for (color in colors) {
                if (colors.hasOwnProperty(color)) {
                    if (color === config.background) {
                        colorMatch = colors[color];
                        break;
                    } else if (colors[color] === config.background) {
                        colorMatch = color;
                        break;
                    }
                }
            }

            return colorMatch;
        }
    });

    return UWA.namespace('Controls/StackedColumn', StackedColumn, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * The TabView module contains classes to create navigable tabbed views of content.
 *
 * @module   UWA/Controls/TabView
 *
 *
 * @example
 * require('UWA/Controls/TabView', function (TabView) {
 *     var tabView = new TabView({
 *         className: 'nav',
 *         tabs: [
 *               new TabView.Tab({name: 'tab1', text: 'Tab 1'})
 *               new TabView.Tab({name: 'tab2', text: 'Tab 2'})
 *         ],
 *         events: {
 *             onSelectTab: function (newTab, oldTab, event) {
 *                 newTab.setContent('some content');
 *             }
 *         }
 *     }).inject(widget.body);
 * });
 */
define('UWA/Controls/TabView', [
    'UWA/Core',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Element',
    'UWA/Controls/Abstract',
    'UWA/Controls/Carousel'
], function (UWA, Client, Event, Element, Abstract, Carousel) {
    'use strict';

    var TabView = Abstract.extend(/** @lends module:UWA/Controls/TabView.UWA.Controls.TabView# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default controls options.
         * @private
         */
        defaultOptions: {
            element: null,
            selectedTab: null,
            className: '',
            classNames: {
                tabView: 'uwa-tabview',
                tabList: 'uwa-tablist',
                tabPanels: 'uwa-tabview-panel',
                tabPanel: 'uwa-tab-panel',
                tab: 'uwa-tab',
                selected: 'selected',
                disabled: 'disabled'
            },
            scroller: {
                scrollSize: 1,
                nextButton: null,
                previousButton: null
            },
            tabScroller: false,
            tabSelector: '.uwa-tab',
            allowReload: false,
            noContent: false
        },

        /**
         *  List of tab instances.
         *
         * @type {Tab[]}
         */
        tabs: null,

        /**
         * Active tab instance.
         *
         * @type {UWA.Controls.TabView.Tab}
         */
        selectedTab: null,

        /**
         * The TabView component is designed to create navigable tabbed views of content.
         *
         * ##### Available Events
         *
         * | Event              | Description                                                      |
         * | ------------------ | ---------------------------------------------------------------- |
         * | `onAddTab`         | Triggered when a tab is added                                    |
         * | `onPreSelectTab`   | Triggered before a tab is selected                               |
         * | `onSelectTab`      | Triggered after a tab is selected                                |
         * | `onRemoveTab`      | Triggered after a tab is removed                                 |
         * | `onOverflowChange` | Triggered when tab list overflow/underflow its scroller wrapper. |
         *
         * ##### Usage
         *
         *     var tabView = new UWA.Controls.TabView({
         *         className: 'nav',
         *         tabs: [
         *             // Use Simple object
         *             {
         *                 id: 'tab1',
         *                 text: 'Tab 1'
         *             },
         *             // Or custom UWA.Controls.TabView.Tab that you can extend
         *             new UWA.Controls.TabView.Tab({
         *                 id: 'tab2',
         *                 text: 'Tab 2'
         *             })
         *         ],
         *         events: {
         *             onSelectTab: function (newTab, oldTab, event) {
         *                 newTab.setContent('some content');
         *             }
         *         }
         *     }).inject(widget.body);
         *
         *     // Select first tab
         *     tabView.selectTab('tab2');
         *
         * Output HTML:
         *
         *      <div class="uwa-tabview nav">
         *          [div class="uwa-carousel">]
         *              <ul class="uwa-tablist">
         *                  <li class="uwa-tab [uwa-tab-dropdown]"><a href="#tab1"><span class="title">Tab 1</span></a></li>
         *                  <li class="uwa-tab [selected]"><a href="#tab2"><span class="title">Tab 2</span></a></li>
         *              </ul>
         *              [<a class="uwa-carousel-button-next"><span></span></a>]
         *              [<a class="uwa-carousel-button-previous"><span></span></a>]
         *           [</div>]
         *          <div class="uwa-tabview-panel">
         *              <div id="tab1" class="uwa-tab-panel [hidden]">some content</div>
         *              <div id="tab2" class="uwa-tab-panel [selected]">some content</div>
         *          </div>
         *      </div>
         *
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @param {HTMLElement} [options.element=null]         - The tabview element
         * @param {String}      [options.className='']         - The tabview CSS class for theming
         * @param {Tab[]}       [options.tabs=null]            - An array of tabs
         * @param {Tab|String}  [options.selectedTab=null]     - Tab to make active on DOM injection
         * @param {Boolean}     [options.tabScroller=false]    - Enable tab scroller feature
         * @param {Boolean}     [options.noContent=false]      - Disable content panels
         * @param {String}      [options.tabSelector=.uwa-tab] - Tab element CSS selector
         * @param {Boolean}     [options.allowReload=false]    - Force onSelectTab event on active tab
         *
         * @constructs UWA.Controls.TabView
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/TabView
         */
        init: function (options) {

            this._parent(options);

            this.tabs = [];
            this.selectedTab = null;

            this.buildContainer();
            this.initEvents();

            if (UWA.is(this.options.tabs, 'array')) {
                this.options.tabs.forEach(this.addTab, this);
                delete this.options.tabs;
            }

            if (this.options.tabScroller ||
                    this.options.scroller.nextButton ||
                    this.options.scroller.previousButton) {
                this.createScroller();
            }
        },

        /**
         * Add a Tab at the end of the TabView or at the specified index.
         *
         * @example <caption>Add a tab with a config Object</caption>
         * tabView.addTab({id: 'xxx', text: 'Tab 1'});
         *
         * @example <caption>Add a Tab instance</caption>
         * tabView.addTab(new UWA.Controls.TabView.Tab({id: 'xxx', text: 'Tab 1'}));
         *
         * @example <caption>Add a custom Tab instance</caption>
         * tabView.addTab(new MyTab({id: 'xxx', text: 'Tab 1'}));
         *
         * @param {Object|Tab} tab - Tab instance
         * @param {Number} [index] - 0-based index position
         * @return {UWA.Controls.TabView} Fluent interface
         */
        addTab: function (tab, index) {
            var contentElement;

            // If a plain object is passed, instanciate a Tab
            if (tab instanceof TabView.Tab === false) {
                tab = new TabView.Tab(tab);
            }

            // Before adding tab, pass css classes to use by Tab instance
            tab.setOption('classNames', this.options.classNames);

            // Insert tab at the given index position
            if (UWA.is(index, 'number') && index < this.tabs.length && index >= 0) {

                tab.tabElement().inject(this.getTab(index).tabElement(), 'before');
                this.tabs.splice(index, 0, tab);

            // Insert tab at the end position (default)
            } else {
                this.elements.tabList.grab(tab.tabElement());
                this.tabs.push(tab);
            }

            // Inject tab content element into the contentNode wrapper
            if (this.elements.contentNode) {

                // If no content element is returned by the Tab at this point, continue
                contentElement = tab.contentElement();
                if (contentElement) {
                    this.elements.contentNode.grab(tab.contentElement());
                }
            }

            if (tab.options.selected) {
                this.selectTab(tab);
            }

            this.onResize();
            this.dispatchEvent('onAddTab', [tab]);

            return this;
        },

        /**
         * Removes the specified Tab from TabView and DOM.
         *
         * @fires onRemoveTab
         * @param {Tab|Number|String} tab - Tab to remove
         * @return {TabView} Fluent interface
         */
        removeTab: function (id) {

            var tab = this.getTab(id);

            if (tab) {

                // Remove tab element from DOM
                tab.remove();

                // Remove tab instance from tab's list
                this.tabs.splice(this.tabs.indexOf(tab), 1);

                this.onResize();
                this.dispatchEvent('onRemoveTab', [tab]);
            }

            return this;
        },

        /**
         * Select the specified Tab.
         *
         * @example <caption>Select a tab by its name or ID</caption>
         * tabView.selectTab('tab2344');
         *
         * @example <caption>Select a tab by its index position</caption>
         * tabView.selectTab(0);
         *
         * @fires onPreSelectTab
         * @fires onSelectTab
         * @param {Tab|Number|String} tab - Tab to select
         * @param {Event} [event] Browser event
         */
        selectTab: function (id, event) {

            var previousTab, scrollDuration,
                tab = this.getTab(id);

            if (tab) {

                if (tab !== this.selectedTab || this.options.allowReload) {

                    previousTab = this.selectedTab;

                    if (previousTab) {
                        previousTab.setSelected(false);

                    // If no previous tab, don't use scroll animation
                    } else {
                        scrollDuration = 0;
                    }

                    this.dispatchEvent('onPreSelectTab', [tab, previousTab, event]);
                    this.selectedTab = tab.setSelected(true);

                    // Update scroller size in case new selected tab have changed dimensions
                    this.onResize();
                    this.dispatchEvent('onSelectTab', [tab, previousTab, event]);
                }
                this.ensureTabIsVisible(tab, false, scrollDuration);
            }
        },

        /**
         * Enable or disable a tab.
         *
         * @param {Tab|Number|String} tab - Tab to enable
         * @param {Boolean} [enabled=false] `true` to enable, `false` to disable
         */
        enableTab: function (id, enabled) {

            var tab = this.getTab(id);

            if (tab) {
                tab.setDisabled(enabled === undefined ? false : !enabled);
            }
        },

        /**
         * Retrieves the specified Tab from the TabView.
         *
         * @example
         * tabView.getTab(0);      // get Tab at index 0
         * tabView.getTab('myId'); // get Tab by id
         * tabView.getTab(li);     // get Tab from LI element
         * tabView.getTab();       // get Current Tab
         *
         * @param {Tab|Number|String} id - Identifier of the tab to retrieve
         * @return {Tab} Tab instance if retrieved, otherwise `false`.
         */
        getTab: function (id) {

            var i, l,
                tab = false;

            if (!UWA.is(id)) {
                tab = this.selectedTab;
            } else if (id instanceof TabView.Tab) {
                tab = id;
            } else {
                // Retrieves the tab
                for (i = 0, l = this.tabs.length; i < l; i += 1) {
                    tab = this.tabs[i];
                    // If argument is a Node, compare to tab's HTML element
                    if (id && id.nodeType && tab.tabElement() === id) {
                        break;
                    // If argument is a Number, compare to tab's index position
                    // If argument is a String, compare to tab's unique id or tab's name
                    } else if (i === id || tab.getId() === id || tab.getName() === id) {
                        break;
                    }

                    tab = false;
                }
            }

            return tab;
        },

        /**
          * Move the given tab to the specified index position.
          *
          * @example:
          * tabView.moveTab(1, 0);   // Invert first and second tab
          * tabView.moveTab(tab, 2); // Move tab to third position
          *
          * @param {Tab|Number|String} id - Tab to move.
          * @param {Number} newIndex - New index position (0-based)
          * @return {Boolean} - `true` if position has changed, `false` otherwise.
          */
        moveTab: function (id, newIndex) {

            var tab, oldIndex,
                isLastPosition = (newIndex + 1 >= this.tabs.length);

            tab = this.getTab(id);
            oldIndex = this.tabs.indexOf(tab);

            if (oldIndex !== newIndex) {

                // Update tab position in tabs[]
                this.tabs.splice(newIndex, 0, this.tabs.splice(oldIndex, 1)[0]);

                // Update tab position in DOM
                if (isLastPosition) {
                    tab.tabElement().inject(this.getTab(newIndex - 1).tabElement(), 'after');
                } else {
                    tab.tabElement().inject(this.getTab(newIndex + 1).tabElement(), 'before');
                }

                return true;
            }

            return false;
        },

        /**
         * Automatically select a tab.
         *
         * @return {Boolean} `true` if a tab has been selected, otherwise `false`.
         * @private
         */
        selectDefaultTab: function () {

            var tab, i, l;

            for (i = 0, l = this.tabs.length; i < l; i += 1) {

                tab = this.tabs[i];
                if (tab.isSelectable()) {
                    this.selectTab(tab);
                    return tab;
                }
            }

            return false;
        },

        /**
         * Set HTML content for the given tab.
         * If the tab panel is not empty, the previous content is cleared.
         *
         * @param {Tab|Number|String} tab
         * @param {String|Element} content - The content to set to the given tab
         * @return {UWA.Controls.TabView} This - Fluent interface.
         */
        setTabContent: function (tab, content) {

            this.getTab(tab).setContent(content);

            return this;
        },

        /**
         * Get the Tab panel HTML element for the given tab.
         *
         * @param {Tab|Number|String} tab
         * @return HTMLElement
        */
        getTabContent: function (tab) {
            return this.getTab(tab).contentElement();
        },

        /**
         * Creates tabview (DIV), tab list (UL) and panels (DIV) wrapper elements.
         *
         * Ouput HTML:
         *
         *     <div class="[uwa-tabview]">;
         *        <ul class="[uwa-tablist]"></ul>
         *        <div class="[uwa-tabview-panel]"></div>
         *     </div>;
         *
         * @private
         */
        buildContainer: function () {

            if (this.options.element) {
                this.elements.container = UWA.extendElement(this.options.element);
                delete this.options.element;
            } else {
                this.elements.container = UWA.createElement('div');
            }

            this.elements.container.addClassName(
                this.options.classNames.tabView + ' ' + this.options.className
            );

            this.elements.tabList = UWA.createElement('ul', {
                'class': this.options.classNames.tabList
            }).inject(this.elements.container);

            if (!this.options.noContent) {
                this.elements.contentNode = UWA.createElement('div', {
                    'class': this.options.classNames.tabPanels
                }).inject(this.elements.container);
            }
        },

        /**
         * Register an Event delegation for all TabView click events.
         * Overrides this method to register other specific events.
         *
         * @private
         */
        initEvents: function () {
            this.elements.container.addEvent('click', /* this */ this.handleEvent.bind(this));
        },

        /**
         * Implements EventHandler interface (DOM2).
         * Overrides this method to handle specific actions.
         *
         * @param {Event} event - Browser event
         */
        handleEvent: function (event) {

            var tab = this.getTabFromEvent(event);

            if (tab) {

                Event.preventDefault(event);

                // Optionnaly, let Tab also handle event (does nothing by default)
                if (UWA.is(tab.handleEvent, 'function')) {
                    tab.handleEvent(event, this);
                }

                if (!tab.isDisabled()) {
                    // Select tab (does nothing if already selected)
                    this.selectTab(tab, event);
                }
            }
        },

        /**
         * Helper method to retrieve the Tab instance from a Browser event.
         *
         * @param {Event} e - Browser event
         * @return {UWA.Controls.TabView.Tab} Closest tab on which event happened
         */
        getTabFromEvent: function (event) {

            var tabElement = Event.getElement(event).getClosest(this.options.tabSelector);

            return tabElement && this.getTab(tabElement);
        },

        /* Scroll methods */

        /**
         * Create a <UWA.Controls.Carousel> instance used to scroll tabs.
         * The scroller container (uwa-scroller) MUST be set to width: auto.
         * If you need to set an explicit width, apply a width to tabView element.
         * @private
         */
        createScroller: function () {

            var that = this,
                container = that.elements.container;

            // Set a [scrollable] attribute for styling purpose
            container.setAttribute('scrollable', 'true');

            // Create Carousel instance
            this.scroller = this.getScroller();
            this.scroller.addEvent('onScrollerResize', this.onScrollerResize.bind(this));
        },

        getScroller: function () {
            if (!this.scroller) {
                this.scroller = new Carousel(this.elements.tabList, this.options.scroller);
            }
            return this.scroller;
        },

        /**
         * Fired by the tab carousel when its size has been updated.
         *
         * @param {Object} e - Custom event
         * @param {Number} e.deltaScroll - Amount of pixels scroller has resize
         * @private
         */
        onScrollerResize: function (e) {

            var previousOverflow = this.overflow;

            this.overflow = this.scroller.hasOverflow();

            if (this.overflow && this.selectedTab && (e && Math.abs(e.deltaScroll) > 100)) {
                // It may happen that scroller's size has changed by a large amount
                // of pixels at once (e.g. a DOM insert for all tabs or large window resize).
                // In that case, we want to force the active tab to be repositionned
                // in the visible zone if not strictly visible.
                this.ensureTabIsVisible(this.selectedTab, false, 0);
            }

            if (previousOverflow !== this.overflow) {

                // The above attribute may be used for styling purpose
                this.elements.container.setAttribute('overflow', String(this.overflow));

                // Trigger an event with the current overflow status
                this.dispatchEvent('onOverflowChange', [{
                    overflow: this.overflow
                }]);
            }
        },

        /**
         * Force TabView instance to refresh itself.
         */
        reload: function () {
            var currentTab = this.selectedTab;
            this.selectedTab = null;
            this.selectTab(currentTab);
        },

        /**
         * Show the list of tabs.
         */
        showTabList: function () {
            this.elements.tabList.show();
        },

        /**
         * Hide the list of tabs.
         */
        hideTabList: function () {
            this.elements.tabList.hide();
        },

        /**
         * When using a scroller, whether or not the tab is visible.
         *
         * @param {Tab|Number|String} id
         * @param {Boolean} partially
         * @return {Boolean} `true` if the tab is visible, otherwise `false`.
         */
        isTabVisible: function (id, partially) {

            var isVisible = false,
                tab = this.getTab(id);

            if (tab) {
                isVisible = this.scroller && this.scroller.isItemVisible(tab.tabElement(), partially);
            }

            return isVisible;
        },

        /**
         * When using a scroller, scroll to the tab if not strictly visible.
         * Automatically called by the selectTab method.
         *
         * @param {Tab|Number|String} id
         * @param {Boolean} partially
         * @param {Number} duration - Scroll duration (ms)
         */
        ensureTabIsVisible: function (id, partially, duration) {
            if (this.scroller) {

                if (!this.isTabVisible(id, partially)) {
                    this.scrollToTab(id, duration);
                }
            }
        },

        /**
         * Scroll the tabs forward.
         */
        scrollNext: function () {
            if (this.scroller) {
                this.scroller.scrollNext();
            }
        },

        /**
         * Scroll the tabs backward.
         */
        scrollPrevious: function () {
            if (this.scroller) {
                this.scroller.scrollPrevious();
            }
        },

        /**
         * Scroll to the specified tab.
         *
         * @param {Tab|Number|String} id - Tab to scroll
         * @param {Number} duration - Scroll duration (ms)
         */
        scrollToTab: function (id, duration) {

            var tab = this.getTab(id).tabElement();

            if (tab) {
                this.scroller.scrollToItem(tab, undefined, duration);
            }
        },

        /**
         * Select the specified DropdownTab menu item.
         *
         * @example
         * tabView.selectTabItem('mydropdownTab', 'url', feedUrl);
         *
         * @param {Tab|Number|String} id - Dropdown tab
         * @param {String} property - Menu item property to lookup
         * @param {String} value - Menu item value to compare
         * @param {Boolean} [selectTab=true] - `true` to select tab if not selected
         * @return {TabView} Fluent interface (`this`)
         */
        selectTabItem: function (id, property, value, selectTab) {

            var tab = this.getTab(id);

            if (tab instanceof TabView.DropdownTab) {

                tab.items.forEach(function (item) {
                    if (item[property] === value) {
                        tab.selectItem(item, this, selectTab !== false);
                    }
                }, this);
            }

            return this;
        },

        /**
         * Adjust tabstrip scroll size.
         */
        onResize: function () {
            if (this.scroller) {
                this.scroller.onRefresh();
            }
        },

        /**
         * Called by inject() method.
         * @private
         */
        onPreInject: function () {

            // Select a tab by default
            // Can be desactivated with option selectedTab to false
            if (this.options.selectedTab === null) {
                this.selectDefaultTab();
            }
        },

        /**
         * Update scroll sizes on DOM insertion if feature is enabled.
         * Called by inject() method.
         * @private
         */
        onPostInject: function () {
            if (this.options.selectedTab !== null) {
                this.selectTab(this.options.selectedTab);
            }
        }
    });

    TabView.Tab = Abstract.extend(/** @lends module:UWA/Controls/TabView.UWA.Controls.TabView.Tab# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default Tab options.
         * @private
         */
        defaultOptions: {

            /**
             * If set, assign a unique ID to the Tab.
             */
            id: '',

            /**
             * If set, Tab can not be activated.
             */
            disabled: false,

            /**
             * If set, Tab is made active.
             */
            selected: false,

            /**
             * The tab label
             */
            text: '',

            /**
             * The tab icon
             */
            icon: '',

            /**
             * The tab name.
             *
             * This string can be used to retrieve the tab by its name if no tab id was provided.
             * If set, adds an additionnal CSS class to tab element
             */
            name: '',

            /**
             * If set, the content displayed by this Tab (string|Element).
             */
            content: null,

            /**
             * If set, adds an additionnal CSS class to tab element
             */
            className: ''
        },

        /**
         * Provides Tab instances for use with TabView.
         *
         * @example
         * var CustomTab = UWA.Controls.TabView.Tab.extend({
         *
         *     // Overrides base method
         *     _createInnerTabElement: function () {
         *         // Build custom DOM
         *         return UWA.createElement('div', {text: 'content'});
         *     }
         * });
         *
         * var tabView = new UWA.Controls.TabView();
         * tabView.addTab(new CustomTab({id: 'someId', text: 'Custom tab'}));
         *
         *
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @param {String}      [options.id='']          - If set, assign a unique ID to the Tab.
         * @param {Boolean}     [options.disabled=false] - If set, Tab can not be activated.
         * @param {Boolean}     [options.selected=false] - If set, Tab is made active.
         *
         * @constructs UWA.Controls.TabView.Tab
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/TabView
         */
        init: function (options) {
            if (options && !options.id && options.id !== 0 && !options.name) {
                // Assign an id if not set
                options.id = Date.now().toString(36);
            }
            this._parent(options);
        },

        /**
         * Return the tab unique identifier.
         *
         * @return {String}
         */
        getId: function () {
            return this.options.id;
        },

        /**
         * Return the tab name.
         *
         * @return {String}
         */
        getName: function () {
            return this.options.name;
        },

        /**
         * Return the tab title.
         */
        getText: function () {
            return this.options.text;
        },

        /**
         * Set the tab icon.
         *
         * @param {String|Boolean} url - Icon URL or `false` to remove icon.
         * @return {Tab} Fluent interface
         */
        setIcon: function (url) {
            if (url) {
                // Add icon
                if (this.elements.icon) {
                    if (this.options.icon !== url) {
                        this.options.icon = url;
                        this.elements.icon.src = url;
                    }
                } else {
                    this.elements.icon = UWA.createElement('img', {'class': 'icon', src: url})
                        .inject(this.tabElement().getElement('.title'), 'before');
                }
            } else if (this.elements.icon) {
                // Remove icon
                this.elements.icon.remove();
            }
            return this;
        },

        /**
         * Set the tab label text.
         *
         * @param {String} Tab label
         * @return {Tab} Fluent interface
         */
        setText: function (text) {
            this.tabElement().getElement('.title').setText(text);
            return this;
        },

        /**
         * Enable or disable this tab.
         *
         * @param {Boolean} disabled - Whether or not to disable the tab
         * @return {Tab} Fluent interface
         */
        setDisabled: function (disabled) {
            if (disabled === undefined) {
                disabled = true;
            }
            this.tabElement().toggleClassName('disabled', disabled);
            if (this.elements.content) {
                this.elements.content.toggleClassName('disabled', disabled);
            }
            this.options.disabled = disabled;
            return this;
        },

        /**
         * Select or unselect the tab.
         *
         * @param {Boolean} selected - `true` to select the tab, `false` to unselect.
         * @return {Tab} Fluent interface
         */
        setSelected: function (selected) {
            this.tabElement().toggleClassName('selected', selected);
            if (this.elements.content) {
                this.elements.content
                    .toggleClassName('selected', selected)
                    .toggleClassName('hidden', !selected);
            }
            this.options.selected = selected;
            return this;
        },

        /**
         * Set the content. Or will do nothing if not content set.
         *
         * @param {String|Element} content - Tab panel content
         * @return {Tab} Fluent interface
         */
        setContent: function (content) {
            this.contentElement().setHTML(content);
            return this;
        },

        /**
         * Whether or not this tab can be selected by default
         * when there is no selected tab.
         *
         * @return {Boolean}
         */
        isSelectable: function () {
            return !this.isDisabled();
        },

        /**
         * Whether or not this tab is selected.
         *
         * @return {Boolean} `true` if the tab is selected, `false` otherwise
         */
        isSelected: function () {
            return this.options.selected;
        },

        /**
         * Whether or not this tab is disabled.
         *
         * @return {Boolean} `true` if the tab is disabled, `false` otherwise
         */
        isDisabled: function () {
            return this.options.disabled;
        },

        /**
         * Remove tab from DOM.
         */
        remove: function () {
            this.tabElement().remove();
            if (this.elements.content) {
                this.elements.content.remove();
            }
        },

        /**
         * Return Tab HTML element.
         *
         * Default HTML:
         *
         *     <li id="xxx" class="[uwa-tab]">
         *         <a href="#content"><span class="title">Title<span></a>
         *     </li>
         *
         * @return {HTMLElement}
         */
        tabElement: function () {
            if (!this.elements.container) {
                this.elements.container = this._createTabElement();
                if (this.options.name) {
                    this.elements.container.addClassName(this.options.name);
                }
                if (this.options.className) {
                    this.elements.container.addClassName(this.options.className);
                }
                if (this.options.icon) {
                    this.setIcon(this.options.icon);
                }
            }
            return this.elements.container;
        },

        /**
         * Return the Tab panel HTML element (content).
         *
         * @return {HTMLElement}
         */
        contentElement: function () {
            if (!this.elements.content) {
                this.elements.content = this._createContentElement();
                if (this.elements.content) {
                    this.elements.content.addClassName('hidden ' + this.options.name);
                }
            }
            return this.elements.content;
        },

        /**
         * Overrides this method to build custom DOM.
         * @private
         */
        _createTabElement: function () {
            var el = UWA.createElement('li', {'class': this.options.classNames.tab});
            return el.grab(this._createInnerTabElement(el));
        },

        /**
         * Overrides this method to build custom DOM.
         * @private
         */
        _createInnerTabElement: function () {
            return UWA.createElement('a', {href: this.options.id ? '#' + this.options.id : ''}).grab(
                UWA.createElement('span', {'class': 'title', text: this.options.text})
            );
        },

        /**
         * Overrides this method to build custom DOM.
         * @private
         */
        _createContentElement: function () {
            var contentEl = UWA.createElement('div', {
                id: this.options.id,
                html: this.options.content || UWA.i18n('Loading...'),
                'class': this.options.classNames.tabPanel
            });
            // Get rid of content option which for initial content only
            delete this.options.content;
            return contentEl;
        }
    });


    TabView.DropdownTab = TabView.Tab.extend(/** @lends module:UWA/Controls/TabView.UWA.Controls.TabView.DropdownTab# */{ // bypass

        /**
         * @property {Object} defaultOptions - The default Tab options.
         * @private
         */
        defaultOptions: {
            autohide: true,
            popupMenuItemSelector: '.uwa-popup-menu-item',
            classNames: {
                dropdownTab: 'uwa-tab-dropdown',
                popupMenu: 'uwa-popup-menu',
                popupMenuItem: 'uwa-popup-menu-item'
            }
        },

        /**
         * Provides DropdownTab instances for use with TabView.
         *
         * @example
         * var dropdownTab = new UWA.Controls.TabView.DropdownTab('tab2', [
         *      {text: 'Display a feed'},
         *      {text: 'Dropdown item1'},
         *      {text: 'Dropdown item2'},
         *      {text: 'Dropdown item3'}
         * ]);
         *
         * var tabView = new UWA.Controls.TabView({
         *    tabs: [
         *        {name: 'tab1', text: 'Tab one'},
         *        dropdownTab
         *   ]
         * }).inject(widget.body);
         *
         * tabView.selecteTab(dropdownTab);
         *
         * @param {String} name - Tab name.
         * @param {Array.<Object>} - An array of Tab menu items.
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.autohide=true]
         *
         * @constructs UWA.Controls.TabView.DropdownTab
         * @extends UWA.Controls.TabView.Tab
         * @memberof module:UWA/Controls/TabView
         */
        init: function (name, items) {
            this.items = items;
            this.selectedItem = items[0];
            this._parent(UWA.merge({name: String(name)}, this.selectedItem));
        },

        /**
         * Overrides base method. When the tab is beeing selected,
         * show the dropdown mark, otherwise hide it.
         *
         * @return {DropdownTab} Fluent interface.
         */
        setSelected: function (selected) {
            this._parent(selected);

            if (this.options.autohide) {
                this.elements.container.getElement('.dropdown')
                    .toggleClassName('hidden', !selected);
            }
            return this;
        },

        /**
         * When set, this method is called by parent TabView handleEvent().
         *
         * @param {UIEvent} e - Browser event
         * @param {TabView} tabView
         * @private
         */
        handleEvent: function (e, tabView) {
            if (this.isSelected()) {
                Event.stop(e);
                this.tabView = tabView;
                this.togglePopupMenu();
            }
        },

        /**
         * Display or hide PopupMenu.
         *
         * @return {Boolean} `true` if displayed else `false`.
         */
        togglePopupMenu: function () {
            var open = this.elements.container.hasClassName('open');
            if (open) {
                this.hidePopupMenu();
            } else {
                this.showPopupMenu();
            }
            return !open;
        },

        /**
         * Display popup menu for this tab.
         */
        showPopupMenu: function () {
            this.createPopupMenu();
            this.elements.container.addClassName('open');
        },

        /**
         * Hide PopupMenu.
         *
         * @param {Event}
         */
        hidePopupMenu: function (e) {
            // If body we have click, only hide if not inside popup
            if (e) {
                var target = UWA.Event.getElement(e).getClosest('.' + this.options.classPopupMenu);
                if (target) {
                    return;
                }
            }
            this.elements.container.removeClassName('open');
            if (this.elements.popupMenu) {
                // Remove from DOM + remove events
                this.elements.popupMenu.destroy();
                delete this.elements.popupMenu;
            }
            if (this.boundHidePopupMenu) {
                // Remove click body listener
                Element.removeEvent.apply(document.body, ['click', this.boundHidePopupMenu]);
                delete this.boundHidePopupMenu;
            }
            if (this.tabView) {
                this.tabView = null;
                delete this.tabView;
            }
        },

        /**
         * Create PopupMenu container.
         *
         * @return {HTMLElement} PopPupMenu container
         */
        createPopupMenu: function () {
            var i, l, popupMenuDimensions, tabDimensions;

            if (this.elements.popupMenu) {
                this.elements.popupMenu.remove();
            }

            // Create menu container
            this.elements.popupMenu = UWA.createElement('ul', {
                'class': this.options.classNames.popupMenu,
                events: {
                    click: this.onPopupMenuItemClick.bind(this)
                }
            });

            // Add menu items
            for (i = 0, l = this.items.length; i < l; i++) {
                if (this.selectedItem !== this.items[i]) {
                    this._createPopupMenuItem(this.items[i])
                        .inject(this.elements.popupMenu).setAttribute('data-index', i);
                }
            }

            // Inject popup
            this.elements.popupMenu.inject(
                this.elements.container.getParent('.' + this.options.classNames.tabView)
            ).setPosition({
                x: 0,
                y: this.elements.container.getDimensions().height
            }, {
                relative: this.elements.container,
                boundary: 'auto',
                fit: 'resize-max'
            });

            // Strech popup dimensions to have same width as the tab
            popupMenuDimensions = this.elements.popupMenu.getDimensions();
            tabDimensions = this.elements.container.getDimensions();

            if (popupMenuDimensions.width < tabDimensions.width) {
                this.elements.popupMenu.setStyle('width', tabDimensions.width + 'px');
            }

            // Add a temporary click event listener on body that will close the menu
            // This listener is removed in hidePopupMenu
            if (!this.boundHidePopupMenu) {
                this.boundHidePopupMenu = this.hidePopupMenu.bind(this);
                Element.addEvent.apply(document.body, ['click', this.boundHidePopupMenu]);
            }

            return this.elements.popupMenu;
        },

        /**
         * Select a popup menu item.
         *
         * @example
         * tab.selectItem('url', feedUrl); // Select item by property
         * tab.selectItem(item, feedUrl);
         *
         * @param {Object} item - Tab item such as {text: 'menu item1'}
         * @param {TabView} tabView - TabView instance
         * @param {Boolean} [selectTab=true] -  `true` to select tab if not selected
         */
        selectItem: function (item, tabView, selectTab) {

            if (UWA.is(item, 'object')) {

                // If a 'handler' was passed, let user function do the action
                // E.g. "Open a popup window"
                if (UWA.is(item.handler, 'function')) {
                    // this.notify('onExtendedActionClicked');
                    item.handler.call(this);

                } else if (item !== this.selectedItem) {

                    var parentControl = tabView || this.tabView;

                    // Update tab text and icon
                    this.tabElement().getElement('.title').setText(item.text || '');

                    if (item.icon) {
                        this.setIcon(item.icon);
                    }

                    this.previousItem = this.selectedItem;
                    this.selectedItem = item;

                    if (parentControl) {
                        if (selectTab !== false) {
                            // Let dispatch a 'select' event telling that active tab has changed
                            parentControl.selectedTab = null;
                            parentControl.selectTab(this);
                        }
                    }
                }
                this.hidePopupMenu();
            }
        },

        onPopupMenuItemClick: function (e) {

            Event.stop(e);

            var target = UWA.Event.getElement(e).getClosest(this.options.popupMenuItemSelector), index, tabItem;

            if (target) {
                index = Number(target.getAttribute('data-index'));
                tabItem = this.items[index];
                if (tabItem) {
                    this.selectItem(tabItem);
                }
            }
        },

        _createPopupMenuItem: function (item) {
            var menuItemEl = UWA.createElement('li', {'class': this.options.classNames.popupMenuItem}),
                menuItemLink = UWA.createElement('a').inject(menuItemEl);

            if (item.icon) {
                menuItemLink.grab(
                    UWA.createElement('img', {src: item.icon, 'class': 'icon'})
                );
            }
            menuItemLink.grab(
                UWA.createElement('span', {text: item.text})
            );
            return menuItemEl;
        },

        _createTabElement: function () {
            return this._parent().addClassName(this.options.classNames.dropdownTab);
        },

        _createInnerTabElement: function () {
            return UWA.createElement('a', {href: this.options.id ? '#' + this.options.id : ''}).grab(
                UWA.createElement('span', {'class': 'title', text: this.options.text})
            ).grab(
                UWA.createElement('span', {'class': 'dropdown hidden'})
            );
        }
    });

    return UWA.namespace('Controls/TabView', TabView, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * This module provides a set custom button like input closable.
 *
 * @module   UWA/Controls/Tag
 *
 *
 * @see http://uwa.netvibes.com/apps/Samples/Controls/Tag/index.xhtml
 */
define('UWA/Controls/Tag', [
    'UWA/Core',
    'UWA/Event',
    'UWA/Controls/Input'
], function (UWA, Event, Input) {
    'use strict';

    // {{{ Tag

    /**
     * Represents a tag.
     * Inherits from Input.Button.
     *
     * ##### Available Events
     *
     * | Event            |  Description                                        |
     * | ---------------- | --------------------------------------------------- |
     * | `onClick`        | When the user click on the control                  |
     * | `onClose`        | When the user clicks on the close icon              |
     *
     * ##### Available CSS Classes
     *
     * The className option can be composed of one or more of those CSS classes:
     *
     * __Themes__: all UWA.Input.Controls.Button themes
     *
     * @example
     * var tag = new UWA.Controls.Tag({
     *     value: "A tag",
     *     events: {
     *         onClick: function () {
     *              this.setClosable(true); // Make the tag closable
     *          },
     *         onClose: function () {
     *              this.setClosable(false); // Make the tag not closable (removes the cross)
     *          }
     *     }
     * }).inject(widget.body);
     *
     * @param {Object} options - Options hash or a option/value pair. Support all options
     * from {@link module:UWA/Controls/Input.UWA.Controls.Input|UWA.Controls.Input} and
     * some specific to this control.
     * @param {Boolean} [options.closable=false] - If the element should be closable
     *
     * @constructs UWA.Controls.Tag
     * @extends module:UWA/Controls/Input.UWA.Controls.Input.Button
     * @memberof module:UWA/Controls/Tag
     */
    var Tag = Input.Button.extend(/** @lends module:UWA/Controls/Tag.UWA.Controls.Tag# */{ // bypass

        /**
         * @property {String} name - The input name. Default: 'uwa-tag'.
         * @protected
         */
        name: 'uwa-tag',

        /**
         * @property {Object} options - The default controls options.
         * @protected
         */
        options: {
            closable: false
        },

        buildSkeleton: function () {
            this._parent();
            var text = this.elements.input.getText();
            this.elements.input.empty();
            this.elements.input = UWA.createElement('div', {
                'class': this.getClassNames('-title'),
                'text': text
            });

            this.elements.content.addContent([
                this.elements.input,
                UWA.createElement('div', {
                    'class': this.getClassNames('-close') + ' uwa-icon',
                    'data-icon': ',',
                    events: {
                        click: this._close.bind(this)
                    }
                })
            ]);

            this.setClosable(this.options.closable);
        },

        /**
         * Toggle the state of the tag
         *
         * @param {Boolean} [closable=true] If `false`, remove the close button.
         */
        setClosable: function (closable) {
            this.elements.container.toggleClassName('closable', closable !== false);
        },


        _close: function (e) {
            this.dispatchEvent('onClose');
            Event.stop(e);
        },

        buildInput: function () {
            return UWA.createElement('div', { tabindex: '0' });
        }
    });

    // }}}

    return UWA.namespace('Controls/Tag', Tag, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global define, _, window*/

/**
 * @module   UWA/Controls/Web
 *
 */
define('UWA/Controls/Web', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Controls/Abstract',
    'UWA/Class/Timed'
], function (
    UWA,
    UWAUtils,
    Abstract,
    Timed
) {
    'use strict';

    function list() {
        var result = {};
        var i, l;
        for (i = 0, l = arguments.length; i < l; i++) {
            result[arguments[i]] = true;
        }

        return result;
    }

    var transparentBackgroundList = list(
        'www.skateslate.com',
        'www.pravdareport.com'
    );

    var Web = Abstract.extend(Timed, /** @lends module:UWA/Controls/Web.UWA.Controls.Web# */{ // bypass

        defaultOptions: {
            url: 'about:blank',
            width: '100%',
            height: '',
            className: 'uwa-web',
            scrolling: 'auto',
            border: false,
            sandbox: false,
            withMessage: false
        },

        /**
         * Display a web content through an iframe.
         *
         * ##### Available Events
         *
         * | Event            |  Description                           |
         * | ---------------- | -------------------------------------- |
         * | `onResize`       | Invoked when control need to resize    |
         * | `onLoad`         | Invoked when the frame load.           |
         * | `onError`        | Invoked when the frame load fail       |
         *
         * @example
         * var myControl = new UWA.Controls.Web({
         *     url: 'http://netvibes.com'
         * });
         *
         * myControl.inject(myControlContainer);
         * // OR
         * myControlContainer.appendChild(myControl.getContent());
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {String} [options.url='about:blank'] - Web Content url
         * @param {String} [options.width='100%'] - Iframe width
         * @param {String} [options.height='100%'] - Iframe height
         * @param {String} [options.className='uwa-web'] - Customized container classname
         * @param {String} [options.scrolling='auto'] - Display Iframe scroller bars
         * @param {Boolean} [options.border=false] - Display Iframe borders
         * @param {Boolean} [options.sandbox=false] - Enable Iframe sandbox (Also disable plugin like flash)
         * @param {Boolean} [options.withMessage=false] - Display a message during loading / if embed is forbidden
         *
         * @constructs UWA.Controls.Web
         * @extends UWA.Controls.Abstract
         * @memberof module:UWA/Controls/Web
         */
        init: function (options) {

            this._parent(options);

            this.buildSkeleton();
        },

        /**
         * Build main dom elements.
         */
        buildSkeleton: function () {

            var iframe, iframeOptions,
                elements = this.elements,
                options = this.options;

            iframeOptions = {
                width: options.width,
                height: options.height,
                scrolling: options.scrolling,
                frameborder: (options.border ? 1 : 0)
            };

            if (options.sandbox) {
                iframeOptions.sandbox = 'allow-same-origin allow-forms allow-scripts allow-popups';
            }

            if (!options.url) {
                options.url = 'about:blank';
            }

            elements.container = UWA.createElement('div', {
                'class': options.className
            });

            elements.iframe = iframe = UWA.createElement('iframe', iframeOptions);

            iframe.onload = this.dispatchAsEventListener('onLoad');
            iframe.onerror = this.dispatchAsEventListener('onError');

            if (options.withMessage) {
                elements.container.addContent(UWA.createElement('div', {
                    'class': 'uwa-web-message',
                    html: elements.loadingMessage = UWA.createElement('p', {'class': 'loading-message'})
                }));

                this.addEvent('onLoad', function () {
                    if (this._shouldClearMessage()) {
                        elements.loadingMessage.empty();
                        return;
                    }
                    // Most websites should display a plain
                    // background. We display an error
                    // message under the iframe so it will
                    // be hidden if the website loads
                    // successfully, and displayed if it
                    // fails.
                    if (!this._isSecureIFrame(options.url)) {
                        this.setDelayed('websitemessage', function () {
                            elements.loadingMessage.setText(_("This app is trying to load unsecure content."));
                        }, 1000);
                    } else {
                        this.setDelayed('websitemessage', function () {
                            elements.loadingMessage.setText(_("This website prevents embedding via iframe."));
                        }, 1000);
                    }
                }.bind(this));
            }

            elements.container.addContent(iframe);

            if (this._isSecureIFrame(options.url)) {
                this.setSrc(options.url);
            }
        },

        /**
         * Set the src attribute of the iframe (start loading process).
         *
         * @param {String} src
         */
        setSrc: function (src) {
            this.elements.iframe.src = src;

            if (this.options.withMessage) {
                if (src === 'about:blank') {
                    this.elements.loadingMessage.empty();
                } else {
                    this.elements.loadingMessage.setText(_("Loading\u2026"));
                }
            }
        },

        /**
         * Set the iFrame height.
         *
         * @param {Number} height
         */
        setIFrameHeight: function (height) {
            this.elements.iframe.setStyle('height', height);
        },

        /**
         * Returns true if iframe src target the 'about:blank' url, false otherwise.
         *
         * @return {Boolean}
         */
        isBlank: function () {
            return this.elements.iframe.src === 'about:blank';
        },

        /**
         * Returns the underlying iframe UWA/Element.
         *
         * @return {UWA/Element}
         */
        getIFrame: function () {
            return this.elements.iframe;
        },

        /**
         * @private
         *
         * @return {Boolean}
         */
        _isSecureIFrame: function (src) {
            var nvUrl = UWAUtils.parseUrl(window.location.href);
            var iframeUrl = UWAUtils.parseUrl(src);

            return nvUrl.protocol === 'http' || (nvUrl && nvUrl.protocol === 'https' && iframeUrl && iframeUrl.protocol === 'https');
        },

        /**
         * @private
         *
         * @return {Boolean}
         */
        _shouldClearMessage: function () {
            var src = this.elements.iframe.src;

            if (this.isBlank() || /\.(png|jpe?g|gif|txt)$/i.test(src)) {
                return true;
            }

            var domain = UWAUtils.parseUrl(src).domain;

            return UWA.owns(transparentBackgroundList, domain);
        }
    });

    return UWA.namespace('Controls/Web', Web, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Auth
 *
 */
define('UWA/Services/Auth', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options'
], function (UWA, Class, Options) {
    'use strict';

    var Auth = Class.extend(Options, /** @lends module:UWA/Services/Auth.UWA.Services.Auth# */ { // bypass

        /**
         * The current adapter instance to use for auth.
         * @private
         */
        Adapter: null,

        /**
         * Provide global settings for overwriting.
         *
         * @type {Object}
         * @private
         */
        defaultOptions: {
            adapter: null,
            adapterOptions: {}
        },

        /**
         * UWA.Services.Auth constructor.
         *
         * @param {Object} options - Options hash or a option/value pair.
         * @param {Object} options.adapter - Adapter instance
         * @param {Object} [options.adapterOptions] - Adapter options
         *
         * @constructs UWA.Services.Auth
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Services/Auth
         */
        init: function (options) {

            this.setOptions(options);

            this.initAdapter();
        },

        /**
         * Init Adapter instance.
         *
         * @return Nothing, but set this.Adapter value.
         */
        initAdapter: function () {

            var adapterName = this.options.adapter,
                adapterOptions = this.options.adapterOptions;


            // Support for Adapter instance has adapter param value
            if (adapterName instanceof UWA.Services.Auth.Adapter.Abstract) {

                adapterName.setOptions(adapterOptions);
                this.Adapter = adapterName;

            // Fail if adapter if not string
            } else if (typeof adapterName !== 'string') {
                throw new Error('Bad adapter options value <' + adapterName + '>.');

            // Else try to create instance of adapter
            } else {

                try {

                    this.Adapter = new UWA.Services.Auth.Adapter[adapterName](adapterOptions);

                    if (!(this.Adapter instanceof UWA.Services.Auth.Adapter.Abstract)) {
                        throw new Error('UWA.Services.Auth.Adapter.' + adapterName + ' is not an instance of UWA.Services.Auth.Adapter.Abstract');
                    }

                } catch (e) {
                    throw new Error('Unable to initialize adapter with name <' + adapterName + '> cause: ' + e);
                }
            }
        },

       /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - on success callback
         * @param {Function} onFailure - on failure callback
         */
        hasIdentity: function (onSuccess, onFailure) {
            this.Adapter.hasIdentity(onSuccess, onFailure);
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - on success callback
         * @param {Function} onFailure - on failure callback
         */
        getIdentity: function (onSuccess, onFailure) {
            this.Adapter.getIdentity(onSuccess, onFailure);
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onSuccess - on success callback
         */
        clearIdentity: function (onSuccess) {
            this.Adapter.clearIdentity(onSuccess);
        },

        /**
         * Authenticate user.
         *
         * @param {Object} credentials - Auth adapter credentials
         * @param {Function} onSuccess - on success callback
         * @param {Function} onFailure - on failure callback
         */
        authenticate: function (credentials, onSuccess, onFailure) {
            this.Adapter.authenticate(credentials, onSuccess, onFailure);
        },

        /**
         * Encode an Adapter to a url string that could be use by UWA.Data.request for example.
         *
         * @example
         * var MyAuth = UWA.Services.Auth({
         *    adapter: 'OAuth',
         *    adapterOptions: {
         *        ...
         *    }
         * });
         *
         * UWA.Data.request(providerOptions.url, {
         *    proxy: 'ajax',
         *    authentication: MyAuth
         * });
         *
         * @return {String} Adapter encoded string.
         */
        toQueryString: function () {
            return this.Adapter.toQueryString();
        }
    });

    return UWA.namespace('Services/Auth', Auth, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Plugins/Auth
 *
 */
define('UWA/Plugins/Auth', [
    'UWA/Core',
    'UWA/Plugins/Abstract',
    'UWA/Utils/Client',
    'UWA/Event',
    'UWA/Controls/Form',
    'UWA/Services/Auth'
], function (UWA, Abstract, Client, Event, Form, ServiceAuth) {
    'use strict';

    /**
     * @class UWA.Plugins.Auth
     * @extends UWA.Plugins.Abstract
     */
    var Auth = Abstract.extend(/** @lends module:UWA/Plugins/Auth.UWA.Plugins.Auth# */{ // bypass

        defaultOptions: {
            formOptions: {
                loginLabel: 'Login',
                passwordLabel: 'Password',
                logoutLabel: 'Logout',
                submitLabel: 'Sign In',
                loadingCredential: 'Credentials validation loading...',
                requireCredential: 'Authentication required!',
                invalidCredential: 'Login / Password combination is incorrect.'
            }
        },

        /**
         * The current auth state.
         *
         * - `0` init
         * - `1` checking
         * - `2` request credentials
         * - `3` failure
         * - `4` success
         *
         * @type {Number}
         */
        state: 0,

        /**
         * This Plugin add an Authentication form to your widget.
         *
         * ##### Examples
         *
         * Using plugin in Widget Javascript:
         *
         * ```html
         * <script type="text/javascript" src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Plugins_Auth.js"></script>
         * <script type="text/javascript" src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Services_Auth.js"></script>
         * <script type="text/javascript" src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Services_Auth_Adapter_Abstract.js"></script>
         * <script type="text/javascript" src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Services_Auth_Adapter_SiteMinder.js"></script>
         * <script type="text/javascript">
         * var MyPlugin = UWA.Plugins.Auth(widget, {
         *    adapter: 'SiteMinder',
         *    adapterOptions: {...},
         *    formOptions: {...},
         * });
         * </script>
         * ```
         *
         * Using plugin in Widget Manifest:
         *
         * ```html
         * <widget:plugins>
         * <widget:plugin name="Auth">
         *    <widget:option name="adapter" value="SiteMinder" />
         *    <widget:options name="adapterOptions">
         *        <widget:option name="smagentname" value="abc..." />
         *        <widget:option name="realmoid" value="123..." />
         *        <widget:option name="type" value="123..." />
         *        <widget:option name="forest" value="dc=uwa,dc=com" />
         *        <widget:option name="target" value="https://apps.example.com/myapp/test.json" />
         *        <widget:option name="login" value="https://apps.example.com/global/2.0/login.fcc" />
         *        <widget:option name="logout" value="https://apps.example.com/global/2.0/logout.fcc" />
         *    </widget:options>
         *    <widget:options name="formOptions">
         *        <widget:option name="logoUrl" value="https://apps.example.com/global/2.0/images/masthead.jpg" />
         *        <widget:option name="loginLabel" value="User ID or Email" />
         *        <widget:option name="passwordLabel" value="Password" />
         *        <widget:option name="logoutLabel" value="Logout" />
         *        <widget:option name="submitLabel" value="Sign In" />
         *        <widget:option name="loadingCredential" value="Credentials validation loading..." />
         *        <widget:option name="invalidCredential" value="The User ID / Password combination is incorrect." />
         *        <widget:option name="warningTitle" value="ATTENTION" />
         *        <widget:option name="warningText" value="Access to this website is restricted to users that have been authorized. " />
         *    </widget:options>
         * </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Using Exposition Server application.ini config file:
         *
         * ```
         * exposition.widget.libraries.Auth                            = "UWA_Plugins_Auth.js";
         * exposition.widget.libraries.Auth                            = "UWA_Service_Auth_Adapter_Abstract.js";
         * exposition.widget.libraries.Auth                            = "UWA_Service_Auth_Adapter_SiteMinder.js";
         * exposition.widget.plugins.Auth.adapter                      = "SiteMinder";
         * exposition.widget.plugins.Auth.adapterOptions.smagentname   = "abc...";
         * exposition.widget.plugins.Auth.adapterOptions....
         * exposition.widget.plugins.Auth.formOptions.logoUrl          = "https://apps.example.com/global/2.0/images/masthead.jpg";
         * exposition.widget.plugins.Auth.formOptions....
         * ```
         *
         * @param {Object} widget
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Plugins.Auth
         * @memberof module:UWA/Plugins/Auth
         */
        init: function (widget, options) {

            // Init Instance properties
            this.elements = {};

            // Call Parent init
            this._parent(widget, options);

            // Init Authentication Service
            this.auth = new ServiceAuth(this.options);

            // Save Widget original body
            this.saveWidgetBody();

            if (Client.isOnline()) {
                this.addEvent('onLoad', this.checkIdentity, this, 1);
                this.addEvent('onRefresh', this.checkIdentity, this, 1);
            } else {
                this.onAuthenticateFailure('offline');
            }
        },

        checkIdentity: function () {

            // Check hasIdentity if required
            if (this.state === 0) {

                // Set current state to checking
                this.state = 1;

                this.onAuthenticateLoading();

                this.auth.hasIdentity(
                    this.onAuthenticateSuccess.bind(this),
                    this.onAuthenticateFailure.bind(this)
                );
            }

            return this.state === 4;
        },

        onAuthenticateSuccess: function () {

            // Set current state to success
            this.state = 4;

            this.addLogout();

            this.restoreWidgetBody();

            this.dispatchEvent('onLoad');
        },

        onAuthenticateFailure: function (error) {

            this.error = error;

            // Set current state to failure if previous one is request
            if (this.state === 2) {
                this.state = 3;
            }

            // Display authentication form
            this.addForm();
        },

        onAuthenticateLoading: function () {
            this.addLoading();
        },

        onClearIdentity: function () {

            // Clear user identity
            this.auth.clearIdentity();

            // Set current state to init
            this.state = 0;

            // Display authentication forms
            this.addForm();
        },

        onFormSubmit: function (event) {

            Event.stop(event);

            // Disable submit
            this.elements.form.getField('signin').disabled = true;

            this.onAuthenticateLoading();

            // Set current state to request
            this.state = 2;

            this.auth.authenticate(
                this.onAuthenticateSuccess.bind(this),
                this.onAuthenticateFailure.bind(this),
                this.elements.form.getFormValues()
            );
        },

        saveWidgetBody: function () {

            if (!this.widgetBody) {

                var i, l,
                    widget = this.widget,
                    widgetBodyChilds = widget.body.getChildren();

                // Save Widget Body
                this.widgetBody = document.createDocumentFragment();
                for (i = 0, l = widgetBodyChilds.length; i < l; i++) {
                    this.widgetBody.appendChild(widgetBodyChilds[i]);
                }
            }
        },

        restoreWidgetBody: function () {

            // Restore Widget Body
            this.widget.setBody(this.widgetBody);
            this.widgetBody = false;
        },

        addLoading: function () {

            var that = this,
                widget = that.widget;

            that.elements.loading = widget.createElement('p', {
                text: UWA.i18n(this.options.formOptions.loadingCredential),
                styles: {
                    textAlign: 'center'
                }
            }).inject(widget.elements.body.empty());
        },

        addForm: function () {

            var that = this,
                i18n = UWA.i18n,
                widget = that.widget,
                formOptions = that.options.formOptions;

            // Remove Logout Button
            this.removeLogout();

            that.elements.form = new Form({
                fields: [
                    {
                        type: 'img',
                        src: formOptions.logoUrl
                    },
                    {
                        type: 'html',
                        html: {
                            tag: 'p',
                            title: this.error && (this.error.message || this.error),
                            text: (this.state === 3 ? formOptions.invalidCredential : formOptions.requireCredential),
                            styles: {
                                textAlign: 'center'
                            }
                        }
                    },
                    {
                        type: 'text',
                        name: 'login',
                        label: i18n(formOptions.loginLabel),
                        value: ''
                    },
                    {
                        type: 'password',
                        name: 'password',
                        label: i18n(formOptions.passwordLabel),
                        value: ''
                    },
                    {
                        type: 'submit',
                        name: 'signin',
                        value: i18n(formOptions.submitLabel)
                    },
                    {
                        type: 'html',
                        html: [
                            {
                                tag: 'b',
                                text: formOptions.warningTitle
                            },
                            {
                                tag: 'p',
                                text: formOptions.warningText,
                                styles: {
                                    textAlign: 'justify'
                                }
                            }
                        ]
                    }
                ],
                events: {
                    onSubmit: this.onFormSubmit.bind(this)
                }
            }).inject(widget.elements.body.empty());

            // Focus on login field, but not on vista
            // TODO Why?
            if (widget.environment.name !== 'vista') {
                that.elements.form.getField('login').focus();
            }
        },

        removeLogout: function () {
            var logout = this.elements.logout;
            if (logout) {
                logout.remove();
            }
        },

        addLogout: function () {

            var that = this,
                widget = that.widget,
                logoutLabel = UWA.i18n(that.options.formOptions.logoutLabel);

            that.elements.logout = widget.createElement('a', {
                title: logoutLabel,
                styles: {
                    border: 'none',
                    position: 'absolute',
                    top: '0px',
                    right: '5px'
                },
                html: {
                    tag: 'img',
                    src: UWA.hosts.uwa + UWA.paths.css + 'base/img/logout.png',
                    height: 18,
                    width: 20,
                    alt: logoutLabel
                },
                events: {
                    click: function (event) {
                        Event.stop(event);
                        that.onClearIdentity();
                    }
                }
            }).inject(widget.elements.content);
        }
    });

    return UWA.namespace('Plugins/Auth', Auth, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Plugins/Ecosystem
 *
 */
define('UWA/Plugins/Ecosystem', [
    'UWA/Core',
    'UWA/Plugins/Abstract',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Data',
    'UWA/Storage'
], function (UWA, Abstract, Utils, Client, Data, Storage) {
    'use strict';

    /**
     * @class UWA.Plugins.Ecosystem
     * @extends UWA.Plugins.Abstract
     */
    var Ecosystem = Abstract.extend(/** @lends module:UWA/Plugins/Ecosystem.UWA.Plugins.Ecosystem# */{ // bypass

        defaultOptions: {
            api: UWA.hosts.ecosystem.replace('://', '://api.'),
            front: UWA.hosts.ecosystem,
            interval: 86400, // 24 hours
            messages: {
                unavailable: "This Application is not available because it's under maintenance.",
                suspended: "This Application is not available because it's suspended."
            }
        },

        status: ['unknown', 'online', 'unavailable', 'suspended'],

        /**
         * This Plugin add an Netvibes Ecosystem widget availability checking and remotly disabling
         * for all platforms.
         *
         * ##### Examples
         *
         * Using plugin in Widget Javascript:
         *
         * ```html
         * <script type="text/javascript" src="http://uwa.netvibes.com/lib/c/UWA/js/UWA_Plugins_Ecosystem.js"></script>
         * <script type="text/javascript">
         *    var MyPlugin = UWA.Plugins.Ecosystem(widget, {
         *        api: 'http://api.eco.netvibes.com',
         *        front: 'http://eco.netvibes.com',
         *        interval: 86400
         *    });
         * </script>
         * ```
         *
         * Using plugin in Widget Manifest:
         *
         * ```html
         * <widget:plugins>
         *  <widget:plugin name="Ecosystem">
         *    <widget:option name="api" value="http://api.eco.netvibes.com">
         *    <widget:option name="front" value="http://eco.netvibes.com">
         *    <widget:option name="interval" value="86400">
         *  </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Using Exposition Server application.ini config file:
         *
         * ```
         * exposition.widget.libraries.Ecosystem           = "UWA_Plugins_Ecosystem.js";
         * exposition.widget.plugins.Ecosystem.api         = "http://api.eco.netvibes.com";
         * exposition.widget.plugins.Ecosystem.front       = "http://eco.netvibes.com";
         * exposition.widget.plugins.Ecosystem.interval    = "86400";
         * ```
         *
         * @param {Object} widget
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Plugins.Ecosystem
         * @memberof module:UWA/Plugins/Ecosystem
         */
        init: function (widget, options) {

            // Call Parent init
            this._parent(widget, options);

            // Init Database
            this.database = new Storage({
                database: '__plugin_ecosystem_' + Utils.getCheckSum(widget.getUrl())
            });

            if (Client.isOnline()) {
                this.addEvent('onLoad', this.checkStatus);
            }
        },

        checkStatus: function () {

            var status = this.getStatus();

            // If Database is not ready try later
            if (!this.database.isReady) {
                this.environment.setDelayed('EcosystemCheckStatus', this.checkStatus.bind(this), 5000);
            } else {

                if (!UWA.is(status)) {

                    Data.request(this.options.api + '/widget/status', {
                        onComplete: this.checkStatusComplete.bind(this),
                        onFailure: this.checkStatusFailure.bind(this),
                        cache: false,
                        type: 'json',
                        data: {
                            url: this.widget.getUrl(),
                            format: 'json'
                        }
                    });

                } else {

                    // Remove Events to avoid a loop
                    this.removeEvent('onLoad', this.checkStatus);

                    this.checkStatusComplete(status);
                }
            }

            // Return false to interupt dispatch of Events
            return false;
        },

        checkStatusComplete: function (data) {

            var status = this.status,
                currentState = data.state ? parseInt(data.state, 10) :  1;

            this.saveStatus(currentState);

            if (currentState > 1) {
                this.setStatusMessage(status[currentState]);
            } else {
                this.dispatchEvent('onLoad');
            }
        },

        checkStatusFailure: function () {

            // Save has unknown
            this.saveStatus(0);

            // Dispatch onLoad
            this.dispatchEvent('onLoad');
        },

        getStatus: function () {

            var status = this.database.get('status'),
                statusTimestamp = parseInt(this.database.get('status_timestamp'), 10),
                nextTimestamp = (Math.round(Date.now() / 1000) - this.options.interval);

            return (!UWA.is(status) || statusTimestamp < nextTimestamp ? null : status);
        },

        saveStatus: function (value) {
            this.database.set('status', value);
            this.database.set('status_timestamp', Math.round(Date.now() / 1000));
        },

        setStatusMessage: function (status, message) {

            var i18n = UWA.i18n,
                widget = this.widget;

            message = message || this.options.messages[status];

            // Set Widget Error Message
            widget.setTitle(i18n('Unavailable Application'));
            widget.setBody(i18n(message));
        }
    });

    return UWA.namespace('Plugins/Ecosystem', Ecosystem, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window, document
*/

/**
 * @module   UWA/Plugins/GoogleAnalytics
 *
 */
define('UWA/Plugins/GoogleAnalytics', [
    'UWA/Core',
    'UWA/Plugins/Abstract',
    'UWA/Utils',
    'UWA/Utils/Client',
    'UWA/Json'
], function (UWA, Abstract, Utils, Client, Json) {
    'use strict';

    /**
     * @class UWA.Plugins.GoogleAnalytics
     * @extends UWA.Plugins.Abstract
     */
    var GoogleAnalytics = Abstract.extend(/** @lends module:UWA/Plugins/GoogleAnalytics.UWA.Plugins.GoogleAnalytics# */{ // bypass

        /**
         * This Plugin add an Google Analytics tracker to your widget.
         *
         * ##### Examples
         *
         * Using plugin in Widget Javascript:
         *
         * ```html
         * <script type="text/javascript" src="http://cdn.uwa.preview.netvibes.com/lib/c/UWA/js/UWA_Plugins_GoogleAnalytics.js"></script>
         * <script type="text/javascript">
         *    var MyPlugin = UWA.Plugins.GoogleAnalytics(widget, {
         *        '_setAccount': 'UA-XXXX'
         *    });
         * </script>
         * ```
         *
         * Using plugin in Widget Manifest:
         *
         * ```html
         * <widget:plugins>
         *  <widget:plugin name="GoogleAnalytics">
         *    <widget:option name="_setAccount" value="UA-XXXX">
         *  </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Or:
         *
         * ```html
         * <widget:plugins>
         *  <widget:plugin name="GoogleAnalytics">
         *    <widget:options name="UA-XXXX">
         *        <widget:option name="_setDomainName" value=".example.com" />
         *    </widget:options>
         *  </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Using Exposition Server application.ini config file:
         *
         * ```
         * exposition.widget.libraries.GoogleAnalytics             = "UWA_Plugins_GoogleAnalytics.js";
         * exposition.widget.plugins.GoogleAnalytics._setAccount   = "UA-XXXX";
         * ```
         *
         * @param {Object} widget
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Plugins.GoogleAnalytics
         * @memberof module:UWA/Plugins/GoogleAnalytics
         */
        init: function (widget, options) {

            // Call Parent init
            this._parent(widget, options);

            this.initScript();

            this.addEvent('beforeLoad', this.loadScript);
        },

        initScript: function () {

            var option, optionValue, optionType, hasTracker,
                options = this.options,
                gaq = window._gaq || [];

            // Forward Options to Google Analytics
            for (option in options) {
                if (options.hasOwnProperty(option)) {

                    optionValue = options[option];
                    optionType = UWA.typeOf(optionValue);

                    // Handle tracker ID option UA-XXX
                    if (option.contains('UA-')) {

                        if (hasTracker) {
                            gaq.push(['_trackPageview']);
                        }

                        hasTracker = true;
                        gaq.push(['_setAccount', option]);
                    }

                    // Handle Json optionValue
                    if (Json.isJson(optionValue)) {
                        optionValue = Json.decode(optionValue);
                        optionType = UWA.typeOf(optionValue);
                    }

                    if (optionType === 'array') {

                        gaq.push(optionValue);

                    } else if (optionType === 'string' || optionType === 'number') {

                        if (!hasTracker && optionType === 'string') {
                            hasTracker = optionValue.contains('UA-');
                        }

                        gaq.push([option, optionValue]);
                    } else {
                        throw new Error('Invalid GoogleAnalytics Plugin option with value "' + Json.encode(optionValue) + '".');
                    }
                }
            }

            if (hasTracker) {

                this.addCustomVars(gaq);

                gaq.push(['_trackPageview']);
            }

            window._gaq = gaq;

            // Track externals links
            this.addEvent('onOpenURL', this.openURL);
        },

        addCustomVars: function (gaq) {

            // Track Custom Var
            /*
            gaq.push(['_setCustomVar',
              1,                        // This custom var is set to slot #1.  Required optioneter.
              'Widget',                 // The name acts as a kind of category for the user activity.  Required optioneter.
              this.widget.getUrl(),     // This value of the custom variable.  Required optioneter.
              1                         // Sets the scope to session-level.  Optional optioneter.
            ]);
            */
            var referer,
                WidgetUri = Utils.parseUrl(this.widget.getUrl());

            try {
                referer = String(window.top.location);
            } catch (e) {
                referer = this.widget.widgetDomain || String(window.location);
            }

            gaq.push(['_setCustomVar', 1, 'widget_url', WidgetUri.source, 5]);
            gaq.push(['_setCustomVar', 2, 'widget_platform', this.widget.environment.name, 5]);
            gaq.push(['_setCustomVar', 3, 'widget_referer', referer, 5]);
        },

        loadScript: function () {
            var lastScript = document.getElementsByTagName('script')[0];

            UWA.createElement('script', {
                src: ('https:' === document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js',
                async: true,
                type: 'text/javascript'
            }).inject(lastScript || document.body || document.head, lastScript ? 'after' : 'bottom');


            this.removeEvent('afterLoad', this.loadScript);
        },

        openURL: function () {

        }
    });

    return UWA.namespace('Plugins/GoogleAnalytics', GoogleAnalytics, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Plugins/I18n
 *
 */
define('UWA/Plugins/I18n', [
    'UWA/Core',
    'UWA/Plugins/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Plugins.I18n
     * @extends UWA.Plugins.Abstract
     */
    var I18n = Abstract.extend(/** @lends module:UWA/Plugins/I18n.UWA.Plugins.I18n# */{ // bypass

        /**
         * ##### Examples
         *
         * Using plugin in Widget Manifest:
         *
         * ```html
         * <widget:plugins>
         *  <widget:plugin name="I18n">
         *    <widget:options name="fr">
         *        <widget:option name="Hello" value="Bonjour" />
         *    </widget:options>
         *  </widget:plugin>
         * </widget:plugins>
         * ```
         *
         * Using plugin in Widget Javascript:
         *
         * ```html
         * <script type="text/javascript" src="http://cdn.uwa.preview.netvibes.com/lib/c/UWA/js/UWA_Plugins_I18n.js"></script>
         * <script type="text/javascript">
         *    var MyPlugin = UWA.Plugins.I18n(widget, {
         *        fr: {
         *            'Hello': 'Bonjour'
         *        }
         *    });
         * </script>
         * ```
         *
         * Using Exposition Server application.ini config file:
         *
         * ```
         * exposition.widget.libraries.I18n             = "UWA_Plugins_I18n.js";
         * exposition.widget.plugins.I18n."Hello"       = "Bonjour";
         * ```
         *
         * @param {Object} widget
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Plugins.I18n
         * @memberof module:UWA/Plugins/I18n
         */
        init: function (widget, options) {

            // Call Parent init
            this._parent(widget, options);

            // Load current lang is available
            if (UWA.is(options[widget.lang], 'object')) {
                UWA.i18n(options[widget.lang]);
            }
        }
    });

    return UWA.namespace('Plugins/I18n', I18n, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Auth/Adapter/Abstract
 *
 */
define('UWA/Services/Auth/Adapter/Abstract', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options'
], function (UWA, Class, Options) {
    'use strict';

    var Abstract = Class.extend(Options, /** @lends module:UWA/Services/Auth/Adapter/Abstract.UWA.Services.Auth.Adapter.Abstract# */{ // bypass

        /**
         * UWA.Services.Auth.Adapter.Abstract constructor.
         *
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @constructs UWA.Services.Auth.Adapter.Abstract
         * @mixes UWA.Class.Options
         * @memberOf module:UWA/Services/Auth/Adapter/Abstract
         */
        init: function (options) {
            this.setOptions(options);
        },

        /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        hasIdentity: function () {
            // TODO
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        getIdentity: function () {
            // TODO
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentity: function () {
            // TODO
        },

        /**
         * Authenticate user.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         * @param {Object} credentials - Auth adapter credentials
         */
        authenticate: function () {
            // TODO
        }
    });

    return UWA.namespace('Services/Auth/Adapter/Abstract', Abstract, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Auth/Adapter/Exposition
 *
 */
define('UWA/Services/Auth/Adapter/Exposition', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Json',
    'UWA/Services/Auth/Adapter/Abstract',
    'UWA/Controls/Popup'
], function (UWA, Utils, Json, Abstract, Popup) {
    'use strict';

    /**
     * This Adapter class is made to support Auth for Exposition.
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @class UWA.Services.Auth.Adapter.Exposition
     * @extends UWA.Services.Auth.Adapter.Abstract
     * @memberof module:UWA/Services/Auth/Adapter/Exposition
     */
    var Exposition = Abstract.extend(/** @lends module:UWA/Services/Auth/Adapter/Exposition.UWA.Services.Auth.Adapter.Exposition# */{ // bypass

        /**
         * The default service options.
         * @private
         */
        defaultOptions: {},

        /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        hasIdentity: function (onSuccess, onFailure) {

            function onComplete(hasidentity) {
                if (hasidentity) {
                    onSuccess();
                } else {
                    onFailure('No identity found.');
                }
            }

            this.request('hasidentity', onComplete, onFailure);
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        getIdentity: function (onSuccess, onFailure) {
            this.request('getidentity', onSuccess, onFailure);
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentity: function (onComplete) {
            this.request('clearidentity', onComplete, onComplete);
        },

        /**
         * Authenticate user.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         * @param {Object} credentials - Auth adapter credentials
         */
        authenticate: function (onSuccess, onFailure) {

            var that = this;

            // Using popup only to avoid popup blocker inside
            // ajax callback.
            /*
            var popup = new Popup({
                url: that.getActionUrl('authenticate'),
                events: {
                    onClose: function () {
                        that.hasIdentity(onSuccess, onFailure);
                    },
                    onBlocked: function () {
                        if (UWA.is(onFailure)) {
                            onFailure('Unable to open popup due popup blocker.');
                        }
                    }
                }
            }).open();
            */

            // Using Ajax
            function onComplete(response) {

                if (response.type === 'redirect') {

                    new Popup({
                        url: response.url,
                        events: {
                            onClose: function () {
                                that.hasIdentity(onSuccess, onFailure);
                            },
                            onBlocked: function () {
                                if (UWA.is(onFailure)) {
                                    onFailure('Unable to open popup due popup blocker.');
                                }
                            }
                        }
                    }).open();
                }
            }

            this.request('authenticate', onComplete, onFailure);
        },

        /**
         * Encode Adapter to a url string that could be use by UWA.Data.request for example.
         *
         * @return {String} Adapter encoded string.
         */
        toQueryString: function () {

            var options = this.options;

            return UWA.Utils.toQueryString(UWA.merge({
                auth: options.provider
            }, options.data));
        },

        getActionUrl: function (action) {

            var options = this.options,
                data = UWA.clone(options.data || {}),
                url = UWA.hosts.exposition + '/services/auth/' + action + '/' + options.provider;

            url += (url.indexOf('?') > -1 ? '&' : '?') + Utils.toQueryString(data);

            return url;
        },

        request: function (action, onSuccess, onFailure) {

            var actionUrl = this.getActionUrl(action);

            function onComplete(json) {
                // Handle API success
                if (UWA.is(json[action])) {
                    onSuccess(json[action]);

                // Handle invalid response
                } else {
                    onFailure('Invalid Auth response.');
                }
            }

            Json.request(actionUrl, {
                cache: -1,
                onFailure: onFailure,
                onComplete: onComplete
            });
        }
    });

    return UWA.namespace('Services/Auth/Adapter/Exposition', Exposition, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Services/Auth/Adapter/Form
 *
 */
define('UWA/Services/Auth/Adapter/Form', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Ajax',
    'UWA/Json',
    'UWA/Data',
    'UWA/Services/Auth/Adapter/Abstract'
], function (UWA, Utils, Ajax, Json, Data, Abstract) {
    'use strict';

    /**
     * This Adapter class is made to support Auth via Form.
     *
     * @example
     * var myAuthForm = new UWA.Services.Auth({
     *     adapter: 'Form',
     *     adapterOptions: {
     *         checkUrl: 'https://apps.example.com/myapp/test.json',
     *         loginUrl: 'https://apps.example.com/global/2.0/login.fcc',
     *         logoutUrl: 'https://apps.example.com/global/2.0/logout.fcc',
     *         checkTimeout: 15000,
     *         loginTimeout: 15000,
     *         variables: {
     *             realmoid: '123...',
     *             type: '123...',
     *             forest: 'dc=uwa,dc=com',
     *             smauthreason: '',
     *             smagentname: 'abc...'
     *         },
     *         params: {
     *             type: '123...',
     *             realmoid: '{realmoid}',
     *             guid: '',
     *             smauthreason: '0',
     *             method: 'GET',
     *             smagentname: '-SM-{smagentname}',
     *             target: '-SM-{target}'
     *         },
     *         fields: {
     *             userid: '{login}',
     *             password: '{password}',
     *             target: '{checkUrl}',
     *             smauthreason: '{smauthreason}',
     *             smagentname: '{smagentname}',
     *             forest: '{forest}',
     *             smquerydata: '',
     *             postpreservationdata: '',
     *             Submit: ''
     *         }
     *     }
     * });
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @class UWA.Services.Auth.Adapter.Form
     * @extends UWA.Services.Auth.Adapter.Abstract
     * @memberof module:UWA/Services/Auth/Adapter/Form
     */
    var Form = Abstract.extend(/** @lends module:UWA/Services/Auth/Adapter/Form.UWA.Services.Auth.Adapter.Form# */{ // bypass

        /**
         * The default service options.
         * @private
         */
        defaultOptions: {
            timeout: 15000,
            checkUrl: 'https://example.com/myapp/test.json', // A valide JsonP endpoint
            loginUrl: 'https://example.com/global/2.0/login.fcc',
            logoutUrl: 'https://example.com/global/2.0/logout.fcc',
            params: {},
            fields: {},
            variables: {}
        },

        /**
         * Check if Environment support Ajax POST method instead of Frame POST.
         */
        isAjaxPostAllowed: function () {
            return Data.allowCrossOriginRequest;
        },

        /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        hasIdentity: function (onSuccess, onFailure) {

            var options = this.options;

            Json.request(options.target, {
                useOfflineCache: false, // Avoid credentials checking cache
                timeout: options.timeout,
                onComplete: function (json) {
                    if (typeof onSuccess === 'function') {
                        onSuccess(json);
                    }
                }.bind(this),
                onFailure: function (error) {
                    if (typeof onFailure === 'function') {
                        onFailure(error);
                    }
                }.bind(this)
            });
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         *
         * Returns:
         * * Nothing.
         */
        getIdentity: function (onSuccess, onFailure) {
            onFailure(new Error('Not implemented.'));
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onComplete - On success callback
         */
        clearIdentity: function (onComplete) {

            onComplete = onComplete || function () {};

            if (this.isAjaxPostAllowed()) {
                this.clearIdentityUsingAjax(onComplete);
            } else {
                this.clearIdentityUsingFrame(onComplete);
            }
        },

        /**
         * Authenticate user.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         * @param {Object} credentials - Auth adapter credentials
         */
        authenticate: function (onSuccess, onFailure, credentials) {

            onFailure = onFailure || function () {};
            onSuccess = onSuccess || function () {};

            if (!credentials.login || !credentials.password) {
                onFailure(new Error('Invalid credentials values.'));
            } else {

                var options = this.options,

                    loginUrl = options.loginUrl,

                    onComplete = function () {
                        this.hasIdentity(onSuccess, onFailure);
                    }.bind(this),

                    // TODO use options.variables to build fields values
                    fields = options.fields;

                // TODO use options.variables to build params values
                loginUrl += (loginUrl.indexOf('?') > -1 ? '&' : '?') + Utils.toQueryString(options.params).replace(/%25/g, '-%');

                if (this.isAjaxPostAllowed()) {
                    this.authenticateUsingAjax(fields, loginUrl, onComplete, onFailure);
                } else {
                    this.authenticateUsingFrame(fields, loginUrl, onComplete, onFailure);
                }
            }
        },

        /**
         * Authenticate user using Frame.
         *
         * @param {Object} fields - Frame query params
         * @param {String} loginUrl - Frame query url
         * @param {Function} onComplete - On complete callback
         */
        authenticateUsingFrame: function (fields, loginUrl, onComplete) {

            var field, fieldValue,

                frameId = Utils.random(1, 100000),

                container = UWA.createElement('div'),

                frame = UWA.createElement('iframe', {
                    src: 'about:blank',
                    id: 'formAuth:frame:' + frameId,
                    name: 'formAuth:frame:' + frameId,
                    styles: {
                        position: 'absolute',
                        top: '-2000px',
                        left: '0px'
                    }
                }).inject(container),

                form = UWA.createElement('form', {
                    target: 'formAuth:frame:' + frameId,
                    action: loginUrl,
                    method: 'post'
                }).inject(container);

            // Add Form fields
            for (field in fields) {
                if (fields.hasOwnProperty(field)) {
                    fieldValue = fields[field];
                    UWA.createElement('input', {
                        type: 'hidden',
                        name: field,
                        value: fieldValue
                    }).inject(form);
                }
            }

            // Inject Form and Iframe
            container.inject(document.body);

            // Add OnLoad after  inject to avoid about:blank onLoad
            frame.addEvent('load', function () {
                onComplete();
                container.destroy();
            });

            // Send Form
            form.submit();
        },

        /**
         * Clears the current identity using Frame.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentityUsingFrame: function (onComplete) {

            var frame,
                logoutUrl = this.options.logoutUrl;

            logoutUrl += (logoutUrl.indexOf('?') > -1 ? '&' : '?') + 'rnd=' + Math.random();

            frame = UWA.createElement('iframe', {
                src: logoutUrl,
                styles: {
                    position: 'absolute',
                    top: '-2000px',
                    left: '0'
                },
                events: {
                    load: function () {
                        onComplete();
                        frame.destroy();
                    }
                }
            }).inject(document.body);
        },

        /**
         * Authenticate user using Ajax.
         *
         * @param {Object} fields - Ajax query params
         * @param {String} siteminderUrl - Ajax query url
         * @param {Function} onComplete - On complete callback
         */
        authenticateUsingAjax: function (fields, loginUrl, onComplete, onFailure) {
            Ajax.request(loginUrl, {
                onComplete: onComplete,
                onFailure: onFailure,
                method: 'POST',
                data: fields
            });
        },

        /**
         * Clears the current identity using Ajax.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentityUsingAjax: function (onComplete) {

            var logoutUrl = this.options.logoutUrl;

            logoutUrl += ((logoutUrl.indexOf('?') > -1) ? '&' : '?') + 'rnd=' + Math.random();

            Ajax.request(logoutUrl, {
                onComplete: onComplete,
                onFailure: onComplete,
                method: 'GET'
            });
        }
    });

    return UWA.namespace('Services/Auth/Adapter/Form', Form, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Auth/Adapter/Netvibes
 *
 */
define('UWA/Services/Auth/Adapter/Netvibes', [
    'UWA/Core',
    'UWA/Services/Auth/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * This Adapter class is made to support Auth for Netvibes.
     *
     * @param {Object} options - Options hash or a option/value pair.
     *
     * @class UWA.Services.Auth.Adapter.Netvibes
     * @extends UWA.Services.Auth.Adapter.Abstract
     * @memberof module:UWA/Services/Auth/Adapter/Netvibes
     */
    var Netvibes = Abstract.extend(/** @lends module:UWA/Services/Auth/Adapter/Netvibes.UWA.Services.Auth.Adapter.Netvibes# */{ // bypass

        /**
         * The default service options.
         * @private
         */
        defaultOptions: {},

        /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        hasIdentity: function () {
            // TODO
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        getIdentity: function () {
            // TODO
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentity: function () {
            // TODO
        },

        /**
         * Authenticate user.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         * @param {Object} credentials - Auth adapter credentials
         */
        authenticate: function () {
            // TODO
        }
    });

    return UWA.namespace('Services/Auth/Adapter/Netvibes', Netvibes, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document
*/

/**
 * @module   UWA/Services/Auth/Adapter/SiteMinder
 *
 */
define('UWA/Services/Auth/Adapter/SiteMinder', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Ajax',
    'UWA/Json',
    'UWA/Data',
    'UWA/Services/Auth/Adapter/Abstract'
], function (UWA, Utils, Ajax, Json, Data, Abstract) {
    'use strict';

        /**
         * This Adapter class is made to support Auth for SiteMinder.
         *
         * More details about SiteMinder on following URLs:
         *
         * - http://ca.com/us/internet-access-control.aspx
         * - http://www.codeproject.com/KB/IP/SiteminderHttpWebRequest.aspx
         * - http://www.ericgiguere.com/blackberry/cookie-caching.html
         *
         * @example
         * var CokeSiteMinder = new UWA.Services.Auth({
         *     adapter: 'SiteMinder',
         *     adapterOptions: {
         *         smagentname: 'abc...',
         *         realmoid: '123...',
         *         type: '123...',
         *         forest: 'dc=uwa,dc=com',
         *         target: 'https://apps.example.com/myapp/test.json',
         *         login: 'https://apps.example.com/global/2.0/login.fcc',
         *         logout: 'https://apps.example.com/global/2.0/logout.fcc',
         *     }
         * });
         *
         * @param {Object} options - Options hash or a option/value pair.
         *
         * @class UWA.Services.Auth.Adapter.SiteMinder
         * @extends UWA.Services.Auth.Adapter.Abstract
         * @memberof module:UWA/Services/Auth/Adapter/SiteMinder
         */
    var SiteMinder = Abstract.extend(/** @lends module:UWA/Services/Auth/Adapter/SiteMinder.UWA.Services.Auth.Adapter.SiteMinder# */{ // bypass

        /**
         * The default service options.
         * @private
         */
        defaultOptions: {
            timeout: 15000,
            smagentname: '',
            realmoid: '',
            forest: '',
            guid: '',
            type: '',
            smauthreason: 0,
            target: 'https://example.com/myapp/test.json', // A valide JsonP endpoint
            login: 'https://example.com/global/2.0/login.fcc',
            logout: 'https://example.com/global/2.0/logout.fcc'
        },

        /**
         * Check if Environment support Ajax POST method instead of Frame POST.
         */
        isAjaxPostAllowed: function () {
            return Data.allowCrossOriginRequest;
        },

        /**
         * Check if user has an Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        hasIdentity: function (onSuccess, onFailure) {

            var options = this.options;

            if (this.hasIdentityRequest) {
                this.hasIdentityRequest.cancel();
            }

            this.hasIdentityRequest = Json.request(options.target, {
                useOfflineCache: false, // Avoid credentials checking cache
                timeout: options.timeout,
                onComplete: function (json) {
                    if (typeof onSuccess === 'function') {
                        onSuccess(json);
                    }
                }.bind(this),
                onFailure: function (error) {
                    if (typeof onFailure === 'function') {
                        onFailure(error);
                    }
                }.bind(this)
            });
        },

        /**
         * Get user Identity.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         */
        getIdentity: function (onSuccess, onFailure) {
            onFailure(new Error('Not implemented.'));
        },

        /**
         * Clears the current identity.
         *
         * @param {Function} onComplete - On success callback
         */
        clearIdentity: function (onComplete) {

            onComplete = onComplete || function () {};

            if (this.isAjaxPostAllowed()) {
                this.clearIdentityUsingAjax(onComplete);
            } else {
                this.clearIdentityUsingFrame(onComplete);
            }
        },

        /**
         * Authenticate user.
         *
         * @param {Function} onSuccess - On success callback
         * @param {Function} onFailure - On failure callback
         * @param {Object} credentials - Auth adapter credentials
         */
        authenticate: function (onSuccess, onFailure, credentials) {

            onFailure = onFailure || function () {};
            onSuccess = onSuccess || function () {};

            if (!credentials.login || !credentials.password) {
                onFailure(new Error('Invalid credentials values.'));
            } else {

                var options = this.options,

                    target = options.target + '&callback=jsonp' + (Date.now() + Utils.random(1, 10000)),

                    siteminderUrlParams = Utils.toQueryString({
                        type: options.type,
                        realmoid: options.realmoid,
                        guid: options.guid,
                        smauthreason: options.smauthreason,
                        method: 'GET',
                        smagentname: '-SM-' + options.smagentname,
                        target: '-SM-' + target
                    }).replace(/%25/g, '-%'),

                    siteminderUrl = options.login + '?' + siteminderUrlParams,

                    onComplete = function () {
                        this.hasIdentity(onSuccess, onFailure);
                    }.bind(this),

                    fields = {
                        target: target,
                        smquerydata: '',
                        smauthreason: options.smauthreason,
                        smagentname: options.smagentname,
                        postpreservationdata: '',
                        forest: options.forest,
                        userid: credentials.login,
                        password: credentials.password,
                        Submit: ''
                    };

                if (this.isAjaxPostAllowed()) {
                    this.authenticateUsingAjax(fields, siteminderUrl, onComplete, onFailure);
                } else {
                    this.authenticateUsingFrame(fields, siteminderUrl, onComplete, onFailure);
                }
            }
        },

        /* Group: Frame Methods */

        /**
         * Authenticate user using Frame.
         *
         * @param {Object} fields - Frame query params
         * @param {String} siteminderUrl - Frame query url
         * @param {Function} onComplete - On complete callback
         */
        authenticateUsingFrame: function (fields, siteminderUrl, onComplete) {

            var field, fieldValue,

                frameId = Math.ceil(Math.random() * 100000),

                container = UWA.createElement('div', {
                    styles: {
                        position: 'absolute',
                        top: '-2000px',
                        left: '0px'
                    }
                }),

                frame = UWA.createElement('iframe', {
                    src: 'about:blank',
                    name: 'siteminder:frame:' + frameId
                }).inject(container),

                form = UWA.createElement('form', {
                    target: 'siteminder:frame:' + frameId,
                    action: siteminderUrl,
                    method: 'post'
                }).inject(container);

            for (field in fields) {
                if (fields.hasOwnProperty(field)) {
                    fieldValue = fields[field];
                    UWA.createElement('input', {
                        type: 'hidden',
                        name: field,
                        value: fieldValue
                    }).inject(form);
                }
            }

            document.body.appendChild(container);

            // Add OnLoad before inject to avoid about:blank onLoad
            frame.addEvent('load', function () {
                this.destroy();
                onComplete();
            });

            form.submit();
        },

        /**
         * Clears the current identity using Frame.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentityUsingFrame: function (onComplete) {

            var frame,
                url = this.options.logout;

            url += ((url.indexOf('?') > -1) ? '&' : '?') + 'rnd=' + Math.random();

            frame = UWA.createElement('iframe', {
                src: 'about:blank',
                styles: {
                    position: 'absolute',
                    top: '-2000px',
                    left: '0px'
                }
            }).inject(document.body);

            // Add OnLoad before inject to avoid about:blank onLoad
            frame.addEvent('load', function () {
                this.destroy();
                onComplete();
            });

            frame.setAttribute('src', url);
        },

        /**
         * Authenticate user using Ajax.
         *
         * @param {Object} fields - Ajax query params
         * @param {String} siteminderUrl - Ajax query url
         * @param {Function} onComplete - On complete callback
         */
        authenticateUsingAjax: function (fields, siteminderUrl, onComplete, onFailure) {
            Ajax.request(siteminderUrl, {
                onComplete: onComplete,
                onFailure: function () {
                    // Handle possible error on 302
                    this.hasIdentity(onComplete, onFailure);
                }.bind(this),
                method: 'POST',
                data: fields
            });
        },

        /**
         * Clears the current identity using Ajax.
         *
         * @param {Function} onComplete - On complete callback
         */
        clearIdentityUsingAjax: function (onComplete) {
            Ajax.request(this.options.logout, {
                onComplete: onComplete,
                onFailure: onComplete,
                method: 'GET'
            });
        }
    });

    return UWA.namespace('Services/Auth/Adapter/SiteMinder', SiteMinder, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * @module   UWA/Services/ControlParser
 *
 */
define('UWA/Services/ControlParser', [
    'UWA/Core',
    'UWA/Element'
], function (UWA, Element) {
    'use strict';

    var controls = Object.create(null),
        ControlParser;

    function dispose(dom) {
        var parent = dom.parentNode,
            sibling = dom.nextSibling;
        if (parent) {
            parent.removeChild(dom);
        }
        return function (ndom) {
            if (!ndom) {
                ndom = dom;
            }
            if (ndom.inject) {
                ndom.inject(sibling || parent, sibling && 'before');
            } else {
                parent.insertBefore(ndom, sibling);
            }
        };
    }

    function popAttribute(el, name) {
        var result = el.getAttribute(name) || el.getAttribute('data-' + name);
        el.removeAttribute(name);
        el.removeAttribute('data-' + name);
        return result;
    }

    /**
     * Register a control in the parser.
     *
     * @example
     * ControlParser.register('AMD/path/to/a/control', 'control-name');
     * ControlParser.register('AMD/path/to/a/control SubObject.SubSubObject', 'sub-control-name');
     * ControlParser.register(ControlClass); // name is extracted from the prototype
     *
     * function factory(dom) {
     *    if (dom.id === 'whatever') return new WhatEverControl();
     * }
     * ControlParser.register(factory, 'whatever-name');
     *
     * @param {Class|String|Function} klass - The control definition or location
     * @param {String} [type] - The parser type, corresponding to the uwa-control attribute to search for.
     * @alias UWA.Services.ControlParser.register
     * @memberof module:UWA/Services/ControlParser
     */
    function register(klass, name) {
        if (!name) {
            name = klass.prototype.name;
        }
        controls[name] = klass;
    }

    function requireControl(path, fct) {
        path = path.split(' ');
        var amdModule = path[0],
            subObject = path[1] ? path[1].split('.') : [];

        (window.require || window.curl)([amdModule], function (object) {
            subObject.forEach(function (name) {
                object = object[name];
            });
            fct(null, object);
        });
    }

    function getControl(name, next) {
        var control = controls[name];
        if (!UWA.owns(controls, name)) {
            next('Control ' + name + ' not found');
        } else if (UWA.is(control, 'string')) {
            requireControl(control, next);
        } else {
            next(null, control);
        }
    }

    function renderControl(dom, name, next) {
        getControl(name, function (error, builder) {
            var control,
                inject = dispose(dom);
            if (!error) {
                if (UWA.is(builder, 'class')) {
                    var options = {
                        element: dom
                    };
                    if (dom.className) {
                        options.className = dom.className;
                        dom.className = '';
                    }
                    control = new builder(options); // jshint ignore: line
                } else if (UWA.is(builder, 'function')) {
                    control = builder(dom);
                }

                if (control) {
                    inject(control);
                } else {
                    error = 'Can\'t build the control ' + name;
                }
            }
            next(error, control);
        });
    }

   /**
     * Parse some dom and instantiate corresponding controls.
     *
     * ##### Example:
     *
     * ```
     * var element = UWA.createElement('div', {
     *    html: '<input type="text" uwa-control="uwa-text" />' +
     *        '<button type="button" uwa-name="myButton" uwa-control="uwa-button">Clickme</button>'
     * });
     * ControlParser.parse(element, {
     *    onError: function (error) {
     *        // debug help
     *        widget.log(error);
     *    },
     *    onSuccess: function (controls) {
     *        controls.myButton.setValue("Click me now!");
     *    }
     * });
     * ```
     *
     * __Controls instances__:
     *
     * `onComplete` and `onSuccess` gets the created controls passed as their
     * first argument. This will be a hash associating the control name
     * with its instance. If the control name ends with `[]`, it will
     * collect all instances with the same name and store it in an array.
     *
     * All unnamed controls are stored in the `lostAndFound` property
     * (which is an array). Ie: the default name is `lostAndFound[]`.
     *
     * The name of an instance is defined by the attribute uwa-name.
     *
     * @param {HTMLElement} dom - The root element
     * @param {Object} options - A hash with some options
     * @param {Function} [options.onComplete] - A callback called once, with an array
     *   containing the controls instances as first argument and the last error as second argument.
     * @param {Function} [options.onSuccess] - A callback called once if there is no
     *   error, with an array containing the controls instances as first argument.
     * @param [options.onError] - A callback called for each error, with the
     *  error (in general, a string) as first argument.
     *
     * @alias UWA.Services.ControlParser.parse
     * @memberof module:UWA/Services/ControlParser
     */
    function parse(dom, options) {
        if (!options) {
            options = {};
        }
        var elements = Element.getElements.call(dom, '[uwa-control],[data-uwa-control]'),
            count = elements.length,
            controls = {},
            error;

        function storeControl(name, instance) {
            if (name.indexOf('[]', name.length - 2) > -1) {
                name = name.slice(0, -2);
                if (!controls[name]) {
                    controls[name] = [];
                }
                controls[name].push(instance);
            } else {
                controls[name] = instance;
            }
        }

        function end(index, name, err, control) {
            count--;
            if (err) {
                error = err;
                if (options.onError) { options.onError(err); }
            } else {
                storeControl(name, control);
            }
            if (count === 0) {
                if (options.onComplete) {
                    options.onComplete(controls, error);
                }
                if (!error && options.onSuccess) {
                    options.onSuccess(controls);
                }
            }
        }

        elements.forEach(function (el, index) {
            renderControl(
                el,
                popAttribute(el, 'uwa-control'),
                end.bind(null, index, popAttribute(el, 'uwa-name') || 'lostAndFound[]')
            );
        });
    }

    register('UWA/Controls/Tag', 'uwa-tag');
    register('UWA/Controls/Input Text', 'uwa-text');
    register('UWA/Controls/Input Button', 'uwa-button');
    register('UWA/Controls/Input File', 'uwa-file');
    register('UWA/Controls/Input Select', 'uwa-select');
    register('UWA/Controls/Input Checkbox', 'uwa-checkbox');
    register('UWA/Controls/Input Radio', 'uwa-radio');
    register('UWA/Controls/ColorPicker', 'uwa-colorpicker');
    register('UWA/Controls/DatePicker', 'uwa-datepicker');

    ControlParser = {

        register: register,

        parse: parse,

        /* Testing only, *don't use* */
        _tests: {
            getControl: getControl
        }
    };

    return UWA.namespace('Services/ControlParser', ControlParser, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/
/*jshint camelcase: false*/

/**
 * This module provide classes to manipulate and load feeds.
 *
 * @module   UWA/Services/Feed
 *
 */
define('UWA/Services/Feed', [
    'UWA/Core',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Utils',
    'UWA/Json',
    'UWA/Data',
    'UWA/Internal/StringMap'
], function (UWA, Class, Options, Utils, Json, Data, StringMap) {
    'use strict';

    var Feed = Class.extend(Options, /** @lends module:UWA/Services/Feed.UWA.Services.Feed# */ { // bypass

        /**
         * Unique feed id.
         *
         * @type {String}
         */
        id: null,

        timeOffset: null,

        /**
         * The timestamp of the last feed update.
         *
         * @type {Number}
         */
        lastFetchedDate: null,

        /**
         * Current error message.
         *
         * @type {String}
         */
        error: null,

        /**
         * The default feed options.
         *
         * @type {Object}
         * @private
         */
        defaultOptions: {
            id: 0,
            timeOffset: 0,
            readOnly: true,
            bufferItemMaxLen: 30,
            itemLinkFilters: [],
            itemEnclosureFilters: [
                (function () {
                    var badEnclosures = /feedads|icon|button|addthis|feed|feedburner/;
                    return function (url) {
                        return !badEnclosures.test(url);
                    };
                }())
            ]
        },

        /**
         * This Service provide a class to manipulate and load feeds.
         *
         * ##### Example
         *
         * Load one feed using using <UWA.Data.request> and <UWA.Services.Feed>:
         *
         * ```
         * UWA.Data.request('http://feeds.feedburner.com/NetvibesDevBlog', {
         * proxy: 'feed',
         * type: 'json',
         * onComplete: function (data) {
         *
         *    var feed = new UWA.Services.Feed({
         *        data: data
         *    });
         *
         *    feed.getTitle();
         *    feed.getItem(0);
         * }
         * });
         * ```
         *
         * Load multiple feed using using <UWA.Services.Feed.Utils.load>:
         *
         * ```
         * UWA.Services.Feed.Utils.load({
         *     urls: [
         *         'http://feeds.feedburner.com/NetvibesDevBlog',
         *         'http://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml'
         *     ],
         *     onComplete: function (feeds) {
         *         // feeds will be an object with UWA.Services.Feed instance
         *         // indexed by feed url.
         *     }
         * });
         * ```
         *
         * @param {Object} options - Options hash
         * @constructs UWA.Services.Feed
         * @mixes UWA.Class.Options
         * @memberof module:UWA/Services/Feed
         */
        init: function (options) {

            // Init Data
            this.data = {
                dir: 'ltr',
                flags: {
                    read: 0,
                    unread: 0
                },
                items: []
            };

            // Set options
            this.setOptions(options);
        },

        /**
         * Set options of this instance. Passing an 'events' field will
         * automatically add those events.
         *
         * @param {Object} options - Options hash
         * @return {this}
         */
        setOptions: function (options) {

            var that = this;

            that._parent(options);

            // Update options reference
            options = that.options;

            // Expose some options
            that.id = options.id;
            that.timeOffset = options.timeOffset;

            // Set Error
            if (options.error) {
                that.setError(options.error);

            // Set Data
            } else if (options.data) {
                that.setData(options.data);

                // We GC data on options
                delete options.data;
            }

            return that;
        },

        /**
         * Set error message of this instance.
         *
         * @param {Object} error - Error message
         * @return {this}
         */
        setError: function (error) {

            var that = this;

            that.error = error;

            return that;
        },

        /**
         * Get error message of this instance.
         *
         * @return {String} Error message.
         */
        getError: function () {
            return this.error;
        },

        /**
         * Return the current state of read/unread percistency on this
         * feed instance.
         *
         * @return {Boolean} `true` if in read only else `false`.
         */
        isReadOnly: function () {
            return (this.options.readOnly === true);
        },

        /**
         * Set the last time that the feed has been fetched using timespamp.
         *
         * @param {Integer} timeStampInSeconds - The timespamp of the last fetch in seconds
         * @return {this}
         */
        setLastFetchedDate: function (timeStampInSeconds) {

            this.lastFetchedDate = parseInt(timeStampInSeconds, 10);

            return this;
        },

        /**
         * Get the timespamp that define when that feed has been fetched.
         *
         * @return {Integer} The timespamp of the last fetch in seconds.
         */
        getLastFetchedDate: function () {
            return parseInt(this.lastFetchedDate, 10);
        },

        /**
         * Add data to Feed instance.
         *
         * @return {Object}
         */
        setData: function (data, options) {

            options = options || {};

            var result,
                that = this,
                fetchedDate = data.server_time || Math.round(Date.now() / 1000),
                items = data.items,
                currentLength = this.getItemsLength();

            // Remove items from data
            delete data.items;

            // Update
            if (options.last_update) {

                // Add item on the top of our item list
                that.addItems(items, 'before');

                // Update fetched date
                that.setLastFetchedDate(fetchedDate);

            // Load next chunk
            } else if (options.published_before) {

                // Add item at the end of our item list
                that.addItems(items, 'after');

            // First load
            } else {

                // Shoud check/populate data.infos with
                // title, dir, url, link, type
                UWA.extend(that.data, data, true);

                // Add item on the top of our item list
                this.addItems(items);

                // Update fetched date
                this.setLastFetchedDate(fetchedDate);

                // Deprecated?
                if (data.url) {
                    this.ownerURL = data.url;
                    this.feedSiteUrlDomain = Utils.parseUrl(data.url).domain;
                }
            }

            // Set result
            result = {
                data: UWA.clone(this.data),
                addedItem: currentLength - this.data.length
            };

            // Handle deprecated callback options
            if (options.callback) {
                options.onComplete = options.callback;
                delete options.callback;
            }

            // Call callback if defined
            if (UWA.is(options.onComplete, 'function')) {
                options.onComplete(result);
            }

            return result;
        },

        /* Group: Items manipulation methods */

        /**
         * Add items to the feed instance.
         *
         * @param {Array} items - A collection of items to add
         * @param {String} where - The position of the added items, could be
         *  "before", "after" and default is using <sortItemsByDate>
         */
        addItems: function (items, where) {

            if (Array.isArray(items) && items.length > 0) {

                var i, l, item,
                    currentItems = this.getItems();

                if (where === 'before') {

                    // UWA.log('(FEEDID: ' + this.id + ') adding ' + items.length + ' items at the begining of the list (update)');
                    for (i = items.length - 1; i >= 0; i--) {
                        item = this.preProcessItem(items[i]);
                        currentItems.unshift(item);
                    }

                    // Set array indexes in items data
                    this.setItemsIndexes();

                } else if (where === 'after') {

                    // UWA.log('(FEEDID: ' + this.id + ') adding ' + items.length + ' items at the end of the list');
                    for (i = 0, l = items.length; i < l; i++) {
                        item = this.preProcessItem(items[i]);
                        currentItems.push(item);
                    }

                    // Set array indexes in items data
                    this.setItemsIndexes();

                } else {

                    // UWA.log('(FEEDID: ' + this.id + ') adding ' + items.length + ' items then sort by date');
                    for (i = 0, l = items.length; i < l; i++) {
                        item = this.preProcessItem(items[i]);
                        currentItems.push(item);
                    }

                    // Set array indexes in items data
                    this.sortItemsByDate();
                }
            }
        },

        /**
         * Sort current items by date and update their indexes.
         *
         * @param {String} order - Define the order, possible value are "asc" or "desc",
         *  default is "desc".
         */
        sortItemsByDate: function (order) {

            this.getItems().sort(function (a, b) {
                var aTime = new Date(a.date).getTime();
                var bTime = new Date(b.date).getTime();
                return (order === 'asc' ? aTime - bTime : bTime - aTime);
            });

            // set array indexes in items data
            this.setItemsIndexes();
        },

        /**
         * Define the index property of each items, related to their
         * position defined by <sortItemsByDate> for example.
         */
        setItemsIndexes: function () {

            var itemIndex,
                itemLength = this.getItemsLength();

            for (itemIndex = 0; itemIndex < itemLength; itemIndex++) {
                this.getItem(itemIndex).index = itemIndex;
            }
        },

        /**
         * Pre process item, extract enclosures, filter link and enclosures.
         *
         * @param {Object} item - The item to pre process
         * @return {Object} The processed item.
         */
        preProcessItem: function (item) {

            if (!item.__preProcessed) {

                item.content = item.content || '';
                item.title = item.title || '';
                item.flags = item.flags || {};

                this.preProcessItemEnclosures(item);
                this.applyItemLinkFilters(item);
                this.applyItemEnclosureFilters(item);

                item.__preProcessed = true;
            }

            return item;
        },

        /**
         * Pre process item to extract enclosures.
         *
         * @param {Object} item - The item to pre process
         * @return {Object} The processed item.
         */
        preProcessItemEnclosures: (function () {

            function extractTagAttribureFromHtml(html, tagName, attributeName) {

                var i, l, value, element,
                    values = [],
                    elements = html.getElementsByTagName(tagName);

                for (i = 0, l = elements.length; i < l; i++) {
                    element = elements[i];
                    value = elements[i].getAttribute(attributeName);

                    if (
                        // Has value
                        value &&

                            // Is a img tag and if have heigth or width is bigger that 0
                            (
                                (
                                    tagName === 'img' &&
                                    (!element.height || element.height > 1) &&
                                    (!element.width || element.width > 1)

                                // Or is a a tag, and not a simple anchor link
                                ) || (
                                    tagName === 'a' &&
                                    (element.href && element.href.indexOf('#') > 1)
                                )
                            )

                    ) {
                        values.push(value);
                    }
                }

                return values;
            }

            return function (item) {

                var i, l, j, m, itemHtml, enclosureUrl, enclosuresType, isValid, itemEnclosureFilter,
                    isImageUrl = /\.(jpeg|gif|jpg|bmp|png)$/i,
                    isAudioUrl = /\.(m4a|ogg|mp3|acc)$/i,
                    isVideoUrl = /\.(flv|mp4|h264|avi|mpeg|mpg)$/i,
                    that = this,
                    options = that.options,
                    feedUrl = that.getUrl(),
                    enclosures = item.enclosures,
                    itemEnclosureFilters = options.itemEnclosureFilters,
                    enclosureUrls = [],
                    enclosuresByTypes = {
                        image: [],
                        video: [],
                        audio: []
                    };

                // This methid will populate following item properties:
                // item.video
                // item.audio
                // item.image

                // Analyze enclosures
                if (Array.isArray(enclosures)) {
                    enclosures.forEach(function (enclosure) {

                        var url = enclosure.url,
                            type = enclosure.type;

                        if (url) {

                            if (
                                (type && /^image\/(jpeg|gif|jpg|bmp|png)$/.test(type)) ||
                                    isImageUrl.test(url)
                            ) {
                                enclosuresByTypes.image.push(url);
                            } else if (
                                (type && /^audio\/mpeg$/.test(type)) ||
                                    isAudioUrl.test(url)
                            ) {
                                enclosuresByTypes.audio.push(url);
                            } else if (
                                (type && /^video/.test(type)) ||
                                    isVideoUrl.test(url)
                            ) {
                                enclosuresByTypes.video.push(url);
                            }
                        }
                    });
                }

                // Load html to a document for testing
                itemHtml = Utils.loadHtml(item.content);

                // Get image tags src
                enclosureUrls = enclosureUrls.concat(extractTagAttribureFromHtml(itemHtml, 'img', 'src'));

                // Get link tags href
                enclosureUrls = enclosureUrls.concat(extractTagAttribureFromHtml(itemHtml, 'a', 'href'));
                for (i = 0, l = enclosureUrls.length; i < l; i++) {

                    enclosureUrl = enclosureUrls[i];

                    if (!item.image && isImageUrl.test(enclosureUrl)) {
                        enclosuresByTypes.image.push(enclosureUrl);
                    } else if (!item.audio && isAudioUrl.test(enclosureUrl)) {
                        enclosuresByTypes.audio.push(enclosureUrl);
                    } else if (!item.video && isVideoUrl.test(enclosureUrl)) {
                        enclosuresByTypes.video.push(enclosureUrl);
                    }
                }

                // Retrieve image from embed videos
                if (!item.image || !item.video) {

                    // Youtube thumb
                    enclosureUrls = item.content.match(/http:\/\/www.youtube.com\/v\/([\w|\-]+)/);
                    if (enclosureUrls && enclosureUrls.length > 0) {
                        item.video = enclosureUrls[0];
                        item.image = 'https://i2.ytimg.com/vi/' + enclosureUrls[1] + '/hqdefault.jpg';
                    }
                }

                // Now we filter and assign
                for (enclosuresType in enclosuresByTypes) {

                    enclosureUrls = enclosuresByTypes[enclosuresType];

                    for (i = 0, l = enclosureUrls.length; i < l; i++) {
                        enclosureUrl = enclosureUrls[i];

                        isValid = true;

                        if (Array.isArray(itemEnclosureFilters)) {
                            for (j = 0, m = itemEnclosureFilters.length; j < m && isValid; j++) {
                                itemEnclosureFilter = itemEnclosureFilters[j];
                                isValid = itemEnclosureFilter(enclosureUrl, item);
                            }
                        }

                        if (isValid) {
                            item[enclosuresType] = Utils.buildUrl(feedUrl, enclosureUrl);
                        }
                    }
                }

                // Handle deprecated thumbnail and watchable
                item.thumbnail = item.image;
                item.watchable = Boolean(item.video);

                return item;
            };
        }()),

        /**
         * Add a new link filters function.
         *
         * @param {Function} filter - The enclosure filter function
         */
        addItemLinkFilter: function (filter) {

            var options = this.options;

            if (!UWA.is(options.itemLinkFilters, 'array')) {
                options.itemLinkFilters = [];
            }

            if (UWA.is(filter, 'function')) {
                options.itemLinkFilters.push(filter);
            }
        },

        /**
         * Apply link filters on an item.
         *
         * @param {Object} item - The item to process
         */
        applyItemLinkFilters: function (item) {

            var itemLinkFilter, i, l,
                itemLinkFilters = this.options.itemLinkFilters;

            if (
                Array.isArray(itemLinkFilters) &&
                    !item.__linksFiltered
            ) {

                for (i = 0, l = itemLinkFilters.length; i < l; i++) {

                    itemLinkFilter = itemLinkFilters[i];

                    if (UWA.is(itemLinkFilter, 'function') && item.link) {
                        item.link = itemLinkFilter(item.link, item, this);
                    }
                }

                item.__linksFiltered = true;
            }
        },

        /**
         * Add a new enclosure filters function.
         *
         * @param {Function} filter - The enclosure filter function
         */
        addItemEnclosureFilter: function (filter) {

            var options = this.options;

            if (!UWA.is(options.itemEnclosureFilters, 'array')) {
                options.itemEnclosureFilters = [];
            }

            if (UWA.is(filter, 'function')) {
                options.itemEnclosureFilters.push(filter);
            }
        },

        /**
         * Apply enclosure filters on an item.
         *
         * @param {Object} item - The item to process
         */
        applyItemEnclosureFilters: function (item) {

            var i, l, j, m, enclosureType, itemEnclosureFilter,
                that = this,
                itemEnclosureFilters = that.options.itemEnclosureFilters,
                enclosureTypes = ['image', 'audio', 'video'];

            if (
                Array.isArray(itemEnclosureFilters) &&
                    !item.__enclosuresFiltered
            ) {

                for (i = 0, l = itemEnclosureFilters.length; i < l; i++) {

                    itemEnclosureFilter = itemEnclosureFilters[i];

                    if (UWA.is(itemEnclosureFilter, 'function')) {

                        for (j = 0, m = enclosureTypes.length; j < m; j++) {

                            enclosureType = enclosureTypes[j];

                            if (
                                item[enclosureType] &&
                                    !itemEnclosureFilter(item[enclosureType], item)
                            ) {

                                delete item[enclosureType];
                            }
                        }
                    }
                }

                item.__enclosuresFiltered = true;
            }
        },

        /**
         * Get feed title defined by the feed.
         *
         * @return {String}
         */
        getTitle: function () {
            return this.data.title;
        },

        /**
         * Get the preferred language direction defined by the feed.
         *
         * @return {String}
         */
        getDir: function () {
            return this.data.dir;
        },

        /**
         * Get the url source of the feed.
         *
         * @return {String}
         */
        getUrl: function () {
            return this.data.url;
        },

        /**
         * Get website url that relly on the feed.
         *
         * @return {String}
         */
        getLink: function () {
            return this.data.link;
        },

        /**
         * Get the feed type (e.g rss2, atom, rdf).
         *
         * @return {String}
         */
        getType: function () {
            return this.data.type;
        },

        /* Group: Items getter methods */

        /**
         * Get all items.
         *
         * @return {Array}
         */
        getItems: function () {
            return this.data.items;
        },

        /**
         * Get item by index.
         *
         * @return {Object}
         */
        getItem: function (index) {
            return this.getItems()[index];
        },

        /**
         * Get item by index.
         *
         * @return {Object}
         */
        getItemByGuid: function (guid) {
            return this.getItemByProperty('guid', guid);
        },

        /**
         * Get item by property value.
         *
         * @return {Object}
         */
        getItemByProperty: function (property, value) {

            var item, itemIndex,
                itemLength = this.getItemsLength();

            for (itemIndex = 0; item < itemLength; itemIndex++) {
                item = this.getItem(itemIndex);
                if (item[property] === value) {
                    break;
                }
            }

            return item;
        },

        /**
         * Get last item id.
         *
         * @return {String}
         */
        getLastItemId: function () {

            var item = this.getItem(this.getItemsLength() - 1);

            return item && item.id;
        },

        /**
         * Get the number of loaded items.
         *
         * @return {Number}
         */
        getItemsLength: function () {
            return this.data.items.length;
        },

        /* Group: Items unread/read methods */

        /**
         * Get the unread items.
         *
         * @return {Array}
         */
        getUnread: function (options) {

            options = options || {};

            var i, l, feedFlags, read,
                unreadFirst = 0,
                unread = 0,
                data = this.data,
                infos = this.infos,
                itemLength = this.getItemsLength();

            if (infos && itemLength > 0) {

                feedFlags = data.flags;
                read = (feedFlags && feedFlags.read) ? feedFlags.read : 0;
                unread = infos.item_count - read;

                if (options.onlyNFirst) {

                    options.onlyNFirst = (options.onlyNFirst <= itemLength) ? options.onlyNFirst : itemLength;

                    for (i = 0, l = options.onlyNFirst; i < l; i++) {
                        if (!this.isItemRead(i)) {
                            unreadFirst++;
                        }
                    }

                    unread = unreadFirst;
                }
            }

            // TODO: there's a bug in backend, We can have 500 items in the feed, and 500+ unread...
            return (unread >= 0) ? unread : 0;
        },

        /**
         * Check if item state is read.
         *
         * @return {Boolean}
         */
        isItemRead: function (index) {

            var item = this.getItem(index);

            return Boolean(item && item.flags && item.flags.read);
        },

        /**
         * Set item state to read.
         */
        setItemRead: function (index, save) {

            if (!this.isItemRead(index)) {

                this.data.flags.read++;

                this.setItemsFlag({
                    indexes: [index],
                    flag: 'read',
                    value: Math.ceil(Date.now() / 1000), // now
                    save: save
                });
            }
        },

        /**
         * Set item state to unread.
         */
        setItemUnread: function (index, save) {

            if (this.isItemRead(index)) {

                this.data.flags.read--;

                this.setItemsFlag({
                    indexes: [index],
                    flag: 'read',
                    value: false,
                    save: save
                });
            }
        },

        /**
         * Set all item state to read.
         */
        setAllItemsRead: function (save) {

            var itemIndex, itemIndexes,
                that = this,
                itemLength = that.getItemsLength();

            for (itemIndex = 0; itemIndex < itemLength; itemIndex++) {
                that.setItemRead(itemIndex, false);
                itemIndexes.push(itemIndex);
            }

            that.setItemsFlag({
                indexes: itemIndexes,
                flag: 'read',
                value: Math.ceil(Date.now() / 1000), // now
                save: save
            });
        },

        /**
         * Set all item state to unread.
         */
        setAllItemsUnread: function (save) {

            var itemIndex,
                that = this,
                itemLength = that.getItemsLength(),
                itemIndexes = [];

            for (itemIndex = 0; itemIndex < itemLength; itemIndex++) {
                that.setItemRead(itemIndex, false);
                itemIndexes.push(itemIndex);
            }

            that.setItemsFlag({
                indexes: itemIndexes,
                flag: 'read',
                value: false,
                save: save
            });
        },

        /**
         * Set flags on items.
         */
        setItemsFlag: function (options) {

            var i, l, item,
                that = this,
                itemIds = [],
                save = (that.isReadOnly() ? false : (options.save || true));

            // Handle options index
            if (options.index) {
                options.indexes = [options.index];
            }

            for (i = 0, l = options.indexes.length; i < l; i++) {

                item = that.getItem(i);

                itemIds.push(item.id);

                if (options.value && options.value !== false) {
                    item.flags[options.flag] = options.value;
                } else {
                    delete item.flags[options.flag];
                }
            }

            if (save) {
                Feed.Adapter.Netvibes.feedApiRequest({
                    readState: ((options.value && options.value !== false) ? 'add' : 'remove'),
                    feedIds: that.id,
                    feedItemIds: itemIds
                });
            }
        }
    });

    /**
     * @namespace UWA.Services.Feed.Utils
     * @memberof module:UWA/Services/Feed
     */
    Feed.Utils = /** @lends module:UWA/Services/Feed.UWA.Services.Feed.Utils */{ // bypass

        /**
         * Default adapter name used to load feeds.
         * @private
         */
        adapterName: (Data.allowCrossOriginRequest ? 'Ajax' : 'Proxy'),

        /**
         * Load multiple feed at once.
         *
         * @example
         * UWA.Services.Feed.Utils.load({
         *    urls: [
         *        'http://feeds.feedburner.com/NetvibesDevBlog',
         *        'http://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml'
         *    ],
         *    onComplete: function (feeds) {
         *
         *        // feeds will be an object with UWA.Services.Feed instance
         *        // indexed by feed url.
         *    }
         * });
         *
         * @param {Object} options - Options hash
         * @param {String} adapterName - Adapter to use to get feed
         * @alias UWA.Services.Feed.Utils.load
         */
        load: function (options, adapterName) {

            adapterName = adapterName || this.adapterName;
            options = options || {};

            // Handle deprecated callback options
            if (options.callback) {
                options.onComplete = options.callback;
                delete options.callback;
            }

            return Feed.Adapter.Cache.load(options, adapterName);
        },

        /**
         * Generate an unique id from url.
         *
         * @param {String} url - The url used to generate unique id
         * @return {String} Unique id based on url params.
         */
        getIdFromUrl: function (url) {
            return Math.abs(parseInt(Utils.getCRC32(url), 10)).toString(36);
        },

        /**
         * Clean url before use it.
         *
         * @param {String} url - The url to clean
         * @return {String} Cleaned url.
         */
        cleanFeedUrl: function (url) {

            // Handle flvProxy.php
            if (url.contains('flvProxy.php')) {
                url = Utils.getQueryString(url, 'url');
            // Handle commeaucinemaProxy.php
            } else if (url.contains('commeaucinemaProxy.php')) {
                url = 'http://www.commeaucinema.com/rssfile.php?feed=netvibes_' + Utils.getQueryString(url, 'id');

            // Fix possible bad url with protocol "feed://"
            } else if (/^feed:\/\/(.*)/.test(url)) {

                // Remove sub protocol
                url = url.replace('feed:', '');

                // Add protocol is missing
                if (!/^http(s)?:\/\/(.*)/.test(url)) {
                    url = 'http://' + url;
                }
            }

            // Clean Url not starting wih http(s)://
            if (!/^http(s)?:\/\/(.*)/.test(url)) {
                url = UWA.hosts.netvibes + url;
            }

            return url;
        }
    };


    Feed.Adapter = {

        /**
         * Adapter that use Cache then falback to default adapter to parse Feed.
         *
         * @namespace UWA.Services.Feed.Adapter.Cache
         * @memberof module:UWA/Services/Feed
         */
        Cache: /** @lends module:UWA/Services/Feed.UWA.Services.Feed.Adapter.Cache */{ // bypass

            /**
             * Check if feed is in cache then fallback on another adapter if not in cache.
             *
             * @param {Object} options - Options hash
             * @param {String} fallbackAdapter - Fallback adapter if feed is not in cache
             */
            load: function (options, fallbackAdapter) {

                var i, l, feedUrl, feedObj,
                    feedObjs = {},
                    feedsUrls = options.urls || [],
                    feedsUrlsMissing = [];

                for (i = 0, l = feedsUrls.length; i < l; i++) {

                    feedUrl = Feed.Utils.cleanFeedUrl(feedsUrls[i]);
                    feedObj = this.getFromCache(feedUrl);

                    if (feedObj) {
                        feedObjs[feedUrl] = new Feed(feedObj);
                    } else {
                        feedsUrlsMissing.push(feedUrl);
                    }
                }

                // We need to get data out of cache
                if (feedsUrlsMissing.length > 0) {

                    options.urls = feedsUrlsMissing;
                    Feed.Adapter[fallbackAdapter].load(options, feedObjs);

                // We found all feed from cache
                } else if (UWA.is(options.onComplete, 'function')) {
                    options.onComplete(feedObjs);
                }
            },

            /**
             * Get cache Storage instance.
             *
             * @return {Object} UWA.Storage instance for cache.
             */
            getCache: function () {

                if (!this.data) {
                    this.data = new StringMap();
                }

                return this.data;
            },

            /**
             * Store url data into cache Storage.
             *
             * @return {Object}
             */
            storeInCache: function (url, data) {
                return this.getCache().set(url, data);
            },

            /**
             * Retrieve url data from cache Storage.
             *
             * @return {Object}
             */
            getFromCache: function (url) {
                return this.getCache().get(url);
            }
        },

        /**
         * Adapter that use Exposition Server to parse Feed.
         *
         * @namespace UWA.Services.Feed.Adapter.Proxy
         * @memberof module:UWA/Services/Feed
         */
        Proxy: /** @lends module:UWA/Services/Feed.UWA.Services.Feed.Adapter.Proxy */{ // bypass

            /**
             * Use Exposition Proxy to parse and load feed.
             *
             * @param {Object} options - Options hash
             */
            load: function (options, feedObjs) {

                var i, l,
                    feedsLoaded = 0,
                    feedsUrls = options.urls || [];

                feedObjs = feedObjs || {};

                function onComplete(feedUrl, data) {

                    var feedObj = {
                        url: feedUrl,
                        readOnly: true,
                        data: {
                            title: data.title,
                            dir: data.dir,
                            url: data.url,
                            link: data.link,
                            type: data.type,
                            items: data.items
                        }
                    };

                    // Save into Cache
                    feedObjs[feedUrl] = new Feed(feedObj);
                    Feed.Adapter.Cache.storeInCache(feedUrl, feedObj);

                    // call Callback if required
                    feedsLoaded++;

                    if (
                        feedsUrls.length === feedsLoaded &&
                            UWA.is(options.onComplete, 'function')
                    ) {
                        options.onComplete(feedObjs);
                    }
                }

                function onFailure(feedUrl, error) {

                    feedObjs[feedUrl] = new Feed({
                        url: feedUrl,
                        readOnly: true,
                        error: error
                    });

                    // call Callback if required
                    feedsLoaded++;
                    if (
                        feedsUrls.length === feedsLoaded &&
                            UWA.is(options.onComplete, 'function')
                    ) {
                        options.onComplete(feedObjs);
                    }
                }

                for (i = 0, l = feedsUrls.length; i < l; i++) {

                    var feedUrl = Feed.Utils.cleanFeedUrl(feedsUrls[i]);

                    Data.request(feedUrl, {
                        proxy: 'feed',
                        type: 'json',
                        onComplete: onComplete.bind(null, feedUrl),
                        onFailure: onFailure.bind(null, feedUrl)
                    });
                }
            }
        },

        /**
         * Adapter that use JavaScript to parse Feed.
         *
         * @namespace UWA.Services.Feed.Adapter.Ajax
         * @memberof module:UWA/Services/Feed
         */
        Ajax: /** @lends module:UWA/Services/Feed.UWA.Services.Feed.Adapter.Ajax */{ // bypass

            /**
             * Use JavaScript to parse and load feed.
             */
            load: (function () {

                function getItemLink(item) {

                    var l, i, link, el;

                    if (!Array.isArray(item.link)) {
                        link = item.link.href || item.link;
                    } else {
                        link = item.link[0].href || item.link[0];
                        for (i = 0, l = item.link.length; i < l; i++) {
                            el = item.link[i];
                            if (el.rel && ['self', 'alternate'].indexOf(el.rel) !== -1) {
                                link = el.href;
                            }
                        }
                    }

                    return link;
                }

                function getItemString(item) {
                    var string = item.toString ? item.toString() : item;
                    return UWA.is(string) && string.length > 0 ? string : '';
                }

                function getItemDate(time) {
                    return new Date(Date.parse(time)).toGMTString();
                }

                function feedToJSON(feed, feedUrl) {

                    feed = Json.xmlToJson(feed);

                    var items, item, i, l,
                        data = {
                            dir: 'ltr',
                            url: feedUrl,
                            items: []
                        };

                    // Parse Atom
                    if (feed.feed) {

                        UWA.extend(data, {
                            title: getItemString(feed.feed.title),
                            link: getItemLink(feed.feed)
                        });

                        items = Utils.splat(feed.feed.entry);
                        for (i = 0, l = items.length; i < l; i++) {

                            item = items[i];

                            data.items[i] = {
                                id: i,
                                title: getItemString(item.title),
                                link: getItemLink(item),
                                content: getItemString(item.content),
                                date: getItemDate(item.updated)
                            };

                            // Add thumbnail if available
                            if (item['media:thumbnail'] && item['media:thumbnail'].url) {
                                data.items[i].image = item['media:thumbnail'].url;
                            }
                        }

                    // Parse RDF
                    } else if (feed['rdf:RDF']) {

                        feed.rdf = feed['rdf:RDF'];

                        UWA.extend(data, {
                            title: getItemString(feed.rdf.channel.title),
                            link: getItemLink(feed.rdf.channel)
                        });

                        items = Utils.splat(feed.rss.channel.item);
                        for (i = 0, l = items.length; i < l; i++) {

                            item = items[i];

                            data.items[i] = {
                                id: i,
                                title: getItemString(item.title),
                                link: getItemLink(item),
                                content: getItemString(item.description),
                                date: getItemDate(item['dc:date'])
                            };

                            // Add thumbnail if available
                            if (item['media:content'] && item['media:content'].url) {
                                data.items[i].image = item['media:content'].url;
                            }
                        }

                    // Parse Rss
                    } else if (feed.rss) {

                        UWA.extend(data, {
                            title: getItemString(feed.rss.channel.title),
                            link: getItemLink(feed.rss.channel)
                        });

                        items = Utils.splat(feed.rss.channel.item);

                        for (i = 0, l = items.length; i < l; i++) {

                            item = items[i];

                            data.items[i] = {
                                id: i,
                                title: getItemString(item.title),
                                link: getItemLink(item),
                                content: getItemString(item['content:encoded'] || item.description),
                                date: getItemDate(item.pubDate)
                            };

                            if (typeof data.items[i].content !== 'string') {
                                data.items[i].content = '';
                            }

                            // Add enclosure if available
                            if (item.enclosure) {
                                data.items[i].enclosures = [item.enclosure];
                            }

                            // Add thumbnail if available
                            if (item['media:thumbnail'] && item['media:thumbnail'].url) {
                                data.items[i].image = getItemString(item['media:thumbnail'].url);
                            }
                        }

                    } else {
                        throw new Error('Unable to Parse Feed using Ajax Adapter.');
                    }

                    return data;
                }

                return function (options, feedObjs) {

                    feedObjs = feedObjs || {};

                    var i, l,
                        feedsLoaded = 0,
                        feedsUrls = options.urls || [];

                    function onComplete(feedUrl, feed) {

                        var feedObj,
                            data = feedToJSON(feed, feedUrl);

                        feedObj = new Feed({
                            url: feedUrl,
                            readOnly: true,
                            data: data
                        });

                        // Save into Cache
                        feedObjs[feedUrl] = new Feed(feedObj);
                        Feed.Adapter.Cache.storeInCache(feedUrl, feedObj);

                        // call Callback if required
                        feedsLoaded++;
                        if (
                            feedsUrls.length === feedsLoaded &&
                                UWA.is(options.onComplete, 'function')
                        ) {
                            options.onComplete(feedObjs);
                        }
                    }

                    function onFailure(feedUrl, error) {

                        feedObjs[feedUrl] = new Feed({
                            url: feedUrl,
                            readOnly: true,
                            error: error
                        });

                        // call Callback if required
                        feedsLoaded++;
                        if (
                            feedsUrls.length === feedsLoaded &&
                                UWA.is(options.onComplete, 'function')
                        ) {
                            options.onComplete(feedObjs);
                        }
                    }

                    for (i = 0, l = feedsUrls.length; i < l; i++) {

                        var feedUrl = Feed.Utils.cleanFeedUrl(feedsUrls[i]);

                        Data.request(feedUrl, {
                            method: 'GET',
                            onComplete: onComplete.bind(null, feedUrl),
                            onFailure: onFailure.bind(null, feedUrl)
                        });
                    }
                };
            }())
        },

        /**
         * Adapter that use Netvibes backend to parse Feed.
         *
         * @namespace UWA.Services.Feed.Adapter.Netvibes
         * @memberof module:UWA/Services/Feed
         */
        Netvibes: {

            load: function (/*options, feedObjs*/) {

            }
        }
    };

    return UWA.namespace('Services/Feed', Feed, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, navigator
*/

/**
 * This service provide a geolocation using Client capabilities.
 *
 * @module   UWA/Services/Geo
 *
 */
define('UWA/Services/Geo', ['UWA/Core', 'UWA/Json'], function (UWA, Json) {
    'use strict';

   /*
    * Todo:
    * - google jsapi https://gist.github.com/366184
    */

    /**
     * This service provide a geolocation using Client capabilities.
     *
     * @example
     * var geo = new UWA.Services.Geo();
     *
     * geo.getCurrentPosition(
     *     function onSuccess (position) {
     *         // position.coords.latitude
     *         // position.coords.longitude
     *     },
     *     function onError (error) {
     *         // Unable to get position...
     *     }
     * );
     *
     * @param {Object} adapterName - Adapter name or empty if should autodetect
     * @class UWA.Services.Geo
     * @memberof module:UWA/Services/Geo
     */
    var Geo = function (adapterName) {

        this.adapter = null;

        var adapter,
            adapters = UWA.Services.Geo.Adapters;

        if (adapterName) {

            if (!adapters[adapterName]) {
                return new Error('Invalid UWA.Services.Geo AdapterName.');
            }

            this.adapter = adapters[adapterName]();

        } else {

            for (adapter in adapters) {
                if (adapters.hasOwnProperty(adapter)) {
                    this.adapter = adapters[adapter]();
                    if (this.adapter) {
                        break;
                    }
                }
            }
        }
    };

    Geo.prototype = /** @lends module:UWA/Services/Geo.UWA.Services.Geo# */{ // bypass

        /**
         * Get current position then call callback.
         *
         * @param {Function} onSuccess - on success callback
         * @param {Function} onError - on error callback
         * @param {Object} options - options
         */
        getCurrentPosition: function (onSuccess, onError, options) {

            if (this.adapter) {
                this.adapter.getCurrentPosition(onSuccess, onError, options);
            } else if (UWA.is(onError, 'function')) {
                onError(new Error('Geolocalization support not found.'));
            }
        }
    };

    Geo.Adapters = {

        /**
         * Service based on navigator.geolocation.getCurrentPosition.
         *
         * @alias Adapters.html5
         * @memberof module:UWA/Services/Geo
         */
        html5: function () {

            if (navigator.geolocation !== undefined) {

                return {

                    getCurrentPosition: function (onSuccess, onError, options) {

                        options = options || {};
                        options.enableHighAccuracy = true;

                        var _onSuccess = function (p) {

                            // for mozilla geode,it returns the coordinates slightly differently
                            if (p.latitude !== undefined) {
                                onSuccess({
                                    timestamp: p.timestamp,
                                    coords: {
                                        latitude: p.latitude,
                                        longitude: p.longitude
                                    }
                                });
                            } else {
                                onSuccess(p);
                            }
                        };

                        navigator.geolocation.getCurrentPosition(_onSuccess, onError, options);
                    }
                };
            }
        },

        /**
         * Service based on http://freegeoip.net.
         * You can install you own using https://github.com/fiorix/freegeoip.
         *
         * @alias Adapters.freegeoip
         * @memberof module:UWA/Services/Geo
         */
        freegeoip: function () {

            return {

                getCurrentPosition: function (onSuccess, onError, options) {

                    options = UWA.merge(options || {}, {
                        server: 'http://freegeoip.net/json/'
                    });

                    var _onSuccess = function (data) {

                        onSuccess({
                            timestamp: Date.now(),
                            coords: {
                                latitude: data.latitude,
                                longitude: data.longitude
                            }
                        });
                    };

                    Json.request(options.server, {
                        onComplete: _onSuccess,
                        onFailure: onError
                    });
                }
            };
        }
    };

    return UWA.namespace('Services/Geo', Geo, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/ICal
 *
 */
define('UWA/Services/ICal', ['UWA/Core', 'UWA/String'], function (UWA, UWAString) {
    'use strict';

    /**
     * Parse iCal format calendars.
     *
     * > Also Internet Calendaring and Scheduling Core Object Specification
     * > @link {http://www.ietf.org/rfc/rfc2445.txt}
     *
     * @param {String} stream - ICal data content
     * @class UWA.Services.Geo
     * @memberof module:UWA/Services/ICal
     */
    var ICal = function (stream) {
        this.stream = stream;
        this.parse();
    };

    ICal.prototype = /** @lends module:UWA/Services/ICal.UWA.Services.ICal# */ { // bypass

        /**
         * ICal data content.
         *
         * @type {String}
         */
        stream: null,

        /**
         * @property {Object} regexes - Set of regexes to parse components and properties.
         * @protected
         */
        regexes: {
            component:              'BEGIN:{0}(?:[^])*?END:{0}',
            multipleProperties:     '\n{0}[^:]*',
            singleProperty:         '({0})(;[^=]*=[^;:\n]*)*:([^\n]*)'
        },

        /**
         * @property {Object} keys - All core and components properties definition.
         * @protected
         */
        keys: {
            core: {
                version:            'VERSION',
                prodId:             'PRODID',
                calendarScale:      'CALSCALE',
                method:             'METHOD'
            },
            components: {
                event:              'VEVENT',
                todo:               'VTODO',
                journal:            'VJOURNAL',
                freebusy:           'VFREEBUSY'
            },
            event: {
                classification:     { key: 'CLASS', multiple: false },
                created:            { key: 'CREATED', multiple: false },
                description:        { key: 'DESCRIPTION', multiple: false },
                geo: { key: 'GEO', multiple: false },
                lastModified:       { key: 'LAST-MODIFIED', multiple: false },
                location:           { key: 'LOCATION', multiple: false },
                organizer:          { key: 'ORGANIZER', multiple: false },
                priority:           { key: 'PRIORITY', multiple: false },
                dateTimeStamp:      { key: 'DTSTAMP', multiple: false },
                sequence:           { key: 'SEQUENCE', multiple: false },
                status:             { key: 'STATUS', multiple: false },
                transparent:        { key: 'TRANSP', multiple: false },
                url: { key: 'URL', multiple: false },
                recurrenceId:       { key: 'RECURRENCE-ID', multiple: false },
                duration:           { key: 'DURATION', multiple: false },

                attach:             { key: 'ATTACH', multiple: true },
                attendee:           { key: 'ATTENDEE', multiple: true },
                categories:         { key: 'CATEGORIES', multiple: true },
                comment:            { key: 'COMMENT', multiple: true },
                contact:            { key: 'CONTACT', multiple: true },
                exceptionDate:      { key: 'EXDATE', multiple: true },
                exceptionRule:      { key: 'EXRULE', multiple: true },
                requestStatus:      { key: 'REQUEST-STATUS', multiple: true },
                related:            { key: 'RELATED', multiple: true },
                ressources:         { key: 'RESSOURCES', multiple: true },
                recurrenceDate:     { key: 'RDATE', multiple: true },
                recurrenceRule:     { key: 'RRULE', multiple: true },
                xProperty:          { key: 'X-', multiple: true },
                uid: { key: 'UID', multiple: true },

                summary:            { key: 'SUMMARY', multiple: false },
                dateTimeStart:      { key: 'DTSTART', multiple: false },
                dateTimeEnd:        { key: 'DTEND', multiple: false }
            },
            todo: {
                classification:     { key: 'CLASS', multiple: false },
                completed:          { key: 'COMPLETED', multiple: false },
                created:            { key: 'CREATED', multiple: false },
                description:        { key: 'DESCRIPTION', multiple: false },
                dateTimeStamp:      { key: 'DTSTAMP', multiple: false },
                geoPosition:        { key: 'GEO', multiple: false },
                lastModified:       { key: 'LAST-MODIFIED', multiple: false },
                location:           { key: 'LOCATION', multiple: false },
                organizer:          { key: 'ORGANIZER', multiple: false },
                percentComplete:    { key: 'PERCENT-COMPLETE', multiple: false },
                priority:           { key: 'PRIORITY', multiple: false },
                recurrenceId:       { key: 'RECURRENCE-ID', multiple: false },
                sequence:           { key: 'SEQUENCE', multiple: false },
                status:             { key: 'STATUS', multiple: false },
                summary:            { key: 'SUMMARY', multiple: false },
                uid: { key: 'UID', multiple: false },
                url: { key: 'URL', multiple: false },
                due: { key: 'DUE', multiple: false },
                duration:           { key: 'DURATION', multiple: false },

                attach:             { key: 'ATTACH', multiple: true },
                attendee:           { key: 'ATTENDEE', multiple: true },
                categories:         { key: 'CATEGORIES', multiple: true },
                comment:            { key: 'COMMENT', multiple: true },
                contact:            { key: 'CONTACT', multiple: true },
                exceptionDate:      { key: 'EXDATE', multiple: true },
                exceptioRule:       { key: 'EXRULE', multiple: true },
                requestStatus:      { key: 'REQUEST-STATUS', multiple: true },
                related:            { key: 'RELATED', multiple: true },
                ressources:         { key: 'RESSOURCES', multiple: true },
                recurrenceDate:     { key: 'RDATE', multiple: true },
                recurrenceRule:     { key: 'RRULE', multiple: true },
                xProperty:          { key: 'X-', multiple: true }
            },
            journal: {
                classification:     { key: 'CLASS', multiple: false },
                created:            { key: 'CREATED', multiple: false },
                description:        { key: 'DESCRIPTION', multiple: false },
                datetimeStart:      { key: 'DTSTART', multiple: false },
                datetimeStamp:      { key: 'DTSTAMP', multiple: false },
                lastModified:       { key: 'LAST-MODIFIED', multiple: false },
                organizer:          { key: 'ORGANIZER', multiple: false },
                recurrenceId:       { key: 'RECURRENCE-ID', multiple: false },
                sequence:           { key: 'SEQUENCE', multiple: false },
                status:             { key: 'STATUS', multiple: false },
                summary:            { key: 'SUMMARY', multiple: false },
                uid: { key: 'UID', multiple: false },
                url: { key: 'URL', multiple: false },

                attach:             { key: 'ATTACH', multiple: true },
                attendee:           { key: 'ATTENDEE', multiple: true },
                categories:         { key: 'CATEGORIES', multiple: true },
                comment:            { key: 'COMMENT', multiple: true },
                contact:            { key: 'CONTACT', multiple: true },
                exceptionDate:      { key: 'EXDATE', multiple: true },
                exceptionRule:      { key: 'EXRULE', multiple: true },
                related:            { key: 'RELATED', multiple: true },
                recurrenceDate:     { key: 'RDATE', multiple: true },
                recurrenceRule:     { key: 'RRULE', multiple: true },
                requestStatus:      { key: 'REQUEST-STATUS', multiple: true },
                xProperty:          { key: 'X-', multiple: true }
            },
            freebusy: {
                contact:            { key: 'CONTACT', multiple: false },
                datetimeStart:      { key: 'DTSTART', multiple: false },
                datetimeEnd:        { key: 'DTEND', multiple: false },
                duration:           { key: 'DURATION', multiple: false },
                description:        { key: 'DESCRIPTION', multiple: false },
                datetimeStamp:      { key: 'DTSTAMP', multiple: false },
                organizer:          { key: 'ORGANIZER', multiple: false },
                uid: { key: 'UID', multiple: false },
                url: { key: 'URL', multiple: false },
                attendee:           { key: 'ATTENDEE', multiple: true },
                comment:            { key: 'COMMENT', multiple: true },
                freebusy:           { key: 'FREEBUSY', multiple: true },
                requestStatus:      { key: 'REQUEST-STATUS', multiple: true },
                xProperty:          { key: 'X-', multiple: true }
            }
        },

        /**
         * @property {Object} core - Core properties.
         * @protected
         */
        core: {
            version:            '',
            prodId:             '',
            calendarScale:      '',
            method:             ''
        },

        /**
         * @property {Object} components - Components properties.
         * @protected
         */
        components: {
            event:             [],
            todo:              [],
            journal:           [],
            freebusy:          []
        },

        /**
         * Called first on instanciation.
         */
        parse: function () {
            this.parseCoreProperties();
            this.parseComponent('event');
            this.parseComponent('todo');
            this.parseComponent('journal');
            this.parseComponent('freebusy');
        },

        /**
         * Parse for calendar core properties.
         */
        parseCoreProperties: function () {
            var stream = this.stream;

            this.core.version = this.parseProperty(this.keys.core.version, stream);
            this.core.prodId = this.parseProperty(this.keys.core.prodId, stream);
            this.core.calendarScale = this.parseProperty(this.keys.core.calendarScale, stream);
            this.core.method = this.parseProperty(this.keys.core.method, stream);
        },

        /**
         * Parse component properties.
         *
         * @param {String} component - Component label
         */
        parseComponent: function (component) {
            var componentKey, match,
                keys = this.keys,
                components = this.components,
                regex = new RegExp(UWAString.format(this.regexes.component, keys.components[component]), 'g'),
                matches;

            if (typeof (this.stream) === 'string') {
                matches = this.stream.match(regex);
                if (matches) {
                    for (match in matches) {
                        if (typeof (matches[match]) === 'string') {
                            components[component].push({});
                            for (componentKey in keys[component]) {
                                if (typeof (keys[component][componentKey]) === 'object') {
                                    components[component][match][componentKey] = (keys[component][componentKey].multiple) ?
                                            this.parseMultipleProperties(keys[component][componentKey].key, matches[match]) :
                                                    this.parseProperty(keys[component][componentKey].key, matches[match]);
                                }
                            }
                        }
                    }
                }
            }
        },

        /**
         * Parse properties values.
         *
         * @param {String} key - Key parameter
         * @param {String} stream - Component content
         * @return {Object} Value and parameters for given key.
         */
        parseProperty: function (key, stream) {
            var i, value, parameters, pair,
                regex = new RegExp(UWAString.format(this.regexes.singleProperty, key), 'g'),
                match = regex.exec(stream);

            if (match) {
                value = match[3];
                if (match[2]) {
                    parameters = match[2].substr(1).split(';');
                    for (i = 0; i < parameters.length; i++) {
                        pair = parameters[i].split('=');
                        if (pair[1] === undefined) {
                            pair[1] = pair[0];
                        }
                        parameters[pair[0]] = pair[1];
                    }
                }
                return {
                    value: value,
                    parameters: parameters
                };
            }
            return (undefined);
        },

        /**
         * Parse for multiple properties.
         *
         * @param {String} key - Key parameter
         * @param {String} stream - Component content
         * @return {Object} Properties for given key.
         */
        parseMultipleProperties:    function (key, stream) {
            var i, properties,
                regex = new RegExp(UWAString.format(this.regexes.multipleProperties, key), 'g'),
                matches = stream.match(regex);

            if (matches) {
                properties = [];
                for (i = 0; i < matches.length; i++) {
                    matches[i] = matches[i].replace(/;.*/, '');
                    properties[properties.length] = this.parseProperty(matches[i]);
                }
                return (properties);
            }
            return (undefined);
        },

        /**
         * Returns a calendar object.
         *
         * @return {Object} Calendar.
         */
        getCalendar: function () {
            return ({
                core:       this.core,
                components: this.components
            });
        },

       /**
         * Returns events.
         *
         * @return {Object} Events array.
         */
        getEvents:   function () {
            return (this.components.event);
        },

        /**
         * Returns todos
         *
         * @return {Object} Todos array.
         */
        getTodoArray: function () {
            return (this.components.todo);
        },

        /**
         * Returns journals
         *
         * @return {Object} Journals array.
         */
        getJournals: function () {
            return (this.components.journal);
        },

        /**
         * Returns freebusys
         *
         * @return {Object} Freebusys array.
         */
        getFreebusys: function () {
            return (this.components.freebusy);
        },

        /**
         * Returns core calendar properties.
         *
         * @return {Object} Core properties.
         */
        getCoreProperties: function () {
            return (this.core);
        }
    };

    return UWA.namespace('Services/ICal', ICal, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Mail
 *
 */
define('UWA/Services/Mail', ['UWA/Core', 'UWA/Data'], function (UWA, Data) {
    'use strict';

    var Mail = {

        // post parameter is a fake argument, to avoid a problem in IE (see #3102)

        /**
         * Send request on search engine.
         *
         * Sample request object:
         *
         * ```
         * { method : 'get', proxy: 'ajax', type: 'xml', onComplete: callback }
         * ```
         *
         * @param {String} provider - A provider name for mail
         * @param {Object} options - Options hash
         * @param {String} [options.method=POST] - GET, POST (in uppercase!)
         * @param {Number} [options.cache] - Seconds of server caching
         * @param {Function} options.onComplete - Choose your own method
         * @param {Function} [options.onTimeout] - Choose your own method
         * @param {Function} [options.onComplete] - Choose your own method
         * @param {Object} [options.authentication] - The auth object.
         *
         * @example
         * UWA.Services.Mail.getFromProvider('gmail', {...})
         *
         * @alias UWA.Services.Mail.getFromProvider
         * @memberof module:UWA/Services/Mail
         */
        getFromProvider: function (provider, request) {

            if (!Data.proxies[provider]) {
                throw new Error('Not supported UWA.Services.Mail proviver');
            }

            switch (provider) {
            case 'pop':
            case 'gmail':
                return Data.request(Data.proxies[provider], UWA.merge({
                    method: 'POST',
                    type: 'json'
                }, request));

            default:
                UWA.log('invalid request type');
                break;
            }
        }
    };

    return UWA.namespace('Services/Mail', Mail, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * @module   UWA/Services/Search
 *
 */
define('UWA/Services/Search', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Data'
], function (UWA, Utils, Data) {
    'use strict';

    /*
     * TODO:
     * - https://ajax.googleapis.com/ajax/services/search/web?v=1.0&q=Paris%20Hilton&callback=processResults
     */
    var Search = {

        /**
         * Send request on search engine.
         *
         * @param {String} provider - A provider name for search
         * @param {Object} options - Options hash
         * @param {String} [options.lang] - Search language
         * @param {String} [options.locale] - Search locale
         * @param {String} [options.mode] - Search mode
         * @param {String} [options.category] - Search category
         * @param {String} [options.shop] - Search shop
         *
         * @example
         * UWA.Services.Search.getFromProvider('websearch', "My Search words")
         *
         * @alias UWA.Services.Search.getFromProvider
         * @memberof module:UWA/Services/Search
         */
        getFromProvider: function (provider, request) {

            var url,
                options = '';

            if (request.lang !== undefined) {
                options += '&lang=' + request.lang;
            }

            if (request.locale !== undefined) {
                options += '&locale=' + request.locale;
            }

            if (request.mode !== undefined) {
                options += '&mode=' + request.mode;
            }

            if (request.category !== undefined) {
                options += '&category=' + request.category;
            }

            if (request.shop !== undefined) {
                options += '&shop=' + request.shop;
            }

            switch (request.type) {
            case 'websearch':
            case 'blogsearch':
            case 'imagesearch':
            case 'videosearch':
            case 'podcastsearch':
            case 'shoppingsearch':
            case 'opensearch':
                url = UWA.hosts.netvibes + '/data/' + request.type + '/?q=' + Utils.encodeUrl(request.query) + '&engine=' + Utils.encodeUrl(provider) + options;

                return Data.request(url, {
                    method: 'GET',
                    type: 'json',
                    onComplete: request.onComplete
                });

            default:
                UWA.log('invalid request type');
                break;
            }
        }
    };

    return UWA.namespace('Services/Search', Search, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, document, setInterval, clearInterval, setTimeout, clearTimeout
*/

/**
 * @module   UWA/Services/Upload
 *
 */
define('UWA/Services/Upload', [
    'UWA/Core',
    'UWA/Utils',
    'UWA/Class',
    'UWA/Class/Options',
    'UWA/Json'
], function (UWA, Utils, Class, Options, Json) {
    'use strict';

    /**
     * @class UWA.Services.Upload
     * @extends UWA.Class.Options
     */
    var Upload = Class.extend(Options, /** @lends module:UWA/Services/Upload.UWA.Services.Upload# */ { // bypass

        intervalId: null,

        timeoutId: null,

        /**
         * Default options.
         * @private
         */
        defaultOptions: {
            isUploadSuccess: function (response) {
                return (response.status === 'uploaded');
            },
            isUploadFailed: function (response) {
                return (response.status === 'failed');
            },
            formElement: 'undefined',
            onUpload: '',
            onUploadSuccess: '',
            onUploadFailed: '',
            frameIdPrefix: '',
            timeout: 10000,
            polling: 1000,
            urls: {
                statusScript: '', // A valid JsonP endpoint
                uploadScript: ''
            }
        },

        /**
         * UWA.Services.Upload constructor.
         *
         * @param {Object} options - Options hash
         * @param {Function} [options.isUploadSuccess] - Callback used to validate upload success state
         * @param {Function} [options.isUploadFailed] - Callback used to validate upload failed state
         * @param {Element} [options.formElement] - Form Dom Element
         * @param {Function} [options.onUpload] - Callback fired when upload start
         * @param {Function} [options.onUploadSuccess] - Callback fired when upload finish with success
         * @param {Function} [options.onUploadFailed] - Callback fired when upload fails
         * @param {String} [options.frameIdPrefix=''] - Prefix of the frame id
         * @param {Number} [options.timeout=10000] - Timeout limit (in micro seconds)
         * @param {Number} [options.polling=1000] - Polling interval (in micro seconds)
         * @param {Object} [options.urls] - Endpoints ({statusScript: '', uploadScript: ''})
         *
         * @example
         * var myService = new UWA.Services.Upload({
         *     onUploadSuccess: Bookmarks.onUploadSuccess,
         *     onUploadFailed: Bookmarks.onUploadFailed,
         *     onUpload: Bookmarks.onUpload,
         *     formElement: uploadForm,
         *     frameIdPrefix: 'Bookmarks',
         *     urls: {
         *         statusScript: 'http://www.netvibes.com/api/my/bookmarks/import/status',
         *         uploadScript: 'http://www.netvibes.com/api/my/bookmarks/import'
         *      }
         * });
         *
         * @constructs UWA.Services.Upload
         * @memberof module:UWA/Services/Upload
         */
        init: function (options) {

            this.setOptions(options);
            this.options.formElement = UWA.extendElement(options.formElement);

            //Build Frame and form elements
            var frameId = this.buildIframe();
            this.buildFormRequirements(frameId);

            this.options.formElement.addEvent('submit', function (frameId) {
                if (options.urls.statusScript !== undefined) {
                    this.setTimer(frameId);
                }
                this.options.onUpload();
            }.bind(this, frameId));
        },

        /**
         * Inject Upload iframe to current HTML page.
         *
         * @return {Number} Id of the recently created frame
         */
        buildIframe: function () {

            var frame,
                options = this.options,
                frameId = options.frameIdPrefix + Utils.random(1, 100000),
                container = UWA.createElement('div'),
                initialized = false;

            frame = UWA.createElement('iframe', {
                src: 'about:blank',
                id: frameId,
                name: frameId,
                styles: {
                    position: 'absolute',
                    top: '-2000px',
                    left: '0px'
                }
            }).inject(container);

            frame.addEvent('load', function () {
                if (initialized) {
                    options.onUploadSuccess();
                }
                initialized = true;
            });

            document.body.appendChild(container);

            return frameId;
        },

        /**
         * Add form requirements (multipart option, hidden fields...)
         * usefull for Upload component to do its job.
         *
         * @param {Number} frameId - Id of the frame
         */
        buildFormRequirements: function (frameId) {

            var form = this.options.formElement;

            form.setAttributes({
                target: frameId,
                method: 'post',
                enctype: 'multipart/form-data',
                action: this.options.urls.uploadScript
            });

            UWA.createElement('input', {
                type: 'hidden',
                name: 'frameId',
                value: frameId
            }).inject(form);

        },

        /**
         * Fire this.checkStatus each this.options.poll microseconds
         * unless this.options.timeout is reached
         *
         * @param {Number} frameId - Id of the frame
         */
        setTimer: function (frameId) {

            this.intervalId = setInterval(this.checkStatus.bind(this, frameId), this.options.polling);

            this.timeoutId = setTimeout(function () {

                clearInterval(this.intervalId);

                this.options.onUploadFailed({
                    status: 'failed',
                    details: {
                        errors: {
                            TimeoutError: 'Upload timeout after ' + this.options.timeout + 'ms.'
                        }
                    }
                });

            }.bind(this), this.options.timeout);
        },

        /**
         * Ask to status endpoint the upload status.
         *
         * @param {Number} frameId - Id of the frame
         */
        checkStatus: function (frameId) {

            Json.request(this.options.urls.statusScript + '?format=jsonp&frameId=' + frameId, {
                onComplete: function (response) {
                    if (this.options.isUploadSuccess(response)) {
                        this.options.onUploadSuccess(response);
                    } else if (this.options.isUploadFailed(response)) {
                        this.options.onUploadFailed(response);
                    } else {
                        return;
                    }

                    clearTimeout(this.timeoutId);
                    clearInterval(this.intervalId);

                }.bind(this)
            });
        }
    });

    return UWA.namespace('Services/Upload', Upload, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, air, window
*/

/**
 * Data Storage API Adobe Air adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Air
 *
 */
define('UWA/Storage/Adapter/Air', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Air
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Air
     */
    var Air = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Air.UWA.Storage.Adapter.Air# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Air',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 64 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = database;

            // Create a hidden div to store attributes in
            this.db = null;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return window.air !== undefined;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return 'uwa-' + this.database + '-' + key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            var value = air.EncryptedLocalStore.getItem(this.getKey(key));

            if (value === undefined || value === null) {
                return undefined;
            }

            // Cast has String
            return String(value);
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            var bytes = new air.ByteArray();
            bytes.writeUTFBytes(value);

            air.EncryptedLocalStore.setItem(this.getKey(key), bytes);

            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var beforeDelete = this.get(key);

            air.EncryptedLocalStore.removeItem(this.getKey(key));

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/Air', Air, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, jsProxy
*/

/**
 * Data Storage API Android Native adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Android
 *
 */
define('UWA/Storage/Adapter/Android', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Android
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Android
     */
    var Android = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Android.UWA.Storage.Adapter.Android# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Android',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return !!jsProxy;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return ('uwa-' + this.database + '-' + key);
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            return jsProxy.getData(this.getKey(key));
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            jsProxy.setData(this.getKey(key), value);

            return this.get(key);
        },
        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var out = this.get(key);

            jsProxy.setData(this.getKey(key), null);

            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/Android', Android, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define
*/

/**
 * Data Storage API CoucheDB adapter implementation.
 *
 * > Experimental
 *
 * @module   UWA/Storage/Adapter/CouchDB
 *
 *
 * @see {@link http://groups.google.com/group/crunchbase-api/browse_thread/thread/ec52364989153973?pli=1}
 * @see {@link http://answers.yahooapis.com/AnswersService/V1/questionSearch?appid=demoid&sort=relevance&start=1&results=5&query=whale&output=json&callback=jsonp1231}
 * @see {@link http://api.crunchbase.com/v/1/financial-organization/venrock.js?callback=jsonp1231}
 * @see {@link http://melchizetech.com:5984/uwa/f3e537076251b0b4bb583cfac90dcdf6?callback=jsonp1231}
 */
define('UWA/Storage/Adapter/CouchDB', [
    'UWA/Core',
    'UWA/Data',
    'UWA/Json',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Data, Json, Abstract) {
    'use strict';

    /*
      Todo:
         - host option
         - one doc per database
         - this.data cache
         - php proxy for write
    */

    /**
     * @class UWA.Storage.Adapter.CouchDB
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/CouchDB
     */
    var CouchDB = Abstract.extend(/** @lends module:UWA/Storage/Adapter/CouchDB.UWA.Storage.Adapter.CouchDB# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'CouchDB',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * @property {Object} defaultOptions - The default adapter options.
         * @protected
         */
        defaultOptions: {
            host: false
        },

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = database;

            // Test database
            Data.request(this.options.host + '/' + this.database, {
                method: 'GET',
                type: 'json',
                async: false,
                onComplete: function (json) {
                    if (!json.error) {
                        this.available = json;
                        this.storage.isReady = true;
                    }
                }.bind(this)
            });

            return this.available;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return this.available;
        },

        normalizeKey: function (key) {
            return (key === '_keysIndex' ? 'keysIndex' : (key === '_lastUpdate' ? 'lastUpdate' : key));
        },

        request: function (method, uri, options) {

            var defaultOptions = {
                method: method,
                type: 'json',
                async: false
            };

            options = UWA.merge(defaultOptions, options);

            return Data.request(uri, options);
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            var uri, options;

            this.interruptAccess();

            key = this.normalizeKey(key);

            // Update index
            this.data[key] = {
                value: undefined
            };

            // Get value
            uri = this.options.host + '/' + this.database + '/' + key;
            options = {
                onComplete: function (json) {
                    if (!json.error) {
                        this.data[key] = json;
                    }
                }.bind(this)
            };

            this.request('GET', uri, options);

            return this.data[key].value;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            var uri, options;

            this.interruptAccess();

            key = this.normalizeKey(key);

            // Prepare for create new value
            if (this.data[key] === undefined) {

                this.data[key] = {
                    value: value
                };

            // Prepare for update existing value
            } else {
                this.data[key].value = value;
            }

            // Update/Create value
            uri = this.options.host + '/' + this.database + '/' + key;

            options = {
                data: Json.encode(this.data[key]),
                onComplete: function (json) {
                    if (!json.error) {
                        this.data[key] = json;
                    }
                }.bind(this)
            };

            this.request('PUT', uri, options);

            return this.data[key].value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            var beforeDelete, uri, options;

            this.interruptAccess();

            beforeDelete = this.get(key);

            key = this.normalizeKey(key);

            uri = this.options.host + '/' + this.database + '/' + key + '?rev=' + this.data[key]._rev;

            options = {
                data: Json.encode(this.data[key]),
                onComplete: function (json) {
                    if (!json.error) {
                        this.data[key] = json;
                    }
                }.bind(this)
            };

            this.request('DELETE', uri, options);

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/CouchDB', CouchDB, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * Data Storage API OSX Dashboard adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Dashboard
 *
 */
define('UWA/Storage/Adapter/Dashboard', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Dashboard
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Dashboard
     */
    var Dashboard = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Dashboard.UWA.Storage.Adapter.Dashboard# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Dashboard',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 64 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = database;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return window.widget && window.widget.preferenceForKey;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            if (window.widget) {
                return window.widget.identifier + '-' + this.database + '-' + key;
            }
            return key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            var value = window.widget.preferenceForKey(this.getKey(key));

             // Avoid Vista Gadget Error
            if (value === null || value === '') {
                return undefined;
            }

            return value;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            return window.widget.setPreferenceForKey(value, this.getKey(key));
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var beforeDelete = this.get(key);

            this.set(key, null);

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/Dashboard', Dashboard, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, ActiveXObject, window, location, navigator
*/
/*jshint camelcase: false*/

/**
 * Data Storage API Adobe Flash adapter implementation.
 *
 * > Experimental
 *
 * @module   UWA/Storage/Adapter/Flash
 *
 */
define('UWA/Storage/Adapter/Flash', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Flash
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Flash
     */
    var Flash = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Flash.UWA.Storage.Adapter.Flash# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Flash',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 5 * 1024 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            this.db = !window.globalStorage ? window.localStorage : window.globalStorage[location.hostname];

            // To make Flash Storage work on IE, we have to load up an iFrame
            // which contains an HTML page that embeds the object using an
            // object tag wrapping an embed tag. Of course, this is unnecessary for
            // all browsers except for IE, which, to my knowledge, is the only browser
            // in existance where you need to complicate your code to fix bugs. Goddamnit. :(
            /*
            $(document.body).append('<iframe style="height:1px;width:1px;position:absolute;left:0;top:0;margin-left:-100px;" ' +
                    'id="jStoreFlashFrame" src="' + this.flashProxyPath + '"></iframe>');
                    */

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return !!(this.hasFlash('8.0.0'));
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            this.interruptAccess();
            var out = this.db.f_get_cookie(key);
            return out === 'null' ? null : out;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            this.db.f_set_cookie(key, value);
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var beforeDelete = this.get(key);
            this.db.f_delete_cookie(key);
            return beforeDelete;
        },

        hasFlash: function (version) {

            var i,
                pv = this.flashVersion().match(/\d+/g),
                rv = version.match(/\d+/g);

            for (i = 0; i < 3; i++) {

                pv[i] = parseInt(pv[i] || 0, 10);
                rv[i] = parseInt(rv[i] || 0, 10);

                // player is less than required
                if (pv[i] < rv[i]) {
                    return false;
                }

                // player is greater than required
                if (pv[i] > rv[i]) {
                    return true;
                }
            }

            // major version, minor version and revision match exactly
            return true;
        },

        flashVersion: function () {

            // ie
            try {

                try {
                    // avoid fp6 minor version lookup issues
                    // see: http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6/
                    var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
                    try {
                        axo.AllowScriptAccess = 'always';
                    } catch (e) {
                        return '6,0,0';
                    }

                } catch (noShockwaveFlashIE) {

                }

                return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
                // other browsers
            } catch (noActiveXObject) {

                try {
                    if (navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin) {
                        return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
                    }
                } catch (noShockwaveFlash) {

                }
            }

            return '0,0,0';
        }
    });

    return UWA.namespace('Storage/Adapter/Flash', Flash, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * Data Storage API Object (not persistent) adapter implementation.
 *
 * @module   UWA/Storage/Adapter/IGoogle
 *
 */
define('UWA/Storage/Adapter/IGoogle', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.IGoogle
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/IGoogle
     */
    var IGoogle = Abstract.extend(/** @lends module:UWA/Storage/Adapter/IGoogle.UWA.Storage.Adapter.IGoogle# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'IGoogle',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            // Initialize iGoogle Preference when Dom is ready
            UWA.Event.onDomReady(function () {

                this.db = new window._IG_Prefs(); // jshint ignore:line

                this.storage.isReady = true;

            }.bind(this));
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return window._IG_Prefs; // jshint ignore:line
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            return this.db.getString(this.getKey(key));
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            this.db.set(this.getKey(key), value);
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var out = this.get(key);
            this.db.set(this.getKey(key), null);
            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/IGoogle', IGoogle, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * Data Storage API IndexDb adapter implementation.
 *
 * @module   UWA/Storage/Adapter/IndexDb
 *
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB}
 * @see {@link http://www.html5labs.com/IndexedDBTest/CodeSnippets/samples.html}
 */
define('UWA/Storage/Adapter/IndexDb', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract',
    'UWA/Utils/Client'
], function (UWA, Abstract, Client) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.IndexDb
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/IndexDb
     */
    var IndexDb = Abstract.extend(/** @lends module:UWA/Storage/Adapter/IndexDb.UWA.Storage.Adapter.IndexDb# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'IndexDb',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 1024 * 200,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            var db,
                that = this;

            // Alias some API
            that.indexedDB = Client.getVendorProperty(window, 'indexedDB');

            // Moreover, you may need references to some window.IDB* objects:
            that.IDBTransaction = Client.getVendorProperty(window, 'IDBTransaction');
            that.IDBKeyRange = Client.getVendorProperty(window, 'IDBKeyRange');

            // The type of storage engine
            that.database = database;

            // Create our database connection
            that.db = db = that.indexedDB.open('uwa-data-storage-' + that.database, 1);

            db.onerror = function (/*event*/) {
                // Do something with request.errorCode!
            };

            db.onsuccess = function (/*event*/) {
                // Do something with request.result!
            };

            // Cache the data from the table
            this.updateCache();
        },

        updateCache: function () {

            /*
            // Create an objectStore to hold information about our customers. We're
            // going to use "ssn" as our key path because it's guaranteed to be
            // unique.
            db.createObjectStore("customers", {
                keyPath: "ssn"
            });

            // Create an index to search customers by name. We may have duplicates
            // so we can't use a unique index.
            db.createIndex("name", "name", {
                unique: false
            });
            */

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            // TODO

            return this.data[key] || undefined;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            // Update the database
            // TODO

            // Cache the data from the table
            this.data[key] = value;

            this.updateCache();

            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            // Update the database
            var beforeDelete = this.get(key);

            // TODO

            // Cache the data from the table
            delete this.data[key];

            this.updateCache();

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/IndexDb', IndexDb, UWA);
});

/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, window
*/

/**
 * Data Storage API Opera Extension adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Opera
 *
 */
define('UWA/Storage/Adapter/Opera', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Opera
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Opera
     */
    var Opera = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Opera.UWA.Storage.Adapter.Opera# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Dashboard',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 64 * 1024,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // The type of storage engine
            this.database = database;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return (window.widget && window.widget.preferences && window.widget.preferences.getItem);
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return 'uwa-' + this.database + '-' + key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {

            this.interruptAccess();

            var value = window.widget.preferences.getItem(this.getKey(key));

             // Avoid Vista Gadget Error
            if (value === null || value === '') {
                return undefined;
            }

            return value;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            return window.widget.preferences.setItem(value, this.getKey(key));
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var beforeDelete = this.get(key);

            this.set(key, null);

            return beforeDelete;
        }
    });

    return UWA.namespace('Storage/Adapter/Opera', Opera, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, System
*/

/**
 * Data Storage API Microsoft Windows Gadget adapter implementation.
 *
 * @module   UWA/Storage/Adapter/Vista
 *
 */
define('UWA/Storage/Adapter/Vista', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.Vista
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/Vista
     */
    var Vista = Abstract.extend(/** @lends module:UWA/Storage/Adapter/Vista.UWA.Storage.Adapter.Vista# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'Vista',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return System && System.Gadget && System.Gadget.Settings;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return 'uwa-' + this.database + '-' + key;
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            return System.Gadget.Settings.read(this.getKey(key)) || undefined;
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {
            this.interruptAccess();
            System.Gadget.Settings.write(this.getKey(key), value);
            return value;
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {
            this.interruptAccess();
            var out = this.get(key);
            System.Gadget.Settings.write(this.getKey(key), undefined);
            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/Vista', Vista, UWA);
});


/*
Copyright 2006-2016 Netvibes, a Dassault Systèmes company.
All rights reserved.
*/

/*global
    define, Mojo
*/

/**
 * Data Storage API WebOS Mojo Cookie adapter implementation.
 *
 * @module   UWA/Storage/Adapter/WebOs
 *
 */
define('UWA/Storage/Adapter/WebOs', [
    'UWA/Core',
    'UWA/Storage/Adapter/Abstract'
], function (UWA, Abstract) {
    'use strict';

    /**
     * @class UWA.Storage.Adapter.WebOs
     * @extends UWA.Storage.Adapter.Abstract
     * @memberof module:UWA/Storage/Adapter/WebOs
     */
    var WebOs = Abstract.extend(/** @lends module:UWA/Storage/Adapter/WebOs.UWA.Storage.Adapter.WebOs# */{ // bypass

        /**
         * The type of storage engine used by Adapter.
         * @type {String}
         */
        type: 'WebOs',

        /**
         * The maximum limit of the storage engine.
         * @type {Number}
         */
        limit: 0,

        /**
         * Initialize database connexion.
         *
         * @param {String} database - The database name
         */
        connect: function (database) {

            // set current database
            this.database = database;

            // set storage to ready state
            this.storage.isReady = true;
        },

        /**
         * Check if adapter is available.
         *
         * @return {Boolean} `true` if available and writable else `false`.
         */
        isAvailable: function () {
            return !!Mojo;
        },

        /**
         * Normalize key name to avoid collision with native or internal keys.
         *
         * @param {String} key - The key name
         * @return {String} New key name.
         */
        getKey: function (key) {
            return new Mojo.Model.Cookie('uwa-' + this.database + '-' + key);
        },

        /**
         * Provide a simple interface for reading key value.
         *
         * @param {String} key - The key name
         * @return {*} Key value.
         */
        get: function (key) {
            return this.getKey(key).get();
        },

        /**
         * Provide a simple interface for storing key value.
         *
         * @param {String} key - The key name
         * @param {String} value - The serialized key value
         * @return {String} Key value.
         */
        set: function (key, value) {

            this.interruptAccess();

            this.getKey(key).put(value);

            return this.get(key);
        },

        /**
         * Provide a simple interface for removing values.
         *
         * @param {String} key - The key name
         * @return {String} Previous key value.
         */
        rem: function (key) {

            this.interruptAccess();

            var out = this.get(key);

            this.getKey(key).put(null, new Date());

            return out;
        }
    });

    return UWA.namespace('Storage/Adapter/WebOs', WebOs, UWA);
});

