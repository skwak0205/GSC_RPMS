define("DS/WAfrHandlers/mod_Handler",[],function(){"use strict";function e(e,t){if(!e)throw new Error("clients must be defined");if(void 0===t)throw new Error("value must be defined.");for(const n in e)e[n](t)}let t=Object.create(null);return t.Handler=class{constructor(e){if(this._private||(this._private=Object.create(null)),this._private._currentAvailability=!0,this._private._isEnabled=!0,this._private._isEnabledChangeClients={},this._private._isEnabledNextClientUid=0,!e)throw new Error("Missing parameters. Please see the Handler documentation to see the required parameters.");if(!e.id)throw new Error("Missing parameter. id has to be defined.");this._private._id=e.id,e.i18n&&(this._private._i18n=e.i18n),e.accelerator&&(this._private._accelerator=e.accelerator)}getAccelerator(){return this._private._accelerator}getId(){return this._private._id}setI18n(e){if(!(e&&e.title&&e.shortHelpImage&&e.shortHelpImage.uri&&e.longHelpImage&&e.longHelpImage.uri))throw new Error("One or many parameters are missing.");e&&(this._private._i18n=e)}getI18n(){return this._private._i18n}beingInitialized(){let e=!1;const t=this.getHandlerComponent();return t&&t.getInitializedState()&&(e=!0),e}getHandlerComponent(){throw new Error("getHandlerComponent has to be implemented on subclasses.")}onAvailabilityChanged(){throw new Error("onAvailabilityChanged has to be implemented on subclasses")}onAvailabilityEvent(e){if(!e||"function"!=typeof e)throw new Error("cb has to be a function",e);const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=this.getId();if(!r)throw new Error("handlerIdentifier has to be a non empty string.");return n.subscribe({event:r+"/AVAILABILITY"},e)}removeAvailabilityEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}isAvailable(){return this._private._currentAvailability}isEnabled(){return this._private._isEnabled}disable(){this._private._isEnabled&&(this._private._isEnabled=!1,e(this._private._isEnabledChangeClients,!1))}enable(){this._private._isEnabled||(this._private._isEnabled=!0,e(this._private._isEnabledChangeClients,!0))}isExecutable(){return this.isAvailable()&&this.isEnabled()}onIsEnabledChangeEvent(e){if(!e||"function"!=typeof e)throw new TypeError("cb must be a function.");const t=this._private._isEnabledNextClientUid++;return this._private._isEnabledChangeClients[t]=e,t}removeIsEnabledChangeEventSubscription(e){const t=this._private._isEnabledChangeClients;if(!t.hasOwnProperty(e))throw new Error("No element registered with this token",e);delete t[e]}destroy(){this._private._isEnabledChangeClients&&delete this._private._isEnabledChangeClients}},t}),define("DS/WAfrHandlers/private/private_Utilities",[],function(){"use strict";let e=Object.create(null);return e.enums=Object.create(null),e.enums.HandlerType={},e.executeHandlerFunctions=[],e.registerLeafHandler=function(t,n){const r=e.enums.HandlerType;if(r.hasOwnProperty(t))throw new Error("There already are a handler registered using the same handlerId",t);if(!n||!n.executeFunc)throw new Error("Missing parameters");let a=-1;for(let e in r)r.hasOwnProperty(e)&&(a=a>r[e]?a:r[e]);++a,r[t]=a,e.executeHandlerFunctions[a]=n.executeFunc},e.publishHandlerAvailability=function(e){const t=e.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this Handler",e);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=e.getId();if(!r)throw new Error("handlerIdentfier has to be a non empty string.");setTimeout(function(){n.publish({event:r+"/AVAILABILITY",data:{newValue:e.isAvailable()}})},0)},e.computeArgs=function(e,t){const n=e.getArgs();if(t&&n)for(let e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e]);else n&&(t=n);return t},e}),define("DS/WAfrHandlers/private/private_CheckHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities"],function(e,t){"use strict";let n=Object.create(null);return n.executeCheckHandler=function(n,r){if(!n)throw new Error("checkHandler has to be defined and cannot be null");const a=n.getHandlerComponent();if(!a)throw new Error("handlerComponent must be defined.");if(!a.getExecutionContext())throw new Error("Execution Context not found.");if(!r||void 0===r.action||"boolean"!=typeof r.action)throw new Error("Wrong parameters");let i=!0;(n.beingInitialized()||n._private._isChecked!==r.action)&&(n._private._isChecked=r.action,function(e){const t=e.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CheckHandler",e);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");const r=e.getId();if(!r)throw new Error("handlerIdentfier has to be a non empty string.");const a=e._private._isChecked?"/CHECK":"/UNCHECK";n.publish({event:r+a})}(n),n._private._isChecked?n._private._check&&void 0!==n._private._check._private._type&&(i=!1,t.executeHandlerFunctions[n._private._check._private._type]({handler:n._private._check,cb:r.cb,args:r.args})):n._private._uncheck&&void 0!==n._private._uncheck._private._type&&(i=!1,t.executeHandlerFunctions[n._private._uncheck._private._type]({handler:n._private._uncheck,cb:r.cb,args:r.args}))),i&&r.cb&&setTimeout(function(){const t=e.getErrorManager(),n=e.createReturnObject(t.SUCCEEDED);r.cb(n)},0)},n}),define("DS/WAfrHandlers/mod_HandlerComponent",["DS/CoreUtilities/ErrorManagement","DS/CoreEvents/ModelEvents","DS/WAfrHandlers/private/private_Utilities","DS/WAfrDebug/mod_Performances"],function(e,t,n,r){"use strict";var a=r.Performances,i="[DS/WAfrHandlers/mod_HandlerComponent]",o=Object.create(null);function s(t){if(!(this&&this.resolve&&this.reject&&t))throw new Error;e.hasSucceeded(t)?this.resolve(t):this.reject(t)}o.DEFAULT_COMPONENT_NAME="AFR_HandlerComponent";var d=Object.create(null);function l(e,t,n){if(!(e&&t&&n&&e._private.hasOwnProperty(t)))throw new Error;const r=e._private[t],a=n.getId();if(!r||!a)throw new Error;if(!n.setHandlerComponent(e))throw new Error;r[a]=n}function h(e,t,n){if(!(e&&t&&n&&e._private.hasOwnProperty(t)))throw new Error;const r=e._private[t],a=n.getId();if(!r||!a)throw new Error;if(!n.setHandlerComponent(null))throw new Error;delete r[a]}function c(){return Promise.resolve()}function p(e){if(!e)throw new Error("handlerComponent has to be defined");const t=e._perf,n=t.start([i,"manageDefaultCommand"].join(" ")),r=e._private._defaultCommandIdentifier;return new Promise(function(a,i){if(r){const o=e.getExecutionContext();if(o){require(["DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent"],function(s){const d=o.getComponent(s.CommandsManagerComponent.DEFAULT_COMPONENT_NAME);d?(d.subscribeOnceToCmdState(r,"begin",function(){return t.stop(n),a()}),d.setDefaultCommand(r),delete e._private._defaultCommandIdentifier):(t.stop(n),i(new Error("No commandsManagerComponent found using this executionContext",o)))},function(){t.stop(n),i(new Error("Require failed (DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent)"))})}else t.stop(n),i(new Error("executionContext is undefined"))}else t.stop(n),a()})}function m(e,t){const n=e._perf.start([i,"cleanUpHandlers"].join(" ")),r=d.HandlerMap;for(var a in r)if(r.hasOwnProperty(a)){const n=r[a],i=e._private[n];for(let e in i)i.hasOwnProperty(e)&&i[e].destroy();delete e._private[n],t&&(e._private[n]={})}e._perf.stop(n)}function u(e,t){let n={};if(void 0!==t&&e&&e._private&&e._private._hdlrMap){const a=e._private._hdlrMap;for(var r in a)if(a.hasOwnProperty(r)){const i=a[r]._private._type;e._private._hdlrMap.hasOwnProperty(r)&&i===t&&(n[r]=e._private._hdlrMap[r])}}return n}d.HandlerMap={HANDLER:"_hdlrMap",CHECK_HANDLER:"_chkHdlrMap",RADIO_HANDLER:"_radioHdlrMap"};class _{constructor(){this._perf=new a,this._private={};var e=d.HandlerMap;for(var t in e)if(e.hasOwnProperty(t)){var n=e[t];this._private[n]={}}}getExposedComponentCtor(){function e(){}return e.prototype.initialize=c,e.prototype.clean=c,e.prototype.destroy=c,e.prototype.executeHandler=this.executeHandler.bind(this),e.prototype.toggleCheck=this.toggleCheck.bind(this),e.prototype.setCheckState=this.setCheckState.bind(this),e.prototype.getCheckState=this.getCheckState.bind(this),e.prototype.toggleRadioItemState=this.toggleRadioItemState.bind(this),e.prototype.setRadioItemState=this.setRadioItemState.bind(this),e.prototype.getRadioItemState=this.getRadioItemState.bind(this),e.prototype.enableHandler=this.enableHandler.bind(this),e.prototype.disableHandler=this.disableHandler.bind(this),e.prototype.isHandlerExecutable=this.isHandlerExecutable.bind(this),e.prototype.enableCheck=this.enableCheck.bind(this),e.prototype.disableCheck=this.disableCheck.bind(this),e.prototype.isCheckExecutable=this.isCheckExecutable.bind(this),e.prototype.enableRadio=this.enableRadio.bind(this),e.prototype.disableRadio=this.disableRadio.bind(this),e.prototype.isRadioExecutable=this.isRadioExecutable.bind(this),e}initialize(){return this._private._eventChannel=new t,Promise.resolve()}configure(){const e=this,t={ActionHandler:"executeHandler",CommandHandler:"executeHandler",CheckHandler:"setCheckState",RadioHandler:"setRadioItemState"},n=this._private._initializationData;return!n||n.length<=0?p(e):function e(t,n,r){return t(r)?n(r).then(e.bind(null,t,n)):r}(function(e){return e<n.length},function(r){const a=n[r],i=t[a.type];return e[i](a).then(function(){return++r},function(e){if(e&&e.getError&&"NOT_EXECUTABLE"===e.getReturnValue().internalValue)return++r;throw e})},0).then(function(){return p(e)}).catch(function(e){return Promise.reject(e)})}clean(){return m(this,!0),this._private._eventChannel.destroy(),this._private._eventChannel=new t,this._private._availabilityModesComponent=null,this._private._defaultCommandIdentifier=void 0,Promise.resolve()}destroy(){return m(this,!1),this._private._eventChannel.destroy(),delete this._private._eventChannel,delete this._private._availabilityModesComponent,Promise.resolve()}getEventChannel(){return this._private._eventChannel}setInitializedState(e){if(void 0===e)throw new Error("state has to be defined");this._private._initializedState=e}setInitializationDefaultCommand(e){if(!e||"string"!=typeof e)throw new Error("commandIdentifier has to be a string");this._private._defaultCommandIdentifier=e}getInitializedState(){return Boolean(this._private._initializedState)}setInitializationData(e){if(!Array.isArray(e))throw new Error("data has to be an array");this._private._initializationData=e}addInitializationData(e){if(!Array.isArray(e))throw new Error("data has to be an array");this._private._initializationData?this._private._initializationData=this._private._initializationData.concat(e):this._private._initializationData=e}setAvailabilityModesComponent(e){if(void 0===e)throw new Error("component has to be defined");if(null!==e&&this._private._availabilityModesComponent)throw new Error("There is already one AvailabilityModesComponent attached to this HandlerComponent");this._private._availabilityModesComponent=e}getAvailabilityModesComponent(){return this._private._availabilityModesComponent}addHandler(e){l(this,d.HandlerMap.HANDLER,e)}removeHandler(e){h(this,d.HandlerMap.HANDLER,e)}addCheckHandler(e){l(this,d.HandlerMap.CHECK_HANDLER,e)}removeCheckHandler(e){h(this,d.HandlerMap.CHECK_HANDLER,e)}addRadioHandler(e){l(this,d.HandlerMap.RADIO_HANDLER,e)}removeRadioHandler(e){h(this,d.HandlerMap.RADIO_HANDLER,e)}executeHandler(t){if(t&&t.cb)throw new Error;const n=this;return new Promise(function(r,a){var i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),n._private._hdlrMap.hasOwnProperty(o)?n._private._hdlrMap[o].execute({cb:s.bind({resolve:r,reject:a}),args:t.args}):a(e.createReturnObject(i.FAILED,{description:"No Handler corresponding to the following id: "+o}))})}toggleCheck(t){if(t&&t.cb)throw new Error;const n=this;return new Promise(function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.args;if(o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),n._private._chkHdlrMap.hasOwnProperty(o)){const e=n._private._chkHdlrMap[o],t=e.getState();e.setState({state:!t,cb:s.bind({resolve:r,reject:a}),args:d})}else a(e.createReturnObject(i.FAILED,{description:"No CheckHandler corresponding to the following id: "+o}))})}setCheckState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise(function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.state,l=t.args;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),void 0!==d&&"boolean"==typeof d||a(new Error),n._private._chkHdlrMap.hasOwnProperty(o)?n._private._chkHdlrMap[o].setState({state:d,cb:s.bind({resolve:r,reject:a}),args:l}):a(e.createReturnObject(i.FAILED,{description:"No CheckHandler corresponding to the following id: "+o}))})}getCheckState(e){if(!e)throw new Error;const t=e.id;if(!t||"string"!=typeof t)throw new Error;if(!this._private._chkHdlrMap.hasOwnProperty(t))throw new Error;return this._private._chkHdlrMap[t].getState()}toggleRadioItemState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise(function(r,a){const i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.radioId,l=t.args;o&&"string"==typeof o||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),d&&"string"==typeof d||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.radioId has to be defined"}));const h=n._private._radioHdlrMap;if(h.hasOwnProperty(d)){const e=!h[d].getRadioItemState(o);h[d].setRadioItemState({radioHdlrItemId:o,state:e,cb:s.bind({resolve:r,reject:a}),args:l})}else a(e.createReturnObject(i.FAILED,{description:"No item corresponding to the following id: "+d}))})}setRadioItemState(t){if(t&&t.cb)throw new Error;const n=this;return new Promise(function(r,a){var i=e.getErrorManager();t||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters has to be defined"}));const o=t.id,d=t.radioId,l=t.state,h=t.args;o&&"string"==typeof o||a(new Error),d&&"string"==typeof d||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.id has to be defined"})),void 0!==l&&"boolean"==typeof l||a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"parameters.state has to be defined"}));var c=n._private._radioHdlrMap;c.hasOwnProperty(d)?c[d].setRadioItemState({radioHdlrItemId:o,state:l,cb:s.bind({resolve:r,reject:a}),args:h}):a(e.createReturnObject(i.MISSING_PARAMETERS,{description:"No CheckHandler corresponding to the following id: "+o}))})}getRadioItemState(e){if(!e)throw new Error;const t=e.id,n=e.radioId;if(!t||"string"!=typeof t)throw new Error;if(!n||"string"!=typeof n)throw new Error;const r=this._private._radioHdlrMap;if(!r.hasOwnProperty(n))throw new Error;return r[n].getRadioItemState(t)}enableHandler(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableHandler - id has to be defined.");const t=this._private._hdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] enableHandler - Handler not found: ${e}`);t[e].enable()}disableHandler(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableHandler - id has to be defined.");const t=this._private._hdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] disableHandler - Handler not found: ${e}`);t[e].disable()}isHandlerExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isHandlerExecutable - id has to be defined.");const t=this._private._hdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] isHandlerExecutable - Handler not found: ${e}`);return t[e].isExecutable()}enableCheck(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableCheck - id has to be defined.");const t=this._private._chkHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] enableCheck - Handler not found: ${e}`);t[e].enable()}disableCheck(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableCheck - id has to be defined.");const t=this._private._chkHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] disableCheck - Handler not found: ${e}`);t[e].disable()}isCheckExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isCheckExecutable - id has to be defined.");const t=this._private._chkHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] isCheckExecutable - Handler not found: ${e}`);return t[e].isExecutable()}enableRadio(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] enableRadio - id has to be defined.");const t=this._private._radioHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] enableRadio - Handler not found: ${e}`);t[e].enable()}disableRadio(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] disableRadio - id has to be defined.");const t=this._private._radioHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] disableRadio - Handler not found: ${e}`);t[e].disable()}isRadioExecutable(e){if(!e||"string"!=typeof e)throw new TypeError("[HandlerComponent] isRadioExecutable - id has to be defined.");const t=this._private._radioHdlrMap;if(!t.hasOwnProperty(e))throw new Error(`[HandlerComponent] isRadioExecutable - Handler not found: ${e}`);return t[e].isExecutable()}getActionHandlerMap(){return u(this,n.enums.HandlerType.ACTION_HANDLER)}getCommandHandlerMap(){return u(this,n.enums.HandlerType.COMMAND_HANDLER)}getLeafHandlerMaps(){let e=Object.create(null);if(e.actionHandlers={},e.commandHandlers={},this._private&&this._private._hdlrMap){const r=this._private._hdlrMap;for(var t in r)if(r.hasOwnProperty(t)){const a=r[t]._private._type;a===n.enums.HandlerType.ACTION_HANDLER?e.actionHandlers[t]=r[t]:a===n.enums.HandlerType.COMMAND_HANDLER?e.commandHandlers[t]=r[t]:console.warn("Unknown LeafHandler type",r[t]._private._type)}}return e}getCheckHandlerMap(){return this._private[d.HandlerMap.CHECK_HANDLER]}getRadioHandlerMap(){return this._private[d.HandlerMap.RADIO_HANDLER]}}return _.DEFAULT_COMPONENT_NAME=o.DEFAULT_COMPONENT_NAME,o.HandlerComponent=_,o}),define("DS/WAfrHandlers/mod_LeafHandler",["DS/WAfrHandlers/mod_Handler","DS/CoreUtilities/ErrorManagement"],function(e,t){"use strict";const n=e.Handler;class r{constructor(e,t){if(!e||!t)throw new Error("handler and manager have to be defined");this._handler=e,this._manager=t}execute(e){return this._manager.handleExecute({cb:e.cb,manageable:this._handler,args:e.args})}setHandlerComponent(){return console.warn("Impossible to set a HandlerComponent to a LeafHandler which is managed."),!1}getHandlerComponent(){return this._manager.getHandlerComponent()}onAvailabilityChanged(e,t){const n=this._handler;return this._manager.handleOnAvailabilityChanged({manageable:n,args:{newValue:e,info:t}})}isExecutable(){return this._manager.handleIsExecutable({manageable:this._handler})}disable(){throw new Error("Impossible to disable a Managed Handler")}enable(){throw new Error("Impossible to enable a Managed Handler")}onIsEnabledChangeEvent(){throw new Error("Impossible to subscribe to isEnabledChangeEvent from a Managed Handler")}removeIsEnabledChangeEventSubscription(){throw new Error("Impossible to unsubscribe to isEnabledChangeEvent from a Managed Handler")}}let a=Object.create(null);return a.LeafHandler=class extends n{constructor(e){if(super(e),!e)throw new Error("Missing parameters. Please see the LeafHandler documentation to see the required parameters.");e.availabilityMode&&(this._private._availabilityMode=e.availabilityMode),this._private._currentAvailability=!0,e.icon&&e.icon.uri&&(this._private._icon=e.icon)}initAvailabilityModesSubscription(){const e=this.getHandlerComponent();if(!e)throw new Error("Impossible to retrieve the HandlerComponent.");const t=e.getAvailabilityModesComponent();if(!t)throw new Error("Impossible to retrieve the AvailabilityModesComponent.");return t.subscribe(this,!0).then(function(e){this._private._availabilityModesSubscriptionToken=e}.bind(this))}destroy(){super.destroy();const e=this.getHandlerComponent();if(!e)throw new Error("Impossible to retrieve the HandlerComponent.");const t=e.getAvailabilityModesComponent();t&&t.unsubscribe(this._private._availabilityModesSubscriptionToken)}getAvailabilityModesInfo(){return{modes:this._private._availabilityMode,currentAvailability:this._private._currentAvailability}}onAvailabilityChanged(e,t){return this._private._currentAvailability=e,this._private._handlerState.onAvailabilityChanged(e,t)}getIcon(){return this._private._icon}makeManaged(e){if(this._private._handlerState instanceof r)throw new Error("Call makeManaged method on an LeafHandler which is already managed");this._private._handlerState=new r(this,e)}isExecutable(){return this._private._handlerState.isExecutable()}disable(){return this._private._handlerState.disable()}enable(){return this._private._handlerState.enable()}onIsEnabledChangeEvent(e){return this._private._handlerState.onIsEnabledChangeEvent(e)}removeIsEnabledChangeEventSubscription(e){return this._private._handlerState.removeIsEnabledChangeEventSubscription(e)}execute(e){if(e&&"object"!=typeof e)throw new Error("parameters has to be an object if defined");if(this.isExecutable())return this._private._handlerState.execute(e);e&&e.cb?setTimeout(function(){const n=t.getErrorManager(),r=t.createReturnObject(n.NOT_EXECUTABLE,{description:"This LeafHandler is not executable"});e.cb(r)},0):console.warn("This LeafHandler is not executable",this.getId())}setArgs(e){if("object"!=typeof e)throw new Error("args has to be an object");this._private._args=e}getArgs(){return this._private._args}},a.StandaloneLeafHandlerState=class{constructor(e){if(!e)throw new Error("handler has to be defined");this._handler=e}execute(){throw new Error("execute has to be implemented on subclasses")}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be defined");return this._handler._private._handlerComponent=e,!0}getHandlerComponent(){return this._handler._private._handlerComponent}onAvailabilityChanged(e){const t=this._handler;t._private._currentAvailability=e;const n=t.getHandlerComponent();if(!n)throw new Error("There is no HandlerComponent related to this LeafHandler",t);const r=n.getEventChannel();if(!r)throw new Error("Retrieved eventChannel is undefined");const a=t.getId();if(!a)throw new Error("handlerIdentfier has to be a non empty string.");r.publish({event:a+"/AVAILABILITY",data:{newValue:e}})}isExecutable(){return n.prototype.isExecutable.call(this._handler)}disable(...e){return n.prototype.disable.call(this._handler,...e)}enable(...e){return n.prototype.enable.call(this._handler,...e)}onIsEnabledChangeEvent(...e){return n.prototype.onIsEnabledChangeEvent.call(this._handler,...e)}removeIsEnabledChangeEventSubscription(...e){return n.prototype.removeIsEnabledChangeEventSubscription.call(this._handler,...e)}},a.ManagedLeafHandlerState=r,a}),define("DS/WAfrHandlers/private/private_RadioHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_CheckHandlerUtilities"],function(e,t){"use strict";let n=Object.create(null);return n.fireEvent=function(e,t,n){if(!e||!t||void 0===n)throw new Error("radioHandler, itemIdentifier and state has to be defined");const r=e.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this RadioHandler",e);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=e.getId();if(!i)throw new Error("radioHandlerIdentifier has to be a non empty string.");const o="/"+t,s=n?"/SELECT":"/UNSELECT";a.publish({event:i+o+s})},n.checkOnUncheck=function(r){if(!(this&&this.manager&&this.manageable&&r))throw new Error("Internal error. Manageable has to be defined");if(e.hasSucceeded(r))n.fireEvent(this.manager,this.manageable.getId(),!0),t.executeCheckHandler(this.manageable,{cb:this.cb,action:!0,args:this.args});else{if(!this.cb)throw r.getError();this.cb(r)}},n.isManagedByRadioHandler=function(e,t){let n=!1,r=0;const a=t._private._elements.length;for(;!n&&r<a;)t._private._elements[r]===e&&(n=!0),++r;return n},n}),define("DS/WAfrHandlers/private/private_CommandHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities"],function(e,t){"use strict";let n=Object.create(null);return n.CmdMode={EXCLUSIVE:0,NESTED:1},n.RepeatMode={NEVER:0,STANDARD:1,ALWAYS:2},n.LifeCycleEvents={BEGIN:"BEGIN",PAUSE:"PAUSE",RESUME:"RESUME",CANCEL:"CANCEL",END:"END"},n.HandlerState={EXECUTING:"EXECUTING",PAUSED:"PAUSED",CANCELED:"CANCELED",ENDING:"ENDING",ENDED:"ENDED"},n.isValidHandlerState=function(e){return Boolean(e)&&this.HandlerState.hasOwnProperty(e)},n.executeCommandHandler=function(r){if(!r||!r.handler)throw new Error("parameters.handler has to be defined");r.args=t.computeArgs(r.handler,r.args),r.handler._private._cmdsManager.stackCommandExecutionRequest(function(t){if(!this)throw new Error("this (commandHandler) is undefined.");if(this.getState()!==n.HandlerState.ENDED)throw new Error("The command ended with the status Stated");if(!t||!t.notStarted)for(let n=0;n<this._private._appCB.length;n++)if(this._private._appCB[n]&&"function"==typeof this._private._appCB[n]){if(!t){const n=e.getErrorManager();t=e.createReturnObject(n.SUCCEEDED)}this._private._appCB[n](t)}}.bind(r.handler),r)},n}),define("DS/WAfrHandlers/mod_CommandHandler",["DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_CommandHandlerUtilities","DS/WAfrHandlers/mod_LeafHandler"],function(e,t,n){"use strict";const r=n.LeafHandler,a=n.StandaloneLeafHandlerState,i="COMMAND_HANDLER";e.registerLeafHandler(i,{executeFunc:t.executeCommandHandler});let o=Object.create(null);function s(e){return Boolean(e)&&o.LifeCycleEvents.hasOwnProperty(e)}o.CmdMode={EXCLUSIVE:t.CmdMode.EXCLUSIVE,NESTED:t.CmdMode.NESTED},o.RepeatMode={NEVER:t.RepeatMode.NEVER,STANDARD:t.RepeatMode.STANDARD,ALWAYS:t.RepeatMode.ALWAYS},o.LifeCycleEvents={BEGIN:t.LifeCycleEvents.BEGIN,PAUSE:t.LifeCycleEvents.PAUSE,RESUME:t.LifeCycleEvents.RESUME,CANCEL:t.LifeCycleEvents.CANCEL,END:t.LifeCycleEvents.END};class d extends a{constructor(e){super(e)}execute(e){const n=e?e.cb:void 0,r=e?e.args:void 0;return t.executeCommandHandler({handler:this._handler,cb:n,args:r})}}return o.CommandHandler=class extends r{constructor(t){if(super(t),!t)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters has to be defined");if(!t.module||"string"!=typeof t.module)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters.module has to be defined and to be a non empty string");if(!t.cmdsManager||"object"!=typeof t.cmdsManager)throw new Error("DS/WAfrHandlers/mod_CommandHandler.CommandHandler: parameters.cmdsManager has to be defined and to be Object of type DS/WAfrCommandsArchitecture/mod_CommandsManagerComponent");this._private||(this._private=Object.create(null)),this._private._type=e.enums.HandlerType[i],this._private._command=Object.create(null),this._private._command._module=t.module,this._private._command._instance=null,this._private._command._mode=t.cmdMode?t.cmdMode:o.CmdMode.EXCLUSIVE,this._private._repeatMode=t.repeatMode?t.repeatMode:o.RepeatMode.NEVER,this._private._cmdsManager=t.cmdsManager,this._private._useComputeServer=!!t.computeServer&&t.computeServer,this._private._cb=null,this._private._cbIfCommandNotStarted=null,this._private._handlerState=new d(this)}makeStandalone(){if(this._private._handlerState instanceof d)throw new Error("Call makeStandalone method on an CommandHandler which is already a standalone item");this._private._handlerState=new d(this)}execute(e){super.execute(e)}getMode(){return this._private._command._mode}setMode(e){if("string"!=typeof e&&"number"!=typeof e||!t.CmdMode.hasOwnProperty(e)&&(e<0||e>t.CmdMode.NESTED))throw new Error("CommandHandler.setMode : command mode value illegal. The command mode must be defined on mod_CommandHandler.CmdMode");if(this._private._command._instance)throw new Error("CommandHandler.setMode : command mode cannot be changed durring command execution");this._private._command._mode=e}getRepeatMode(){return this._private._repeatMode}setRepeatMode(e){if("number"!=typeof e||e<0||e>t.RepeatMode.ALWAYS)throw new Error("CommandHandler.setRepeatMode : command repeat mode value illegal. The command repeat mode must be defined on mod_CommandHandler.RepeatMode");this._private._repeatMode=e}getCSIdentifier(){return this._private._command._instance}isUsingComputeServer(){return this._private._useComputeServer}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}setStateAndSendEvent(e){if(!e||!e.state)throw new Error("parameters has to be defined with a non empty and valid state property (mod_CommandHandler.HandlerState) ");const n=e.state.toUpperCase();if(!t.isValidHandlerState(e.state))throw new Error("There is no state corresponding to the event "+e.state+" for a CommandHandler");if(this._private._command._state=t.HandlerState[n],e.event){const n=e.event.toUpperCase();if(s(n)){const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentifier has to be a non empty string.");a.publish({event:i+"/"+t.LifeCycleEvents[n],data:{repeated:e.repeated,canceled:e.canceled,notStarted:e.notStarted}})}}}getState(){return this._private._command._state}onLifeCycleEvent(e,t){if(!e||"string"!=typeof e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!s(n))throw new Error("The given identifier is not supported by an CommandHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentifier has to be a non empty string.");return a.subscribe({event:i+"/"+n},t)}removeLifeCycleEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CommandHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}},o}),define("DS/WAfrHandlers/private/private_ActionHandlerUtilities",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities"],function(e,t){"use strict";let n=Object.create(null);return n.ImplementationTypes={EXPORTED_FUNCTION:"EXPORTED_FUNCTION",COMPONENT_METHOD:"COMPONENT_METHOD"},n.executeActionHandler=function(r){const a=r.handler;let i=r.cb;if(!a)throw new Error("actionHandler has to be defined and cannot be null");var o=a.getHandlerComponent();if(!o)throw console.warn("NO HANDLER COMPONENT SET"),new Error;if(!o.getExecutionContext())throw console.warn("NO EXECUTION CONTEXT SET"),new Error;null!==i&&"function"==typeof i||(i=void 0);let s=null;(s=a._private._implementationType===n.ImplementationTypes.EXPORTED_FUNCTION?new Promise((t,n)=>{require([a._private._action._module],function(r){const i=e.getErrorManager();let o;if(r){const s=r[a._private._action._func];return s&&"function"==typeof s?t(s):(o=e.createReturnObject(i.FAILED,{description:`Unknown function ${a._private._action._func} in ${a._private._action._module}`}),n(o))}return o=e.createReturnObject(i.WRONG_VALUE,{description:"Module require return undefined"}),n(o)},function(){const t=e.getErrorManager(),r=e.createReturnObject(t.FAILED,{description:`Require failed (${a._private._action._module})`});return n(r)})}):new Promise((t,n)=>{if(!(o=a.getHandlerComponent()))throw new Error("There is no HandlerComponent related to this ActionHandler",a);const r=o.getExecutionContext().applicationContext,i=a._private._action._component,s=r.getComponent(i);if(!s){const t=e.getErrorManager();return n(e.createReturnObject(t.FAILED,{description:`Impossible to retrieve the component (${i})`}))}if(!s[a._private._action._func]){const t=e.getErrorManager();return n(e.createReturnObject(t.FAILED,{description:`No function ${a._private._action._func} exposed by ${i}`}))}return t(s[a._private._action._func].bind(s))})).then(function(s){let d=Object.create(null);if(d.cb=i,d.actionHandler=a,!(o=a.getHandlerComponent()))throw new Error("There is no HandlerComponent related to this ActionHandler",a);let l=Object.create(null);a._private._implementationType!==n.ImplementationTypes.COMPONENT_METHOD&&(l.executionContext=o.getExecutionContext().applicationContext),l.args=t.computeArgs(a,r.args);const h=o.getEventChannel();if(!h)throw new Error("Retrieved eventChannel is undefined");const c=a.getId();if(!c)throw new Error("handlerIdentfier has to be a non empty string.");h.publish({event:c+"/BEGIN"});const p=function(t){if(!this.actionHandler)throw new Error("this.action is undefined. A problem occurred when calling this function.");const n=this.actionHandler,r=n.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this ActionHandler",n);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=n.getId();if(!i)throw new Error("handlerIdentfier has to be a non empty string.");if(a.publish({event:i+"/END"}),!t){const n=e.getErrorManager();t=e.createReturnObject(n.SUCCEEDED)}if(this.cb&&"function"==typeof this.cb)this.cb(t);else if(t&&!e.hasSucceeded(t))throw t.getError()}.bind(d);a._private._implementationType===n.ImplementationTypes.EXPORTED_FUNCTION?s(p,l):s(l).then(p).catch(p)},function(t){if(t)if(i)i(t);else if(!e.hasSucceeded(t))throw t.getError()})},n}),define("DS/WAfrHandlers/mod_ActionHandler",["DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_ActionHandlerUtilities","DS/WAfrHandlers/mod_LeafHandler","DS/WAfrHandlers/mod_HandlerComponent"],function(e,t,n){"use strict";let r=Object.create(null);const a=n.LeafHandler,i=n.StandaloneLeafHandlerState,o="ACTION_HANDLER";e.registerLeafHandler(o,{executeFunc:t.executeActionHandler}),r.LifeCycleEvents={BEGIN:"BEGIN",END:"END"},r.ImplementationTypes=t.ImplementationTypes;class s extends i{constructor(e){super(e)}execute(e){const n=e?e.cb:void 0,r=e?e.args:void 0;return t.executeActionHandler({handler:this._handler,cb:n,args:r})}}return r.ActionHandler=class extends a{constructor(t){if(super(t),this._private||(this._private=Object.create(null)),!t)throw new Error("parameters has to be defined");if(this._private._type=e.enums.HandlerType[o],this._private._action=Object.create(null),this._private._implementationType=r.ImplementationTypes.EXPORTED_FUNCTION,void 0!==t.implementationType){if(n=t.implementationType,!Boolean(n)||!r.ImplementationTypes.hasOwnProperty(n))throw new Error(`parameters.implementationType value is not a valid one. (${t.implementationType})`);this._private._implementationType=t.implementationType}var n;if(this._private._implementationType===r.ImplementationTypes.EXPORTED_FUNCTION){if(!t.module||"string"!=typeof t.module)throw new Error('parameters.module has to be defined and to be a non empty string in case of "EXPORTED_FUNCTION"');this._private._action._module=t.module}else{if(!t.component||"string"!=typeof t.component)throw new Error('parameters.component has to be defined and to be a non empty string in case of "COMPONENT_METHOD"');this._private._action._component=t.component}if(!t.func||"string"!=typeof t.func)throw new Error("parameters.func has to be defined and to be a non empty string");this._private._action._func=t.func,this._private._handlerState=new s(this)}makeStandalone(){if(this._private._handlerState instanceof s)throw new Error("Call makeStandalone method on an ActionHandler which is already a standalone item");this._private._handlerState=new s(this)}execute(e){super.execute(e)}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}onLifeCycleEvent(e,t){if(!e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!function(e){return Boolean(e)&&r.LifeCycleEvents.hasOwnProperty(e)}(n))throw new Error("The given identifier is not supported by an ActionHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const a=this.getHandlerComponent();if(!a)throw new Error("There is no HandlerComponent related to this ActionHandler",this);const i=a.getEventChannel();if(!i)throw new Error("Retrieved eventChannel is undefined");const o=this.getId();if(!o)throw new Error("handlerIdentfier has to be a non empty string.");return i.subscribe({event:o+"/"+n},t)}removeLifeCycleEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this ActionHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentfier has to be a non empty string.");return n.unsubscribe(e)}},r}),define("DS/WAfrHandlers/mod_CheckHandler",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/mod_Handler","DS/WAfrHandlers/mod_ActionHandler","DS/WAfrHandlers/mod_CommandHandler"],function(e,t,n,r,a,i){"use strict";const o=r.Handler,s=a.ActionHandler,d=i.CommandHandler;let l=Object.create(null);function h(e,t){let n=!1;return e.beingInitialized()?n=!0:(t===e._private._check&&!e._private._isChecked||t===e._private._uncheck&&e._private._isChecked)&&(n=!0),n}function c(e){let t=!1;var n=!0;return(e._private._check&&!e._private._check.isAvailable()||e._private._uncheck&&!e._private._uncheck.isAvailable())&&(n=!1),e.isAvailable()!==n&&(e._private._currentAvailability=n,t=!0),t}l.StateEvents={CHECK:"CHECK",UNCHECK:"UNCHECK"};class p{constructor(e,t){if(!e||!t)throw new Error("manageable and handlerManager have to be define");this._checkHandler=e,this._manager=t}handleExecute(t){if(!t)throw new Error("Wrong parameters");{const n=t.cb,r=t.manageable,a=t.args;if(r!==this._checkHandler._private._check&&r!==this._checkHandler._private._uncheck)throw new Error("Internal error. The manageable calling handle is not managed by this manager.");h(this._checkHandler,r)?this._manager.handleExecute({cb:t.cb,manageable:this._checkHandler,action:!this._checkHandler._private._isChecked,args:a}):n&&"function"==typeof n&&setTimeout(function(){const t=e.getErrorManager();n(e.createReturnObject(t.SUCCEEDED))},0)}}handleOnAvailabilityChanged(e){const t=this._checkHandler,n=this._manager;c(t)&&(e.args.newValue=t.isAvailable(),e.manageable=t,n.handleOnAvailabilityChanged(e))}isExecutable(){return this.handleIsExecutable()}handleIsExecutable(){return this._manager.handleIsExecutable({manageable:this._checkHandler})}setState(){throw new Error("You can not directly change the state of a CheckHandler which is managed")}setHandlerComponent(){return console.warn("Impossible to set a HandlerComponent to a CheckHandler which is managed."),!1}getHandlerComponent(){return this._manager.getHandlerComponent()}disable(){throw new Error("Impossible to disable a Managed Handler")}enable(){throw new Error("Impossible to enable a Managed Handler")}onIsEnabledChangeEvent(){throw new Error("Impossible to subscribe to isEnabledChangeEvent from a Managed Handler")}removeIsEnabledChangeEventSubscription(){throw new Error("Impossible to unsubscribe to isEnabledChangeEvent from a Managed Handler")}}class m{constructor(e){if(!e)throw new Error("checkHandler has to be defined");this._checkHandler=e}handleExecute(t){if(!t)throw new Error("Wrong parameters");{const r=t.cb,a=t.manageable,i=t.args;if(a!==this._checkHandler._private._check&&a!==this._checkHandler._private._uncheck)throw new Error("Internal error. The manageable calling handleExecute is not managed by this manager.");h(this._checkHandler,a)?n.executeCheckHandler(this._checkHandler,{cb:r,action:!this._checkHandler._private._isChecked,args:i}):r&&"function"==typeof r&&setTimeout(function(){const t=e.getErrorManager();r(e.createReturnObject(t.SUCCEEDED))},0)}}setState(t){const n=t.state,r=t.cb,a=t.args;if(n!==this._checkHandler._private._isChecked){let e;e=this._checkHandler._private._isChecked?this._checkHandler._private._uncheck:this._checkHandler._private._check,this.handleExecute({cb:r,manageable:e,args:a})}else setTimeout(function(){const t=e.getErrorManager();r(e.createReturnObject(t.SUCCEEDED))},0)}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be defined");return this._checkHandler._private._handlerComponent=e,!0}getHandlerComponent(){return this._checkHandler._private._handlerComponent}handleOnAvailabilityChanged(){const e=this._checkHandler;c(e)&&t.publishHandlerAvailability(e)}isExecutable(){return this.handleIsExecutable()}handleIsExecutable(){return o.prototype.isExecutable.call(this._checkHandler)}disable(...e){return o.prototype.disable.call(this._checkHandler,...e)}enable(...e){return o.prototype.enable.call(this._checkHandler,...e)}onIsEnabledChangeEvent(...e){return o.prototype.onIsEnabledChangeEvent.call(this._checkHandler,...e)}removeIsEnabledChangeEventSubscription(...e){return o.prototype.removeIsEnabledChangeEventSubscription.call(this._checkHandler,...e)}}return l.CheckHandler=class extends o{constructor(e){if(super(e),this._private._check=null,this._private._uncheck=null,!e||!e.id)throw new Error("Wrong parameters");this._private._id=e.id,this._private._isChecked=!1,this._private._handlerState=new m(this)}makeStandalone(){if(this._private._handlerState instanceof m)throw new Error("Call makeStandalone method on an CheckHandler which is already a standalone item");this._private._handlerState=new m(this)}makeManaged(e){if(this._private._handlerState instanceof p)throw new Error("Call makeManaged method on an CheckHandler which is already managed");this._private._handlerState=new p(this,e),delete this._private._handlerComponent}validateElement(e){return e instanceof s||e instanceof d}addElement(e,t){let n=!1;if(!e||!t||!t.state||"check"!==t.state&&"uncheck"!==t.state)throw new Error("Imcompatible parameters");const r="_"+t.state;return this.validateElement(e)&&!this._private[r]&&(this._private[r]=e,e.makeManaged(this),this._private._handlerState.handleOnAvailabilityChanged({manageable:this,args:{newValue:e.isAvailable()}}),n=!0),n}handleExecute(e){return this._private._handlerState.handleExecute(e)}isExecutable(){return this._private._handlerState.isExecutable()}handleIsExecutable(e){if(!e||!e.manageable)throw new Error("Wrong parameters");if(e.manageable!==this._private._check&&e.manageable!==this._private._uncheck)throw new Error("The given manageable is not managed by this CheckHandler");return this._private._handlerState.handleIsExecutable()}getCheckHandler(){return this._private._check}getUncheckHandler(){return this._private._uncheck}setState(t){if(this.isExecutable())this._private._handlerState.setState(t);else{const n=e.getErrorManager(),r=e.createReturnObject(n.NOT_EXECUTABLE,{description:"This CheckHandler is not executable"});if(!t||!t.cb)throw r.getError();setTimeout(function(){t.cb(r)},0)}}getState(){return this._private._isChecked}setHandlerComponent(e){return this._private._handlerState.setHandlerComponent(e)}getHandlerComponent(){return this._private._handlerState.getHandlerComponent()}handleOnAvailabilityChanged(e){if(!e||!e.manageable||!e.args||void 0===e.args.newValue)throw new Error("handleExecute was called using wrong parameters",e);return this._private._handlerState.handleOnAvailabilityChanged(e)}onStateEvent(e,t){if(!e)throw new Error("identifier has to be a non empty string");const n=e.toUpperCase();if(!function(e){return Boolean(e)&&l.StateEvents.hasOwnProperty(e)}(n))throw new Error("The given identifier is not supported by a CheckHandler",e);if(!t||"function"!=typeof t)throw new Error("cb has to be a function",t);const r=this.getHandlerComponent();if(!r)throw new Error("There is no HandlerComponent related to this CheckHandler",this);const a=r.getEventChannel();if(!a)throw new Error("Retrieved eventChannel is undefined");const i=this.getId();if(!i)throw new Error("handlerIdentfier has to be a non empty string.");return a.subscribe({event:i+"/"+n},t)}removeStateEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this CheckHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}disable(){return this._private._handlerState.disable()}enable(){return this._private._handlerState.enable()}onIsEnabledChangeEvent(e){return this._private._handlerState.onIsEnabledChangeEvent(e)}removeIsEnabledChangeEventSubscription(e){return this._private._handlerState.removeIsEnabledChangeEventSubscription(e)}destroy(){super.destroy(),this._private._check&&this._private._check.destroy(),this._private._uncheck&&this._private._uncheck.destroy()}},l}),define("DS/WAfrHandlers/mod_RadioHandler",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_Utilities","DS/WAfrHandlers/mod_Handler","DS/WAfrHandlers/mod_CheckHandler"],function(e,t,n,r){"use strict";const a=n.Handler,i=r.CheckHandler;let o=Object.create(null);o.ItemStateEvents={SELECT:"SELECT",UNSELECT:"UNSELECT"};return o.RadioHandler=class extends a{constructor(e){super(e),this._private._checkedElement=null,this._private._elements=[]}validateElement(e){return e instanceof i}addElement(e){let t=!1;if(!e||e===this||!e.makeManaged||"function"!=typeof e.makeManaged)throw new Error;if(!this.validateElement(e))throw new Error("elt is not a valide element to add to a RadioHandler");return this._private._elements.push(e),e.makeManaged(this),this.handleOnAvailabilityChanged({manageable:this,args:{newValue:e.isAvailable()}}),t=!0}getElements(){if(!this._private||!this._private._elements||!Array.isArray(this._private._elements))throw new Error("Internal error");return this._private._elements}getElementById(e){const t=this._private._elements.length;let n=0,r=!1,a=null;for(;!r&&n<t;){const t=this._private._elements[n];t.getId()===e&&(r=!0,a=t),++n}return a}getSelectedItem(){let e=null;const t=this.getSelectedItemId();return t&&(e=this.getElementById(t)),e}setRadioItemState(t){const n=t.radioHdlrItemId,r=t.state,a=t.cb,i=t.args,o=e.getErrorManager();let s,d,l=0;const h=this._private._elements.length;for(l=0;l<h;++l)this._private._elements[l].getId()===n&&(d=this._private._elements[l]);if(d)if(this.isExecutable()){let e=Object.create(null);e.cb=a,e.manageable=d,e.action=r,e.args=i,this.handleExecute(e)}else{if(s=e.createReturnObject(o.NOT_EXECUTABLE,{description:"This RadioHandler is not executable"}),!t||!t.cb)throw s;setTimeout(function(){a(s)},0)}else{if(s=e.createReturnObject(o.FAILED,{description:"Unknown item: "+n}),!a)throw s.getError();setTimeout(function(){a(s)},0)}}getRadioItemState(e){if(!e||"string"!=typeof e)throw new Error("itemId has to be a non empty string");let t;const n=this._private._elements.length;for(let r=0;r<n;++r)this._private._elements[r].getId()===e&&(t=this._private._elements[r].getState());if(void 0===t)throw new Error("This item does not belong to this RadioHandler");return t}getSelectedItemId(){let e;return this._private._checkedElement&&(e=this._private._checkedElement.getId()),e}setHandlerComponent(e){if(void 0===e)throw new Error("component has to be define");return this._private._handlerComponent=e,!0}getHandlerComponent(){return this._private._handlerComponent}handleOnAvailabilityChanged(e){if(!e||!e.manageable||!e.args||void 0===e.args.newValue)throw new Error("handleExecute was called using wrong parameters",e);(function(e){for(var t=!1,n=!0,r=e._private._elements,a=r.length,i=0;i<a&&n;)n=r[i].isAvailable(),++i;return n!==e.isAvailable()&&(e._private._currentAvailability=n,t=!0),t})(this)&&t.publishHandlerAvailability(this)}handleIsExecutable(e){if(!e||!e.manageable)throw new Error("Wrong parameters");return this.isExecutable()}onItemStateEvent(e,t,n){if(!e)throw new Error("identifier has to be a non empty string");if(!t)throw new Error("itemIdentifier has to be a non empty string");const r=e.toUpperCase();if(!function(e){return Boolean(e)&&o.ItemStateEvents.hasOwnProperty(e)}(r))throw new Error("The given identifier is not supported by an RadioHandler",e);if(!n||"function"!=typeof n)throw new Error("cb has to be a function",n);const a=this.getHandlerComponent();if(!a)throw new Error("There is no HandlerComponent related to this RadioHandler",this);const i=a.getEventChannel();if(!i)throw new Error("Retrieved eventChannel is undefined");const s=this.getId();if(!s)throw new Error("handlerIdentfier has to be a non empty string.");return i.subscribe({event:s+"/"+t+"/"+r},n)}removeItemStateEventSubscription(e){if(void 0===e)throw new Error("token has to be defined");const t=this.getHandlerComponent();if(!t)throw new Error("There is no HandlerComponent related to this RadioHandler",this);const n=t.getEventChannel();if(!n)throw new Error("Retrieved eventChannel is undefined");if(!this.getId())throw new Error("handlerIdentifier has to be a non empty string.");return n.unsubscribe(e)}destroy(){super.destroy();const e=this._private._elements,t=this._private._elements.length;for(var n=0;n<t;++n)e[n].destroy()}},o}),define("DS/WAfrHandlers/mod_RadioHandlerZERO",["DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/private/private_RadioHandlerUtilities","DS/WAfrHandlers/mod_RadioHandler"],function(e,t,n){"use strict";const r=n.RadioHandler;let a=Object.create(null);return a.RadioHandlerZERO=class extends r{constructor(e){super(e)}isUnselectAuthorized(){return!0}handleExecute(n){if(!n||!n.manageable)throw new Error("Wrong parameters");{const r=n.manageable;if(!t.isManagedByRadioHandler(r,this))throw new Error("Internal error. The manageable calling handleExecute is not managed by this RadioHandler.");if(n.action)if(this._private._checkedElement){if(this._private._checkedElement!==n.manageable){let r=Object.create(null);r.cb=n.cb,r.manager=this,r.manageable=n.manageable,r.args=n.args,t.fireEvent(this,this._private._checkedElement.getId(),!1),e.executeCheckHandler(this._private._checkedElement,{cb:t.checkOnUncheck.bind(r),action:!1}),this._private._checkedElement=n.manageable}}else t.fireEvent(this,n.manageable.getId(),n.action),e.executeCheckHandler(n.manageable,{cb:n.cb,action:n.action,args:n.args}),this._private._checkedElement=n.manageable;else n.manageable.getState()!==n.action&&(t.fireEvent(this,n.manageable.getId(),n.action),e.executeCheckHandler(n.manageable,{cb:n.cb,action:n.action,args:n.args}),this._private._checkedElement=null)}}},a}),define("DS/WAfrHandlers/mod_RadioHandlerONE",["DS/CoreUtilities/ErrorManagement","DS/WAfrHandlers/private/private_CheckHandlerUtilities","DS/WAfrHandlers/private/private_RadioHandlerUtilities","DS/WAfrHandlers/mod_RadioHandler"],function(e,t,n,r){"use strict";const a=r.RadioHandler;let i=Object.create(null);return i.RadioHandlerONE=class extends a{constructor(e){super(e)}isUnselectAuthorized(){return!1}handleExecute(r){if(!r||!r.manageable)throw new Error("Wrong parameters");{const a=r.manageable;if(!n.isManagedByRadioHandler(a,this))throw new Error("Internal error. The manageable calling handleExecute is not managed by this RadioHandler.");if(!r.action){const t=e.getErrorManager(),n=e.createReturnObject(t.FAILED,{description:"It is impossible to uncheck the checked element for RadioHandler of type ONE"});if(!r.cb||"function"!=typeof r.cb)throw n.getError();setTimeout(function(){r.cb(n)},0)}if(this._private._checkedElement)if(r.manageable!==this._private._checkedElement){let e=Object.create(null);e.cb=r.cb,e.manageable=r.manageable,e.manager=this,e.args=r.args,n.fireEvent(this,this._private._checkedElement.getId(),!1),t.executeCheckHandler(this._private._checkedElement,{cb:n.checkOnUncheck.bind(e),action:!1}),this._private._checkedElement=r.manageable}else this.beingInitialized()&&(n.fireEvent(this,r.manageable.getId(),!0),t.executeCheckHandler(r.manageable,{cb:r.cb,action:!0,args:r.args}),this._private._checkedElement=r.manageable);else n.fireEvent(this,r.manageable.getId(),!0),t.executeCheckHandler(r.manageable,{cb:r.cb,action:!0,args:r.args}),this._private._checkedElement=r.manageable}}},i}),define("DS/WAfrHandlers/mod_HandlerInterpreter",["DS/WAfrHandlers/mod_ActionHandler","DS/WAfrHandlers/mod_CommandHandler","DS/WAfrHandlers/mod_CheckHandler","DS/WAfrHandlers/mod_RadioHandlerZERO","DS/WAfrHandlers/mod_RadioHandlerONE","DS/WAfrHandlers/mod_HandlerComponent","DS/WAfrAvailabilityModes/mod_AvailabilityModesComponent"],function(e,t,n,r,a,i,o){"use strict";var s=e.ActionHandler,d=t.CommandHandler,l=n.CheckHandler,h=r.RadioHandlerZERO,c=a.RadioHandlerONE;const p={AC_NOT_FOUND:"AC_NOT_FOUND"};var m={};function u(e){return{id:e.identifier,i18n:e.internationalization,icon:e.icon,availabilityMode:e.availability,accelerator:e.accelerator}}function _(e){return{id:e.identifier,i18n:e.internationalization,icon:e.icon,availabilityMode:e.availability,accelerator:e.accelerator}}function f(n,r,a){var i,o=null;if(r.declerr&&Array.isArray(r.declerr))for(let e=0,t=r.declerr,n=t.length;e<n;++e){let n=t[e];if(n.id===p.AC_NOT_FOUND)throw new Error(`[HandlerInterpreter] ${n.args.itemName} was not found.`)}if("Action"===r.type)i=function(t,n){var r=n(t);return r.implementationType=t.code.type,void 0===r.implementationType||r.implementationType===e.ImplementationTypes.EXPORTED_FUNCTION?r.module=t.code.module:r.component=t.code.component,r.func=t.code.func,r.args=t.argument,r}(r,a),o=new s(i);else{if("Command"!==r.type)throw new Error("Unknown handler type",r.type);i=function(e,n,r){var a=r(n);a.module=n.code.module;var i=e.getComponent("AFR_CommandsManager");return a.cmdsManager=i,a.cmdMode=t.CmdMode[n.mode],a.repeatMode=t.RepeatMode[n.repeatability],a.args=n.argument,a.computeServer=n.computeServer,a}(n,r,a),o=new d(i)}return i&&i.args&&o.setArgs(i.args),o}function E(e,t){let n=o.DEFAULT_COMPONENT_NAME;return t&&t[o.DEFAULT_COMPONENT_NAME]&&(n=t[o.DEFAULT_COMPONENT_NAME]),e.getComponent(n)}class b{constructor(){this._initializationValues=[],this._handler=[],this._chkHandler=[],this._radioHandler=[]}interpretLeafHandler(e,t){if(!t)return;const n=t.length;let r,a;for(let i=0;i<n;++i)a=f(e,r=t[i],u),this._handler.push(a),this.addToAvailabilityModesSubscribers(a)}interpretCheckHandler(e,t){if(!t)return;const n=t.length;let r,a,i,o,s;for(let d=0;d<n;++d)if(r=t[d],a=new l({id:r.identifier}),r.accelerator&&(r.check.accelerator=r.accelerator,r.uncheck.accelerator=r.accelerator),i=f(e,r.check,_),a.addElement(i,{state:"check"}),this.addToAvailabilityModesSubscribers(i),o=f(e,r.uncheck,_),a.addElement(o,{state:"uncheck"}),this.addToAvailabilityModesSubscribers(o),this._chkHandler.push(a),void 0!==r.defaultState&&"string"==typeof r.defaultState&&(r.defaultState="true"===r.defaultState),void 0!==r.defaultState&&r.defaultState){let e=!1;(r.check&&r.check.argument&&r.check.argument.isA2X||r.uncheck&&r.uncheck.argument&&r.uncheck.argument.isA2X)&&(e=!0),e||(s={type:"CheckHandler",id:r.identifier,state:!0},this._initializationValues.push(s))}}interpretRadioHandler(e,t){if(!t)return;const n=t.items;if(!Array.isArray(n))return;if(0===n.length)return;const r=n.length;let a,i,o,s,d=0;for(d=0;d<r;++d){if(a={id:(o=n[d]).identifier},"ONE"===o.radioType)i=new c(a);else{if("ZERO"!==o.radioType)throw new Error;i=new h(a)}let t,r,p,m,u=0,E=o.items,b=E.length;for(u=0;u<b;++u)r=E[u],t=new l({id:r.identifier}),r.accelerator&&(r.check.accelerator=r.accelerator,r.uncheck.accelerator=r.accelerator),r.check&&(p=f(e,r.check,_),t.addElement(p,{state:"check"}),this.addToAvailabilityModesSubscribers(p)),r.uncheck&&(m=f(e,r.uncheck,_),t.addElement(m,{state:"uncheck"}),this.addToAvailabilityModesSubscribers(m)),i.addElement(t);this._radioHandler.push(i),o.default&&(s={type:"RadioHandler",id:o.default,radioId:o.identifier,state:!0},this._initializationValues.push(s))}}interpret(e,t,n){if(!e||!t)throw new Error("Missing parameters");var r=i.DEFAULT_COMPONENT_NAME;if(n&&n.componentId?r=n.componentId:console.warn("Caution! You are using the default component name. This is not recommended"),this._executionContext=t,this._handlerComponent=t.getComponent(r),!this._handlerComponent)throw new Error("HandlerComponent not found");if(e){if(e.handlers){if(e.handlers&&e.handlers.default){var a=e.handlers.default;this.interpretLeafHandler(t,a)}if(e.handlers&&e.handlers.check){var o=e.handlers.check;this.interpretCheckHandler(t,o)}e.handlers.defaultCommand&&(this._defaultCommandIdentifier=e.handlers.defaultCommand)}if(e.radioGroup){var s=e.radioGroup;this.interpretRadioHandler(t,s)}}return Promise.resolve()}commitHandlers(){let e=this._handler.length,t=0,n=null;for(t=0;t<e;++t)n=this._handler[t],this._handlerComponent.addHandler(n);for(this._handler.splice(0,e),delete this._handler,e=this._chkHandler.length,t=0;t<e;++t)n=this._chkHandler[t],this._handlerComponent.addCheckHandler(n);for(this._chkHandler.splice(0,e),delete this._chkHandler,e=this._radioHandler.length,t=0;t<e;++t)n=this._radioHandler[t],this._handlerComponent.addRadioHandler(n);this._radioHandler.splice(0,e),delete this._radioHandler}commit(e){this.commitHandlers(),this._handlerComponent.setInitializationData(this._initializationValues),this._defaultCommandIdentifier&&this._handlerComponent.setInitializationDefaultCommand(this._defaultCommandIdentifier);let t=Promise.resolve();const n=E(this._executionContext,e);return n&&(this._handlerComponent.setAvailabilityModesComponent(n),this._availabilityModesSubscribers&&this._availabilityModesSubscribers.length>0&&(t=this.commitAvailabilityModesSubscribers())),t.then(()=>{delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers})}commitEnrich(e){this.commitHandlers(),this._handlerComponent.addInitializationData(this._initializationValues);let t=Promise.resolve();return E(this._executionContext,e)&&(t=this.commitAvailabilityModesSubscribers()),t.then(()=>{delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers})}enrich(e,t,n){if(!e||!t)throw new Error("Missing parameters");if(void 0!==this._handler||void 0!==this._chkHandler||void 0!==this._radioHandler||void 0!==this._executionContext||void 0!==this._handlerComponent||void 0!==this._initializationValues||void 0!==this._availabilityModesSubscribers)throw new Error('Enrich was called whereas internal variables are still defined. Possible cause: enrich was called before an "interpret"-"commit" sequence.');return this._handler=[],this._chkHandler=[],this._radioHandler=[],this._initializationValues=[],this.interpret(e,t).then(this.commitEnrich.bind(this,n)).then(()=>{delete this._handler,delete this._chkHandler,delete this._radioHandler,delete this._handlerComponent,delete this._executionContext,delete this._initializationValues,delete this._availabilityModesSubscribers})}addToAvailabilityModesSubscribers(e){if(!e||!this._executionContext)throw new Error("element and this._executionContext has to be defined");this._availabilityModesSubscribers||(this._availabilityModesSubscribers=[]),this._availabilityModesSubscribers.push(e)}commitAvailabilityModesSubscribers(){let e=[],t=0,n=0,r=null;if(this._availabilityModesSubscribers)for(n=this._availabilityModesSubscribers.length,t=0;t<n;++t)r=this._availabilityModesSubscribers[t],e.push(r.initAvailabilityModesSubscription());return Promise.all(e)}}var v=Object.create(null);return v.generateInterpreter=function(e){var t=b;return void 0!==m[e]&&(t=m[e]),new t},v});