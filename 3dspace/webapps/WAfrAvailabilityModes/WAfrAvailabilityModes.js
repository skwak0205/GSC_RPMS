define("DS/WAfrAvailabilityModes/mod_AvailabilityModesComponent",["text!DS/WAfrAvailabilityModes/assets/afr/availabilitymodes/AFR_DEFAULT_AVAILABILITY_MODES.json"],function(e){"use strict";const t="DEACTIVATED",i=JSON.parse(e);let o=Object.create(null);o.DEFAULT_COMPONENT_NAME="AFR_AvailabilityModesComponent";const r="[AVAILABILITY_MODE]";let n=!1;o.setDebugMode=function(e){if(void 0!==e&&"boolean"==typeof e&&n!==e){let t;(n=e)?((t=new Error("Debug mode activated - DO NOT USE IN PRODUCTION")).name="Warning",console.warn(t.stack)):((t=new Error("Debug mode deactivated - DO NOT USE IN PRODUCTION")).name="Warning",console.warn(t.stack))}};const s="[DS/WAfrAvailabilityModes/mod_AvailabilityModesComponent]",a=s+"_b_",l=s+"_e_",p=s+"_m_";let d=!1;function u(e,t){if(null==e||null==t)throw new Error("probesId and identifier has to be defined");d&&window.performance.mark(a+t+e)}function v(e,t){if(null==e||null==t)throw new Error("probesId and identifier has to be defined");if(d){window.performance.mark(l+t+e);const s=p+t+e;if(window.performance.measure(s,a+t+e,l+t+e),n){var i=window.performance.getEntriesByName(s),o=i[i.length-1];console.log(r+" [PROBES] "+t,o)}}}function _(e){for(let t in e)e.hasOwnProperty(t)&&delete e[t]}function c(){return Promise.resolve()}function b(e,t){let i=Promise.resolve();const o=e._private._defaultModesValues,n=e._private._currentModes,s=t.getAvailabilityModesInfo();if(!s||void 0===s.currentAvailability)throw new Error("Cannot retrieve availabilityModes information for this client",t);let a=null,l=null;a=s.modes||{},l=s.currentAvailability;const p=function(e,t){let i=JSON.parse(JSON.stringify(e)),o=JSON.parse(JSON.stringify(t));for(let e in o)if(o.hasOwnProperty(e)){if(!i[e])throw new Error(r+" Unsupported availability mode ("+e+")");let t=i[e].values,n=o[e].values;for(let e in n)n.hasOwnProperty(e)&&n[e]!==t[e]&&(t[e]=n[e])}return i}(o,a);let d=null,u=null,v=!1;for(d in n)if(n.hasOwnProperty(d)&&(u=n[d],!1===p[d].values[u.selected])){v=!0,l&&(i=Promise.resolve().then(t.onAvailabilityChanged.bind(t,!1,{mode:u,value:u.selected})));break}return v||l||(i=Promise.resolve().then(t.onAvailabilityChanged.bind(t,!0))),i}o.setProbeMode=function(e){if(void 0!==e&&"boolean"==typeof e&&d!==e){let t;(d=e)?((t=new Error("Probe mode activated - DO NOT USE IN PRODUCTION")).name="Warning",console.warn(t.stack)):((t=new Error("Probe mode deactivated - DO NOT USE IN PRODUCTION")).name="Warning",console.warn(t.stack))}};return o.AvailabilityModesComponent=class{constructor(){this._private=Object.create(null),this._private._probesId=(new Date).valueOf()}initialize(){u(this._private._probesId,"AvailabilityModesComponent.prototype.initialize"),this._private._currentModes={},this._private._clients={},this._private._nextClientUid=0;const e=this;return this._private._defaultModesValues?(v(this._private._probesId,"AvailabilityModesComponent.prototype.initialize"),Promise.resolve()):Promise.resolve(i).then(function(t){return e._private._defaultModesValues=t,v(e._private._probesId,"AvailabilityModesComponent.prototype.initialize"),Promise.resolve()},function(e){throw e})}clean(){if(u(this._private._probesId,"AvailabilityModesComponent.prototype.clean"),!this._private||!this._private._clients||!this._private._currentModes)throw new Error("AvailabilityModeComponent state is corrupted. You may have call clean before initialize");return _(this._private._currentModes),_(this._private._clients),this._private._nextClientUid=0,v(this._private._probesId,"AvailabilityModesComponent.prototype.clean"),Promise.resolve()}destroy(){if(u(this._private._probesId,"AvailabilityModesComponent.prototype.destroy"),!this._private||!this._private._clients||!this._private._currentModes)throw new Error("AvailabilityModeComponent state is corrupted. You may have call clean before initialize");return delete this._private._currentModes,delete this._private._clients,delete this._private._nextClientUid,delete this._private._defaultModesValues,v(this._private._probesId,"AvailabilityModesComponent.prototype.destroy"),Promise.resolve()}canBeParallelized(){return!1}getExposedComponentCtor(){function e(){}return u(this._private._probesId,"AvailabilityModesComponent.prototype.getExposedComponentCtor"),e.prototype.initialize=c,e.prototype.clean=c,e.prototype.destroy=c,e.prototype.subscribe=this.subscribe.bind(this),e.prototype.unsubscribe=this.unsubscribe.bind(this),e.prototype.publish=this.publish.bind(this),e.prototype.canBeParallelized=this.canBeParallelized.bind(this),e.prototype.getCurrentModeValue=this.getCurrentModeValue.bind(this),v(this._private._probesId,"AvailabilityModesComponent.prototype.getExposedComponentCtor"),e}subscribe(e,t){u(this._private._probesId,"AvailabilityModesComponent.prototype.subscribe"),t||console.warn("[DEPRECATED] Usage of AvailabilityModesComponent.prototype.subscribe must not be used in a synchronous way. Please refer to its documentation in order to migrate your code.");let i=Promise.resolve();!function(e){if(!e||!e.getAvailabilityModesInfo||"function"!=typeof e.getAvailabilityModesInfo||!e.onAvailabilityChanged||"function"!=typeof e.onAvailabilityChanged)throw new Error("element is not defined or it does not implement required methods")}(e);const o=this._private._clients;for(var r in o)if(o.hasOwnProperty(r)&&o[r]===e){let i=new Error("Trying to subscribe an element which is already registered",e);if(t)return Promise.reject(i);throw i}if(o.hasOwnProperty(this._private._nextClientUid))throw new Error("Internal Error");var n;return o[this._private._nextClientUid]=e,++this._private._nextClientUid,n=this._private._nextClientUid-1,i=b(this,e).then(function(){return n}),v(this._private._probesId,"AvailabilityModesComponent.prototype.subscribe"),t?i:this._private._nextClientUid-1}unsubscribe(e){u(this._private._probesId,"AvailabilityModesComponent.prototype.unsubscribe");const t=this._private._clients;if(!t.hasOwnProperty(e))throw new Error("No element registered with this token",e);delete t[e],v(this._private._probesId,"AvailabilityModesComponent.prototype.unsubscribe")}publish(e){n&&console.log(r+" [MODES_ARRAY] AvailabilityModesComponent.prototype.publish - Before computation",this._private._currentModes),u(this._private._probesId,"AvailabilityModesComponent.prototype.publish");let i=e.mode,o=e.data,s=e.value;if(!i||void 0===s)throw new Error("settings.mode, settings.value has to be defined");if(!function(e,i,o){let r=!1;const n=e._private._defaultModesValues;return n.hasOwnProperty(i)&&(n[i].values.hasOwnProperty(o)||o===t)&&(r=!0),r}(this,i,s))throw new Error("INVALID MODE OR VALUE",i,s);let a=!1;this._private._currentModes.hasOwnProperty(i)?this._private._currentModes[i].value!==s&&(s===t?delete this._private._currentModes[i]:this._private._currentModes[i]={selected:s,data:o},a=!0):s!==t&&(this._private._currentModes[i]={selected:s,data:o},a=!0);let l=Promise.resolve();return a&&(l=function(e){n&&console.log(r+" [AVAILABILITY_COMPUTATION] AvailabilityModesComponent~computeAvailabilityAndPublishAsync - Begin computation",e._private._clients),u(e._private._probesId,"AvailabilityModesComponent~computeAvailabilityAndPublishAsync");let t=[];const i=e._private._clients;for(let o in i)i.hasOwnProperty(o)&&t.push(b(e,i[o]));return v(e._private._probesId,"AvailabilityModesComponent~computeAvailabilityAndPublishAsync"),n&&console.log(r+" [AVAILABILITY_COMPUTATION] AvailabilityModesComponent~computeAvailabilityAndPublishAsync - End computation",e._private._clients),Promise.all(t)}(this)),n&&console.log(r+" [MODES_ARRAY] AvailabilityModesComponent.prototype.publish - After computation",this._private._currentModes),v(this._private._probesId,"AvailabilityModesComponent.prototype.publish"),l}getCurrentModeValue(e){let t="DEACTIVATED";return this._private._currentModes.hasOwnProperty(e)&&(t=this._private._currentModes[e].selected),t}},o.AvailabilityModesComponent.DEFAULT_COMPONENT_NAME=o.DEFAULT_COMPONENT_NAME,o});