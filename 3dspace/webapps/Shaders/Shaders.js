define("DS/Shaders/ESMBlurShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t,o,a,i={defines:{LEVEL:1},uniforms:{tDiffuse:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","float unpackDepth(sampler2D tex, vec2 uv){","   vec4 rgba_depth = texture2D(tex,uv);","   #ifdef USE_UINT_ESM","\t    float depth = unpackRGB( rgba_depth.xyz) * pow(10.0,rgba_depth.w*255.0);","\t    return depth;","   #else","       return rgba_depth.x;","   #endif","}","float unpackLerp(sampler2D shadowMap, vec2 coord) {","#ifdef USE_UINT_ESM","   vec2 fractCoord = fract(coord/invSize + 0.5);","   vec2 centroidUV = (coord/invSize - fractCoord) * invSize;","   float lb = unpackDepth(shadowMap, centroidUV);","   float lt = unpackDepth(shadowMap, centroidUV + vec2(0.0, invSize.y));","   float rb = unpackDepth(shadowMap, centroidUV + vec2(invSize.x, 0.0));","   float rt = unpackDepth(shadowMap, centroidUV + invSize);","   float a = mix(lb, lt, fractCoord.y);","   float b = mix(rb, rt, fractCoord.y);","   return mix(a, b, fractCoord.x);","#else","    return texture2D(shadowMap, coord).x;","#endif","}","vec4 packDepth(float depth){","   #ifdef USE_UINT_ESM","\tfloat exposant = ceil(log(depth)/log(10.0));","\tfloat normDepth = depth/pow(10.0,exposant);","\treturn vec4(packRGB(normDepth),exposant/255.0);","   #else","       return vec4(depth,0.0,0.0,1.0);","   #endif","}","void main() {","vec2 screenPos = vUv;","float result = 0.0;","float blurSize = invSize.y;","#if (LEVEL == 1)","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 1.2 * blurSize)) * 0.3125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y)) * 0.375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 1.2 * blurSize)) * 0.3125;","#endif","#if (LEVEL == 2)","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 1.285714285714 * blurSize)) * 0.328125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y)) * 0.3125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 1.285714285714 * blurSize)) * 0.328125;","#endif","#if (LEVEL == 3)","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 3.111111111111 * blurSize)) * 0.03515625;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 1.333333333333 * blurSize)) * 0.328125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y)) * 0.2734375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 1.333333333333 * blurSize)) * 0.328125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 3.111111111111 * blurSize)) * 0.03515625;","#endif","#if (LEVEL == 4)","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 3.181818181818 * blurSize)) * 0.0537109375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 1.363636363636 * blurSize)) * 0.322265625;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y)) * 0.24609375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 1.363636363636 * blurSize)) * 0.322265625;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 3.181818181818 * blurSize)) * 0.0537109375;","#endif","#if (LEVEL == 5)","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 5.076923076923 * blurSize)) * 0.003173828125;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 3.230769230769 * blurSize)) * 0.06982421875;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y - 1.384615384615 * blurSize)) * 0.314208984375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y)) * 0.2255859375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 1.384615384615 * blurSize)) * 0.314208984375;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 3.230769230769 * blurSize)) * 0.06982421875;","result += unpackLerp(tDiffuse, vec2(vUv.x, vUv.y + 5.076923076923 * blurSize)) * 0.003173828125;","#endif","gl_FragColor = packDepth(result);","}"].join("\n")};return{BlurH2:(t=2,o="tDiffuse"+(t||""),a={defines:{LEVEL:1},uniforms:{invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D "+o+";","varying vec2 vUv;","float unpackDepth(sampler2D tex, vec2 uv){","   vec4 rgba_depth = texture2D(tex,uv);","   #ifdef USE_UINT_ESM","\t    float depth = unpackRGB(rgba_depth.xyz) * pow(10.0,rgba_depth.w*255.0);","\t    return depth;","   #else","       return rgba_depth.x;","   #endif","}","float unpackLerp(sampler2D shadowMap, vec2 coord) {","#ifdef USE_UINT_ESM","   vec2 fractCoord = fract(coord/invSize + 0.5);","   vec2 centroidUV = (coord/invSize - fractCoord) * invSize;","   float lb = unpackDepth(shadowMap, centroidUV);","   float lt = unpackDepth(shadowMap, centroidUV + vec2(0.0, invSize.y));","   float rb = unpackDepth(shadowMap, centroidUV + vec2(invSize.x, 0.0));","   float rt = unpackDepth(shadowMap, centroidUV + invSize);","   float a = mix(lb, lt, fractCoord.y);","   float b = mix(rb, rt, fractCoord.y);","   return mix(a, b, fractCoord.x);","#else","    return texture2D(shadowMap, coord).x;","#endif","}","vec4 packDepth(float depth){","   #ifdef USE_UINT_ESM","\tfloat exposant = ceil(log(depth)/log(10.0));","\tfloat normDepth = depth/pow(10.0,exposant);","\treturn vec4(packRGB(normDepth),exposant/255.0);","   #else","       return vec4(depth,0.0,0.0,1.0);","   #endif","}","void main() {","vec2 screenPos = vUv;","float result = 0.0;","float blurSize = invSize.x;","#if (LEVEL == 1)","result += unpackLerp("+o+", vec2(vUv.x - 1.2 * blurSize, vUv.y)) * 0.3125;","result += unpackLerp("+o+", vec2(vUv.x, vUv.y)) * 0.375;","result += unpackLerp("+o+", vec2(vUv.x + 1.2 * blurSize, vUv.y)) * 0.3125;","#endif","#if (LEVEL == 2)","result += unpackLerp("+o+", vec2(vUv.x - 1.285714285714 * blurSize, vUv.y)) * 0.328125;","result += unpackLerp("+o+", vec2(vUv.x, vUv.y)) * 0.3125;","result += unpackLerp("+o+", vec2(vUv.x + 1.285714285714 * blurSize, vUv.y)) * 0.328125;","#endif","#if (LEVEL == 3)","result += unpackLerp("+o+", vec2(vUv.x - 3.111111111111 * blurSize, vUv.y)) * 0.03515625;","result += unpackLerp("+o+", vec2(vUv.x - 1.333333333333 * blurSize, vUv.y)) * 0.328125;","result += unpackLerp("+o+", vec2(vUv.x, vUv.y)) * 0.2734375;","result += unpackLerp("+o+", vec2(vUv.x + 1.333333333333 * blurSize, vUv.y)) * 0.328125;","result += unpackLerp("+o+", vec2(vUv.x + 3.111111111111 * blurSize, vUv.y)) * 0.03515625;","#endif","#if (LEVEL == 4)","result += unpackLerp("+o+", vec2(vUv.x - 3.181818181818 * blurSize, vUv.y)) * 0.0537109375;","result += unpackLerp("+o+", vec2(vUv.x - 1.363636363636 * blurSize, vUv.y)) * 0.322265625;","result += unpackLerp("+o+", vec2(vUv.x, vUv.y)) * 0.24609375;","result += unpackLerp("+o+", vec2(vUv.x + 1.363636363636 * blurSize, vUv.y)) * 0.322265625;","result += unpackLerp("+o+", vec2(vUv.x + 3.181818181818 * blurSize, vUv.y)) * 0.0537109375;","#endif","#if (LEVEL == 5)","result += unpackLerp("+o+", vec2(vUv.x - 5.076923076923 * blurSize, vUv.y)) * 0.003173828125;","result += unpackLerp("+o+", vec2(vUv.x - 3.230769230769 * blurSize, vUv.y)) * 0.06982421875;","result += unpackLerp("+o+", vec2(vUv.x - 1.384615384615 * blurSize, vUv.y)) * 0.314208984375;","result += unpackLerp("+o+", vec2(vUv.x, vUv.y)) * 0.2255859375;","result += unpackLerp("+o+", vec2(vUv.x + 1.384615384615 * blurSize, vUv.y)) * 0.314208984375;","result += unpackLerp("+o+", vec2(vUv.x + 3.230769230769 * blurSize, vUv.y)) * 0.06982421875;","result += unpackLerp("+o+", vec2(vUv.x + 5.076923076923 * blurSize, vUv.y)) * 0.003173828125;","#endif","gl_FragColor = packDepth(result);","}"].join("\n")},a.uniforms[o]={type:"t",value:null},a),BlurV:i}}),define("Shaders/ESMBlurShader",["DS/Shaders/ESMBlurShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/ESMBlurShader"),e}),define("DS/Shaders/BloomShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=function(t){var o="tDiffuse"+(t||""),a={defines:{LEVEL:1},uniforms:{direction:{type:"v2",value:new e.Vector2(1,0)},blurSize:{type:"f",value:1},ratio:{type:"f",value:1},kernel:{type:"fv1",value:[]}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D "+o+";","uniform vec2 direction;","uniform float blurSize;","uniform float ratio;","uniform float kernel[LEVEL * 2 + 1];","varying vec2 vUv;","void main() {","vec2 dir = direction * blurSize * 0.5/float(LEVEL);","dir *= ratio;","vec4  color = vec4(0.0);","for(int i=-LEVEL; i<=LEVEL; i++){","vec2 texCoord   =  dir * float(i) + vUv;","vec4 sampleCol  =  texture2D("+o+", texCoord);","color += sampleCol * kernel[i+LEVEL];","}","gl_FragColor = color;","}"].join("\n")};return a.uniforms[o]={type:"t",value:null},a},o=function(t){var o="tDiffuse"+(t||""),a={defines:{LEVEL:1},uniforms:{invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D "+o+";","varying vec2 vUv;","void main() {","vec2 screenPos = vUv;","vec4 result = vec4(0.0);","float blurSize = invSize.x;","#if (LEVEL == 1)","result += texture2D("+o+", vec2(vUv.x - 1.2 * blurSize, vUv.y)) * 0.3125;","result += texture2D("+o+", vec2(vUv.x, vUv.y)) * 0.375;","result += texture2D("+o+", vec2(vUv.x + 1.2 * blurSize, vUv.y)) * 0.3125;","#endif","#if (LEVEL == 2)","result += texture2D("+o+", vec2(vUv.x - 1.285714285714 * blurSize, vUv.y)) * 0.328125;","result += texture2D("+o+", vec2(vUv.x, vUv.y)) * 0.3125;","result += texture2D("+o+", vec2(vUv.x + 1.285714285714 * blurSize, vUv.y)) * 0.328125;","#endif","#if (LEVEL == 3)","result += texture2D("+o+", vec2(vUv.x - 3.111111111111 * blurSize, vUv.y)) * 0.03515625;","result += texture2D("+o+", vec2(vUv.x - 1.333333333333 * blurSize, vUv.y)) * 0.328125;","result += texture2D("+o+", vec2(vUv.x, vUv.y)) * 0.2734375;","result += texture2D("+o+", vec2(vUv.x + 1.333333333333 * blurSize, vUv.y)) * 0.328125;","result += texture2D("+o+", vec2(vUv.x + 3.111111111111 * blurSize, vUv.y)) * 0.03515625;","#endif","#if (LEVEL == 4)","result += texture2D("+o+", vec2(vUv.x - 3.181818181818 * blurSize, vUv.y)) * 0.0537109375;","result += texture2D("+o+", vec2(vUv.x - 1.363636363636 * blurSize, vUv.y)) * 0.322265625;","result += texture2D("+o+", vec2(vUv.x, vUv.y)) * 0.24609375;","result += texture2D("+o+", vec2(vUv.x + 1.363636363636 * blurSize, vUv.y)) * 0.322265625;","result += texture2D("+o+", vec2(vUv.x + 3.181818181818 * blurSize, vUv.y)) * 0.0537109375;","#endif","#if (LEVEL == 5)","result += texture2D("+o+", vec2(vUv.x - 5.076923076923 * blurSize, vUv.y)) * 0.003173828125;","result += texture2D("+o+", vec2(vUv.x - 3.230769230769 * blurSize, vUv.y)) * 0.06982421875;","result += texture2D("+o+", vec2(vUv.x - 1.384615384615 * blurSize, vUv.y)) * 0.314208984375;","result += texture2D("+o+", vec2(vUv.x, vUv.y)) * 0.2255859375;","result += texture2D("+o+", vec2(vUv.x + 1.384615384615 * blurSize, vUv.y)) * 0.314208984375;","result += texture2D("+o+", vec2(vUv.x + 3.230769230769 * blurSize, vUv.y)) * 0.06982421875;","result += texture2D("+o+", vec2(vUv.x + 5.076923076923 * blurSize, vUv.y)) * 0.003173828125;","#endif","gl_FragColor = result;","}"].join("\n")};return a.uniforms[o]={type:"t",value:null},a},a={defines:{LEVEL:1},uniforms:{tDiffuse:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec2 screenPos = vUv;","vec4 result = vec4(0.0);","float blurSize = invSize.y;","#if (LEVEL == 1)","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.2 * blurSize)) * 0.3125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.2 * blurSize)) * 0.3125;","#endif","#if (LEVEL == 2)","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.285714285714 * blurSize)) * 0.328125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.3125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.285714285714 * blurSize)) * 0.328125;","#endif","#if (LEVEL == 3)","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 3.111111111111 * blurSize)) * 0.03515625;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.333333333333 * blurSize)) * 0.328125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.2734375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.333333333333 * blurSize)) * 0.328125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 3.111111111111 * blurSize)) * 0.03515625;","#endif","#if (LEVEL == 4)","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 3.181818181818 * blurSize)) * 0.0537109375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.363636363636 * blurSize)) * 0.322265625;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.24609375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.363636363636 * blurSize)) * 0.322265625;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 3.181818181818 * blurSize)) * 0.0537109375;","#endif","#if (LEVEL == 5)","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 5.076923076923 * blurSize)) * 0.003173828125;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 3.230769230769 * blurSize)) * 0.06982421875;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y - 1.384615384615 * blurSize)) * 0.314208984375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y)) * 0.2255859375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 1.384615384615 * blurSize)) * 0.314208984375;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 3.230769230769 * blurSize)) * 0.06982421875;","result += texture2D(tDiffuse, vec2(vUv.x, vUv.y + 5.076923076923 * blurSize)) * 0.003173828125;","#endif","gl_FragColor = result;","}"].join("\n")},i={uniforms:{tDiffuse:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","uniform float radius;","varying vec2 vUv;","void main() {","vec4 result = vec4(0.0);","float radiusH = invSize.x * radius;","float radiusV = invSize.y * radius;","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.326212, vUv.y + radiusV * -0.405805 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.840144, vUv.y + radiusV * -0.07358 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.695914, vUv.y + radiusV * 0.457137 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.203345, vUv.y + radiusV * 0.620716 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.96234, vUv.y + radiusV * -0.194983 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.473434, vUv.y + radiusV * -0.480026 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.519456, vUv.y + radiusV * 0.767022 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.185461, vUv.y + radiusV * -0.893124 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.507431, vUv.y + radiusV * 0.064425 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * 0.530992, vUv.y + radiusV * 0.412458 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.32194, vUv.y + radiusV * -0.871945 ) );","result += texture2D( tDiffuse, vec2( vUv.x + radiusH * -0.791559, vUv.y + radiusV * 0.597705 ) );","gl_FragColor = result * 0.0833333333333333;","}"].join("\n")},r={uniforms:{tDiffuse2:{type:"t",value:null},threshold:{type:"f",value:1},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","uniform float threshold;","uniform vec2 invSize;","varying vec2 vUv;","vec4 WeighedAverageColor(vec2 offset){","\tvec2 coord = vUv+ offset * invSize;","\tvec4 color = texture2D( tDiffuse2, coord );","\tcolor = vec4(color.xyz,1.0);","\tfloat luminance = dot(color.rgb, vec3(0.3,0.6,0.1));","\tcolor *= 1.0/(1.0+luminance);","\treturn color;","}","bool isNan( vec3 val ){","   return !( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) || !( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) || !( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 );","}","void main() {","\t#if defined (OLD_BLOOM)","    \tvec4 color = texture2D( tDiffuse2, vUv );","\t\tfloat lum = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));","\t\tfloat lum2 = clamp(lum - threshold, 0.0, 1.0);","\t\tcolor.rgb *= lum2;","\t\tgl_FragColor = color;","\t#else","   \tvec4 color = vec4(0.0);","\t\tcolor += WeighedAverageColor(vec2(0.0,0.0));","\t\tcolor += WeighedAverageColor(vec2(1.0,0.0));","\t\tcolor += WeighedAverageColor(vec2(1.0,1.0));","\t\tcolor += WeighedAverageColor(vec2(0.0,1.0));","\t\tcolor.xyz /= color.w;","       if(isNan(color.xyz)){color=vec4(0.0);}","\t\tfloat luminance = dot(color.rgb, vec3(0.3,0.6,0.1));","\t\tif(luminance<threshold) color=vec4(0.0);","\t\tgl_FragColor = vec4(color.xyz,1.0);","\t#endif","}"].join("\n")},n={uniforms:{tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform vec2 invSize;","varying vec2 vUv;","vec4 GetSourceTexture(vec2 delta){","vec2 coord = vUv+delta * invSize;","return texture2D( tDiffuse2, coord );","}","void main() {","vec4 color = GetSourceTexture(vec2(0,0))*0.25;","color += GetSourceTexture(vec2(-1,-1))*0.0625;","color += GetSourceTexture(vec2( 1,-1))*0.0625;","color += GetSourceTexture(vec2( 1, 1))*0.0625;","color += GetSourceTexture(vec2(-1, 1))*0.0625;","color += GetSourceTexture(vec2( 0,-1))*0.125;","color += GetSourceTexture(vec2( 0, 1))*0.125;","color += GetSourceTexture(vec2( 1, 0))*0.125;","color += GetSourceTexture(vec2(-1, 0))*0.125;","color += texture2D( tDiffuse3, vUv );","gl_FragColor = color;","}"].join("\n")},l={uniforms:{tDiffuse2:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","uniform vec2 invSize;","varying vec2 vUv;","vec4 GetSourceTexture(vec2 delta){","vec2 coord = vUv+delta * invSize;","return texture2D( tDiffuse2, coord );","}","void main() {","vec4 color = GetSourceTexture(vec2(0,0))*0.25;","color += GetSourceTexture(vec2(-1,-1))*0.0625;","color += GetSourceTexture(vec2( 1,-1))*0.0625;","color += GetSourceTexture(vec2( 1, 1))*0.0625;","color += GetSourceTexture(vec2(-1, 1))*0.0625;","color += GetSourceTexture(vec2( 0,-1))*0.125;","color += GetSourceTexture(vec2( 0, 1))*0.125;","color += GetSourceTexture(vec2( 1, 0))*0.125;","color += GetSourceTexture(vec2(-1, 0))*0.125;","gl_FragColor = color;","}"].join("\n")},s={uniforms:{tDiffuse2:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","uniform vec2 invSize;","varying vec2 vUv;","vec4 GetSourceTexture(vec2 delta){","vec2 coord = vUv+delta * invSize;","return texture2D( tDiffuse2, coord );","}","void main() {","vec4 color = GetSourceTexture(vec2(0,0))*0.125;","color += GetSourceTexture(vec2(-1, -1))*0.125;","color += GetSourceTexture(vec2( 1, -1))*0.125;","color += GetSourceTexture(vec2( 1,  1))*0.125;","color += GetSourceTexture(vec2(-1,  1))*0.125;","color += GetSourceTexture(vec2(-2,  0))*0.0625;","color += GetSourceTexture(vec2( 2,  0))*0.0625;","color += GetSourceTexture(vec2( 0, -2))*0.0625;","color += GetSourceTexture(vec2( 0,  2))*0.0625;","color += GetSourceTexture(vec2(-2, -2))*0.03125;","color += GetSourceTexture(vec2( 2, -2))*0.03125;","color += GetSourceTexture(vec2( 2,  2))*0.03125;","color += GetSourceTexture(vec2(-2,  2))*0.03125;","gl_FragColor = color;","}"].join("\n")},f={uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform sampler2D tDiffuse6;","varying vec2 vUv;","void main() {","    vec4 color = texture2D( tDiffuse, vUv );","    vec4 bloom1 = texture2D( tDiffuse2, vUv );","    vec4 bloom2 = texture2D( tDiffuse3, vUv );","    vec4 bloom3 = texture2D( tDiffuse4, vUv );","    vec4 bloom4 = texture2D( tDiffuse5, vUv );","    vec4 bloom5 = texture2D( tDiffuse6, vUv );","    vec3 bloom = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;","    float bloomFactor = 0.9;","\t vec3 result = color.rgb + bloomFactor * bloom;","\t float maxComponent = max(result.x, max(result.y, result.z));","\t if (maxComponent > 1.0) { result /= maxComponent; }","    gl_FragColor = vec4(result, color.a);","}"].join("\n")},c={uniforms:{bloomFactor:{type:"f",value:.9},tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float bloomFactor;","#if(USE_BLOOM >= 1)","\tuniform sampler2D tDiffuse2;","#endif","#if(USE_BLOOM == 2)","\tuniform sampler2D tDiffuse3;","\tuniform sampler2D tDiffuse4;","\tuniform sampler2D tDiffuse5;","\tuniform sampler2D tDiffuse6;","#endif","varying vec2 vUv;","void main() {","   vec4 inColorAlpha = texture2D( tDiffuse, vUv );","   vec3 inColor = inColorAlpha.xyz;","#if (USE_BLOOM == 1)","    vec3 bloom = texture2D( tDiffuse2, vUv ).xyz;","\t inColor += bloomFactor * bloom;","#elif (USE_BLOOM == 2)","    vec4 bloom1 = texture2D( tDiffuse2, vUv );","    vec4 bloom2 = texture2D( tDiffuse3, vUv );","    vec4 bloom3 = texture2D( tDiffuse4, vUv );","    vec4 bloom4 = texture2D( tDiffuse5, vUv );","    vec4 bloom5 = texture2D( tDiffuse6, vUv );","    vec3 bloom = 0.5 * bloom1.rgb + 0.5 * bloom2.rgb + 0.5 * bloom3.rgb + 0.5 * bloom4.rgb + 0.5 * bloom5.rgb;","\t inColor += bloomFactor * bloom;","#endif","    gl_FragColor = vec4(inColor, inColorAlpha.a);","}"].join("\n")};return{Threshold:r,Blur:t(),Blur2:t(2),BlurH:o(),BlurH2:o(2),BlurV:a,UpAdd:n,UpReplace:l,Down:s,PoissonBlur:i,FinalBlending:f,MixShader:c}}),define("Shaders/BloomShaders",["DS/Shaders/BloomShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/BloomShaders"),e}),define("DS/Shaders/CATCrDFeltPenShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(t,o){t.force=!0,t.useLighting=!1,t.activatePDSFX(),t.transparent=!0,t.side=e.DoubleSide,t.setPDSFXPolygonOffset("Frontward1");var a=["vec4 commonFinalColor;"].join("\n");t.setPDSFXGlobalShaderCode("",a);var i={CrD_Base_UniformColor:{type:"v4",value:new e.Vector4(o.Color[0],o.Color[1],o.Color[2],o.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:o.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:o.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new e.Vector3(o.PlanePosition[0],o.PlanePosition[1],o.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new e.Vector3(o.PlaneNormal[0],o.PlaneNormal[1],o.PlaneNormal[2])},CrD_FeltPen_UniformThickness:{type:"f",value:o.Thickness},CrD_FeltPen_UniformLength:{type:"f",value:o.Length},CrD_FeltPen_UniformResizeUMode:{type:"f",value:o.ResizeUMode},CrD_FeltPen_UniformUMin:{type:"f",value:o.UMin},CrD_FeltPen_UniformUMax:{type:"f",value:o.UMax},CrD_FeltPen_UniformClosedWire:{type:"f",value:o.ClosedWire}};t.setPDSFXUniforms(i);t.setPDSFXVaryings({vTexCoord:{type:"v3"}});var r={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},n={ComputeCommonValues:["void ComputeCommonValues() {","float isOpenedWire = 1.0 - clamp(sign(CrD_FeltPen_UniformClosedWire), 0.0, 1.0);","// Pen handles pressure, we must take it into account when computing pen thickness","float pressure = clamp(1.02 * 1.0, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0","float thickness = CrD_FeltPen_UniformThickness * pressure;","float adjustedLength = max(thickness, CrD_FeltPen_UniformLength);","float thicknessUV = 0.5 * thickness / adjustedLength;","vec2 cornerUV = vTexCoord.xy;","cornerUV.y = 2.0 * (cornerUV.y - 0.5);","float xUVTest1 = clamp(sign(thicknessUV - cornerUV.x), 0.0, 1.0); // if cornerUV.x<thicknessUV","float xUVTest2 = clamp(sign(cornerUV.x - (1.0 - thicknessUV)), 0.0, 1.0); // if cornerUV.x>1.0f - thicknessUV","cornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x / thicknessUV, xUVTest1); // if cornerUV.x<thicknessUV => cornerUV.x = 1.0f - cornerUV.x/thicknessUV","cornerUV.x = mix(cornerUV.x, (cornerUV.x - (1.0 - thicknessUV)) / thicknessUV, xUVTest2); // if cornerUV.x > 1.0f - thicknessUV => (cornerUV.x - (1.0f - thicknessUV))/thicknessUV","float inTheCorner = xUVTest1 + xUVTest2; // xUVTest1 || xUVTest2","float corner = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;","if(isOpenedWire * inTheCorner * corner > 1.0) // true only if isOpenedWire == 1 and inTheCorner == 1 and corner > 1 as isOpenedWire and inTheCorner can only be 0 or 1","{","discard;","}","//-----------------------------------------------------------------------------------------------","// Handle cut by plane","//-----------------------------------------------------------------------------------------------","float cutByPlaneActivated = clamp(sign(CrD_Base_UniformCutByPlane), 0.0, 1.0); // 0 if CutByPlane <= 0, 1 if CutByPlane > 0        ","float screenActivated = clamp(sign(CrD_Base_UniformScreenPlane), 0.0, 1.0); // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0","// We do the work in the view space","// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)","vec4 viewPlaneEq = vGetWorldViewInvTranspMatrix() * vec4(CrD_Base_UniformPlaneNormal, -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition));","// eye and Fragment position","vec4 fragPos = vec4(vGetViewPosition(), 1.0);","vec4 eyePos = vec4(0.0, 0.0, 0.0, 1.0);","// The sign of the plane's equation applied to the previous position gives the side of each point","float eyeClip = dot(viewPlaneEq, eyePos); // => d","float fragClip = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;","// cutByPlaneActivated == 0 => hide = 0.0","// If both values have the same sign, they are on the same side => hide = 0.0","// If there signs are different, they are on opposite side      => hide = 1.0","float hide = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);","//-----------------------------------------------------------------------------------------------","// Handle Resize UV","//-----------------------------------------------------------------------------------------------","float resizeMode = clamp(sign(CrD_FeltPen_UniformResizeUMode), 0.0, 1.0);","float outsideLimit = clamp(sign(CrD_FeltPen_UniformUMin - vTexCoord.x), 0.0, 1.0) + clamp(sign(vTexCoord.x - CrD_FeltPen_UniformUMax), 0.0, 1.0); //if((uv.x < UMin) || (uv.x > UMax)) ","float alpha = mix(CrD_Base_UniformColor.a, 0.0625 * CrD_Base_UniformColor.a, resizeMode * outsideLimit);","commonFinalColor = vec4(CrD_Base_UniformColor.xyz, pressure * alpha * mix(1.0, 0.25, hide));","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return t.setPDSFXOverridableFunctions(r,n),t.needsUpdate=!0,t}}),define("DS/Shaders/DisplayMipsRoughnessShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{DisplayMips:{uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null},tDiffuse7:{type:"t",value:null},offset1:{type:"v2",value:new e.Vector2(0,.5)},scale1:{type:"f",value:.5},offset2:{type:"v2",value:new e.Vector2(0,.25)},scale2:{type:"f",value:.25},offset3:{type:"v2",value:new e.Vector2(.25,.25)},scale3:{type:"f",value:.25},offset4:{type:"v2",value:new e.Vector2(0,.125)},scale4:{type:"f",value:.125},offset5:{type:"v2",value:new e.Vector2(.125,.125)},scale5:{type:"f",value:.125},offset6:{type:"v2",value:new e.Vector2(.25,.125)},scale6:{type:"f",value:.125},offset7:{type:"v2",value:new e.Vector2(.375,.125)},scale7:{type:"f",value:.125}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform sampler2D tDiffuse6;","uniform sampler2D tDiffuse7;","uniform vec2 offset1;","uniform float scale1;","uniform vec2 offset2;","uniform float scale2;","uniform vec2 offset3;","uniform float scale3;","uniform vec2 offset4;","uniform float scale4;","uniform vec2 offset5;","uniform float scale5;","uniform vec2 offset6;","uniform float scale6;","uniform vec2 offset7;","uniform float scale7;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv1 = (vUv - offset1) / scale1;","vec2 vUv2 = (vUv - offset2) / scale2;","vec2 vUv3 = (vUv - offset3) / scale3;","vec2 vUv4 = (vUv - offset4) / scale4;","vec2 vUv5 = (vUv - offset5) / scale5;","vec2 vUv6 = (vUv - offset6) / scale6;","vec2 vUv7 = (vUv - offset7) / scale7;","if (vUv1.x > 0.0 && vUv1.y > 0.0 && vUv1.x < 1.0 && vUv1.y < 1.0) {","    vec3 color = texture2D( tDiffuse1, vUv1 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    vec3 color = texture2D( tDiffuse2, vUv2 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    vec3 color = texture2D( tDiffuse3, vUv3 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    vec3 color = texture2D( tDiffuse4, vUv4 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    vec3 color = texture2D( tDiffuse5, vUv5 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv6.x > 0.0 && vUv6.y > 0.0 && vUv6.x < 1.0 && vUv6.y < 1.0) {","    vec3 color = texture2D( tDiffuse6, vUv6 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv7.x > 0.0 && vUv7.y > 0.0 && vUv7.x < 1.0 && vUv7.y < 1.0) {","    vec3 color = texture2D( tDiffuse7, vUv7 ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","}","}"].join("\n")},MergeMips:{uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null},tDiffuse7:{type:"t",value:null},offset1:{type:"v2",value:new e.Vector2(0,.5)},scale1:{type:"v2",value:new e.Vector2(1,.5)},offset2:{type:"v2",value:new e.Vector2(0,.25)},scale2:{type:"v2",value:new e.Vector2(.5,.25)},offset3:{type:"v2",value:new e.Vector2(.5,.25)},scale3:{type:"v2",value:new e.Vector2(.5,.25)},offset4:{type:"v2",value:new e.Vector2(0,.125)},scale4:{type:"v2",value:new e.Vector2(.25,.125)},offset5:{type:"v2",value:new e.Vector2(.25,.125)},scale5:{type:"v2",value:new e.Vector2(.25,.125)},offset6:{type:"v2",value:new e.Vector2(.5,.125)},scale6:{type:"v2",value:new e.Vector2(.25,.125)},offset7:{type:"v2",value:new e.Vector2(.75,.125)},scale7:{type:"v2",value:new e.Vector2(.25,.125)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform sampler2D tDiffuse6;","uniform sampler2D tDiffuse7;","uniform vec2 offset1;","uniform vec2 scale1;","uniform vec2 offset2;","uniform vec2 scale2;","uniform vec2 offset3;","uniform vec2 scale3;","uniform vec2 offset4;","uniform vec2 scale4;","uniform vec2 offset5;","uniform vec2 scale5;","uniform vec2 offset6;","uniform vec2 scale6;","uniform vec2 offset7;","uniform vec2 scale7;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv1 = (vUv - offset1) / scale1;","vec2 vUv2 = (vUv - offset2) / scale2;","vec2 vUv3 = (vUv - offset3) / scale3;","vec2 vUv4 = (vUv - offset4) / scale4;","vec2 vUv5 = (vUv - offset5) / scale5;","vec2 vUv6 = (vUv - offset6) / scale6;","vec2 vUv7 = (vUv - offset7) / scale7;","if (vUv1.x > 0.0 && vUv1.y > 0.0 && vUv1.x < 1.0 && vUv1.y < 1.0) {","    vec3 color = texture2D( tDiffuse1, vec2(1.0 - vUv1.x, vUv1.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    vec3 color = texture2D( tDiffuse2, vec2(1.0 - vUv2.x, vUv2.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    vec3 color = texture2D( tDiffuse3, vec2(1.0 - vUv3.x, vUv3.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    vec3 color = texture2D( tDiffuse4, vec2(1.0 - vUv4.x, vUv4.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    vec3 color = texture2D( tDiffuse5, vec2(1.0 - vUv5.x, vUv5.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv6.x > 0.0 && vUv6.y > 0.0 && vUv6.x < 1.0 && vUv6.y < 1.0) {","    vec3 color = texture2D( tDiffuse6, vec2(1.0 - vUv6.x, vUv6.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","} else if (vUv7.x > 0.0 && vUv7.y > 0.0 && vUv7.x < 1.0 && vUv7.y < 1.0) {","    vec3 color = texture2D( tDiffuse7, vec2(1.0 - vUv7.x, vUv7.y) ).xyz;","    gl_FragColor = vec4(color, 1.0); return;","}","}"].join("\n")},MergeMipsRGBE:{uniforms:{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null},tDiffuse7:{type:"t",value:null},offset1:{type:"v2",value:new e.Vector2(0,.5)},scale1:{type:"v2",value:new e.Vector2(1,.5)},offset2:{type:"v2",value:new e.Vector2(0,.25)},scale2:{type:"v2",value:new e.Vector2(.5,.25)},offset3:{type:"v2",value:new e.Vector2(.5,.25)},scale3:{type:"v2",value:new e.Vector2(.5,.25)},offset4:{type:"v2",value:new e.Vector2(0,.125)},scale4:{type:"v2",value:new e.Vector2(.25,.125)},offset5:{type:"v2",value:new e.Vector2(.25,.125)},scale5:{type:"v2",value:new e.Vector2(.25,.125)},offset6:{type:"v2",value:new e.Vector2(.5,.125)},scale6:{type:"v2",value:new e.Vector2(.25,.125)},offset7:{type:"v2",value:new e.Vector2(.75,.125)},scale7:{type:"v2",value:new e.Vector2(.25,.125)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform sampler2D tDiffuse6;","uniform sampler2D tDiffuse7;","uniform vec2 offset1;","uniform vec2 scale1;","uniform vec2 offset2;","uniform vec2 scale2;","uniform vec2 offset3;","uniform vec2 scale3;","uniform vec2 offset4;","uniform vec2 scale4;","uniform vec2 offset5;","uniform vec2 scale5;","uniform vec2 offset6;","uniform vec2 scale6;","uniform vec2 offset7;","uniform vec2 scale7;","varying vec2 vUv;","vec4 toRGBE(vec3 color) {","float value = max(color.r, max(color.g, color.b));","int exponent = 0;","float mantissa = 0.0;","if (value > 1.0) {","for (int i = 1; i <= 127; i++) {","value /= 2.0;","exponent++;","if (value < 1.0) { break; }","}","} else if (value < 1.0) {","int j = 1;","for (int i = 1; i <= 129; i++) {","value *= 2.0;","exponent--;","if (value > 1.0) { j = 0; break; }","}","value /= 2.0;","exponent++;","if (j > 0) {","color = vec3(0.0);","exponent = 0;","}","}","return vec4(color * pow(2.0, float(-exponent)), float(exponent + 128) / 255.0);","}","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv1 = (vUv - offset1) / scale1;","vec2 vUv2 = (vUv - offset2) / scale2;","vec2 vUv3 = (vUv - offset3) / scale3;","vec2 vUv4 = (vUv - offset4) / scale4;","vec2 vUv5 = (vUv - offset5) / scale5;","vec2 vUv6 = (vUv - offset6) / scale6;","vec2 vUv7 = (vUv - offset7) / scale7;","if (vUv1.x > 0.0 && vUv1.y > 0.0 && vUv1.x < 1.0 && vUv1.y < 1.0) {","    vec3 color = texture2D( tDiffuse1, vec2(1.0 - vUv1.x, vUv1.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    vec3 color = texture2D( tDiffuse2, vec2(1.0 - vUv2.x, vUv2.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    vec3 color = texture2D( tDiffuse3, vec2(1.0 - vUv3.x, vUv3.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    vec3 color = texture2D( tDiffuse4, vec2(1.0 - vUv4.x, vUv4.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    vec3 color = texture2D( tDiffuse5, vec2(1.0 - vUv5.x, vUv5.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv6.x > 0.0 && vUv6.y > 0.0 && vUv6.x < 1.0 && vUv6.y < 1.0) {","    vec3 color = texture2D( tDiffuse6, vec2(1.0 - vUv6.x, vUv6.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","} else if (vUv7.x > 0.0 && vUv7.y > 0.0 && vUv7.x < 1.0 && vUv7.y < 1.0) {","    vec3 color = texture2D( tDiffuse7, vec2(1.0 - vUv7.x, vUv7.y) ).xyz;","    gl_FragColor = toRGBE(color); return;","}","}"].join("\n")},MergeCustomMips:{defines:{MAPPING:0,MIP_OFFSET:0,ZERO_RBGE:1},uniforms:{tDiffuse0:{type:"t",value:null},tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},tDiffuse6:{type:"t",value:null},tDiffuse7:{type:"t",value:null},size0:{type:"v2",value:new e.Vector2},size1:{type:"v2",value:new e.Vector2},size2:{type:"v2",value:new e.Vector2},size3:{type:"v2",value:new e.Vector2},size4:{type:"v2",value:new e.Vector2},size5:{type:"v2",value:new e.Vector2},size6:{type:"v2",value:new e.Vector2},size7:{type:"v2",value:new e.Vector2},offset1:{type:"v2",value:new e.Vector2(0,.5)},scale1:{type:"v2",value:new e.Vector2(1,.5)},offset2:{type:"v2",value:new e.Vector2(0,.25)},scale2:{type:"v2",value:new e.Vector2(.5,.25)},offset3:{type:"v2",value:new e.Vector2(.5,.25)},scale3:{type:"v2",value:new e.Vector2(.5,.25)},offset4:{type:"v2",value:new e.Vector2(0,.125)},scale4:{type:"v2",value:new e.Vector2(.25,.125)},offset5:{type:"v2",value:new e.Vector2(.25,.125)},scale5:{type:"v2",value:new e.Vector2(.25,.125)},offset6:{type:"v2",value:new e.Vector2(.5,.125)},scale6:{type:"v2",value:new e.Vector2(.25,.125)},offset7:{type:"v2",value:new e.Vector2(.75,.125)},scale7:{type:"v2",value:new e.Vector2(.25,.125)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","vUv.x = 1.0 - vUv.x;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse0;","uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform sampler2D tDiffuse6;","uniform sampler2D tDiffuse7;","uniform vec2 size0;","uniform vec2 size1;","uniform vec2 size2;","uniform vec2 size3;","uniform vec2 size4;","uniform vec2 size5;","uniform vec2 size6;","uniform vec2 size7;","uniform vec2 offset1;","uniform vec2 scale1;","uniform vec2 offset2;","uniform vec2 scale2;","uniform vec2 offset3;","uniform vec2 scale3;","uniform vec2 offset4;","uniform vec2 scale4;","uniform vec2 offset5;","uniform vec2 scale5;","uniform vec2 offset6;","uniform vec2 scale6;","uniform vec2 offset7;","uniform vec2 scale7;","varying vec2 vUv;","#if MAPPING == 0","#define LINEAR","#endif","#if MAPPING == 1","#define NON_LINEAR","#endif","#if MAPPING == 2","#define INVERSE_LINEAR","#endif","#if MAPPING == 3","#define INVERSE_NON_LINEAR","#endif",e._DefaultShaderChunk.rgbe_sample_methods,"float roughnessToMips(in float roughness) {","float mip;","#ifdef LINEAR","mip = roughness * (6.0 - float(MIP_OFFSET));","#endif","#ifdef NON_LINEAR","mip = roughness == 0.0 ? 0.0 : (6.0 - float(MIP_OFFSET) ) + 1.15 * log2(roughness);","#endif","#ifdef INVERSE_LINEAR","mip = (1.0 - roughness) * (6.0 - float(MIP_OFFSET));","#endif","#ifdef INVERSE_NON_LINEAR","mip = roughness == 1.0 ? 6.0 - float(MIP_OFFSET) : (6.0 - float(MIP_OFFSET)) + 1.15 * log2(1.0 - roughness);","#endif","return mip + float(MIP_OFFSET);","}","vec4 toRGBE(vec3 color) {","float value = max(color.r, max(color.g, color.b));","int exponent = 0;","float mantissa = 0.0;","if (value > 1.0) {","for (int i = 1; i <= 127; i++) {","value /= 2.0;","exponent++;","if (value < 1.0) { break; }","}","} else if (value < 1.0) {","int j = 1;","for (int i = 1; i <= 129; i++) {","value *= 2.0;","exponent--;","if (value > 1.0) { j = 0; break; }","}","value /= 2.0;","exponent++;","if (j > 0) {","color = vec3(0.0);","exponent = 0;","}","}","return vec4(color * pow(2.0, float(-exponent)), float(exponent + 128) / 255.0);","}","vec4 getColor(in float roughness, in vec2 uv) {","float mipValue = roughnessToMips(roughness);","float leftMip = floor(mipValue);","float factor = fract(mipValue);","uv.x = 1.0 - uv.x;","vec3 color;","if (leftMip == 0.0) {","#if ZERO_RBGE == 1","color = mix(texture2DBilinearFromRGBE( tDiffuse0, vec2(uv.x, uv.y), size0, 1.0/size0 ).xyz, texture2DBilinearFromRGBE( tDiffuse1, vec2(uv.x, uv.y), size1, 1.0/size1 ).xyz, factor);","#else","color = mix(texture2D( tDiffuse0, vec2(uv.x, uv.y)).xyz, texture2DBilinearFromRGBE( tDiffuse1, vec2(uv.x, uv.y), size1, 1.0/size1 ).xyz, factor);","#endif","}","if (leftMip == 1.0) {","color = mix(texture2DBilinearFromRGBE( tDiffuse1, vec2(uv.x, uv.y), size1, 1.0/size1 ).xyz, texture2DBilinearFromRGBE( tDiffuse2, vec2(uv.x, uv.y), size2, 1.0/size2 ).xyz, factor);","}","if (leftMip == 2.0) {","color = mix(texture2DBilinearFromRGBE( tDiffuse2, vec2(uv.x, uv.y), size2, 1.0/size2 ).xyz, texture2DBilinearFromRGBE( tDiffuse3, vec2(uv.x, uv.y), size3, 1.0/size3 ).xyz, factor);","}","if (leftMip == 3.0) {","color = mix(texture2DBilinearFromRGBE( tDiffuse3, vec2(uv.x, uv.y), size3, 1.0/size3 ).xyz, texture2DBilinearFromRGBE( tDiffuse4, vec2(uv.x, uv.y), size4, 1.0/size4 ).xyz, factor);","}","if (leftMip == 4.0) {","color = mix(texture2DBilinearFromRGBE( tDiffuse4, vec2(uv.x, uv.y), size4, 1.0/size4 ).xyz, texture2DBilinearFromRGBE( tDiffuse5, vec2(uv.x, uv.y), size5, 1.0/size5 ).xyz, factor);","}","if (leftMip == 5.0) {","color = mix(texture2DBilinearFromRGBE( tDiffuse5, vec2(uv.x, uv.y), size5, 1.0/size5 ).xyz, texture2DBilinearFromRGBE( tDiffuse6, vec2(uv.x, uv.y), size6, 1.0/size6 ).xyz, factor);","}","if (leftMip == 6.0) {","color = texture2DBilinearFromRGBE( tDiffuse6, vec2(uv.x, uv.y), size6, 1.0/size6 ).xyz;","}","return toRGBE(color);","}","void main() {","vec2 vUv1 = (vUv - offset1) / scale1;","vec2 vUv2 = (vUv - offset2) / scale2;","vec2 vUv3 = (vUv - offset3) / scale3;","vec2 vUv4 = (vUv - offset4) / scale4;","vec2 vUv5 = (vUv - offset5) / scale5;","vec2 vUv6 = (vUv - offset6) / scale6;","vec2 vUv7 = (vUv - offset7) / scale7;","gl_FragColor = toRGBE(vec3(0.0));","if (vUv1.x > 0.0 && vUv1.y > 0.0 && vUv1.x < 1.0 && vUv1.y < 1.0) {","    gl_FragColor = getColor(0.04911045206, vUv1); return;","} else if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    gl_FragColor = getColor(0.08973030532, vUv2); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    gl_FragColor = getColor(0.1639473341, vUv3); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    gl_FragColor = getColor(0.29955017162, vUv4); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    gl_FragColor = getColor(0.54731176821, vUv5); return;","} else if (vUv6.x > 0.0 && vUv6.y > 0.0 && vUv6.x < 1.0 && vUv6.y < 1.0) {","    gl_FragColor = getColor(1.0, vUv6); return;","} else if (vUv7.x > 0.0 && vUv7.y > 0.0 && vUv7.x < 1.0 && vUv7.y < 1.0) {","vUv7.x = 1.0 - vUv7.x;","    vec3 color = texture2DBilinearFromRGBE( tDiffuse7, vec2(vUv7.x, vUv7.y), size7, 1.0/size7 ).xyz;","    gl_FragColor = toRGBE(color); return;","}","}"].join("\n")}}}),define("ShadersDebug/DisplayMipsRoughnessShader",["DS/Shaders/DisplayMipsRoughnessShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("ShadersDebug/DisplayMipsRoughnessShader"),e}),define("DS/Shaders/FXAAShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=["vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;","vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;","vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;","vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;","vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );","vec3 rgbM  = rgbaM.xyz;","float opacity  = rgbaM.w;","vec3 luma = vec3( 0.299, 0.587, 0.114 );","float lumaNW = dot( rgbNW, luma );","float lumaNE = dot( rgbNE, luma );","float lumaSW = dot( rgbSW, luma );","float lumaSE = dot( rgbSE, luma );","float lumaM  = dot( rgbM,  luma );","float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );","float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );","vec2 dir;","dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));","dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));","float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );","float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );","dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),","max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),","dir * rcpDirMin)) * resolution;"].join("\n"),o={uniforms:{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new e.Vector2(1/1024,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n")};return{FXAAShader:Object.assign({fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","#define FXAA_REDUCE_MIN   (1.0/128.0)","#define FXAA_REDUCE_MUL   (1.0/8.0)","#define FXAA_SPAN_MAX     8.0","void main() {",t,"vec3 rgbA = 0.5 * (","texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +","texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );","vec3 rgbB = rgbA * 0.5 + 0.25 * (","texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz +","texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz );","float lumaB = dot( rgbB, luma );","if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {","gl_FragColor = vec4( rgbA, opacity );","} else {","gl_FragColor = vec4( rgbB, opacity );","}","}"].join("\n")},o),OITFXAAShader:Object.assign({fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","#define FXAA_REDUCE_MIN   (1.0/128.0)","#define FXAA_REDUCE_MUL   (1.0/8.0)","#define FXAA_SPAN_MAX     8.0","vec4 sampleColor(vec2 uv, vec4 color) {","vec4 res = texture2D(tDiffuse, uv);","if (res.a < 1e-6) {","return vec4(color.rgb, 0.2 * color.a);","}","return res;","}","void main() {",t,"vec4 rgbA = 1.0 / 3.0 * ( rgbaM + ","sampleColor(gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ), rgbaM) +","sampleColor(gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ), rgbaM) );","vec4 rgbB = rgbA * 0.6 + 0.2 * (","sampleColor(gl_FragCoord.xy  * resolution + dir * -0.5, rgbaM) +","sampleColor(gl_FragCoord.xy  * resolution + dir * 0.5, rgbaM ) );","float lumaB = dot( rgbB.rgb, luma );","if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {","gl_FragColor = rgbA;","} else {","gl_FragColor = rgbB;","}","}"].join("\n")},o)}}),define("Shaders/FXAAShader",["DS/Shaders/FXAAShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/FXAAShader"),e}),define("DS/Shaders/DeferredShaders",["DS/Visualization/ThreeJS_R57"],function(e){"use strict";var t={encode_float:["float shift_right(float v, float amt) {","v = floor(v) + 0.5;","return floor(v / exp2(amt));","}","float shift_left(float v, float amt) {","return floor(v * exp2(amt) + 0.5);","}","float mask_last(float v, float bits) {","return mod(v, shift_left(1.0, bits));","}","float extract_bits(float num, float from, float to) {","from = floor(from + 0.5);","to = floor(to + 0.5);","return mask_last(shift_right(num, from), to - from);","}","vec4 encode_float(float val) {","if (val == 0.0)","return vec4(0, 0, 0, 0);","float sign = val > 0.0 ? 0.0 : 1.0;","val = abs(val);","float exponent = floor(log2(val));","float biased_exponent = exponent + 127.0;","float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;","float t = biased_exponent / 2.0;","float last_bit_of_biased_exponent = fract(t) * 2.0;","float remaining_bits_of_biased_exponent = floor(t);","float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;","float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;","float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;","float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;","return vec4(byte4, byte3, byte2, byte1);","}","vec4 packRGBAFace( const in float depth ) {","float depthToUse = depth;","#if defined(GL_OES_standard_derivatives) || defined(GLSL300ES)","float dx = dFdx (depth);","float dy = dFdy (depth);","depthToUse += sqrt(dx*dx + dy*dy) + DEPTH_PRECISION;","#else","depthToUse += 2.0 *DEPTH_PRECISION;","#endif","return packRGBA(depthToUse);","}"].join("\n"),decalNormalStencilDepth:["uniform float decalStencilValue;"].join("\n"),unpackFloat:["vec3 float_to_vec3( float data ) {","vec3 uncompressed;","uncompressed.x = fract( data );","float zInt = floor( data / 255.0 );","uncompressed.z = fract( zInt / 255.0 );","uncompressed.y = fract( floor( data - ( zInt * 255.0 ) ) / 255.0 );","return uncompressed;","}"].join("\n"),picking_instancing_vertex:["if (instanceId > 16777215.0) vInstancePickingColor = vec3(0.0);","else {","vInstancePickingColor.r = floor(instanceId / 65536.0);","vInstancePickingColor.g = floor((instanceId - vInstancePickingColor.r * 65536.0) / 256.0);","vInstancePickingColor.b = floor(instanceId - vInstancePickingColor.r * 65536.0 - vInstancePickingColor.g * 256.0);","vInstancePickingColor /= 255.0;","}"].join("\n"),picking_instancing_fragment:["gl_FragColor = vec4(vInstancePickingColor, 1.0);"].join("\n")},o={uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)}}]),vertexShaderPars:["#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#endif"].join("\n"),vertexShaderBody:["#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","pickingColor = specialMeshPicking;","#endif"].join("\n"),fragmentShaderPars:["#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#else","uniform vec3 pickingColor;","#endif"].join("\n"),fragmentShaderBody:["#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","   gl_FragColor = vec4( pickingColor, 1.0 );"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#endif","void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex,"#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif",e.ShaderChunk.clip_vertex,"#ifdef SPECIAL_PICKING_INSTANCING","pickingColor = specialMeshPicking;","#endif",e.ShaderChunk.PDSFX_end_vertex,"#ifdef PDSFX_USE_MAP","vUv = uv;","#endif","}"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef SPECIAL_PICKING_INSTANCING","varying vec3 pickingColor;","#else","uniform vec3 pickingColor;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,"#endif",e.ShaderChunk.clip_fragment,"#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","   gl_FragColor = vec4( pickingColor, 1.0 );","}"].join("\n")},a={uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)}}]),vertexShader:[e.ShaderChunk.clip_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","varying vec3 vInstancePickingColor;","void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex,"#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif",e.ShaderChunk.clip_vertex,e.ShaderChunk.PDSFX_end_vertex,t.picking_instancing_vertex,"#ifdef PDSFX_USE_MAP","vUv = uv;","#endif","}"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","varying vec3 vInstancePickingColor;","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,"#endif",e.ShaderChunk.clip_fragment,"#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif",t.picking_instancing_fragment,"}"].join("\n")},i=function(o){return{uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)}}]),fragmentShaderPars:[t.encode_float,"varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif"].join("\n"),fragmentShaderBody:["#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","\tfloat tmp = 0.5 + 0.5 * clipPos.z / clipPos.w;",o?"\tvec4 encode = packRGBAFace(tmp);":"\tvec4 encode = encode_float(tmp);","   gl_FragColor = encode;"].join("\n"),vertexShaderPars:["varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif"].join("\n"),vertexShaderBody:["#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif","   clipPos = gl_Position;"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,t.encode_float,"varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,"#endif",e.ShaderChunk.clip_fragment,"#ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","   if ( alpha < ALPHATEST ) discard;","#endif","\t#ifdef PDSFX","\tfloat tmp = 0.5 + 0.5 * _DSclipPosition.z / _DSclipPosition.w;","\t#else","\tfloat tmp = 0.5 + 0.5 * clipPos.z / clipPos.w;","\t#endif",o?"\tvec4 encode = packRGBAFace(tmp);":"\tvec4 encode = encode_float(tmp);","   gl_FragColor = encode;","}"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinning_vertex,"#ifdef PDSFX",e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,"#else",e.ShaderChunk.default_vertex,"#endif","#ifdef USE_MAP_ALPHATEST","   vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif",e.ShaderChunk.clip_vertex,"   clipPos = gl_Position;",e.ShaderChunk.PDSFX_end_vertex,"#ifdef PDSFX_USE_MAP","vUv = uv;","#endif","}"].join("\n")}},r={uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector2(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector2(1,1)},bumpMap:{type:"t",value:null},bumpScale:{type:"f",value:1},offsetBumpMap:{type:"v2",value:new e.Vector2(0,0)},repeatBumpMap:{type:"v2",value:new e.Vector2(1,1)}}]),fragmentShaderPars:["varying vec3 normalView;"].join("\n"),fragmentShaderBody:["   vec3 normal = normalize( normalView );","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif","   gl_FragColor.xyz = normal * 0.5 + 0.5;"].join("\n"),vertexShaderPars:["varying vec3 normalView;"].join("\n"),vertexShaderBody:["   normalView = normalize( mvNormal );"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef USE_BUMPMAP","   /*#extension GL_OES_standard_derivatives : enable*/\n","varying vec2 vUv;","#ifndef PDSFX","varying vec3 vViewPosition;","#else","vec3 vViewPosition;","#endif",e.ShaderChunk.bumpmap_pars_fragment,"#endif","#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","varying vec2 vUv;","#endif","varying vec3 normalView;","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,e.ShaderChunk.PDSFX_viewNormal_fragment,"#ifdef USE_BUMPMAP","vViewPosition = -ComputeViewPosition();","#endif","#endif",e.ShaderChunk.clip_fragment,"   #ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","       if ( alpha < ALPHATEST ) discard;","   #endif","#ifdef PDSFX","   vec3 normal = ComputeViewNormal();","#else","   vec3 normal = normalize( normalView );","#endif","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif","   #ifdef USE_BUMPMAP","       normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );","   #endif","   gl_FragColor.xyz = normal * 0.5 + 0.5;","}"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,"varying vec3 normalView;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef USE_BUMPMAP","varying vec2 vUv;","#ifndef PDSFX","varying vec3 vViewPosition;","#endif","uniform vec2 offsetBumpMap;","uniform vec2 repeatBumpMap;","#endif","#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","varying vec2 vUv;","#endif",e.ShaderChunk.morphtarget_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.morphnormal_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.morphtarget_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,e.ShaderChunk.clip_vertex,"#ifdef PDSFX","transformedNormal = _viewTangentSpace.Normal;","#endif","   normalView = transformedNormal;","   #ifdef USE_MAP_ALPHATEST","vUvMap = uv * repeatAlphaMap.xy + offsetAlphaMap.xy;","   #endif","   #ifdef USE_BUMPMAP","vUv = uv * repeatBumpMap.xy + offsetBumpMap.xy;","vViewPosition = -mvPosition.xyz;","   #endif",e.ShaderChunk.PDSFX_end_vertex,"#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","vUv = uv;","#endif","}"].join("\n")},n=function(o,a){o||(a=!1);var i=o?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","gl_FragColor.xy = normalToOct22(normal);","#else","gl_FragColor.xyz = normalize(normal) * 0.5 + 0.5;","#endif"].join("\n"):["   gl_FragColor.x = normalToOct24(normal);","#ifdef USE_NEWSSLR","   gl_FragColor.z = roughness;","#else","   gl_FragColor.z = reflectionCoef;","#endif"].join("\n"),r=o?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","gl_FragColor.xy = normalToOct22(normal);","#else","gl_FragColor.xyz = normalize(normal) * 0.5 + 0.5;","#endif"].join("\n"):["   gl_FragColor.x = normalToOct24(normal);","float roughnessValue = roughness;","#ifdef USE_ROUGHNESSMAP","roughnessValue = texture2D(roughnessMap, uvToUse).r;","#endif","#ifdef USE_GLOSSINESSMAP","roughnessValue = 1.0 - texture2D(glossinessMap, uvToUse).r;","#endif","#ifdef USE_NEWSSLR","gl_FragColor.z = min(max(roughnessValue, 0.025),0.975);","#else","   gl_FragColor.z = reflectionCoef;","#endif"].join("\n");return{uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector2(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector2(1,1)},bumpMap:{type:"t",value:null},bumpScale:{type:"f",value:1},offsetBumpMap:{type:"v2",value:new e.Vector2(0,0)},repeatBumpMap:{type:"v2",value:new e.Vector2(1,1)},normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new e.Vector2(1,1)},reflectionCoef:{type:"f",value:0},roughness:{type:"f",value:0},roughnessMap:{type:"t",value:null},glossinessMap:{type:"t",value:null}}]),fragmentShaderPars:[a?t.decalNormalStencilDepth:"","vec2 normalToOct22(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","return floor((2047.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","}","float normalToOct24(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","vec2 compNormal = floor((4095.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","return compNormal.x * 4096.0 + compNormal.y;","}","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","uniform float reflectionCoef;","uniform float roughness;","varying vec3 normalView;","varying vec4 clipPos;"].join("\n"),fragmentShaderBody:["   #ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","       if ( alpha < ALPHATEST ) discard;","   #endif","   vec3 normal = normalView;","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif",i,a?"gl_FragColor.xy = normalToOct22(normal); gl_FragColor.z = decalStencilValue;":"","   gl_FragColor.w = 0.5 + 0.5 * clipPos.z / clipPos.w;",o?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","float convertedDepth = 8388608.0 * gl_FragColor.w;","gl_FragColor.z = floor(convertedDepth / 4096.0);","gl_FragColor.w = mod(convertedDepth, 4096.0);","#endif"].join("\n"):""].join("\n"),vertexShaderPars:["varying vec3 normalView;","varying vec4 clipPos;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif"].join("\n"),vertexShaderBody:["   normalView = normalize( mvNormal );","   #ifdef USE_MAP_ALPHATEST","vUvMap = uv * repeatAlphaMap.xy + offsetAlphaMap.xy;","   #endif","   clipPos = gl_Position;"].join("\n"),fragmentShader:[a?t.decalNormalStencilDepth:"","vec2 normalToOct22(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","return floor((2047.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","}",e.ShaderChunk.clip_pars_fragment,"float normalToOct24(in vec3 normal) {","float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);","float oNx = normal.x / manNorm;","float oNy = normal.y / manNorm;","if (normal.z < 0.0) {","float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);","float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);","oNx = tmpx;","oNy = tmpy;","}","vec2 compNormal = floor((4095.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);","return compNormal.x * 4096.0 + compNormal.y;","}","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef USE_BUMPMAP","varying vec2 vUv;","#ifndef PDSFX","varying vec3 vViewPosition;","#else","vec3 vViewPosition;","#endif",e.ShaderChunk.bumpmap_pars_fragment,"#endif","#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","varying vec2 vUv;","#endif","#if defined(USE_NORMALMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_GLOSSINESSMAP)","varying vec2 uvToUse;","#endif","#ifdef USE_NORMALMAP","   /*#extension GL_OES_standard_derivatives : enable*/\n","#ifndef PDSFX","varying vec3 vViewPosition;","#else","vec3 vViewPosition;","#endif",e.ShaderChunk.normalmap_pars_fragment,"#endif","uniform float roughness;","#ifdef USE_ROUGHNESSMAP","uniform sampler2D roughnessMap;","#endif","#ifdef USE_GLOSSINESSMAP","uniform sampler2D glossinessMap;","#endif","uniform float reflectionCoef;","#ifndef PDSFX","varying vec3 normalView;","varying vec4 clipPos;","#endif","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,e.ShaderChunk.PDSFX_viewNormal_fragment,"#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP)","vViewPosition = -ComputeViewPosition();","#endif","#endif",e.ShaderChunk.clip_fragment,"   #ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","       if ( alpha < ALPHATEST ) discard;","   #endif","#ifdef PDSFX","   vec3 normal = ComputeViewNormal();","#else","   vec3 normal = normalView;","#endif","   #ifdef DOUBLE_SIDED","       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","   #endif","#ifdef USE_NORMALMAP","normal = perturbNormal2Arb( -vViewPosition, normal );","#elif defined( USE_BUMPMAP )","       normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );","   #endif",r,a?"gl_FragColor.xy = normalToOct22(normal); gl_FragColor.z = decalStencilValue;":"","#ifdef PDSFX","   gl_FragColor.w = 0.5 + 0.5 * _DSclipPosition.z / _DSclipPosition.w;","#else","   gl_FragColor.w = 0.5 + 0.5 * clipPos.z / clipPos.w;","#endif",o?["#if !defined(RENDER_TO_FLOAT_TEXTURE)","float convertedDepth = 8388608.0 * gl_FragColor.w;","gl_FragColor.z = floor(convertedDepth / 4096.0);","gl_FragColor.w = mod(convertedDepth, 4096.0);","#endif"].join("\n"):"","}"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,"#ifndef PDSFX","varying vec3 normalView;","varying vec4 clipPos;","#endif","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef USE_BUMPMAP","varying vec2 vUv;","#ifndef PDSFX","varying vec3 vViewPosition;","#endif","uniform vec2 offsetBumpMap;","uniform vec2 repeatBumpMap;","#endif","#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","varying vec2 vUv;","#endif","#if defined(USE_NORMALMAP) && !defined(PDSFX)","\tvarying vec3 vViewPosition;","#endif","#if defined(USE_NORMALMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_GLOSSINESSMAP)","varying vec2 uvToUse;","#endif",e.ShaderChunk.morphtarget_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.morphnormal_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.morphtarget_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,e.ShaderChunk.clip_vertex,"#ifdef PDSFX","transformedNormal = _viewTangentSpace.Normal;","#endif","#ifdef USE_MAP_ALPHATEST","vUvMap = uv * repeatAlphaMap.xy + offsetAlphaMap.xy;","#endif","#ifdef USE_BUMPMAP","vUv = uv * repeatBumpMap.xy + offsetBumpMap.xy;","#ifndef PDSFX","vViewPosition = -mvPosition.xyz;","#endif","#endif","#if defined(USE_NORMALMAP) && !defined(PDSFX)","vViewPosition = -mvPosition.xyz;","#endif","#if defined(USE_NORMALMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_GLOSSINESSMAP)","uvToUse = uv;","#endif","#ifndef PDSFX","normalView = transformedNormal;","clipPos = gl_Position;","#endif",e.ShaderChunk.PDSFX_end_vertex,"#if defined(PDSFX_USE_MAP) && !defined(USE_BUMPMAP)","vUv = uv;","#endif","}"].join("\n")}},l={uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector2(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector2(1,1)}}]),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"varying vec2 vUv;","varying vec2 vUv2;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,"#endif",e.ShaderChunk.clip_fragment,"   #ifdef USE_MAP_ALPHATEST","   #ifdef ALPHA_CHANNEL","       float alpha = texture2D( map, vUvMap ).r;","   #else","       float alpha = texture2D( map, vUvMap ).w;","   #endif","       if ( alpha < ALPHATEST ) discard;","   #endif","   gl_FragColor = vec4(vUv.xy, vUv2.xy);","}"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,"varying vec2 vUv;","varying vec2 vUv2;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif",e.ShaderChunk.morphtarget_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.morphnormal_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.morphtarget_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,e.ShaderChunk.clip_vertex,"   #ifdef USE_MAP_ALPHATEST","vUvMap = uv * repeatAlphaMap.xy + offsetAlphaMap.xy;","   #endif",e.ShaderChunk.PDSFX_end_vertex,"vUv = uv;","vUv2 = uv2;","}"].join("\n")};return{NormalDepthIoRRoughness:n(!1),NormalDepth:n(!0),DecalNormalStencilDepth:n(!0,!0),Normal:r,Depth:i(!1),DepthRGBA:i(!0),PickingFragment:o,PickingFragmentInstancing:a,TextureCoordinate:l,Chunks:t}}),define("Shaders/DeferredShaders",["DS/Shaders/DeferredShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/DeferredShaders"),e}),define("DS/Shaders/DefaultShaders",[],function(){"use strict";var e=["uniform int mappingType;","uniform mat3 mappingNormTransformation;","uniform mat4 mappingObjTransformation;","uniform mat3 mappingUVTransformation;","uniform int mappingTransformSemantic;","mat4 mappingTranspose(in mat4 m){","vec4 i0 = m[0];","vec4 i1 = m[1];","vec4 i2 = m[2];","vec4 i3 = m[3];","mat4 outMatrix = mat4(","vec4(i0.x, i1.x, i2.x, i3.x),","vec4(i0.y, i1.y, i2.y, i3.y),","vec4(i0.z, i1.z, i2.z, i3.z),","vec4(i0.w, i1.w, i2.w, i3.w));","return outMatrix;","}","vec2 applyMappingOperator(in vec2 inUV, in vec3 pos, in vec3 norm, in int type, inout vec3 outTangent,inout vec3 outBinormal) {","vec2 outUV = inUV;","mat4 invMappingObjTransformation = mappingTranspose(mappingObjTransformation);","vec3 x = vec3(invMappingObjTransformation[0]);","vec3 y = vec3(invMappingObjTransformation[1]);","vec3 z = vec3(invMappingObjTransformation[2]);","vec3 localpos = (mappingObjTransformation * vec4(pos, 1.0)).xyz; ","vec3 localnorm = (mappingObjTransformation * vec4(norm, 0.0)).xyz; ","if (type == 1) {","outUV = localpos.xy;","outTangent = x;","outBinormal = y;","} else if (type == 2) {","float radius3d = max(0.000001,length(localpos.xyz));","float z_by_radius3d = localpos.z / radius3d;","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0) {","thetaMapping = atan(localpos.y, localpos.x);}","float phiMapping   = asin(z_by_radius3d );","float u=thetaMapping*radius3d;","float v=phiMapping*radius3d;","outUV = vec2(u, v);","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","float cos_phi = cos(phiMapping);","float sin_phi = z_by_radius3d;","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;","} else if (type == 6) {","float radius3d = max(0.000001,length(localpos.xyz));","float z_by_radius3d = localpos.z / radius3d;","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0) {","thetaMapping = atan(localpos.y, localpos.x);}","float phiMapping   = asin(z_by_radius3d );","float u=thetaMapping/3.14159;","float v=phiMapping/3.14159;","outUV = vec2(u, v);","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","float cos_phi = cos(phiMapping);","float sin_phi = z_by_radius3d;","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = -cos_theta*sin_phi*x - sin_theta*sin_phi*y + cos_phi*z;","} else if (type == 3) {","vec3 absolute_normal = abs(localnorm);","float maxima_normal = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));","#ifdef DSPBR","vec3 n = normalize(localnorm);","if(dot(localpos,localnorm)<0.0){","n = -n;","}","#else","vec3 n = normalize(localpos);","#endif","vec3 s;","s.x = n.x >= -0.0000001 ?  1.0 : -1.0;","s.y = n.y >= -0.0000001 ? -1.0 :  1.0;","s.z = n.z >= -0.0000001 ?  1.0 : -1.0;","if(maxima_normal == absolute_normal.x){","outUV = vec2(s.x * localpos.y, localpos.z );","outTangent = s.x * y;","outBinormal = z;","}","else if(maxima_normal == absolute_normal.y){","outUV = vec2(s.y * localpos.x, localpos.z );","outTangent = s.y * x;","outBinormal = z;","}","else{","outUV = vec2(s.z * localpos.x, localpos.y );","outTangent = s.z * x;","outBinormal = y;","}","} else if (type == 4) {","vec3 n = localnorm;","#ifdef DSPBR","if(dot(localpos,localnorm)<0.0){","n = -n;","}","#endif","float radius2d = length(localpos.xy);","vec3 absolute_normal = abs(n);","float maxima_normal = max(absolute_normal.x, max(absolute_normal.y, absolute_normal.z));","if(maxima_normal == absolute_normal.z){","float s = localpos.z >= 0.0 ?  1.0 : -1.0;","outUV.x = s * localpos.x;","outUV.y = localpos.y;","outTangent = s * x;","outBinormal = y;","}else{","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0){","thetaMapping = atan(localpos.y, localpos.x);}","float u=thetaMapping*radius2d;","outUV = vec2(u , localpos.z);","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = z;","}","} else if (type == 5) {","float radius2d = length(localpos.xy);","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0) {","thetaMapping = atan(localpos.y, localpos.x);}","float u=thetaMapping*radius2d;","outUV = vec2(u, localpos.z);","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = z;","} else if (type == 7) {","float radius2d = length(localpos.xy);","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0) {","thetaMapping = atan(localpos.y, localpos.x);}","float u=thetaMapping/3.14159;","outUV = vec2(u, localpos.z/(radius2d*3.14159));","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = z;","} else if (type == 8) {","float thetaMapping=0.0;","if (localpos.y!=0.0 || localpos.x!=0.0) {","thetaMapping = atan(localpos.y, localpos.x);}","float u=thetaMapping/3.14159;","outUV = vec2(u, localpos.z);","float cos_theta = cos(thetaMapping);","float sin_theta = sin(thetaMapping);","outTangent = -sin_theta*x + cos_theta*y;","outBinormal = z;","}","if(type >0){","outTangent= normalize(cross(outBinormal,norm));","outBinormal= normalize(cross(norm,outTangent));","}","if (mappingTransformSemantic==1){","   return (mappingUVTransformation * vec3(outUV, 1.0)).xy;","}else{","   return outUV;","}","}","vec2 applyMappingOperator(in vec2 inUV, in vec3 pos, in vec3 norm, inout vec3 outTangent,inout vec3 outBinormal) {","return applyMappingOperator(inUV, pos, norm, mappingType, outTangent, outBinormal);","}","vec2 applyMappingOperator(in vec2 inUV, in vec3 pos, in vec3 norm, in int type) {","vec3 bogusTangent;","vec3 bogusBinormal;","return applyMappingOperator(inUV,pos,norm,type, bogusTangent,bogusBinormal);","}","vec2 applyMappingOperator(in vec2 inUV, in vec3 pos, in vec3 norm) {","vec3 bogusTangent;","vec3 bogusBinormal;","return applyMappingOperator(inUV,pos,norm,bogusTangent,bogusBinormal);","}"].join("\n");return{model_view_transformation_vertex:["#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","auxPosMV = position;","#ifdef BILLBOARD","auxPosMV = (simpleNodeData.billboardMatrix * vec4(auxPosMV,1.0)).xyz;","#endif","#ifdef FIXED_SIZE","auxPosMV *= simpleNodeData.fixedSizeScale;","#ifdef FIXED_SIZE_CENTER","auxPosMV += simpleNodeData.fixedSizeScaleCenter * fixedSizeCenterRatio.xyz;","#endif","#endif","vec4 mvPosition = computeModelViewPosition(auxPosMV);"].join("\n"),model_view_projection_transformation_vertex:["#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","auxPosMVP = position;","#ifdef BILLBOARD","auxPosMVP = (simpleNodeData.billboardMatrix * vec4(auxPosMVP,1.0)).xyz;","#endif","#ifdef FIXED_SIZE","auxPosMVP *= simpleNodeData.fixedSizeScale;","#ifdef FIXED_SIZE_CENTER","auxPosMVP += simpleNodeData.fixedSizeScaleCenter * fixedSizeCenterRatio.xyz;","#endif","#endif","gl_Position = projectionMatrix * computeModelViewPosition(auxPosMVP);"].join("\n"),model_view_normal_vertex:["#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","vec3 mvNormal = normal;","#if defined(BILLBOARD)","mvNormal = (simpleNodeData.billboardMatrix * vec4(mvNormal,0.0)).xyz;","#endif","if (use_normal_matrix)","mvNormal = normalMatrix * mvNormal;","else {","mvNormal = vec3(modelViewMatrix * vec4(mvNormal, 0.0));","}","mvNormal = normalize( mvNormal );"].join("\n"),getModelViewTransformationChunk:function(e,t){return["#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","auxPosMVPFunc = "+t+";","#ifdef BILLBOARD","auxPosMVPFunc = simpleNodeData.billboardMatrix * auxPosMVPFunc;","#endif","#ifdef FIXED_SIZE","auxPosMVPFunc.xyz *= simpleNodeData.fixedSizeScale;","#ifdef FIXED_SIZE_CENTER","auxPosMVPFunc.xyz += auxPosMVPFunc.w * simpleNodeData.fixedSizeScaleCenter * fixedSizeCenterRatio.xyz;","#endif","#endif",e+" = computeModelViewPosition(auxPosMVPFunc.xyz);"].join("\n")},getModelViewUnitVectorTransformationChunk:function(e,t){return["#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","MVUnit = "+t+";","#if defined(BILLBOARD)","MVUnit = (simpleNodeData.billboardMatrix * vec4(MVUnit,0.0)).xyz;","#endif",e+" = vec3(modelViewMatrix * vec4(MVUnit, 0.0));"].join("\n")},map_pars_vertex:["#if defined(MAPPING_OPERATOR)",e,"#endif","#if defined (MAPPING_OPERATOR) && !defined (USE_MAPPING_OPERATOR_VERTEX)","varying vec3 localPosition;","varying vec3 localNormal;","#endif"].join("\n"),map_pars_fragment:["#if defined (MAPPING_OPERATOR)",e,"#endif","#if defined (USE_MAPPING_OPERATOR_FRAGMENT) && defined (MAPPING_OPERATOR)","varying vec3 localPosition;","varying vec3 localNormal;","#endif"].join("\n"),rgbe_sample_methods:["vec4 texture2DFromRGBE(sampler2D textureSampler, vec2 uv) {","vec4 texelRGBE = texture2D(textureSampler, uv);","float exponent = pow(2.0, 255.0 * texelRGBE.w - 128.0);","return vec4(texelRGBE.xyz * exponent, 1.0);","}","vec4 texture2DBilinearFromRGBE(sampler2D textureSampler, vec2 uv, vec2 textureSize, vec2 texelSize) {","vec2 st = uv * textureSize - 0.5;","vec2 iuv = (floor(st) + vec2(0.5)) * texelSize;","vec2 fuv = fract(st);","vec4 tl = texture2DFromRGBE(textureSampler, iuv);","vec4 tr = texture2DFromRGBE(textureSampler, iuv + vec2(texelSize.x, 0.0));","vec4 bl = texture2DFromRGBE(textureSampler, iuv + vec2(0.0, texelSize.y));","vec4 br = texture2DFromRGBE(textureSampler, iuv + vec2(texelSize.x, texelSize.y));","vec4 tA = mix(tl, tr, fuv.x);","vec4 tB = mix(bl, br, fuv.x);","return mix(tA, tB, fuv.y);","}","vec2 get2DBilinearFromRGBEwBOXUV(in vec2 iuv, in vec2 offset, in vec2 factor, in vec2 start) {","float x = mod(iuv.x + offset.x, factor.x) + start.x;","float y = iuv.y + offset.y;","return vec2(x,y);","}","vec4 texture2DBilinearFromRGBEwBox(sampler2D textureSampler, vec4 uvBox, vec2 uv, vec2 textureSize, vec2 texelSize) {","#ifdef NON_REPEAT_IBL_SAMPLING","return texture2DBilinearFromRGBE(textureSampler, uvBox.xy, textureSize, texelSize);","#else","vec2 start = uvBox.xy;","vec2 factor = uvBox.zw;","vec2 fetchUVToUse = factor* uv + start;","vec2 st = fetchUVToUse * textureSize - 0.5;","vec2 iuv = (floor(st) + vec2(0.5)) * texelSize;","vec2 fuv = fract(st);","vec4 tl = texture2DFromRGBE(textureSampler, get2DBilinearFromRGBEwBOXUV(iuv, vec2(0.0, 0.0), factor, start));","vec4 tr = texture2DFromRGBE(textureSampler, get2DBilinearFromRGBEwBOXUV(iuv, vec2(texelSize.x, 0.0), factor, start));","vec4 bl = texture2DFromRGBE(textureSampler, get2DBilinearFromRGBEwBOXUV(iuv, vec2(0.0, texelSize.y), factor, start));","vec4 br = texture2DFromRGBE(textureSampler, get2DBilinearFromRGBEwBOXUV(iuv, vec2(texelSize.x, texelSize.y), factor, start));","vec4 tA = mix(tl, tr, fuv.x);","vec4 tB = mix(bl, br, fuv.x);","return mix(tA, tB, fuv.y);","#endif","}"].join("\n"),normal_viewposition_pars_vertex:["#ifndef PDSFX","varying vec3 vViewPosition;","varying vec3 vNormal;","#endif"].join("\n"),normal_viewposition_vertex:["#ifndef PDSFX","vNormal = normalize( transformedNormal );","vViewPosition = -mvPosition.xyz;","#else","transformedNormal = _viewTangentSpace.Normal;","#endif"].join("\n"),normal_viewposition_pars_fragment:["#ifndef PDSFX","varying vec3 vViewPosition;","varying vec3 vNormal;","#else","vec3 vViewPosition;","#endif"].join("\n"),normal_viewposition_fragment:["#ifdef PDSFX","vec3 normal = _DSvNormal;","#else","vec3 normal = normalize( vNormal );","#endif","#ifdef DOUBLE_SIDED","normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","#endif","vec3 viewPosition = normalize( vViewPosition );","vec3 vPos = vViewPosition;"].join("\n")}}),define("DS/Shaders/MirrorShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t={uniforms:{tDiffuse:{type:"t",value:null},texelSize:{type:"v2",value:new e.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform vec2 texelSize;","vec4 blur(){","vec4 sum = vec4(0);","int nbSamples = 0;","float pixelSizeX = 1.0 / texelSize.x;","float pixelSizeY = 1.0 / texelSize.y;","for( int i = -10; i < 10; i+=2 ){","for( int j = -10; j < 10; j+=2 ){","sum += texture2D( tDiffuse, vUv + vec2(float(i)*pixelSizeX,float(j)*pixelSizeY) );","nbSamples++;","}","}","return sum / float(nbSamples);","}","void main() {","gl_FragColor = blur();","} "].join("\n")};return{blend:{defines:{POSTPRO:1},uniforms:{tReflectedScene:{type:"t",value:null},tDiffuse:{type:"t",value:null},reflectivity:{type:"f",value:.3}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","#if (POSTPRO == 1)","uniform sampler2D tDiffuse;","#endif","uniform sampler2D tReflectedScene;","uniform float reflectivity;","void main() {","vec4 reflectedScene = texture2D(tReflectedScene, vUv);","float blend = 1.0 - reflectivity;","float srcAlpha = (1.0 - blend) * reflectedScene.w;","#if (POSTPRO == 1)","vec4 mirrorPlane = texture2D(tDiffuse, vUv);","vec3 mirrorPlaneColor = mirrorPlane.xyz;","vec3 mirrorMix = (1.0 - blend) * reflectedScene.xyz + blend * mirrorPlaneColor;","gl_FragColor = vec4(mirrorMix * reflectedScene.w + mirrorPlaneColor * (1.0 - reflectedScene.w), srcAlpha + (1.0-srcAlpha)*mirrorPlane.w);","#else","gl_FragColor = vec4(reflectedScene.rgb, srcAlpha);","#endif","} "].join("\n")},reflectedScene:t}}),define("Shaders/MirrorShaders",["DS/Shaders/MirrorShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/MirrorShaders"),e}),define("DS/Shaders/PreComputeSDFFontIterativeShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t={defines:{},uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","float dist = texture2D(tDiffuse, vUv).r;","gl_FragColor = vec4(vec3(mod(10.0*dist, 1.0)), 1.0);","}"].join("\n")},o={defines:{},uniforms:{prevMap:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D prevMap;","varying vec2 vUv;","void main() {","vec4 texel = texture2D(prevMap, vUv);","float diff = length(texel.rg) - length(texel.ba);","diff = clamp(20.0 * diff, -1.0, 1.0);","float toto = clamp(0.5 * diff + 0.5, 0.0, 1.0);","gl_FragColor = vec4(vec3(toto), 1.0);","}"].join("\n")},a={defines:{},uniforms:{textureSize:{type:"v2",value:new e.Vector2(256,256)},invSize:{type:"v2",value:new e.Vector2(1/256,1/256)},tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["/*#extension GL_OES_standard_derivatives : enable*/","uniform sampler2D tDiffuse;","uniform vec2 textureSize;","uniform vec2 invSize;","varying vec2 vUv;","float aastep (float threshold , float value) {","float afwidth = 0.7 * length ( vec2(dFdx(value), dFdy(value)));","return smoothstep (threshold - afwidth, threshold + afwidth, value);","}","void main() {","vec2 uv = vUv * textureSize;","vec2 uv00 = floor(uv - vec2(0.5));","vec2 uvlerp = uv - uv00 - vec2(0.5);","vec2 st00 = (uv00 + vec2(0.5)) * invSize;","vec4 D00 = texture2D(tDiffuse, st00);","vec4 D10 = texture2D(tDiffuse, st00 + vec2(invSize.x, 0.0));","vec4 D01 = texture2D(tDiffuse, st00 + vec2(0.0, invSize.y));","vec4 D11 = texture2D(tDiffuse, st00 + vec2(invSize.x, invSize.y));","vec2 D00_10 = vec2(D00.r, D10.r)*255.0-128.0 + vec2(D00.g, D10.g)*(255.0/256.0);","vec2 D01_11 = vec2(D01.r, D11.r)*255.0-128.0 + vec2(D01.g, D11.g)*(255.0/256.0);","vec2 D0_1 = mix(D00_10, D01_11, uvlerp.y);","float D = mix(D0_1.x, D0_1.y, uvlerp.x);","float g = aastep(0.0, D);","gl_FragColor = vec4(vec3(g), 1.0);","}"].join("\n")},i={defines:{},uniforms:{prevMap:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D prevMap;","varying vec2 vUv;","void main() {","float texel = texture2D(prevMap, vUv).r;","gl_FragColor = vec4(texel > 0.99999 ? vec2(9999.0) : vec2(0.0), texel > 0.99999 ? vec2(0.0) : vec2(9999.0));","}"].join("\n")},r={defines:{},uniforms:{invSize:{type:"v2",value:new e.Vector2(1/256,1/256)},prevMap:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D prevMap;","uniform vec2 invSize;","varying vec2 vUv;","void ComputeDistance(vec2 uv, vec2 offset, inout vec4 bestseed) {","vec2 newvec = uv + offset;","vec4 newseed = texture2D(prevMap, newvec);","if (newvec.x >= 0.0 && newvec.x <= 1.0 && newvec.y >= 0.0 && newvec.y <= 1.0) {","newseed.rg += offset;","newseed.ba += offset;","if (length(newseed.rg) < length(bestseed.rg)) {","bestseed.rg = newseed.rg;","}","if (length(newseed.ba) < length(bestseed.ba)) {","bestseed.ba = newseed.ba;","}","}","}","void main() {","vec4 bestseed = texture2D(prevMap, vUv);","ComputeDistance(vUv, vec2(-invSize.x, -invSize.y), bestseed);","ComputeDistance(vUv, vec2(-invSize.x,        0.0), bestseed);","ComputeDistance(vUv, vec2(-invSize.x,  invSize.y), bestseed);","ComputeDistance(vUv, vec2(0.0, -invSize.y),        bestseed);","ComputeDistance(vUv, vec2(0.0,  invSize.y),        bestseed);","ComputeDistance(vUv, vec2(invSize.x, -invSize.y), bestseed);","ComputeDistance(vUv, vec2(invSize.x,        0.0), bestseed);","ComputeDistance(vUv, vec2(invSize.x,  invSize.y), bestseed);","gl_FragColor = bestseed;","}"].join("\n")},n={defines:{},uniforms:{tDiffuse1:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse1;","varying vec2 vUv;","void main() {","vec4 texel = texture2D(tDiffuse1, vUv);","gl_FragColor = vec4(texel);","}"].join("\n")},l={uniforms:{tDiffuse2:{type:"t",value:null},tileMin:{type:"v2",value:new e.Vector2(0,0)},tileMax:{type:"v2",value:new e.Vector2(64,64)},realTileMax:{type:"v2",value:new e.Vector2(64,64)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 tileMin;","uniform vec2 tileMax;","uniform vec2 realTileMax;","uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","vec2 uv = vUv;","if (uv.x < tileMin.x) { discard; }","vec2 tiledUV = (uv - tileMin) / (tileMax - tileMin);","tiledUV.y = 1.0 - tiledUV.y;","gl_FragColor = texture2D(tDiffuse2, tiledUV);","}"].join("\n")};return{ComputeSDFFont:{defines:{},uniforms:{prevMap:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(1/256,1/256)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["const float SQRT2 = 1.41421356;","uniform sampler2D prevMap;","uniform vec2 invSize;","varying vec2 vUv;","void main() {","#if defined(OUTSIDE)","float value = texture2D(prevMap, vUv).r;","#else","float value = texture2D(prevMap, vUv).r;","#endif","float qv = invSize.x;","float qd = SQRT2 * invSize.x;","#if defined(OUTSIDE)","float lValue  = texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y)).r + qv;","float rValue  = texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y)).r + qv;","float bValue  = texture2D(prevMap, vec2(vUv.x, vUv.y - invSize.y)).r + qv;","float tValue  = texture2D(prevMap, vec2(vUv.x, vUv.y + invSize.y)).r + qv;","float tlValue = texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y + invSize.y)).r + qd;","float trValue = texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y + invSize.y)).r + qd;","float blValue = texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y - invSize.y)).r + qd;","float brValue = texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y - invSize.y)).r + qd;","if (vUv.x - invSize.x > 0.0) { value = min(lValue, value); }","if (vUv.x + invSize.x < 1.0) { value = min(rValue, value); }","if (vUv.y - invSize.y > 0.0) { value = min(bValue, value); }","if (vUv.y + invSize.y < 1.0) { value = min(tValue, value); }","if (vUv.x - invSize.x > 0.0 && vUv.y + invSize.y < 1.0) { value = min(tlValue, value); }","if (vUv.x + invSize.x < 1.0 && vUv.y + invSize.y < 1.0) { value = min(trValue, value); }","if (vUv.x - invSize.x > 0.0 && vUv.y - invSize.y > 0.0) { value = min(blValue, value); }","if (vUv.x + invSize.x < 1.0 && vUv.y - invSize.y > 0.0) { value = min(brValue, value); }","#else","float lValue  = mix(1.0, texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y)).r + qv, inScreen4.x);","float rValue  = mix(1.0, texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y)).r + qv, inScreen4.y);","float bValue  = mix(1.0, texture2D(prevMap, vec2(vUv.x, vUv.y - invSize.y)).r + qv, inScreen4.z);","float tValue  = mix(1.0, texture2D(prevMap, vec2(vUv.x, vUv.y + invSize.y)).r + qv, inScreen4.w);","float tlValue = mix(1.0, texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y + invSize.y)).r + qd, inScreen4.x * inScreen4.w);","float trValue = mix(1.0, texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y + invSize.y)).r + qd, inScreen4.y * inScreen4.w);","float blValue = mix(1.0, texture2D(prevMap, vec2(vUv.x - invSize.x, vUv.y - invSize.y)).r + qd, inScreen4.x * inScreen4.z);","float brValue = mix(1.0, texture2D(prevMap, vec2(vUv.x + invSize.x, vUv.y - invSize.y)).r + qd, inScreen4.y * inScreen4.z);","#endif","gl_FragColor = vec4(vec3(value), 1.0);","}"].join("\n")},ComputeSDFFontSeed:i,ComputeSDFFontFlood:r,ComputeSDFFontDisplay:t,ComputeSDFFontDisplayResult:a,ComputeSDFFontMerge:o,Nothing:n,MergeTiles:l}}),define("DS/Shaders/SkyScatteringShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t,o,a=new e.Vector3(.0058,.0135,.0331),i=new e.Vector3(1.474,1.8504,1.91198),r=new e.Vector2(1/256,1/64),n=new e.Vector4(1/8,1/32,1/128,1/32),l=new e.Vector4(8,32,128,32),s=["float SafeSqrt(float a) {","return sqrt(max(a, 0.0));","}","float ClampDistance(float d) {","return max(d, 0.0);","}","float ClampCosine(float mu) {","return clamp(mu, -1.0, 1.0);","}","float ClampRadius(float r) {","return clamp(r, atmBottom, atmTop);","}","float GetTextureCoordFromUnitRange(float x, float inv_size) {","return 0.5 * inv_size + x * (1.0 - inv_size);","}","float GetUnitRangeFromTextureCoord(float u, float inv_size) {","return (u - 0.5 * inv_size) / (1.0 - inv_size);","}","float DistanceToTopAtmosphereBoundary(float r, float mu) {","float discriminant = r * r * (mu * mu - 1.0) + atmTop * atmTop;","return ClampDistance(-r * mu + SafeSqrt(discriminant));","}","float DistanceToBottomAtmosphereBoundary(float r, float mu) {","float discriminant = r * r * (mu * mu - 1.0) +atmBottom * atmBottom;","return ClampDistance(-r * mu - SafeSqrt(discriminant));","}","float GetLayerDensity(densityProfileLayer layer, float altitude) {","float density = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;","return clamp(density, 0.0, 1.0);","}","float GetProfileDensity(densityProfile profile, float altitude) {","return altitude < profile.layer0.width ?","GetLayerDensity(profile.layer0, altitude) :","GetLayerDensity(profile.layer1, altitude);","}","bool RayIntersectsGround(float r, float mu) {","return mu < 0.0 && r * r * (mu * mu - 1.0) + atmBottom * atmBottom >= 0.0;","}","vec2 GetTransmittanceTextureUvFromRMu(float r, float mu,vec2 invSize) {","float H = sqrt(atmTop * atmTop - atmBottom * atmBottom);","float rho = SafeSqrt(r * r - atmBottom * atmBottom);","float d = DistanceToTopAtmosphereBoundary( r, mu);","float d_min = atmTop - r;","float d_max = rho + H;","float x_mu = (d - d_min) / (d_max - d_min);","float x_r = rho / H;","return vec2(GetTextureCoordFromUnitRange(x_mu, invSize.x),GetTextureCoordFromUnitRange(x_r, invSize.y));","}","vec3 GetTransmittanceToTopAtmosphereBoundary(sampler2D transmittance_texture,float r, float mu,vec2 invSize) {","vec2 uv = GetTransmittanceTextureUvFromRMu(r, mu,invSize);","return vec3(texture2D(transmittance_texture, uv));","}"].join("\n"),f=["const float PI = 3.14159265358979323846264;","vec4 GetScatteringTextureUvwzFromRMuMuSNu(float r, float mu, float mu_s, float nu,bool ray_r_mu_intersects_ground) {","float H = sqrt(atmTop * atmTop - atmBottom * atmBottom);","float rho = SafeSqrt(r * r - atmBottom * atmBottom);","float u_r = GetTextureCoordFromUnitRange(rho / H, 1.0/scatterSize.w);","float r_mu = r * mu;","float discriminant = r_mu * r_mu - r * r + atmBottom * atmBottom;","float u_mu;","if (ray_r_mu_intersects_ground) {","float d = -r_mu - SafeSqrt(discriminant);","float d_min = r - atmBottom;","float d_max = rho;","u_mu = 0.5 - 0.5 * GetTextureCoordFromUnitRange(d_max == d_min ? 0.0 :(d - d_min) / (d_max - d_min), 2.0/scatterSize.z);","} else {","float d = -r_mu + SafeSqrt(discriminant + H * H);","float d_min = atmTop - r;","float d_max = rho + H;","u_mu = 0.5 + 0.5 * GetTextureCoordFromUnitRange((d - d_min) / (d_max - d_min), 2.0/scatterSize.z);","}","float d = DistanceToTopAtmosphereBoundary(atmBottom, mu_s);","float d_min = atmTop - atmBottom;","float d_max = H;","float a = (d - d_min) / (d_max - d_min);","float mu_s_min=-0.207912;","float A =-2.0 * mu_s_min * atmBottom / (d_max - d_min);","float u_mu_s = GetTextureCoordFromUnitRange(max(1.0 - a / A, 0.0) / (1.0 + a), 1.0/scatterSize.y);","float u_nu = (nu + 1.0) / 2.0;","return vec4(u_nu, u_mu_s,1.0- u_mu, u_r);","}","vec3 GetExtrapolatedSingleMieScattering(vec4 scattering) {","return scattering.rgb * scattering.a / max(scattering.r,0.0001) *","(rayleighScattering.r / rayleighScattering);","}","vec4 texture4D(sampler2D scattering_texture,float r, float mu, float mu_s, float nu){","float h       = sqrt(max(0.0, atmTop * atmTop - atmBottom * atmBottom));","float rho     = sqrt(max(0.0, r * r - atmBottom * atmBottom));","float rmu     = r * mu;","float delta   = rmu * rmu - r * r + atmBottom * atmBottom;","vec4  cst     = rmu < 0.0 && delta > 0.0 ? vec4(1.0, 0.0, 0.0, 0.5 - 0.5 / scatterSize.z) : vec4(-1.0, h*h, h, 0.5 + 0.5 / scatterSize.z);","float uR      = 0.5 / scatterSize.w + rho / h * (1.0 - 1.0 / scatterSize.w);","float uMu     = cst.w + (rmu * cst.x + sqrt(max(0.0, delta + cst.y)) ) / (rho + cst.z) * (0.5 - 1.0 / scatterSize.z);","float uMuS    = 0.5 / scatterSize.y + (atan(max(mu_s, -0.1975) * 5.34962349919) / 1.1 + 0.74) * 0.5 * (1.0 - 1.0 / scatterSize.y);","float uNu     = 0.5 * (nu + 1.0);","vec4 uvwz = vec4(uNu,uMuS,1.0-uMu,uR);","float tex_coord_x = uvwz.x * (scatterSize.x-1.0);","float tex_x = floor(tex_coord_x);","float lerpx = tex_coord_x - tex_x;","float tex_coord_y = uvwz.w * (scatterSize.w-1.0);","float tex_y = floor(tex_coord_y);","float lerpy = tex_coord_y - tex_y;","vec2 uv0 = vec2((tex_x + uvwz.z) / scatterSize.x,((tex_y + uvwz.y) / scatterSize.w));","vec2 uv1 = vec2((tex_x + 1.0 + uvwz.z) / scatterSize.x,((tex_y + uvwz.y) / scatterSize.w));","vec2 uv2 = vec2((tex_x + uvwz.z) / scatterSize.x,((tex_y +1.0 + uvwz.y) / scatterSize.w));","vec2 uv3 = vec2((tex_x + 1.0 + uvwz.z) / scatterSize.x,((tex_y +1.0+ uvwz.y) / scatterSize.w));","vec4 combined_scattering = (texture2D(scattering_texture, uv0) * (1.0 - lerpx) + texture2D(scattering_texture, uv1) * lerpx)*(1.0 -lerpy)","+(texture2D(scattering_texture, uv2) * (1.0 - lerpx) + texture2D(scattering_texture, uv3) * lerpx)*(lerpy);","return combined_scattering;","}","vec4 GetCombinedScattering(sampler2D scattering_texture, float r, float mu, float mu_s, float nu,inout vec3 nightHaze) {","float muHorizon = -sqrt(max(0.0, 1.0 - (atmBottom / r) * (atmBottom /r)));","vec3 surfacePos = vec3(0.0,0.0,atmBottom);","nightHaze = vec3(1.0-abs(mu - muHorizon));","nightHaze = nightHazeColor*pow(abs(nightHaze), vec3(nightHazeSkyPower)) * nightHazeSkyIntensity;","nightHaze *= smoothstep(atmTop-atmBottom, 0.0, viewAltitude);","nightHaze = clamp(nightHaze,0.0,1.0);","return texture4D(scattering_texture,r,mu,mu_s,nu);","}","float RayleighPhaseFunction(float nu) {","float k = 3.0 / (16.0 * PI);"," return k * (1.0 + nu * nu);","}","float MiePhaseFunction(float g, float nu) {","float k = 3.0 / (8.0 * PI);","float a = (1.0 - g * g);","float b = (2.0 + g * g);","float c = 1.0 + g * g;","float d = 2.0 * g * nu;","float e = (1.0 + nu * nu);","return k * e * a * pow(abs(c - d), -1.5) / b;","}","float OpticalDepth(float iH, float iR, float iMu, float iD) {","float a     = sqrt(max(0.0, (0.5/iH)*iR));","vec2  a01   = a*vec2(iMu, iMu+iD/iR);","vec2  a01s  = sign(a01);","vec2  a01sq = a01*a01;","float x     = a01s.y > a01s.x ? exp(a01sq.x) : 0.0; ","vec2  y     = a01s / (2.3193*abs(a01) + sqrt(max(vec2(0.0), 1.52*a01sq + 4.0))) * vec2(1.0, exp(-iD/iH*(iD/(2.0*iR)+iMu)));","return sqrt(max(0.0, (6.2831*iH)*iR)) * exp((atmBottom-iR)/iH) * (x + dot(y, vec2(1.0, -1.0)));","}","vec3 AnalyticTransmittance(float iR, float iMu, float iD) {","return exp(-rayleighScattering * OpticalDepth(g_HR, iR, iMu, iD) - mieScattering * OpticalDepth(g_HM, iR, iMu, iD));","}","bool IntersectAtmosphere(vec3 pos,vec3 dir,inout float distToAtmosphere,inout float distInAtmosphere){","vec3 l = -pos;","float l2 = dot(l,l);","float s = dot(l,dir);","float r2 = atmTop*atmTop;","if (l2<=r2){","float m2 = l2 - (s * s);","float q  = sqrt(max(0.0, r2 - m2));","distInAtmosphere = s + q;","distToAtmosphere = 0.0;","return true;","}else if(s>=0.0){","float m2 = l2 - (s * s);","if(m2 <= r2){","float q = sqrt(max(0.0, r2 - m2));","distToAtmosphere = s - q;","distInAtmosphere = (s + q) - distToAtmosphere;","return true;","}else{","return false;","}","}else{","return false;","}","}","vec4 getScatteringFromWorldParams(sampler2D scattering_texture,vec3 point,vec3 view_ray,vec3 sun_direction,float distance, inout vec3 transmittance,inout vec3 nightHaze){","float r = length(point);","float rmu = dot(point, view_ray);","float mu = rmu / r;","float mu_s = dot(point, sun_direction) / r;","float nu = dot(view_ray, sun_direction);","transmittance = AnalyticTransmittance(r, mu, distance);","vec4 scattering;","scattering = GetCombinedScattering(scattering_texture,r, mu, mu_s, nu,nightHaze);","return scattering;","}","vec3 ApplyMieRayleigh(inout vec4 scattering,float mu_s,float nu){","float SunSize     = 10000.0;","float sunFactor   = 0.001*SunSize;","float g_MieBoost  = 0.0;","float lerpFactor  = (max((1.0-sunFactor), nu)-(1.0-sunFactor))*(1.0/sunFactor);","float theta       = smoothstep(0.0, 2.0, pow(lerpFactor, 8.0));","float sunBoost    = 2.0+g_MieBoost*theta;","float sunScatteringIntensity = 60.0;","scattering.w *= smoothstep(0.0,0.02,mu_s);","vec3 single_mie_scattering = GetExtrapolatedSingleMieScattering(scattering);","vec3 InScattering =max((scattering.xyz * RayleighPhaseFunction(nu) + single_mie_scattering * MiePhaseFunction(miePhaseG, nu) * sunBoost),0.0);","InScattering *= sunScatteringIntensity;","return InScattering*0.6;","}","vec3 GetSkyScattering(sampler2D transmittance_texture,sampler2D scattering_texture,inout vec3 cameraPos, vec3 view_ray,vec3 sun_direction,inout vec3 nightHaze) {","float distance_to_atmosphere = 0.0;","float distance_in_atmosphere = 0.0;","bool goThroughAtmosphere = IntersectAtmosphere(cameraPos,view_ray,distance_to_atmosphere,distance_in_atmosphere);","if(!goThroughAtmosphere){","return vec3(0.0);","}","cameraPos = cameraPos + view_ray * distance_to_atmosphere;","vec3 transmittance;","vec4 scattering = getScatteringFromWorldParams(scattering_texture,cameraPos,view_ray,sun_direction,distance_in_atmosphere,transmittance,nightHaze);","float nu = dot(view_ray, sun_direction);","float mu_s = dot(cameraPos, sun_direction) / length(cameraPos);","return ApplyMieRayleigh(scattering,mu_s,nu);","}","vec3 GetSkyScatteringWithDepth(sampler2D scattering_texture,inout vec3 cameraPos, vec3 view_ray,vec3 sun_direction,vec3 pointPos, inout vec3 attenuation) {","float distance_to_atmosphere = 0.0;","float distance_in_atmosphere = 0.0;","bool goThroughAtmosphere = IntersectAtmosphere(cameraPos,view_ray,distance_to_atmosphere,distance_in_atmosphere);","float distanceToObject = distance(cameraPos, pointPos);","if(!goThroughAtmosphere || distanceToObject<distance_to_atmosphere){","return vec3(0.0);","}","cameraPos = cameraPos + view_ray * distance_to_atmosphere;","distanceToObject -= distance_to_atmosphere;","vec3 nightHaze;","vec4 scattering = getScatteringFromWorldParams(scattering_texture,cameraPos,view_ray,sun_direction,distance_in_atmosphere,attenuation,nightHaze);","float mu_s = dot(cameraPos, sun_direction) / length(cameraPos);","float nu = dot(view_ray, sun_direction);","if(distanceToObject < distance_in_atmosphere){","float heightEndPos = length(pointPos);","float musEndPos    = dot(pointPos, sun_direction) / heightEndPos;","float muEndPos = dot(pointPos, view_ray) / heightEndPos;","vec4 scatteringPoint = getScatteringFromWorldParams(scattering_texture,pointPos,view_ray,sun_direction,distanceToObject,attenuation,nightHaze);","scattering = max(scattering - attenuation.rgbr * scatteringPoint,0.0);","}","return ApplyMieRayleigh(scattering,mu_s,nu);","}","vec4 GetHDREncoded(vec3 color) {","float value = max(color.r, max(color.g, color.b));","int exponent = 0;","float mantissa = 0.0;","if (value > 1.0) {","for (int i = 1; i <= 127; i++) {","value /= 2.0;","exponent++;","if (value < 1.0) { break; }","}","} else if (value < 1.0) {","int j = 1;","for (int i = 1; i <= 129; i++) {","value *= 2.0;","exponent--;","if (value > 1.0) { j = 0; break; }","}","value /= 2.0;","exponent++;","if (j > 0) {","color = vec3(0.0);","exponent = 0;","}","}","return vec4(color * pow(2.0, float(-exponent)), float(exponent + 128) / 255.0);","}","vec3 Irradiance(sampler2D tIrr, float iAlt, float iCosSunZenithAngle) {","float uR    = (iAlt - atmBottom) / (atmTop - atmBottom);","float uMuS  = (iCosSunZenithAngle + 0.2) / (1.0 + 0.2);","return texture2D(tIrr, vec2(uMuS, 1.0-uR)).rgb;","}","vec3 Transmittance(sampler2D tTrans, float iAlt, float iCosRayZenithAngle) {","float uR, uMu;","uR  = sqrt(max(0.0, (iAlt - atmBottom) / (atmTop - atmBottom)));","uMu = atan((iCosRayZenithAngle + 0.15) / (1.0 + 0.15) * tan(1.5)) / 1.5;","return texture2D(tTrans, vec2(uMu, 1.0-uR)).rgb;","}","vec3 GetReflectedLight(sampler2D tIrradiance, sampler2D tTransmittance, vec3 iSurfaceColor, vec3 iSurfacePos, vec3 iCameraPos, vec3 sunDirection, vec3 iAttenuation){","float surfacePosHeight\t= length(iSurfacePos);","float dotSunSphere      = dot(iSurfacePos, sunDirection) / surfacePosHeight;","float musSurfacePos     = clamp(dotSunSphere,0.0,1.0);","vec3 irradianceSurface  = Irradiance(tIrradiance, surfacePosHeight, musSurfacePos);","vec3 attenuationSunLight = Transmittance(tTransmittance, surfacePosHeight, musSurfacePos);","float sunScatteringIntensity = 60.0;","vec3 reflectedLight = iSurfaceColor * (attenuationSunLight + irradianceSurface) * sunScatteringIntensity * (0.1 / PI);","float inSpaceFactor = smoothstep(atmBottom+(atmTop-atmBottom)*0.2, atmTop, surfacePosHeight);","reflectedLight = mix(reflectedLight, iSurfaceColor, inSpaceFactor);","float cameraAlt               = length(iCameraPos) - atmBottom;","float planetSunlightFactor    = smoothstep(-0.05,  0.05, dotSunSphere);","float planetSunlightFactorBis = smoothstep(-0.05,  0.2,  dotSunSphere);","float bisFactor               = smoothstep(300.0, 1000.0, cameraAlt);","planetSunlightFactor = (1.0-bisFactor)*planetSunlightFactor + planetSunlightFactorBis*bisFactor;","vec3  fogColor    = nightHazeColor * nightHazeFogIntensity;","float fogDensity  = 0.009;","float fogFactor   = 1.0 - 1.0 / pow(exp(length(iSurfacePos-iCameraPos) * fogDensity), 2.0);","fogFactor *= smoothstep(100.0, 0.0, cameraAlt);","iSurfaceColor = (1.0-fogFactor) * iSurfaceColor + fogFactor * fogColor;","return planetSunlightFactor * reflectedLight + (1.0-planetSunlightFactor) * iSurfaceColor;","}"].join("\n"),c=["struct densityProfileLayer {","float width;","float exp_term;","float exp_scale;","float linear_term;","float constant_term;","};","struct densityProfile {","densityProfileLayer layer0;","densityProfileLayer layer1;","};","densityProfile rayleighDensity;","densityProfile mieDensity;"].join("\n"),v=["densityProfileLayer flR;","flR.width=0.0;","flR.exp_term=0.0;","flR.exp_scale=0.0;","flR.linear_term=0.0;","flR.constant_term=0.0;","densityProfileLayer slR;","slR.width=0.0;","slR.exp_term=1.0;","slR.exp_scale=-0.000125;","slR.linear_term=0.0;","slR.constant_term=0.0;","rayleighDensity.layer0 = flR;","rayleighDensity.layer1 = slR;","densityProfileLayer flM;","flM.width=0.0;","flM.exp_term=0.0;","flM.exp_scale=0.0;","flM.linear_term=0.0;","flM.constant_term=0.0;","densityProfileLayer slM;","slM.width=0.0;","slM.exp_term=1.0;","slM.exp_scale=-0.000833333;","slM.linear_term=0.0;","slM.constant_term=0.0;","mieDensity.layer0 = flM;","mieDensity.layer1 = slM;"].join("\n");return{ComputeScattering:(t=["uniform sampler2D tTrans;","uniform vec4 invSize;","uniform vec2 transInvSize;","uniform float atmTop;","uniform float atmBottom;","uniform vec3 rayleighScattering;","uniform float mieScattering;","uniform vec3 solarIrradiance;","uniform float angularRadius;"].join("\n"),o=["void GetRMuMuSNuFromScatteringTextureUvwz(vec4 uvwz, inout float r, inout float mu, inout float mu_s,inout float nu, inout bool ray_r_mu_intersects_ground) {","float H = sqrt(atmTop * atmTop - atmBottom * atmBottom);","float rho =H * GetUnitRangeFromTextureCoord(uvwz.w, invSize.w);","r = sqrt(rho * rho + atmBottom * atmBottom);","if (uvwz.z < 0.5) {","float d_min = r - atmBottom;","float d_max = rho;","float d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(1.0 - 2.0 * uvwz.z, invSize.z * 2.0);","mu = d == 0.0 ? -1.0 : ClampCosine(-(rho * rho + d * d) / (2.0 * r * d));","ray_r_mu_intersects_ground = true;","} else {","float d_min = atmTop - r;","float d_max = rho + H;","float d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(2.0 * uvwz.z - 1.0, invSize.z * 2.0);","mu = d == 0.0 ? 1.0 :ClampCosine((H * H - rho * rho - d * d) / (2.0 * r * d));","ray_r_mu_intersects_ground = false;","}","float x_mu_s =GetUnitRangeFromTextureCoord(uvwz.y, invSize.y);","float d_min = atmTop - atmBottom;","float d_max = H;","float mu_s_min=-0.207912;","float A =-2.0 * mu_s_min * atmBottom / (d_max - d_min);","float a = (A - x_mu_s * A) / (1.0 + x_mu_s * A);","float d = d_min + min(a, A) * (d_max - d_min);","mu_s = d == 0.0 ? 1.0 : ClampCosine((H * H - d * d) / (2.0 * atmBottom * d));","nu = ClampCosine(uvwz.x * 2.0 - 1.0);","}","void GetRMuMuSNuFromScatteringTextureFragCoord(vec2 frag_coord,inout float r,inout float mu,inout float mu_s,inout float nu,inout bool ray_r_mu_intersects_ground) {","frag_coord.x /=(invSize.x*invSize.z);","frag_coord.y /=(invSize.y*invSize.w);","float frag_coord_nu =floor(frag_coord.x *invSize.z);","float frag_coord_mu =mod(frag_coord.x, 1.0/invSize.z);","float frag_coord_r =floor(frag_coord.y *invSize.y);","float frag_coord_mu_s =mod(frag_coord.y, 1.0/invSize.y);","vec4 uvwz =vec4(frag_coord_nu, frag_coord_mu_s, frag_coord_mu, frag_coord_r)*invSize; ","GetRMuMuSNuFromScatteringTextureUvwz( uvwz, r, mu, mu_s, nu, ray_r_mu_intersects_ground);","nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)),"," mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));","}","vec3 GetTransmittance(sampler2D transmittance_texture,float r, float mu, float d, bool ray_r_mu_intersects_ground) {","float r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));","float mu_d = ClampCosine((r * mu + d) / r_d);","if (ray_r_mu_intersects_ground) {","return min(","GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r_d, -mu_d,transInvSize) /","GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r, -mu,transInvSize),","vec3(1.0));","} else {","return min(","GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r, mu,transInvSize) /","GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r_d, mu_d,transInvSize),","vec3(1.0));","}","}","vec3 GetTransmittanceToSun(sampler2D transmittance_texture,float r, float mu_s) {","float sin_theta_h = atmBottom / r;","float cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));","return GetTransmittanceToTopAtmosphereBoundary(transmittance_texture, r, mu_s,transInvSize) *","smoothstep(-sin_theta_h * angularRadius,","sin_theta_h * angularRadius,","mu_s - cos_theta_h);","}","void ComputeSingleScatteringIntegrand(sampler2D transmittance_texture,float r, float mu, float mu_s, float nu, float d,bool ray_r_mu_intersects_ground,inout vec3 rayleigh, inout float mie) {","float r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));","float mu_s_d = ClampCosine((r * mu_s + d * nu) / r_d);","vec3 transmittance =GetTransmittance(transmittance_texture, r, mu, d,ray_r_mu_intersects_ground) *","GetTransmittanceToSun(transmittance_texture, r_d, mu_s_d);","rayleigh = transmittance * GetProfileDensity(rayleighDensity, r_d - atmBottom);","mie = (transmittance * GetProfileDensity(mieDensity, r_d - atmBottom)).x;","}","float DistanceToNearestAtmosphereBoundary(float r, float mu, bool ray_r_mu_intersects_ground) {","if (ray_r_mu_intersects_ground) {","return DistanceToBottomAtmosphereBoundary(r, mu);","} else {","return DistanceToTopAtmosphereBoundary(r, mu);","}","}","void ComputeSingleScattering(sampler2D transmittance_texture,float r, float mu, float mu_s, float nu,bool ray_r_mu_intersects_ground,inout vec3 rayleigh, inout float mie) {","const float SAMPLE_COUNT = 50.0;","float dx =DistanceToNearestAtmosphereBoundary(r, mu,ray_r_mu_intersects_ground) / SAMPLE_COUNT;","vec3 rayleigh_sum = vec3(0.0);","float mie_sum = 0.0;","for (float i = 0.0; i <= SAMPLE_COUNT; ++i) {","float d_i = i * dx;","vec3 rayleigh_i;","float mie_i;","ComputeSingleScatteringIntegrand(transmittance_texture,r, mu, mu_s, nu, d_i, ray_r_mu_intersects_ground, rayleigh_i, mie_i);","float weight_i = (i == 0.0 || i == SAMPLE_COUNT) ? 0.5 : 1.0;","rayleigh_sum += rayleigh_i * weight_i;","mie_sum += mie_i * weight_i;","}","rayleigh = rayleigh_sum * dx * solarIrradiance * rayleighScattering;","mie = (mie_sum * dx * solarIrradiance * mieScattering).x;","}","void ComputeSingleScatteringTexture(sampler2D transmittance_texture,vec2 frag_coord,inout vec3 rayleigh,inout float mie) {","float r;","float mu;","float mu_s;","float nu;","bool ray_r_mu_intersects_ground;","GetRMuMuSNuFromScatteringTextureFragCoord( frag_coord,r, mu, mu_s, nu, ray_r_mu_intersects_ground);","ComputeSingleScattering( transmittance_texture,r, mu, mu_s, nu, ray_r_mu_intersects_ground, rayleigh, mie);","}"].join("\n"),{uniforms:{tTrans:{type:"t",value:null},invSize:{type:"v4",value:n},transInvSize:{type:"v2",value:r},atmTop:{type:"f",value:6470},atmBottom:{type:"f",value:6370},rayleighScattering:{type:"v3",value:a},mieScattering:{type:"f",value:.003996},angularRadius:{type:"f",value:.004675},solarIrradiance:{type:"v3",value:i}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[t,"varying vec2 vUv;",c,s,o,"void main() {",v,"vec3 rayleigh;","float mie;","ComputeSingleScatteringTexture(tTrans,vUv,rayleigh,mie);","gl_FragColor = vec4(rayleigh,mie);","}"].join("\n")}),ComputeTransmittance:function(){var t=["uniform vec2 invSize;","uniform float atmTop;","uniform float atmBottom;","uniform vec3 rayleighScattering;","uniform float mieScattering;","uniform float mieExtinction;","uniform float absorptionExtinction;"].join("\n"),o=["float ComputeOpticalLengthToTopAtmosphereBoundary( densityProfile profile,float r, float mu) {","const float SAMPLE_COUNT = 500.0;","float dx =DistanceToTopAtmosphereBoundary(r, mu) / SAMPLE_COUNT;","float result = 0.0;","for (float i = 0.0; i <= SAMPLE_COUNT; ++i) {","float d_i = i * dx;","float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);","float y_i = GetProfileDensity(profile, r_i - atmBottom);","float weight_i = i == 0.0 || i == SAMPLE_COUNT ? 0.5 : 1.0;","result += y_i * weight_i * dx;","}","return result;","}","vec3 ComputeTransmittanceToTopAtmosphereBoundary( float r, float mu) {","return exp(-(","rayleighScattering *","ComputeOpticalLengthToTopAtmosphereBoundary( rayleighDensity, r, mu) +","vec3(mieScattering) *","ComputeOpticalLengthToTopAtmosphereBoundary( mieDensity, r, mu)  ));","}","void GetRMuFromTransmittanceTextureUv(vec2 uv, inout float r,inout float mu) {","float x_mu = GetUnitRangeFromTextureCoord(uv.x, invSize.x);","float x_r = GetUnitRangeFromTextureCoord(uv.y, invSize.y);","float H = sqrt(atmTop * atmTop - atmBottom * atmBottom);","float rho = H * x_r;","r = sqrt(rho * rho + atmBottom * atmBottom);","float d_min = atmTop - r;","float d_max = rho + H;","float d = d_min + x_mu * (d_max - d_min);","mu = d == 0.0 ? 1.0 : (H * H - rho * rho - d * d) / (2.0 * r * d);","mu = ClampCosine(mu);","}","vec3 ComputeTransmittanceToTopAtmosphereBoundaryTexture(in vec2 frag_coord) {","float r;","float mu;","GetRMuFromTransmittanceTextureUv( frag_coord, r, mu);","return ComputeTransmittanceToTopAtmosphereBoundary(r, mu);","}"].join("\n");return{uniforms:{invSize:{type:"v2",value:r},atmTop:{type:"f",value:6470},atmBottom:{type:"f",value:6370},rayleighScattering:{type:"v3",value:a},mieScattering:{type:"f",value:.003996},mieExtinction:{type:"f",value:444e-8},absorptionExtinction:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[t,"varying vec2 vUv;",c,s,o,"void main() {",v,"vec3 res = ComputeTransmittanceToTopAtmosphereBoundaryTexture(vUv);","gl_FragColor = vec4(res,1.0);","}"].join("\n")}}(),RenderSky:function(){var t=["uniform sampler2D tTrans;","uniform sampler2D tIrr;","uniform sampler2D tScatter;","uniform vec3 sunDirection;","uniform float viewAltitude;","uniform vec4 scatterSize;","uniform vec2 transInvSize;","uniform float atmTop;","uniform float atmBottom;","uniform vec3 rayleighScattering;","uniform float mieScattering;","uniform float miePhaseG;","uniform vec3 nightHazeColor;","uniform float nightHazeSkyPower;","uniform float nightHazeSkyIntensity;","uniform float nightHazeFogIntensity;"].join("\n"),o=[].join("\n");return{uniforms:{tTrans:{type:"t",value:null},tIrr:{type:"t",value:null},tScatter:{type:"t",value:null},scatterSize:{type:"v4",value:l},transInvSize:{type:"v2",value:r},sunDirection:{type:"v3",value:new e.Vector3(-1,-1,1)},viewAltitude:{type:"f",value:1},atmTop:{type:"f",value:6470},atmBottom:{type:"f",value:6370},rayleighScattering:{type:"v3",value:a},mieScattering:{type:"f",value:.003996},miePhaseG:{type:"f",value:.8},nightHazeColor:{type:"v3",value:new e.Vector3(.25,.34,.49)},nightHazeSkyPower:{type:"f",value:.6},nightHazeSkyIntensity:{type:"f",value:.15},nightHazeFogIntensity:{type:"f",value:.15}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[t,"varying vec2 vUv;",c,"const float g_HR = 0.8*pow(10.0,7.0);","const float g_HM = 0.12*pow(10.0,7.0);","const float g_EpsilonInScatter = 0.004;",s,f,o,"void main() {",v,"vec3 camPos = vec3(0.0,0.0,atmBottom+viewAltitude);","vec3 sunDir = sunDirection;","sunDir = normalize(sunDir);","vec3 view_ray;","float phi = PI * (2.0 * vUv.x - 1.0);","float theta = PI * vUv.y;","view_ray.x = -sin(theta) * sin(phi);","view_ray.y = sin(theta) * cos(phi);","view_ray.z = -cos(theta);","view_ray = normalize(view_ray);","vec3 nightHaze;","vec3 scattering = GetSkyScattering(tTrans,tScatter,camPos,view_ray,sunDir,nightHaze);","vec3  sunColor  = vec3(0.9911, 0.8308, 0.6172);","float sunFactor = smoothstep(0.999956, 0.999957, dot(view_ray, sunDir));","vec3  sun       = sunFactor * sunColor * 60.0;","sun  *= min(sun.x,1.0);","float r = length(camPos);","float rmu = dot(camPos, view_ray);","float mu = rmu / r;","bool intersectGround = RayIntersectsGround(r, mu);","if(intersectGround){","sun  = vec3(0.0,0.0,0.0);","}","vec3 color = scattering+nightHaze+sun;","gl_FragColor = GetHDREncoded(color);","}"].join("\n")}}(),PostProcessScattering:function(){var t=["uniform float near;","uniform vec4 screenToView;","uniform mat4 invView;"].join("\n"),o=["uniform float near;","uniform float far;","uniform sampler2D tDiffuse;","uniform sampler2D tDepth;","uniform sampler2D tTrans;","uniform sampler2D tIrr;","uniform sampler2D tScatter;","uniform vec3 sunDirection;","uniform float viewAltitude;","uniform vec4 scatterSize;","uniform vec2 transInvSize;","uniform float atmTop;","uniform float atmBottom;","uniform vec3 rayleighScattering;","uniform float mieScattering;","uniform float miePhaseG;","uniform vec3 nightHazeColor;","uniform float nightHazeSkyPower;","uniform float nightHazeSkyIntensity;","uniform float nightHazeFogIntensity;","uniform float texturesLoaded;"].join("\n"),i=[].join("\n");return{uniforms:{near:{type:"f",value:null},far:{type:"f",value:null},screenToView:{type:"v4",value:null},invView:{type:"m4",value:null},tDiffuse:{type:"t",value:null},tDepth:{type:"t",value:null},tTrans:{type:"t",value:null},tIrr:{type:"t",value:null},tScatter:{type:"t",value:null},scatterSize:{type:"v4",value:l},transInvSize:{type:"v2",value:r},sunDirection:{type:"v3",value:new e.Vector3(-1,-1,1)},viewAltitude:{type:"f",value:1},atmTop:{type:"f",value:6470},atmBottom:{type:"f",value:6370},rayleighScattering:{type:"v3",value:a},mieScattering:{type:"f",value:.003996},miePhaseG:{type:"f",value:.8},nightHazeColor:{type:"v3",value:new e.Vector3(.25,.34,.49)},nightHazeSkyPower:{type:"f",value:.6},nightHazeSkyIntensity:{type:"f",value:.15},nightHazeFogIntensity:{type:"f",value:.15},texturesLoaded:{type:"f",value:0}},vertexShader:[t,"varying vec2 vUv;","varying vec4 vRay;","void main() {","   vec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );","   vUv = pos.xy * vec2( 0.5 ) + 0.5;","   vRay = invView * vec4(screenToView.xy + vUv*screenToView.zw,-near,0.0);","   gl_Position = pos;","}"].join("\n"),fragmentShader:[o,"varying vec2 vUv;","varying vec4 vRay;",c,"const float g_HR = 0.8*pow(10.0,7.0);","const float g_HM = 0.12*pow(10.0,7.0);","const float g_EpsilonInScatter = 0.004;",s,f,i,"void main() {","vec3 camPos = vec3(0.0,0.0,atmBottom+viewAltitude);","vec3 sunDir = sunDirection;","sunDir = normalize(sunDir);","vec3 viewRay = vRay.xyz;","viewRay = normalize(viewRay);","vec4 color = texture2D(tDiffuse,vUv);","if(texturesLoaded==1.0){","vec4 normalDepth = texture2D( tDepth, vUv );","float zNDC = 2.0*normalDepth.w - 1.0;","float viewZ = zNDC *(2.0*near*far + far - near )/(near+far);","float rayScale = viewZ/near;","vec3 rayToPoint = vRay.xyz * rayScale;","rayToPoint /= 1000000.0;","vec3 position = camPos + rayToPoint;","vec3 attenuation = vec3(1.0);","vec3 nightHaze = vec3(0.0);","vec3 scattering = vec3(0.0);","float r = length(camPos);","float rmu = dot(camPos, viewRay);","float mu = rmu / r;","bool intersectGround = RayIntersectsGround(r, mu);","if(zNDC>-1.0){","scattering = GetSkyScatteringWithDepth(tScatter,camPos,viewRay,sunDir,position,attenuation);","color.xyz = GetReflectedLight(tIrr,tTrans,color.xyz,position,camPos,sunDir,attenuation);","}","color.xyz += scattering;","}","gl_FragColor = color;","}"].join("\n")}}()}}),define("DS/Shaders/DownSamplingShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t,o,a;return{DownSampling:(t=2,o="tDiffuse"+(t||""),a={uniforms:{invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D "+o+";","varying vec2 vUv;","void main() {","gl_FragColor = texture2D("+o+", vUv);","}"].join("\n")},a.uniforms[o]={type:"t",value:null},a),DownSamplingBlur:function(t){var o="tDiffuse"+(t||""),a={uniforms:{invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D "+o+";","varying vec2 vUv;","void main() {","vec3 result = vec3(0.0);","float total = 0.0;","for (int i = -2; i <= 2; ++i) {","for (int j = -2; j <= 2; ++j) {","vec2 offset = 1.0 * invSize * vec2(float(i), float(j));","float weight = 1.0 / (1.0 + dot(offset, offset));","result += weight * texture2D("+o+", vUv + offset).xyz;","total += weight;","}","}","result /= total;","gl_FragColor = vec4(result, 1.0);","}"].join("\n")};return a.uniforms[o]={type:"t",value:null},a}(2),DownSamplingBlurWithAlpha:function(t){var o="tDiffuse"+(t||""),a={uniforms:{invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D "+o+";","varying vec2 vUv;","void main() {","vec4 result = vec4(0.0);","float totalRGB = 0.0;","float totalA = 0.0;","for (int i = -2; i <= 2; ++i) {","for (int j = -2; j <= 2; ++j) {","vec2 offset = 1.0 * invSize * vec2(float(i), float(j));","float weightA = 1.0;","float weightRGB = 1.0 / (1.0 + dot(offset, offset));","vec4 sampledValue = texture2D("+o+", vUv + offset).rgba;","result += vec4(weightRGB * sampledValue.rgb, weightA * sampledValue.a);",,"totalRGB += weightRGB;","totalA += weightA;","}","}","result.rgb /= totalRGB;","result.a /= totalA;","gl_FragColor = result;","}"].join("\n")};return a.uniforms[o]={type:"t",value:null},a}(2),MergeMips:function(t){for(var o={tDiffuse1:{type:"t",value:null}},a=["uniform sampler2D tDiffuse1;"],i=["if (vUv.y < 0.5) {","gl_FragColor = texture2D(tDiffuse1, vec2(vUv.x, 2.0 * vUv.y));","}"],r=0;r<t;r++){var n=r+2,l=Math.pow(2,-n),s=1/l;o["tDiffuse"+n]={type:"t",value:null},a.push("uniform sampler2D tDiffuse"+n+";");var f=1-l,c=2*l;i.push("else if (vUv.y < "+f+" && vUv.x < "+c+") {"),i.push("vec2 uv = vec2(float("+s/2+") * vUv.x, float("+s+") * (vUv.y - "+(1-c)+"));"),i.push("gl_FragColor = texture2D(tDiffuse"+n+", uv);"),i.push("}")}return i.push("else {"),i.push("gl_FragColor = vec4(vec3(0.0), 1.0);"),i.push("}"),a=a.join("\n"),i=i.join("\n"),{uniforms:o,vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[a,"varying vec2 vUv;","void main() {",i,"}"].join("\n")}}}}),define("DS/Shaders/DisplayShadowMapsShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},tDiffuse5:{type:"t",value:null},offset:{type:"v2",value:new e.Vector2(.505,.01)},scale:{type:"f",value:.485},offset2:{type:"v2",value:new e.Vector2(.01,.01)},scale2:{type:"f",value:.485},offset3:{type:"v2",value:new e.Vector2(.505,.505)},scale3:{type:"f",value:.485},offset4:{type:"v2",value:new e.Vector2(.01,.505)},scale4:{type:"f",value:.485}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform sampler2D tDiffuse5;","uniform vec2 offset;","uniform float scale;","uniform vec2 offset2;","uniform float scale2;","uniform vec2 offset3;","uniform float scale3;","uniform vec2 offset4;","uniform float scale4;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv2 = (vUv - offset) / scale;","vec2 vUv3 = (vUv - offset2) / scale2;","vec2 vUv4 = (vUv - offset3) / scale3;","vec2 vUv5 = (vUv - offset4) / scale4;","if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse2, vUv2 );","    gl_FragColor = vec4(vec3(normalDepth.w), 0.7); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse3, vUv3 );","    gl_FragColor = vec4(vec3(normalDepth.w), 0.7); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse4, vUv4 );","    gl_FragColor = vec4(vec3(normalDepth.w), 0.7); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse5, vUv5 );","    gl_FragColor = vec4(vec3(normalDepth.w), 0.7); return;","}","}"].join("\n")}}),define("Shaders/DisplayShadowMapsShader",["DS/Shaders/DisplayShadowMapsShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/DisplayShadowMapsShader"),e}),define("DS/Shaders/SSAOShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t={computeVertexPositionVS:["vec4 normalDepth = texture2D( tNormalDepth, vUv );","#ifndef RENDER_TO_FLOAT_TEXTURE","float z = (normalDepth.z * 4096.0 + normalDepth.w) / 8388608.0;","#else","float z = normalDepth.w;","#endif","if ( z < 0.1 ) return;","vec2 xy = vUv * 2.0 - 1.0;","vec4 vertexPositionProjected = vec4(xy, 2.0 * z - 1.0, 1.0);","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","vertexPositionVS.w = 1.0;"].join("\n"),computeNormal:["#ifndef RENDER_TO_FLOAT_TEXTURE","vec3 normal = decodeOct22Normal(normalDepth.xy);","#else","vec3 normal = normalDepth.xyz * 2.0 - 1.0;","#endif"].join("\n")},o={tNormalDepth:{type:"t",value:null},realProjectionMatrix:{type:"m4",value:new e.Matrix4},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},screenRatio:{type:"f",value:.5},nbSamples:{type:"i",value:16},tau:{type:"f",value:7},tRandomTexture:{type:"t",value:null},radius:{type:"f",value:.5},minRadius:{type:"f",value:.01},maxRadius:{type:"f",value:.2},thresholdAngle:{type:"f",value:.045},screenSize:{type:"v2",value:new e.Vector2(800,600)},invSize:{type:"v2",value:new e.Vector2(1/800,1/600)},maxRadiusInPixels:{type:"f",value:30},attenuation:{type:"f",value:1},quality:{type:"i",value:0}},a=["varying vec2 vUv;","void main() {","  vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),i=["uniform mat4 realProjectionMatrix;","uniform mat4 realProjectionMatrixInverse;","uniform float screenRatio;","uniform vec2 screenSize;","uniform vec2 invSize;","uniform float radius;","uniform float minRadius;","uniform float maxRadius;","uniform int nbSamples;","uniform float tau;","uniform float thresholdAngle;","uniform float attenuation;","#define MAX_SAMPLES 32","uniform sampler2D tNormalDepth;","varying vec2 vUv;","const int kernelSize = 32;","const float PI = 3.14159265358979323846264;","const float one_over_tan_225 = 2.414213562373095;","vec2 getScreenPos(vec3 pos) {","  vec4 offset = realProjectionMatrix * vec4(pos, 1.0);","  offset.xy /= offset.w;","  offset.xy = offset.xy * 0.5 + 0.5;","  return offset.xy;","}","vec3 decodeOct22Normal(in vec2 iEncodedNormal) {","float x = iEncodedNormal.x/2047.0*2.0 - 1.0;","float y = iEncodedNormal.y/2047.0*2.0 - 1.0;","vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));","if (v.z <= 0.0) {","vec2 sgn = signNotZero(v.xy);","v.xy = - abs(v.yx)*sgn + sgn;","}","return normalize(v);","}","bool computePointVS(vec2 iUV, out vec3 posVS) {","vec4 normalDepth = texture2D(tNormalDepth, iUV);","#ifndef RENDER_TO_FLOAT_TEXTURE","float z = (normalDepth.z * 4096.0 + normalDepth.w) / 8388608.0;","#else","float z = normalDepth.w;","#endif","bvec4 inScreen4 = bvec4(iUV.x >= 0.0, iUV.x <= 1.0, iUV.y >= 0.0, iUV.y <= 1.0);","bvec2 inScreen = bvec2(all(inScreen4), z > 0.0);","if (!all(inScreen)) return false;","vec2 xy = iUV * 2.0 - 1.0;","vec4 vertexPositionProjected = vec4(xy, 2.0 * z - 1.0, 1.0);","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","posVS = vertexPositionVS.xyz;","return true;","}","float ComputeAO(const vec3 iSamplePos, vec3 iPos, vec3 iNormal, float iAtt) {","vec3 dir = iSamplePos - iPos;","float l2    = dot(dir, dir);","float angle = dot(iNormal, dir) / sqrt(l2);","float occ = 0.0;","if (l2 > 0.0  && angle > thresholdAngle) {","occ = 1.0 / (1.0 + l2 * iAtt);","angle = 1.0 - angle;","angle *= angle;","angle *= angle;","occ *= (1.0 - angle);","}","return occ;","}"].join("\n"),r=["  gl_FragColor = vec4(1.0);",t.computeVertexPositionVS,t.computeNormal,"  vec3 origin = vertexPositionVS.xyz;","float projRadius = 0.5 * realProjectionMatrix[0][0] * radius;","if (realProjectionMatrix[3][3] < 0.5) {","projRadius /= -origin.z;","}","float scaleRadius = 1.0;","#ifdef ADAPTATIVE_RADIUS","scaleRadius = min(maxRadius, max(projRadius, minRadius)) / projRadius;","#endif","  float newRadius = scaleRadius * radius;","float att = attenuation / (newRadius * newRadius);","  float occ = 0.0;"].join("\n"),n={defines:{ADAPTATIVE_RADIUS:!0},uniforms:{prevMap:{type:"t",value:null},numIteration:{type:"i",value:0},firstSample:{type:"i",value:0}},vertexShader:a,fragmentShader:["uniform sampler2D prevMap;","uniform sampler2D tRandomTexture;","uniform int numIteration;","uniform int firstSample;","float random(vec3 scale, float seed) {","  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","float Random1D(float seed) {","return random(vec3(12.9898, 78.233, 151.7182), seed);","}","float HaltonSequenceShift(int n, int base, float shift) {","float val = 0.0;","float invBase = 1.0 / float(base);","float invBi = invBase;","for (int i = 0; i < 32; i++) {","if (n == 0) break;","float d_i = mod(float(n), float(base));","val += float(d_i) * invBi;","n /= base;","invBi *= invBase;","}","return fract(val + shift);","}","vec3 LowDiscrepancy3DShift(int index, vec2 shift) {","int yy = index / 64;","float xx = mod(float(index), 64.0);","vec2 offset = vec2(xx, float(yy));","vec3 res = texture2D(tRandomTexture, 0.015625 * (offset + 0.5)).xyz;","return fract(res + shift.xyx);","}","vec3 uniformlySampleSphere(vec2 E) {","  float z = 1.0 - 2.0 * E.x;","  float r = sqrt(1.0 - z * z);","  float angle = 6.283185307179586 * E.y;","  return vec3(r * cos(angle), r * sin(angle), z);","}","vec4 precomputeRandom1D(vec2 shift, int index) {","vec3 E = LowDiscrepancy3DShift(firstSample + index + 1, shift);","return vec4(uniformlySampleSphere(E.xy), E.z);","}",i,"float ComputeSampleSSAO(vec3 iSamplingPt, vec3 iPos, vec3 iNormal, float iRadius, float iAtt, float iRandomZ) {","float occ = 0.0;","float delta = iRadius * sign(dot(iSamplingPt, iNormal)) * iRandomZ;","vec3  newPt = delta * iSamplingPt + iPos;","vec2 coord = getScreenPos(newPt);","vec2 tmp = coord - vUv;","coord = vUv + sign(tmp.xy) * max(invSize.xy, abs(tmp.xy));","vec3 samplePos;","if (computePointVS(coord, samplePos) && (samplePos.z > newPt.z)) {","occ = ComputeAO(samplePos, iPos, iNormal, iAtt);","}","return occ;","}","void main() {",r,"vec2 shift = vec2(Random1D(gl_FragCoord.x + gl_FragCoord.y), Random1D(gl_FragCoord.x * gl_FragCoord.y));","for (int i = 0; i < MAX_SAMPLES; i++) {","if (i == nbSamples) {","break;","}","vec4 randVec = precomputeRandom1D(shift, i);","occ += ComputeSampleSSAO(randVec.xyz, origin, normal, newRadius, att, randVec.w);","}","occ /= max(float(nbSamples), 1.0);","float prevAO = texture2D( prevMap, vUv ).r * float(numIteration);","float curAO = 1.0 - occ;","float total = float(numIteration) + 1.0;","float totalAO = (prevAO + curAO) / total;","gl_FragColor = vec4(vec3(totalAO), 1.0);","}"].join("\n")},l={defines:{ADAPTATIVE_RADIUS:!0},uniforms:{samplingPoints:{type:"fv",value:[]}},vertexShader:a,fragmentShader:["uniform sampler2D tRandomTexture;","uniform vec3 samplingPoints[32];","float modI(float a, float b) {","float m = a - floor((a + 0.5) / b) * b;","return floor(m + 0.5);","}","vec3 precomputeRandom1D(vec2 coords) {","vec2 s = 0.2 * (vec2(modI(coords.x, 5.0), modI(coords.y, 5.0)) + 0.5);","return texture2D(tRandomTexture, s).xyz;","}",i,"float ComputeSampleSSAO(vec3 iSamplingPt, vec3 iPos, vec3 iNormal, float iRadius, float iAtt, vec3 iRandomVec) {","float occ = 0.0;","vec3 rayDir = reflect(iSamplingPt, iRandomVec);","float delta = iRadius * sign(dot(rayDir, iNormal));","vec3  newPt = delta * rayDir + iPos;","vec2 coord = getScreenPos(newPt);","vec2 tmp = coord - vUv;","coord = vUv + sign(tmp.xy) * max(invSize.xy, abs(tmp.xy));","vec3 samplePos;","if (computePointVS(coord, samplePos) && (samplePos.z > newPt.z)) {","occ = ComputeAO(samplePos, iPos, iNormal, iAtt);","}","return occ;","}","void main() {",r,"vec3 randVec = precomputeRandom1D(gl_FragCoord.xy);","for (int i = 0; i < MAX_SAMPLES; i++) {","if (i == nbSamples) {","break;","}","occ += ComputeSampleSSAO(samplingPoints[i], origin, normal, newRadius, att, randVec);","}","occ /= max(float(nbSamples), 1.0);","gl_FragColor = vec4(vec3(1.0 - occ), 1.0);","}"].join("\n")};return Object.assign(n.uniforms,o),Object.assign(l.uniforms,o),{Iterative:n,Direct:l}}),define("Shaders/SSAOShader",["DS/Shaders/SSAOShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/SSAOShader"),e}),define("DS/Shaders/DecodeDepthShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDepth:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDepth;","varying vec2 vUv;","void main() {","    gl_FragColor = vec4(0.0,0.0,0.0,0.0);","    gl_FragDepthEXT = unpackRGBA(texture2D(tDepth,vUv));","}"].join("\n")}}),define("DS/Shaders/NothingShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","    gl_FragColor = texture2D( tDiffuse, vUv );","}"].join("\n")}}),define("Shaders/NothingShader",["DS/Shaders/NothingShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/NothingShader"),e}),define("DS/Shaders/PBRShaders",["DS/Visualization/ThreeJS_R57","DS/Materials/PhysicalMaterial"],function(e,t){"use strict";var o,a=function(e,t){return["vec2 "+t+" = applyUVCombination("+e+"UvSlot == 1 ? uvToUse : uv2ToUse,"+e+"UvTransform);"].join("\n")},i=["#ifndef PHONG_PER_PIXEL","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];","uniform int pointLightPhysicalAttenuation[ MAX_POINT_LIGHTS ];","uniform float pointLightDistance[ MAX_POINT_LIGHTS ];","varying vec4 vPointLight[ MAX_POINT_LIGHTS ];","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","uniform int spotLightPhysicalAttenuation[ MAX_SPOT_LIGHTS ];","uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];","#endif","#if MAX_IES_LIGHTS > 0","uniform vec3 iesLightPosition[ MAX_IES_LIGHTS ];","uniform float iesLightDistance[ MAX_IES_LIGHTS ];","varying vec4 viesLight[ MAX_IES_LIGHTS ];","uniform sampler2D iesLightTexture[ MAX_IES_LIGHTS ];","uniform mat4 matrixWorldInv[MAX_IES_LIGHTS];","#endif","#endif","#if MAX_TUBE_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || MAX_DISK_LIGHTS > 0 || MAX_SPHERE_LIGHTS > 0","#define HAS_AREA_LIGHTS","#endif","varying vec3 vWorldPosition;","#if defined(USE_SPECGLOSS_FLAKES) || defined(USE_DSPBR_FLAKES) || defined(USE_ORANGE_PEEL)","#define NEED_OBJECT_SPACE_DATA","varying vec3 vObjectSpacePosition;","varying vec3 vObjectSpaceNormal;","#endif"].join("\n"),r=["#ifndef PHONG_PER_PIXEL","#if MAX_POINT_LIGHTS > 0","for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( pointLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","vPointLight[ i ] = vec4( lVector, lDistance );","}","#endif","#if MAX_SPOT_LIGHTS > 0","for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( spotLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );","vSpotLight[ i ] = vec4( lVector, lDistance );","}","#endif","#if MAX_IES_LIGHTS > 0","for( int i = 0; i < MAX_IES_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( iesLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( iesLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / iesLightDistance[ i ] ), 1.0 );","viesLight[ i ] = vec4( lVector, lDistance );","}","#endif","#endif","vWorldPosition = worldPosition.xyz;","#if defined(NEED_OBJECT_SPACE_DATA)","vObjectSpacePosition = position.xyz;","vObjectSpaceNormal = objectNormal.xyz;","#endif"].join("\n"),n=["const float kEpsilon = 0.00001;","vec3 getGeomT(in vec3 N) {","vec3 normN = normalize(N);","float x = normN.x;","float y = normN.y;","float z = normN.z;","vec3 T = vec3(0.0);","if ( abs(z) > 0.0) {","T.y += 0.0;","T.x += 1.0;","T.z += - x / z;","return normalize(T);","}","if ( abs(y) > 0.0) {","T.x += 0.0;","T.z += 1.0;","T.y += - z / y;","return normalize(T);","}","if ( abs(x) > 0.0) {","T.z += 0.0;","T.y += 1.0;","T.x += - y / x;","return normalize(T);","}","return vec3(0.0);","}","vec3 getGeomB(in vec3 N, in vec3 T) {","N = normalize(N);","T = normalize(T);","return normalize(cross(N,T));","}","float myAtan2(float y,float x){","float absx, absy, val;","float pi = 3.14159265359;","float ret;","if (x == 0.0 && y == 0.0) return 0.0;","absy = y < 0.0 ? -y : y;","if(y < 0.0) absy = -y;","else absy = y;","absx = x < 0.0 ? -x : x;","if (absy - absx == absy) return y < 0.0 ? -pi*0.5 : pi*0.5;","if (absx - absy == absx) val = 0.0;","else val = atan(y/x);","if (x > 0.0) return val;","if (y < 0.0) return val - pi;","return val + pi;","}","vec3 vOrthoProjectionOnLine(in vec3 P, in vec3 A, in vec3 B) {","vec3 v = normalize(B - A);","vec3 AP = P - A;","return A + dot(AP,v) * v;","}","#define INV_GOLDEN_RATIO 0.6180339887","vec2 Hammersley2D(int i, int N)","{","return vec2((float(i) + 0.5) / float(N), fract(float(i) * INV_GOLDEN_RATIO));","}","float vSmoothstep(float lower, float upper, float factor) {","if (upper <= lower) {","return 0.0;","}","return smoothstep(lower, upper, factor);","}","float vLerp(in float a, in float b, in float w) {","return a + w * (b-a);","}","vec3 vLerp(in vec3 a, in vec3 b, in vec3 w) {","return a + w * (b-a);","}","vec3 TangentToWorldGeom(vec3 Vec, vec3 TangentZ) {","vec3 TangentX = getGeomT(TangentZ);","vec3 TangentY = getGeomB(TangentZ, TangentX);","return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;","}","vec3 TangentToWorld(vec3 Vec, vec3 TangentZ) {","vec3 UpVector = abs(TangentZ.x) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);","vec3 TangentX = normalize(cross(UpVector, TangentZ));","vec3 TangentY = cross(TangentZ, TangentX);","return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;","}","vec3 ImportanceSampleGGX(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * 3.14159265359 * Xi.x;","float a = roughness * roughness;","float a2 = a * a;","float CosTheta = clamp(sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)),0.0,1.0);","float SinTheta = sqrt(1.0 - CosTheta * CosTheta);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","vec3 ImportanceSampleGGXAniso(vec2 Xi, float roughness, vec3 T, vec3 B, vec3 N, float iAnisotropy) {","vec3 H;","float m = roughness * roughness;","float a_x = m;","float a_y = mix(0.0, m, 1.0 - iAnisotropy);","a_x = max(a_x, kEpsilon);","a_y = max(a_y, kEpsilon);","float coef = sqrt(Xi.y / (1.0 - Xi.y));","H = coef * (a_x * cos(2.0 * PI * Xi.x) * T + a_y * sin(2.0 * PI * Xi.x) * B) + N;","return normalize(H);","}","vec2 vLogComplex(in float value) {","float real = log(abs(value));","float im = atan(0.0,value);","return vec2(real,im);","}","vec2 invComplex(in vec2 value) {","return vec2(value.x,-value.y)/(value.x * value.x + value.y * value.y);","}","vec3 ImportanceSampleAshikmin(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float a = roughness * roughness;","float interiorTerm = 4.0*a*exp(1.0/a)/(4.0*a*Xi.y + Xi.y - 1.0);","vec2 exteriorTerm = a*vLogComplex(interiorTerm);","vec2 value = invComplex(exteriorTerm);","float val = min(length(value),1.0);","float SinTheta = sqrt(val);","float CosTheta = sqrt(1.0 - val);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","vec3 ImportanceSampleCosine(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float value = Xi.y;","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","vec3 ImportanceSampleEstevezKulla(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float a = roughness;","a = max(1e-3, a);","float SinTheta = pow(Xi.y, a / ( 2.0 * a + 1.0));","float CosTheta = sqrt(1.0 - SinTheta * SinTheta);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","vec3 ImportanceSampleBeckmann(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float a = roughness * roughness;","float a2 = a * a;","float loga = 8.0*a2*log(1.0-Xi.y);","float value = loga / (loga - 1.0);","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","float modI(float a, float b) {","float m = a - floor((a+0.5)/b)*b;","return floor(m+0.5);","}","int modI(int a, int b) {","return int(modI(float(a), float(b)));","}","float vRound(float a) {","return floor(a + 0.5);","}","float vMax(in vec2 v) {","return max(v.x,v.y);","}","float vMax(in vec3 v) {","return max(vMax(v.xy),v.z);","}","float vMax(in vec4 v) {","return max(vMax(v.xy),vMax(v.zw));","}","float vMin(in vec2 v) {","return min(v.x,v.y);","}","float vMin(in vec3 v) {","return min(vMin(v.xy),v.z);","}","float vMin(in vec4 v) {","return min(vMin(v.xy),vMin(v.zw));","}","float affine(in float value, in float value0, in float value1) {","return value * (value1 - value0) + value0;","}","float toTexCoord(in float x, in float minValue, in float maxValue) {","return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);","}","vec2 toTexCoord(in vec2 x, in vec2 minValue, in vec2 maxValue) {","return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);","}","vec3 toTexCoord(in vec3 x, in vec3 minValue, in vec3 maxValue) {","return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);","}","vec4 toTexCoord(in vec4 x, in vec4 minValue, in vec4 maxValue) {","return clamp((clamp(x, minValue, maxValue) - minValue) / (maxValue - minValue),0.0,1.0);","}","float zeroSphericalHarmonics() {","return sqrt(0.31830988618) / 2.0;","}","bool vIsnan( float val )","{","return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;","}","vec2 vNormalize( vec2 val )","{","float len = length(val);","if ( len < 1e-6) {","return vec2(0.0);","}","return val/len;","}","vec3 vNormalize( vec3 val )","{","float len = length(val);","if ( len < 1e-6) {","return vec3(0.0);","}","return val/len;","}","vec4 vNormalize( vec4 val )","{","float len = length(val);","if ( len < 1e-6) {","return vec4(0.0);","}","return val/len;","}","mat3 transposeMatrix(in mat3 m) {","mat3 mT;","mT[0] = vec3(m[0][0], m[1][0], m[2][0]);","mT[1] = vec3(m[0][1], m[1][1], m[2][1]);","mT[2] = vec3(m[0][2], m[1][2], m[2][2]);","return mT;","}","float gaussian(in float x, in float mean, in float variance) ","{","float value = x - mean;","value *= value;","value /= 2.0 * variance;","return exp(-value);","}","float saturate(in float iValue)","{","return clamp(iValue, 0.0, 1.0);","}","vec2 saturate(in vec2 iValue)","{","return clamp(iValue, vec2(0.0), vec2(1.0));","}","vec3 saturate(in vec3 iValue)","{","return clamp(iValue, vec3(0.0), vec3(1.0));","}","vec4 saturate(in vec4 iValue)","{","return clamp(iValue, vec4(0.0), vec4(1.0));","}","float pow2(in float iValue)","{","return iValue*iValue;","}","float pow3(in float iValue)","{","return pow2(iValue) * iValue;","}","float pow4(in float iValue)","{","float tmp = pow2(iValue);","return pow2(tmp);","}","float pow5(in float iValue)","{","float tmp = pow4(iValue);","return tmp * iValue;","}","float pow6(in float iValue)","{","float tmp = pow2(iValue);","float tmp2 = pow2(tmp);","return tmp * tmp2;","}","float fma(in float x, in float y, in float z) {","return x*y + z;","}","vec3 fma(in vec3 x, in vec3 y, in vec3 z) {","return x*y + z;","}","vec2 fma(in vec2 x, in vec2 y, in vec2 z) {","return x*y + z;","}","vec4 fma(in vec4 x, in vec4 y, in vec4 z) {","return x*y + z;","}","vec3 Rotate3D(in vec3 iVec, in float iAngle, in vec3 iAxe) {","float s = sin(iAngle);","float c = cos(iAngle);","float x = iAxe.x;","float y = iAxe.y;","float z = iAxe.z;","mat3 rot = mat3(pow2(x) * (1.0 - c) + c, x * y * (1.0 - c) - z * s, x * z * (1.0 - c) + y * s,","x * y * (1.0 - c) + z * s, pow2(y) * (1.0 - c) + c, y * z * (1.0 - c) - x * s,","x * z * (1.0 - c) - y * s, y * z * (1.0 - c) + x * s, pow2(z) * (1.0 - c) + c);","return rot * iVec;","}"].join("\n"),l=["#if defined (USE_SPECGLOSS_FLAKES) || defined (USE_ORANGE_PEEL)","vec4 mod289(vec4 x) {","  return x - floor(x * (1.0 / 289.0)) * 289.0;","}","vec3 mod289(vec3 x) {","  return x - floor(x * (1.0 / 289.0)) * 289.0;","}","vec2 mod289(vec2 x) {","  return x - floor(x * (1.0 / 289.0)) * 289.0;","}","vec3 permute(vec3 x) {","  return mod289(((x*34.0)+1.0)*x);","}","vec4 permute(vec4 x) {","\treturn mod289(((x*34.0)+1.0)*x);","}","vec4 taylorInvSqrt(vec4 r) {","\treturn 1.79284291400159 - 0.85373472095314 * r;","}","float snoise(vec3 v) {","const vec2  C = vec2(1.0/6.0, 1.0/3.0);","const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);","vec3 i  = floor(v + dot(v, C.yyy) );","vec3 x0 =   v - i + dot(i, C.xxx) ;","vec3 g = step(x0.yzx, x0.xyz);","vec3 l = 1.0 - g;","vec3 i1 = min( g.xyz, l.zxy );","vec3 i2 = max( g.xyz, l.zxy );","vec3 x1 = x0 - i1 + C.xxx;","vec3 x2 = x0 - i2 + C.yyy;","vec3 x3 = x0 - D.yyy;","i = mod289(i);","vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));","float n_ = 0.142857142857;","vec3  ns = n_ * D.wyz - D.xzx;","vec4 j = p - 49.0 * floor(p * ns.z * ns.z);","vec4 x_ = floor(j * ns.z);","vec4 y_ = floor(j - 7.0 * x_ );","vec4 x = x_ *ns.x + ns.yyyy;","vec4 y = y_ *ns.x + ns.yyyy;","vec4 h = 1.0 - abs(x) - abs(y);","vec4 b0 = vec4( x.xy, y.xy );","vec4 b1 = vec4( x.zw, y.zw );","vec4 s0 = floor(b0)*2.0 + 1.0;","vec4 s1 = floor(b1)*2.0 + 1.0;","vec4 sh = -step(h, vec4(0.0));","vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;","vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;","vec3 p0 = vec3(a0.xy,h.x);","vec3 p1 = vec3(a0.zw,h.y);","vec3 p2 = vec3(a1.xy,h.z);","vec3 p3 = vec3(a1.zw,h.w);","vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));","p0 *= norm.x;","p1 *= norm.y;","p2 *= norm.z;","p3 *= norm.w;","vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);","m = m * m;","return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );","}","#endif","#if defined(USE_SPECGLOSS_FLAKES) || defined(USE_ORANGE_PEEL)","#define NBOCTAVES 10","float getMean(in float LODLevel) {","float mult = 1.8;","float LOD = 3.0;","float oldLOD = 0.0;","for (int i = NBOCTAVES - 1 ; i >=0; i--) {","float pente = 1.0 / (LOD - oldLOD);","float origine = float(i) + 1.0 + oldLOD * pente;","if (LODLevel <= LOD) {","return origine - pente * LODLevel;","}","oldLOD = LOD;","LOD *= mult;","}","return 0.0;","}","float FBM(vec3 iVector)","{","vec3 vector = iVector;","float res = 0.0;","float amplitude = 1.0;","float sum = 0.0;","for (int octave = 0; octave < 1; octave++) {","if (amplitude < 10.0 * kEpsilon) {","break;","}","vector = vector * 2.0;","sum += amplitude;","res += snoise(vector) * amplitude;","amplitude *= 0.5;","}","return clamp(res/sum,-1.0,1.0);","}","float arrayFBMMixer(in vec3 iVector, in float LODLevel, in float frequency, in float low, in float up)","{","vec3 vector = iVector;","float res = 0.0;","float sum = 0.0;","float variance = 1.5;","float mean = getMean(LODLevel);","float amplitude;","int minIndex = int(max(0.0, mean - low));","int maxIndex = int(min(float(NBOCTAVES), mean + up));","frequency *= pow(1.8, float(minIndex));","int octave = minIndex;","for (int i = 0; i < 10 ; i++) {","if (octave >= maxIndex) {break;}","vec3 vec = vector * frequency;","frequency *= 1.8;","amplitude = gaussian(float(octave), mean, variance);","sum += amplitude;","res += snoise(vec) * amplitude;","octave++;","}","return clamp(res/sum,-1.0,1.0);","}","#endif"].join("\n"),s=function(e,t,o){return["#ifdef PDSFX",e+" = "+t+";",t+" = "+o+"();","#endif"].join("\n")},f=function(e,t,o){return["#ifdef PDSFX",e+" = "+t+";",t+" = "+o+"();","#if defined(GAMMA_INPUT) && defined(DSPBR)","if (!all(equal("+t+", "+e+"))) {",t+".rgb = convertToLinear("+t+".rgb);","}","#endif","#endif"].join("\n")},c=function(e,t,o,a,i){return["#ifdef "+o,"if ("+t+".x < 0.0 || "+t+".x > 1.0) {",e+" = "+i+";","}","#endif","#ifdef "+a,"if ("+t+".y < 0.0 || "+t+".y > 1.0) {",e+" = "+i+";","}","#endif"].join("\n")},v=function(e,t,o,i,r,n,l,s,f){var c=t+"UV",v=t+"Map",d=t+"MulCoef",u=t+"AddCoef",p=e+"= texture2D("+v+", "+c+")."+n+";";if(l){var m=e+"= texture2D("+v+", "+c+")."+l+";";if(s)p=["#ifdef PBR_FROM_GLTF","#if PBR_FROM_GLTF == 2",e+"= texture2D("+v+", "+c+")."+s+";","#else",m,"#endif","#else",p,"#endif"].join("\n");else p=["#ifdef PBR_FROM_GLTF",m,"#else",p,"#endif"].join("\n")}return[(r?"float ":"")+e+" = "+t+";","#ifdef "+o,a(t,c),p,"#endif","#ifdef "+i,e+" = "+(f?"":"saturate")+"("+d+" * "+e+" + "+u+");","#endif"].join("\n")},d=function(e,t,o,i,r,n,l){var s=t+"UV",f=t+"MulCoef",c=t+"AddCoef",v=e+"= texture2D("+(t+"Map")+", "+s+").rgb;";return[(n?"vec3 ":"")+e+" = "+t+";","#ifdef "+o,a(t,s),v,"#if defined( GAMMA_INPUT ) && !defined("+r+")",e+".rgb = convertToLinear("+e+".rgb);","#endif","#endif","#ifdef "+i,e+" = "+(l?"":"saturate")+"("+f+" * "+e+" + "+c+");","#endif"].join("\n")},u=[v("transparencyValue","transparency","USE_TRANSPARENCYMAP","USE_TRANSPARENCY_COEFFICIENTS",!0,"r"),s("_DStransparency_","transparencyValue","ComputeTransparency"),"#ifdef USE_SUBSURFACE","float transToDivide = ApplyTransparency(transparencyValue, materialData.metalness, materialData.scatteringColor * albedo, NoV);","#else","float transToDivide = ApplyTransparency(transparencyValue, materialData.metalness, albedo, NoV);","#endif","materialData.transparency = transparencyValue;"].join("\n"),p=["float opacityValue = opacity;","#if defined(SELECTION_MATERIAL)","opacityValue = 1.0;","#endif","#ifdef USE_COLOR","opacityValue *= vColor.a;","#endif","#ifdef USE_OPACITYMAP",a("opacity","opacityUV"),"opacityValue = texture2D(opacityMap, opacityUV).r;",c("opacityValue","opacityUV","USE_OPACITYMAP_BORDER_COLOR_U","USE_OPACITYMAP_BORDER_COLOR_V","opacityBorderValue"),"#endif","#if defined(USE_MAP)","#if defined(TEXTURE_MODULATE) || defined(TEXTURE_BLEND) || defined(USE_ALPHA_FROM_MAP)","opacityValue *= texelAlbedo.a;","#endif","#endif","#ifdef USE_OPACITY_COEFFICIENTS","opacityValue = saturate(opacityMulCoef * opacityValue + opacityAddCoef);","#endif",s("_DSopacity_","opacityValue","ComputeOpacity"),"gl_FragColor.a = opacityValue;",e.ShaderChunk.alphatest_fragment].join("\n"),m=["#ifdef DSPBR_WITH_TRANSLUCENCY",v("materialData.translucency","translucency","USE_TRANSLUCENCYMAP","USE_TRANSLUCENCY_COEFFICIENTS",!1,"r"),"#endif","#ifdef DSPBR_WITH_TRANSLUCENCY_COLOR",d("materialData.translucencyColor","translucencyColor","USE_TRANSLUCENCY_COLOR_MAP","USE_TRANSLUCENCY_COLOR_COEFFICIENTS","TRANSLUCENCY_COLOR_LINEAR",!1),"#endif"].join("\n"),S=["#ifdef USE_IRIDESCENCE","materialData.iridescenceIoR = iridescenceIoR;",v("materialData.iridescence","iridescence","USE_IRIDESCENCE_MAP","USE_IRIDESCENCE_COEFFICIENTS",!1,"r"),v("materialData.iridescenceThickness","iridescenceThickness","USE_IRIDESCENCE_THICKNESS_MAP","USE_IRIDESCENCE_THICKNESS_COEFFICIENTS",!1,"r","g",null,!1),"if (materialData.iridescenceThickness < 1e-12) {","materialData.iridescence = 0.0;","}","#endif"].join("\n"),_=["#ifdef PDSFX","vec3 vertexNormal = _DSvNormal;","#else","vec3 vertexNormal = normalize( vNormal );","#ifdef DECAL","vertexNormal = decalNormal;","#endif","#endif","#ifdef DOUBLE_SIDED","vertexNormal = vertexNormal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );","#endif","surfaceData.viewNormal = vertexNormal;","#ifdef USE_NORMALMAP",a("normal","normalUv"),"#ifdef SPECGLOSS","#if defined(USE_NORMALSCALEMAP)",a("normalScale","normalScaleUv"),"vec2 scale = vec2(texture2D(normalScaleMap, normalScaleUv).r);","#else","vec2 scale = normalScale;","#endif","#ifdef USE_NORMALSCALE_COEFFICIENTS","scale = normalScaleMulCoef * scale + normalScaleAddCoef;","#endif","#else","vec2 scale = vec2(1.0);","#endif","surfaceData.viewNormal = perturbNormal3Arb( vertexNormal, tangent, binormal, normalUv, scale );","#elif defined( USE_BUMPMAP ) && defined(SPECGLOSS)",a("bump","bumpUv"),"#if defined(USE_BUMPSCALEMAP)",a("bumpScale","bumpScaleUv"),"float scale = texture2D(bumpScaleMap, bumpScaleUv).r;","#else","float scale = bumpScale;","#endif","#ifdef USE_BUMPSCALE_COEFFICIENTS","scale = bumpScaleMulCoef * scale + bumpScaleAddCoef;","#endif","surfaceData.viewNormal = perturbNormalArb( -surfaceData.viewPosition, vertexNormal, dHdxy_fwd(bumpUv, scale) );","#endif","surfaceData.worldNormal = normalize( vec3( vec4( surfaceData.viewNormal, 0.0 ) * viewMatrix ) );","vec3 normal = surfaceData.viewNormal;"].join("\n"),h=["#ifdef CLEAR_COAT",v("materialData.clearCoat","clearCoat","CLEAR_COAT_MAP","USE_CC_COEFFICIENTS",!1,"r"),"#ifdef CLEAR_COAT_NORMALMAP",a("clearCoatNormal","ccnormalUv"),"surfaceData.clearCoatNormal = perturbNormal3ArbCoat( vertexNormal, tangent, binormal, ccnormalUv );","#else","surfaceData.clearCoatNormal = vertexNormal;","#endif","surfaceData.clearCoatWorldNormal = normalize( vec3( vec4( surfaceData.clearCoatNormal, 0.0 ) * viewMatrix ) );","#ifdef USE_ORANGE_PEEL","doOrangePeel(surfaceData.worldNormal,surfaceData.clearCoatWorldNormal, surfaceData.worldPosition, surfaceData.objectSpacePosition);","surfaceData.clearCoatNormal = normalize( (viewMatrix * vec4( surfaceData.clearCoatWorldNormal, 0.0)).xyz);","#endif","#ifdef SPECGLOSS",d("materialData.clearCoatSR0Color","clearCoatColor","CLEAR_COAT_COLORMAP","USE_CC_COLOR_COEFFICIENTS","CLEARCOAT_LINEAR",!1),"#else","materialData.clearCoatSR0Color = vec3(0.04);","#endif","materialData.clearCoatSR90Color = vec3(1.0);",v("materialData.clearCoatRoughness","clearCoatRoughness","USE_CC_ROUGHNESSMAP","USE_CC_ROUGHNESS_COEFFICIENTS",!1,"r","g"),"#ifdef USE_CC_GLOSSINESSMAP",a("clearCoatRoughness","ccglossinessUV"),"float ccGlossiness = texture2D( coatingGlossinessMap, ccglossinessUV ).r;","materialData.clearCoatRoughness = 1.0 - ccGlossiness;","#endif","#ifdef USE_CC_GLOSSINESS_COEFFICIENTS","materialData.clearCoatRoughness = 1.0 - saturate(coatingGlossinessMulCoef * (1.0 - materialData.clearCoatRoughness) + coatingGlossinessAddCoef);","#endif","materialData.clearCoatRoughness =  clamp(materialData.clearCoatRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);","#endif"].join("\n"),x=["#ifdef USE_SPECGLOSS_FLAKES","doFlakes(surfaceData.worldNormal, surfaceData.worldPosition, surfaceData.objectSpacePosition);","metalFlakes.flakesNormal = normalize((viewMatrix* (vec4(metalFlakes.flakesWorldNormal, 0.0))).xyz);","metal.flakesNormal = surfaceData.viewNormal;","#ifdef PEARL_FLAKES_ACTIVATED","pearlFlakes.flakesNormal = normalize((viewMatrix * (vec4(pearlFlakes.flakesWorldNormal, 0.0))).xyz);","#endif","#endif","#ifdef USE_DSPBR_FLAKES",v("flakesCoverageV","flakesCoverage","USE_FLAKESCOVERAGE_MAP","USE_FLAKESCOVERAGE_COEFFICIENTS",!0,"r"),d("flakesColorV","flakesColor","USE_FLAKESCOLOR_MAP","USE_FLAKESCOLOR_COEFFICIENTS","FLAKES_LINEAR",!0),v("flakesRoughnessV","flakesRoughness","USE_FLAKESROUGHNESS_MAP","USE_FLAKESROUGHNESS_COEFFICIENTS",!0,"r"),"flakesRoughnessV = clamp(flakesRoughnessV, 0.036, 0.986);",v("flakesSizeV","flakesSize","USE_FLAKESSIZE_MAP","USE_FLAKESSIZE_COEFFICIENTS",!0,"r"),"#ifdef DSPBR_WITH_FLIPFLOP_COLOR",d("flipFlopColorV","flipFlopColor","USE_FLIPFLOP_COLOR_MAP","USE_FLIPFLOP_COLOR_COEFFICIENTS","FLIPFLOP_COLOR_LINEAR",!0),v("flipFlopV","flipFlop","USE_FLIPFLOP_MAP","USE_FLIPFLOP_COEFFICIENTS",!0,"r"),"flipFlopV = max(flipFlopV, 1e-12);","initFlakesData(surfaceData.objectSpacePosition, normalize(surfaceData.objectSpaceNormal),flakesSizeV, flakesCoverageV, flakesColorV, flakesRoughnessV, flipFlopV, flipFlopColorV);","#else","initFlakesData(surfaceData.objectSpacePosition, normalize(surfaceData.objectSpaceNormal),flakesSizeV, flakesCoverageV, flakesColorV, flakesRoughnessV);","#endif","#endif"].join("\n"),g=["#ifdef USE_SHEEN","#ifndef DSPBR_WITH_NO_SHEEN_VALUE",v("materialData.sheen","sheen","USE_SHEEN_MAP","USE_SHEEN_COEFFICIENTS",!1,"r"),"#else","materialData.sheen = 1.0;","#endif","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS",v("materialData.sheenRoughness","sheenRoughness","USE_SHEEN_ROUGHNESS_MAP","USE_SHEEN_ROUGHNESS_COEFFICIENTS",!1,"r","a"),"materialData.sheenRoughness = clamp(materialData.sheenRoughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);","#if !defined(DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS) && defined(USE_SOFT_VELVET)","materialData.sheenRoughness = max(materialData.sheenRoughness, 0.07);","#endif",d("materialData.sheenColor","sheenColor","USE_SHEEN_COLOR_MAP","USE_SHEEN_COLOR_COEFFICIENTS","SHEEN_COLOR_LINEAR",!1),"materialData.sheenEnergyConservationConstant = materialData.sheen * vMax(materialData.sheenColor) * DirectionalSheenAlbedo(NoV, materialData.sheenRoughness);","#endif","#endif"].join("\n"),D=["#ifdef DSPBR_WITH_NO_CLAMPED_SPECULAR_TINt",d("materialData.specularTint","specular","USE_SPECULARMAP","USE_SPECULAR_COEFFICIENTS","SPECULAR_LINEAR",!1,!0),"#else",d("materialData.specularTint","specular","USE_SPECULARMAP","USE_SPECULAR_COEFFICIENTS","SPECULAR_LINEAR",!1,!1),"#endif",f("_DSspecular_","materialData.specularTint","ComputeSpecularReflectance")].join("\n"),C=[v("materialData.roughness","roughness","USE_ROUGHNESSMAP","USE_ROUGHNESS_COEFFICIENTS",!1,"r","g","a"),"#ifdef USE_GLOSSINESSMAP",a("roughness","glossinessUV"),"float glossinessTex = texture2D( glossinessMap, glossinessUV ).r;","materialData.roughness = 1.0-glossinessTex;","#endif","#ifdef USE_GLOSSINESS_COEFFICIENTS","materialData.roughness = 1.0 - saturate(glossinessMulCoef * (1.0 - materialData.roughness) + glossinessAddCoef);","#endif",s("_DSroughness_","materialData.roughness","ComputeRoughness"),"materialData.roughness = clamp(materialData.roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX);"].join("\n"),P=[d("emissionColorValue","emissionColor","USE_EMISSIONCOLORMAP","USE_EMISSIONCOLOR_COEFFICIENTS","EMISSION_LINEAR",!0),f("_DSemissive_","emissionColorValue","ComputeEmissive")].join("\n"),E=[v("materialData.metalness","metalness","USE_METALNESSMAP","USE_METALNESS_COEFFICIENTS",!1,"r","b")].join("\n"),y=[v("materialData.specularContribution","specularContrib","USE_SPECULARCONTRIBMAP","USE_SPECULARCONTRIB_COEFFICIENTS",!1,"r","a")].join("\n"),A=["#if defined( USE_ANISOTROPY )",v("materialData.anisotropy","anisotropy","USE_ANISOTROPYMAP","USE_ANISOTROPY_COEFFICIENTS",!1,"r"),"materialData.anisotropy = min(materialData.anisotropy, 0.975);",v("materialData.anisotropyAngle","anisotropyAngle","USE_ANISOTROPYANGLEMAP","USE_ANISOTROPYANGLE_COEFFICIENTS",!1,"r"),"surfaceData.binormal = binormal;","surfaceData.tangent = tangent;","#endif"].join("\n"),M=["#if defined( USE_THICKNESS )",v("surfaceData.thickness","thickness","USE_THICKNESSMAP","USE_THICKNESS_COEFFICIENTS",!1,"r"),"#endif"].join("\n"),T=["vec3 albedo = diffuse;","#ifdef USE_COLOR","albedo *= vColor.rgb;","#endif","#ifdef USE_MAP",a("diffuse","diffuseUV"),"#ifdef _VISUBASIC_FORCE_PHYSICAL_DIFFUSE_UV","diffuseUV = VisuBasic_diffuseTexUvToUse;","#endif","vec4 texelAlbedo = texture2D(map, diffuseUV);",c("texelAlbedo","diffuseUV","USE_DIFFUSEMAP_BORDER_COLOR_U","USE_DIFFUSEMAP_BORDER_COLOR_V","diffuseBorderColor"),"#if defined(GAMMA_INPUT) && !defined(USE_MAP_HDR)","texelAlbedo.rgb = convertToLinear(texelAlbedo.rgb);","#endif","if(_colorOverride == 1) {","texelAlbedo.rgb = albedo;","}","#ifdef TEXTURE_MODULATE ","albedo *= texelAlbedo.rgb;","#endif","#ifdef TEXTURE_BLEND ","albedo = mix(albedo, vec3(1.0), texelAlbedo.rgb);","#endif","#ifdef TEXTURE_DECAL ","albedo = mix(albedo, texelAlbedo.rgb, texelAlbedo.w);","#endif","#ifdef TEXTURE_IGNORE ","#endif","#if defined(TEXTURE_DEFAULT) ","albedo = texelAlbedo.rgb;","#endif","#if defined(TEXTURE_REPLACE)","gl_FragColor.xyz = texelAlbedo.xyz;","#if TEXTURE_FORMAT == 1021","gl_FragColor.a = texelAlbedo.a;","#endif",e.ShaderChunk.alphatest_fragment,"#if !defined(TEXTURE_REPLACE_CONTINUE)","return;","#endif","#endif","#endif","#ifdef USE_REFLECTIVITY_ENVMAP","vec3 cameraToVertexLegacy;","if (projectionMatrix[3][3] > 0.5) {","cameraToVertexLegacy = normalize( vec3( vec4( 0.0,0.0,-1.0, 0.0 ) * viewMatrix ) );","} else {","cameraToVertexLegacy = normalize( surfaceData.worldPosition - cameraPosition );","}","vec3 reflectVecLegacy = reflect( cameraToVertexLegacy, surfaceData.worldNormal );","albedo = sampleReflectivityEnvMap(reflectVecLegacy.yzx, albedo);","#endif","#ifdef USE_DIFFUSE_COEFFICIENTS","albedo = saturate(albedo * diffuseMulCoef + diffuseAddCoef);","#endif",f("_DSalbedo_","albedo","ComputeAlbedo")].join("\n");o=["if (projectionMatrix[3][3] > 0.5) {","surfaceData.view = vec3(0.0,0.0,1.0);","} else {","#ifdef DECAL","surfaceData.view = normalize( dViewPosition);","#else","surfaceData.view = normalize( vViewPosition );","#endif","}","surfaceData.viewPosition = vViewPosition;","#ifdef DECAL","surfaceData.viewPosition = dViewPosition;","#endif","vec3 vPos = surfaceData.viewPosition;","surfaceData.worldPosition = vWorldPosition;","#ifdef DECAL","surfaceData.worldPosition = dWorldPosition;","#endif","#ifdef NEED_OBJECT_SPACE_DATA","surfaceData.objectSpacePosition = vObjectSpacePosition;","surfaceData.objectSpaceNormal = vObjectSpaceNormal;","#ifdef DECAL","surfaceData.objectSpacePosition = dObjectSpacePosition;","surfaceData.objectSpaceNormal = dObjectSpaceNormal;","#endif","#endif",_,"#ifdef USE_SPECULAR_AA","surfaceData.TForSpecularAA = getGeomT(surfaceData.viewNormal);","surfaceData.BForSpecularAA = getGeomB(surfaceData.viewNormal, surfaceData.TForSpecularAA);","surfaceData.TBNMatrixForSpecularAA = transposeMatrix(mat3(surfaceData.TForSpecularAA, surfaceData.BForSpecularAA, surfaceData.viewNormal));","#endif","#ifdef USE_SUBSURFACE","surfaceData.curvature = length(fwidth(surfaceData.worldNormal)) / length(fwidth(surfaceData.worldPosition));","materialData.scatteringColor = SssLUTSampling(surfaceData.curvature);","#endif","float NoV = saturate(dot(surfaceData.viewNormal, surfaceData.view));",T,p,y,D,A,C,S,P,E,m,g,h,x,M,"#ifdef DEBUG_SHADOW","albedo = vec3(1.0);","materialData.specularContribution = 0.0;","materialData.metalness = 0.0;","#endif","#ifdef USE_LIGHTMAP",a("lightMap","lightMapUV"),"vec3 aoValue = texture2D(lightMap, lightMapUV).rgb;","#ifndef USE_LIGHTMAP_LINEAR","aoValue *= aoValue;","#endif","#endif","materialData.ior = ior;","materialData.adjustedIoR = ior;","#ifdef USE_THICKNESS","if (materialData.ior <= 1.0 + 1e-6 || surfaceData.thickness <= 1e-6) {","materialData.adjustedIoR = 1.0;","} else {","vec3 dummyT = getGeomT(surfaceData.worldNormal);","vec3 dummyB = getGeomB(surfaceData.worldNormal, dummyT);","vec3 dummyVector = normalize(surfaceData.worldNormal + dummyB + dummyT);","vec3 refractVec = refract(-dummyVector, surfaceData.worldNormal, 1.0/materialData.ior);","float sin1 = sqrt(1.0 - pow2(dot(-dummyVector, surfaceData.worldNormal)));","refractVec = normalize(-dummyVector + (refractVec * surfaceData.thickness));","float sin2 = sqrt(1.0 - pow2(dot(refractVec, surfaceData.worldNormal)));","materialData.adjustedIoR = max(abs(sin1), 1e-12) / max(abs(sin2), 1e-12);","}","#endif","#ifdef SPECGLOSS","materialData.F0 = 1.0;","#else","materialData.F0 = pow2((materialData.ior - 1.0)/(materialData.ior + 1.0));","#endif","#ifdef SPECGLOSS","materialData.sr0Color = materialData.specularTint;","materialData.sr90Color = vec3(1.0);","#else","materialData.sr0Color = (1.0 - materialData.metalness) * materialData.F0 * materialData.specularContribution  * materialData.specularTint + materialData.metalness * albedo;","materialData.sr90Color = vec3(1.0) * ((1.0-materialData.metalness)*materialData.specularContribution + materialData.metalness);","#endif","materialData.specularBlendingSR0 = materialData.F0 * materialData.specularTint;","#ifdef USE_IRIDESCENCE","materialData.iridescenceSR0Color = materialData.sr0Color;","if (materialData.iridescence > 0.0) {","vec3 fresnelIridescence = computeIridescence(1.0, materialData.iridescenceIoR, materialData.sr0Color, materialData.iridescenceThickness * 1e3, NoV);","materialData.iridescenceSR0Color = F0FromFresnelSchlick(fresnelIridescence, materialData.sr90Color, NoV);","materialData.sr0Color = mix(materialData.sr0Color, materialData.iridescenceSR0Color, materialData.iridescence);","materialData.specularBlendingSR0 = mix(materialData.specularBlendingSR0, materialData.iridescenceSR0Color, materialData.iridescence);","}","#endif",u,"#ifdef SPECGLOSS","materialData.diffuseColor = albedo;","materialData.transparentColor = albedo;","#else","materialData.diffuseColor = albedo * (1.0 - materialData.metalness) * (1.0 - materialData.transparency);","materialData.transparentColor = albedo * (1.0 - materialData.metalness) * materialData.transparency;","#endif","#if !defined(DSPBR_WITH_TRANSLUCENCY_COLOR)","#if defined(DSPBR_WITH_TRANSLUCENCY)","materialData.translucencyColor = materialData.diffuseColor;","#endif","#else","materialData.translucencyColor *= (1.0 - materialData.metalness) * (1.0 - materialData.transparency);","#endif","#if defined(USE_DSPBR_FLAKES)","initFlakesWeights(surfaceData.view, surfaceData.viewNormal);","#endif","#ifdef TRANSMITTANCE","#ifdef DEPTHMAP_BASED_TRANSMITTANCE","initDisk();","#endif","#ifdef THICKNESS_BASED_TRANSMITTANCE","materialData.transmittanceColor = GetTransmittance(surfaceData.thickness);","#endif","#endif","#ifdef HAS_AREA_LIGHTS","vec3 viewReflect = reflect(-surfaceData.view, surfaceData.viewNormal);","#ifdef USE_ANISOTROPY","vec3 areaBitangent = normalize(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal);","vec3 anisotropicAreaTangent = cross(areaBitangent, surfaceData.view);","vec3 anisotropicAreaNormal = cross(anisotropicAreaTangent, areaBitangent);","vec3 bentAreaNormal = normalize(mix(surfaceData.viewNormal, anisotropicAreaNormal, materialData.anisotropy));","vec3 reflArea = -reflect( surfaceData.view, bentAreaNormal );","setAreaGGXData(materialData.roughness, saturate(dot(surfaceData.viewNormal, reflArea)), areaData.fresnel, areaData.Minv);","#else","setAreaGGXData(materialData.roughness, NoV,areaData.fresnel, areaData.Minv);","#endif","#ifdef CLEAR_COAT","setAreaGGXData(materialData.clearCoatRoughness, saturate(dot(surfaceData.clearCoatNormal,surfaceData.view)),areaData.fresnelCC, areaData.MinvCC);","#endif","#ifdef USE_SHEEN","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","float sheenRough_AL = materialData.sheenRoughness;","#else","float sheenRough_AL = materialData.sheen;","#endif","#if defined(USE_VELVET) || defined(USE_SOFT_VELVET)","#if defined(DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS)","setAreaSheenData(sheenRough_AL * sheenRough_AL, NoV, areaData.MinvSheen);","#else","setAreaSheenData(sheenRough_AL, NoV, areaData.MinvSheen);","#endif","#else","setAreaSheenData(0.3, NoV, areaData.MinvSheen);","#endif","#endif","#ifdef USE_SPECGLOSS_FLAKES","setAreaGGXData(metal.flakesRoughness, saturate(dot(metal.flakesNormal,surfaceData.view)),areaData.fresnelMetal, areaData.MinvMetal);","setAreaGGXData(metalFlakes.flakesRoughness, saturate(dot(metalFlakes.flakesNormal,surfaceData.view)),areaData.fresnelMetalFlakes, areaData.MinvMetalFlakes);","#ifdef PEARL_FLAKES_ACTIVATED","setAreaGGXData(pearlFlakes.flakesRoughness, saturate(dot(pearlFlakes.flakesNormal,surfaceData.view)),areaData.fresnelPearlFlakes, areaData.MinvPearlFlakes);","#endif","#endif","#ifdef USE_DSPBR_FLAKES","if (flakesData.smoothWeight > 0.0) {","setAreaGGXData(flakesData.flakesRoughness, NoV,areaData.fresnelMetal, areaData.MinvMetal);","}","if (flakesData.stochasticWeight > 0.0) {","vec3 normalStoFlakes = flakesData.stochasticHemisphereFlakesNormal;","float NdotVSto = saturate(dot(normalStoFlakes, surfaceData.view));","setAreaGGXData(flakesData.flakesRoughness, NdotVSto, areaData.fresnelMetalSto, areaData.MinvMetalSto);","}","if (flakesData.closeupWeight > 0.0) {","vec3 normalCloseUpFlakes = flakesData.closeupFlakesNormal;","float NdotVClose = saturate(dot(normalCloseUpFlakes, surfaceData.view));","setAreaGGXData(flakesData.flakesRoughness, NdotVClose, areaData.fresnelMetalClose, areaData.MinvMetalClose);","}","#endif","#endif","#ifdef DSPBR","float averageDirectionalMultipleAlbedo = AverageDirectionalMultipleAlbedo(materialData.roughness);","vec3 averageMultipleFresnel = AverageMultipleFresnel(materialData.sr0Color, materialData.sr90Color);","float multipleScatteringGGX = pow2(1.0 - DirectionalMultipleAlbedo(NoV, materialData.roughness))/max(1.0 - averageDirectionalMultipleAlbedo, 1e-6);","vec3 multipleScatteringFresnel = (averageMultipleFresnel * averageMultipleFresnel * averageDirectionalMultipleAlbedo)/max(1.0 - averageMultipleFresnel * (1.0 - averageDirectionalMultipleAlbedo), vec3(1e-6));","materialData.specularEnergyConservationConstant =  multipleScatteringGGX * multipleScatteringFresnel;","materialData.diffuseEnergyConservationConstant = mix(1.0, pow2(1.0 - DirectionalAlbedo(materialData.F0, materialData.specularTint, NoV, materialData.roughness)) / max(1.0 - AverageDirectionalAlbedo(materialData.F0, materialData.specularTint, materialData.roughness), 1e-6), materialData.specularContribution);","#endif"].join("\n");var N=["#ifndef DEBUG_SHADOW","#ifdef USE_LIGHTING","gl_FragColor.xyz += totalTransmissive;","#endif","gl_FragColor.xyz += totalEmission;","#ifdef DSPBR","gl_FragColor.xyz /= transToDivide;","#endif","#endif"].join("\n"),U=["vec2 applyUVCombination(in vec2 uv,in mat3 uvtransform){","#ifdef NRE_COMPATIBILITY","#if defined (MAPPING_OPERATOR)","if(mappingTransformSemantic==2){","vec2 T0 = mappingUVTransformation[2].xy;","vec2 Ti = uvtransform[2].xy;","mat2 Ri = mat2(uvtransform);","mat2 R0 = mat2(mappingUVTransformation);","vec2 uv_shifted = uv.xy + T0 +Ti;","return Ri * R0 * uv_shifted;","}else if(mappingTransformSemantic==3){","vec2 T0 = mappingUVTransformation[2].xy;","vec2 Ti = uvtransform[2].xy;","mat2 Ri = mat2(uvtransform);","mat2 R0 = mat2(mappingUVTransformation);","vec2 uv_shifted = uv.xy + T0 +Ti-vec2(0.5,0.5);","return (Ri * R0 * uv_shifted)+vec2(0.5,0.5);","}","#endif","return (uvtransform * vec3(uv,1.0)).xy;","#else","return uv;","#endif","}"].join("\n"),L=["#ifdef NEEDS_UVTOUSE","varying vec2 vUv;","varying vec2 vUv2;","uniform vec2 offsetBumpMap;","uniform vec2 repeatBumpMap;","#endif",e._DefaultShaderChunk.map_pars_vertex,U].join("\n"),I=["#ifdef NEEDS_UVTOUSE","vUv = uv * repeatBumpMap + offsetBumpMap;","#if defined (MAPPING_OPERATOR) && defined(USE_MAPPING_OPERATOR_VERTEX)","#if !defined(USE_TANGENT_BINORMAL)","vUv = applyMappingOperator(uv, position, normal);","#else","vUv = applyMappingOperator(uv, position, normal,tangent,binormal);","#endif","#endif","vUv2 = uv2 * repeatBumpMap + offsetBumpMap;","#if defined (MAPPING_OPERATOR) && defined(USE_MAPPING_OPERATOR_VERTEX)","#if !defined(USE_TANGENT_BINORMAL)","vUv2 = applyMappingOperator(uv2, position, normal);","#else","vUv2 = applyMappingOperator(uv2, position, normal,tangent,binormal);","#endif","#endif","#endif","#if defined(MAPPING_OPERATOR) && !defined(USE_MAPPING_OPERATOR_VERTEX)","localPosition = position;","localNormal = normal;","#endif"].join("\n"),R=["#ifdef NEEDS_UVTOUSE","varying vec2 vUv;","vec2 uvToUse;","varying vec2 vUv2;","vec2 uv2ToUse;","#endif",e._DefaultShaderChunk.map_pars_fragment,U].join("\n"),w=["#ifdef NEEDS_UVTOUSE","uvToUse = vUv;","#ifdef DECAL","uvToUse = dUv;","#endif","#if defined (MAPPING_OPERATOR) && defined(USE_MAPPING_OPERATOR_FRAGMENT)","#ifdef DECAL","if (!decalExplicitUv) {","#if defined(USE_TANGENT_BINORMAL)","uvToUse = applyMappingOperator(uvToUse, dObjectSpacePosition, dObjectSpaceNormal,tangent,binormal);","#else","uvToUse = applyMappingOperator(uvToUse, dObjectSpacePosition, dObjectSpaceNormal);","#endif","} else {","#if defined(USE_TANGENT_BINORMAL)","uvToUse = applyMappingOperator(uvToUse, dObjectSpacePosition, dObjectSpaceNormal, 0, tangent,binormal);","#else","uvToUse = applyMappingOperator(uvToUse, dObjectSpacePosition, dObjectSpaceNormal, 0);","#endif","}","#else","#if defined(USE_TANGENT_BINORMAL)","uvToUse = applyMappingOperator(uvToUse, localPosition, localNormal,tangent,binormal);","#else","uvToUse = applyMappingOperator(uvToUse, localPosition, localNormal);","#endif","#endif","#endif","uv2ToUse = vUv2;","#ifdef DECAL","uv2ToUse = dUv2;","#endif","#if defined (MAPPING_OPERATOR) && defined(USE_MAPPING_OPERATOR_FRAGMENT)","#ifdef DECAL","if (!decalExplicitUv) {","uv2ToUse = applyMappingOperator(uv2ToUse, dObjectSpacePosition, dObjectSpaceNormal);","} else {","uv2ToUse = applyMappingOperator(uv2ToUse, dObjectSpacePosition, dObjectSpaceNormal, 0);","}","#else","uv2ToUse = applyMappingOperator(uv2ToUse, localPosition, localNormal);","#endif","#endif","#elif defined (USE_TANGENT_BINORMAL) && defined (USE_MAPPING_OPERATOR_FRAGMENT) && defined (MAPPING_OPERATOR)","if (mappingType>0){","vec2 bogusUV = applyMappingOperator(vec2(0.0),localPosition, localNormal,tangent,binormal);","}","#endif",,].join("\n"),F=["#ifdef DECAL","varying vec4 positionVS;","varying vec4 positionCS;","#endif"].join("\n"),O=["#ifdef DECAL","positionVS = mvPosition;","positionCS = gl_Position;","#endif"].join("\n"),V=["#ifdef DECAL","uniform sampler2D currentNormalStencilDepth;","uniform sampler2D currentTexCoord;","#ifdef MOBILE_DEVICE_MODE","uniform sampler2D currentRGBADepth;","#endif","uniform bool decalExplicitUv;","uniform mat4 modelViewInvMatrix;","uniform vec2 viewInfo;","uniform float decalStencilValue;","varying vec4 positionVS;","varying vec4 positionCS;","vec3 decodeOct22Normal(in vec2 iEncodedNormal) {","float x = iEncodedNormal.x/2047.0*2.0 - 1.0;","float y = iEncodedNormal.y/2047.0*2.0 - 1.0;","vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));","if (v.z <= 0.0) {","vec2 sgn = signNotZero(v.xy);","v.xy = - abs(v.yx)*sgn + sgn;","}","return normalize(v);","}","float getEyeDepthPers(in float iZClipSpace)","{","return (2.0 * viewInfo.x * viewInfo.y) / (viewInfo.y + viewInfo.x - iZClipSpace * (viewInfo.y - viewInfo.x));","}","float getEyeDepthOrtho(in float iZClipSpace)","{","return 0.5 * ((viewInfo.y - viewInfo.x) * iZClipSpace + viewInfo.y + viewInfo.x);","}","vec3 noBoxTest(in float depth, out vec2 dUv, out vec3 dObjectSpacePosition) {","vec4 nMVPosition;","if (projectionMatrix[3][3] > 0.5) {","float viewDepth = getEyeDepthOrtho(2.0*depth-1.0);","vec3 viewRay = vec3(0.0, 0.0, -1.0);","vec3 origin = vec3(positionVS.xy, 0.0);","nMVPosition = vec4(origin + viewRay * viewDepth,1.0);","} else {","float viewDepth = getEyeDepthPers(2.0*depth-1.0);","vec3 viewRay = (positionVS.xyz  / -positionVS.z);","nMVPosition = vec4(viewRay * viewDepth,1.0);","}","vec4 pos = (modelViewInvMatrix * nMVPosition);","dObjectSpacePosition = pos.xyz;","pos.xyz /= pos.w;","dUv = pos.xy + 0.5;","if (any(greaterThan(abs(pos.xyz), vec3(.5)))){","discard;","}","#ifdef USE_SHADOWMAP","for( int i = 0; i < MAX_SHADOWS; i ++ ) {","vShadowCoord[ i ] = computeShadowCoord(pos.xyz, shadowMatrix[i],shadowCameraPosition[i],lowPartShadowCameraPosition[i]);","}","#endif","float depthToUse = depth;","float dDecalx = dFdx (depthToUse);","float dDecaly = dFdy (depthToUse);","#ifdef MOBILE_DEVICE_MODE","depthToUse -= 4.0 * (sqrt(dDecalx*dDecalx + dDecaly*dDecaly) + DEPTH_PRECISION);","#else","depthToUse -= 2.0 * (sqrt(dDecalx*dDecalx + dDecaly*dDecaly) + DEPTH_PRECISION);","#endif","gl_FragDepthEXT = depthToUse;","return -nMVPosition.xyz;","}","#endif"].join("\n"),z=["#ifdef DECAL","vec2 screenPos = positionCS.xy/positionCS.w;","vec2 decalFetchUv = 0.5*vec2(screenPos.x, screenPos.y) + 0.5;","vec4 normalStencilDepthValue = texture2D(currentNormalStencilDepth, decalFetchUv);","if (floor(normalStencilDepthValue.z + 0.5) - decalStencilValue < 0.0) {","discard;","}","vec3 decalNormal = decodeOct22Normal(normalStencilDepthValue.xy);","vec3 dObjectSpaceNormal = normalize((modelViewInvMatrix * vec4(decalNormal, 0.0)).xyz);","vec2 dUv;","vec3 dObjectSpacePosition;","float decalDepth = normalStencilDepthValue.w;","#ifdef MOBILE_DEVICE_MODE","decalDepth = unpackRGBA(texture2D(currentRGBADepth, decalFetchUv));","#endif","vec3 dViewPosition = noBoxTest(decalDepth, dUv,dObjectSpacePosition);","vec2 dUv2 = dUv;","if (decalExplicitUv) {","vec4 currentTexCoordsFetch = texture2D(currentTexCoord, decalFetchUv);","dUv = currentTexCoordsFetch.xy;","dUv2 = currentTexCoordsFetch.zw;","}","vec3 dWorldPosition = (modelMatrix * vec4(dObjectSpacePosition,1.0)).xyz;","#ifdef USE_SHADOWMAP_CUBE","decalShadowCubeWorldPosition = dWorldPosition;","#endif","#ifdef DEBUG_DECAL","gl_FragColor.rgba = vec4(1.0, 0.0, 0.0, 0.5);","return;","#endif","#endif"].join("\n"),b=["#if defined(USE_DISPLACEMENTMAP)","uniform sampler2D displacementMap;","uniform vec2 displacementMapSize;","uniform float displacementRadius;","uniform mat3 displacementUvTransform;","uniform int displacementUvSlot;","#define DIS_INCLUDE_DIAGONALS","struct DisplacementData","{","vec3 normal;","vec3 tangent;","vec3 binormal;","};","DisplacementData displacementData;","vec3 vNormalize( vec3 val )","{","float len = length(val);","if ( len < 1e-6) {","return vec3(0.0);","}","return val/len;","}","#ifdef SPECGLOSS","uniform float displacementBias;","uniform float displacementScale;","vec3 ComputeDisplacedPosition(in vec2 displacementUV, in vec3 position) {","#ifdef MAPPING_OPERATOR","displacementUV = applyMappingOperator(displacementUV, position, displacementData.normal,displacementData.tangent,displacementData.binormal);","#endif","displacementUV = applyUVCombination(displacementUV,displacementUvTransform);","vec3 dv = 2.0 * texture2D( displacementMap, displacementUV ).xyz - 1.0;","float df = displacementScale * dv.x + displacementBias;","return position + normalize(displacementData.normal) * df;","}","#else","#ifdef USE_DISPLACEMENT_COEFFICIENTS","uniform vec3 displacementAddCoef;","uniform vec3 displacementMulCoef;","#endif","vec3 ComputeDisplacedPosition(in vec2 displacementUV, in vec3 position) {","#ifdef MAPPING_OPERATOR","displacementUV = applyMappingOperator(displacementUV, position, displacementData.normal,displacementData.tangent,displacementData.binormal);","#endif","displacementUV = applyUVCombination(displacementUV,displacementUvTransform);","vec3 dv = 2.0 * texture2D( displacementMap, displacementUV ).xyz - 1.0;","#ifdef USE_DISPLACEMENT_COEFFICIENTS","dv = displacementMulCoef * dv + displacementAddCoef;","#endif","vec3 df = normalize(displacementData.normal) * dv.z + normalize(displacementData.tangent) * dv.x + normalize(displacementData.binormal) * dv.y;","return position + df;","}","#endif","vec3 ComputeDisplacedNormal(in vec2 displacementUV, in vec3 displacedPosition, in vec3 position) {","float displacementDelta = length(displacedPosition - position);","if (displacementDelta <= 1e-3) {","return normal;","}","vec2 uvOffsetFactor = 1.25 / displacementMapSize;","float objectOffsetFactor = 0.00872664625 * displacementRadius / max(max(length(displacementUvTransform[0]),length(displacementUvTransform[1])), 1.0);","vec3 t = displacementData.tangent * objectOffsetFactor;","vec3 b = displacementData.binormal * objectOffsetFactor;","vec3 A = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(1.0,0.0) , position + t    ) - displacedPosition);","vec3 C = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(0.0,1.0) , position     + b) - displacedPosition);","vec3 E = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(-1.0,0.0), position - t    ) - displacedPosition);","vec3 G = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(0.0,-1.0), position     - b) - displacedPosition);","#ifdef DIS_INCLUDE_DIAGONALS","vec3 B = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(1.0,1.0)  , position + t + b) - displacedPosition);","vec3 D = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(-1.0,1.0) , position - t + b) - displacedPosition);","vec3 F = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(-1.0,-1.0), position - t - b) - displacedPosition);","vec3 H = vNormalize(ComputeDisplacedPosition(displacementUV + uvOffsetFactor * vec2(1.0,-1.0) , position + t - b) - displacedPosition);","vec3 displacedNormal = cross(A, B) + cross(B, C) + cross(C, D) + cross(D,E)+ cross(E,F)+ cross(F,G)+ cross(G,H)+ cross(H,A);","#else","vec3 displacedNormal = cross(A, C) + cross(C, E) + cross(E, G) + cross(G,A);","#endif","float dotNdN = dot(displacedNormal, displacementData.normal);","return vNormalize((sign(dotNdN) + 1e-2)* displacedNormal);","}","#endif"].join("\n"),k=["#if defined(USE_DISPLACEMENTMAP)","displacementData.tangent = objectTangent.xyz;","displacementData.binormal = objectBinormal.xyz;","vec2 displacementUv = displacementUvSlot == 1 ? uv : uv2;","#ifdef USE_SKINNING","displacementData.normal = skinnedNormal.xyz;","vec3 displacedPosition = ComputeDisplacedPosition(displacementUv, skinned.xyz);","vec3 displacedNormal = ComputeDisplacedNormal(displacedPosition, skinned.xyz);","#else","displacementData.normal = normal.xyz;","vec3 displacedPosition = ComputeDisplacedPosition(displacementUv, position.xyz);","vec3 displacedNormal = ComputeDisplacedNormal(displacementUv, displacedPosition, position.xyz);","#endif","#endif"].join("\n"),B=function(t,o){t[o+"UvTransform"]={type:"m3",value:new e.Matrix3},t[o+"AddCoef"]={type:"f",value:0},t[o+"MulCoef"]={type:"f",value:1},t[o+"Map"]={type:"t",value:null},t[o+"UvSlot"]={type:"i",value:1}},H=function(e,t){e[t]={type:"f",value:1},B(e,t)},G=function(t,o){t[o+"UvTransform"]={type:"m3",value:new e.Matrix3},t[o+"AddCoef"]={type:"v3",value:new e.Vector3},t[o+"MulCoef"]={type:"v3",value:new e.Vector3},t[o+"Map"]={type:"t",value:null},t[o+"UvSlot"]={type:"i",value:1}},j=function(t,o){t[o]={type:"c",value:new e.Color(16777215)},G(t,o)},X={reflectionColorTexture:{type:"t",value:null},refractionColorTexture:{type:"t",value:null},invScreenSize:{type:"v2",value:new e.Vector2},diffuseUvTransform:{type:"m3",value:new e.Matrix3},diffuseUvSlot:{type:"i",value:1},diffuseMulCoef:{type:"v3",value:new e.Vector3},diffuseAddCoef:{type:"v3",value:new e.Vector3},diffuseBorderColor:{type:"v4",value:new e.Vector4},_colorOverride:{type:"i",value:0},emissionValue:{type:"f",value:0},bumpUvTransform:{type:"m3",value:new e.Matrix3},bumpUvSlot:{type:"i",value:1},ior:{type:"f",value:1.4},iridescenceIoR:{type:"f",value:1},glossinessMap:{type:"t",value:null},glossinessMulCoef:{type:"f",value:1},glossinessAddCoef:{type:"f",value:0},displacementMapSize:{type:"v2",value:new e.Vector2},displacementBias:{type:"f",value:0},displacementScale:{type:"f",value:0},reflectionProbe:{type:"t",value:null},reflectionProbeMips:{type:"t",value:null},reflectionProbeProxyMin:{type:"v3",value:new e.Vector3},reflectionProbeProxyMax:{type:"v3",value:new e.Vector3},reflectionProbePos:{type:"v3",value:new e.Vector3},envMapSheen:{type:"t",value:null},flakesBump:{type:"f",value:0},flakesDensity:{type:"f",value:0},flakesScale:{type:"f",value:0},pearlFlakesColor:{type:"c",value:new e.Color(0)},pearlFlakesDensity:{type:"f",value:0},pearlFlakesBump:{type:"f",value:0},pearlFlakesColorMulCoef:{type:"v3",value:new e.Vector3},pearlFlakesColorAddCoef:{type:"v3",value:new e.Vector3},sphereCenter:{type:"v3",value:new e.Vector3},projectionCenter:{type:"v3",value:new e.Vector3},sphereRadius:{type:"f",value:0},coatingGlossinessMap:{type:"t",value:null},coatingGlossinessMulCoef:{type:"f",value:1},coatingGlossinessAddCoef:{type:"f",value:0},clearCoatNormalScale:{type:"f",value:1},orangePeelScale:{type:"f",value:0},precomputedTexture:{type:"t",value:null},envMap2:{type:"t",value:null},sssLUT:{type:"t",value:null},absorptionCoefficients:{type:"v3",value:new e.Vector3},maxTranslucencyDepth:{type:"v3",value:new e.Vector3}};G(X,"normal"),G(X,"displacement"),G(X,"clearCoatNormal"),B(X,"normalScale"),H(X,"thickness"),j(X,"specular"),H(X,"bumpScale"),H(X,"metalness"),H(X,"specularContrib"),j(X,"emissionColor"),H(X,"transparency"),H(X,"opacity"),X.opacityBorderValue={type:"f",value:0},H(X,"roughness"),H(X,"anisotropy"),H(X,"anisotropyAngle"),H(X,"sheen"),H(X,"sheenRoughness"),j(X,"sheenColor"),j(X,"flakesColor"),H(X,"flakesSize"),H(X,"flakesCoverage"),H(X,"flakesRoughness"),H(X,"flipFlop"),j(X,"flipFlopColor"),H(X,"clearCoat"),H(X,"clearCoatRoughness"),j(X,"clearCoatColor"),H(X,"translucency"),j(X,"translucencyColor"),H(X,"iridescence"),H(X,"iridescenceThickness");var W=t.prototype.deferrable,Z=function(t){return["#define PHYSICALDS",e._DefaultShaderChunk.normal_viewposition_pars_vertex,e.ShaderChunk.color_pars_vertex,e.ShaderChunk.clip_pars_vertex,L,b,t?e.ShaderChunk.envmap_pars_vertex:"",i,t?e.ShaderChunk.shadowmap_pars_vertex:"",e.ShaderChunk.tangent_Binormal_pars,e.ShaderChunk.skinning_pars_vertex,e.ShaderChunk.fog_pars_vertex,e.DeferredShaderChunk.oit_pars_vertex,!t&&W?e.DeferredShaderChunk.depth_pars_vertex:"",!t&&W?e.DeferredShaderChunk.picking_pars_vertex:"",!t&&W?e.DeferredShaderChunk.picking_instancing_pars_vertex:"",!t&&W?e.DeferredShaderChunk.highlight_pars_vertex:"",!t&&W?e.DeferredShaderChunk.texcoord_pars_vertex:"",F,"void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.color_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.skinning_vertex,I,e.ShaderChunk.tangent_Binormal_vertex,k,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,O,e.ShaderChunk.clip_vertex,e.ShaderChunk.fog_vertex,e._DefaultShaderChunk.normal_viewposition_vertex,e.ShaderChunk.worldpos_vertex,t?e.ShaderChunk.envmap_vertex:"",r,t?e.ShaderChunk.shadowmap_vertex:"",e.DeferredShaderChunk.oit_vertex,!t&&W?e.DeferredShaderChunk.depth_vertex:"",!t&&W?e.DeferredShaderChunk.picking_vertex:"",!t&&W?e.DeferredShaderChunk.picking_instancing_vertex:"",!t&&W?e.DeferredShaderChunk.highlight_vertex:"",!t&&W?e.DeferredShaderChunk.texcoord_vertex:"",e.ShaderChunk.PDSFX_end_vertex,"}"].join("\n")},Y=function(t){return["#define PHYSICALDS","#define ROUGHNESS_CLAMP_MIN 0.025","#define ROUGHNESS_CLAMP_MAX 0.975","#ifdef MOBILE_DEVICE_MODE","#define GEOMETRIC_FAST","#endif","#if defined(USE_SPECGLOSS_FLAKES) || defined(USE_DSPBR_FLAKES) ||defined(USE_ORANGE_PEEL) ","#define NEED_OBJECT_SPACE_DATA","#endif","#if defined(USE_LIGHTING)","#if defined(SSLREFRACTION_ENABLED) && !defined(SKIP_TRANSPAR)","#define USE_SSLREFRACTION","#endif","#if defined(SSLREFLECTION_ENABLED)","#define USE_SSLREFLECTION","#endif","#endif","#if !defined(GL_OES_standard_derivatives) && !defined(GLSL300ES)","#if defined(USE_DSPBR_FLAKES)","#undef USE_DSPBR_FLAKES","#endif","#endif","#if !defined(DSPBR19x) && !defined(SPECGLOSS)","#define DSPBR_WITH_TRANSLUCENCY","#define DSPBR_WITH_CLEAR_COAT_ABOVE_EMISSIVE","#define DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","#endif","#if !defined(DSPBR19x) && !defined(SPECGLOSS) && !defined(DSPBR21x)","#ifdef USE_FLIPFLOP","#define DSPBR_WITH_FLIPFLOP_COLOR","#endif","#ifdef USE_SOFT_VELVET","#define DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS","#endif","#define DSPBR_WITH_NO_SHEEN_VALUE","#endif","#if !defined(DSPBR19x) && !defined(SPECGLOSS) && !defined(DSPBR21x) && !defined(DSPBR22x)","#define DSPBR_WITH_TRANSLUCENCY_COLOR","#endif","struct matData","{","float roughness;","float transparency;","float metalness;","vec3 diffuseColor;","vec3 transparentColor;","float specularContribution;","vec3 specularTint;","vec3 specularBlendingSR0;","vec3 sr0Color;","vec3 sr90Color;","float ior;","float adjustedIoR;","float F0;","#ifdef DSPBR","vec3 specularEnergyConservationConstant;","float diffuseEnergyConservationConstant;","#endif","#ifdef DSPBR_WITH_TRANSLUCENCY","float translucency;","vec3 translucencyColor;","#endif","#ifdef USE_IRIDESCENCE","float iridescence;","float iridescenceIoR;","float iridescenceThickness;","vec3 iridescenceSR0Color;","#endif","#ifdef USE_ANISOTROPY","float anisotropy;","float anisotropyAngle;","#endif","#ifdef USE_SHEEN","float sheen;","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","float sheenRoughness;","vec3 sheenColor;","float sheenEnergyConservationConstant;","#endif","#endif","#ifdef CLEAR_COAT","float clearCoat;","float clearCoatRoughness;","vec3 clearCoatSR0Color;","vec3 clearCoatSR90Color;","#endif","#ifdef USE_SUBSURFACE","vec3 scatteringColor;","#ifdef USE_THICKNESS","vec3 transmittanceColor;","#endif","#endif","};","struct surfData","{","vec3 viewNormal;","vec3 worldNormal;","vec3 view;","vec3 worldPosition;","vec3 viewPosition;","#ifdef NEED_OBJECT_SPACE_DATA","vec3 objectSpacePosition;","vec3 objectSpaceNormal;","#endif","#ifdef USE_ANISOTROPY","vec3 tangent;","vec3 binormal;","#endif","#ifdef CLEAR_COAT","vec3 clearCoatNormal;","vec3 clearCoatWorldNormal;","#endif","#ifdef USE_SUBSURFACE","float curvature;","#endif","#ifdef USE_SPECULAR_AA","mat3 TBNMatrixForSpecularAA;","vec3 TForSpecularAA;","vec3 BForSpecularAA;","#endif","#if defined(USE_THICKNESS)","float thickness;","#endif","};","#ifdef TEXTURE_BLENDING","#if TEXTURE_BLENDING == 1","#define TEXTURE_MODULATE","#endif","#if TEXTURE_BLENDING == 2","#define TEXTURE_BLEND","#endif","#if TEXTURE_BLENDING == 0","#define TEXTURE_DECAL","#endif","#if TEXTURE_BLENDING == 3","#define TEXTURE_REPLACE",t?"":"#define TEXTURE_REPLACE_CONTINUE","#endif","#if TEXTURE_BLENDING == 4","#define TEXTURE_IGNORE","#endif","#if TEXTURE_BLENDING == 5","#define TEXTURE_DEFAULT","#endif","#else","#define TEXTURE_DEFAULT","#endif","matData materialData;","surfData surfaceData;","vec2 hdrSize;","vec2 hdrTexelSize;","vec2 mipsSize;","vec2 mipsTexelSize;","vec3 luminanceVector = vec3(0.299, 0.587, 0.114);","varying vec3 vWorldPosition;",e._DefaultShaderChunk.normal_viewposition_pars_fragment,e.ShaderChunk.color_pars_fragment,e.ShaderChunk.clip_pars_fragment,R,"#ifdef USE_MAP","uniform sampler2D map;","#endif",t?e.ShaderChunk.envmap_pars_fragment:"","#ifndef USE_ENVMAP","const float PI = 3.14159265359;","const float INV_PI = 0.31830988618;","#endif",e.ShaderChunk.tangent_Binormal_pars_fragment,t?e.ShaderChunk.shadowmap_pars_fragment:"",n,t?l:"",function(e){var t,o,a=function(e,t){return["uniform "+e+" "+t+"MulCoef;","uniform "+e+" "+t+"AddCoef;"].join("\n")},i=function(e){return a("vec3",e)},r=function(e){return a("float",e)},n=["#ifdef USE_DIFFUSE_COEFFICIENTS",i("diffuse"),"#endif","#ifdef USE_SPECULAR_COEFFICIENTS",i("specular"),"#endif","#ifdef USE_METALNESS_COEFFICIENTS",r("metalness"),"#endif","#ifdef USE_SPECULARCONTRIB_COEFFICIENTS",r("specularContrib"),"#endif","#ifdef USE_EMISSIONCOLOR_COEFFICIENTS",i("emissionColor"),"#endif","#if defined(USE_NORMAL_COEFFICIENTS) && defined(DSPBR)",i("normal"),"#endif","#ifdef USE_TRANSPARENCY_COEFFICIENTS",r("transparency"),"#endif","#ifdef USE_OPACITY_COEFFICIENTS",r("opacity"),"#endif","#if defined(USE_TRANSLUCENCY_COEFFICIENTS) && defined(DSPBR_WITH_TRANSLUCENCY)",r("translucency"),"#endif","#if defined(USE_TRANSLUCENCY_COLOR_COEFFICIENTS) && defined(DSPBR_WITH_TRANSLUCENCY_COLOR)",i("translucencyColor"),"#endif","#if defined(USE_IRIDESCENCE_COEFFICIENTS)",r("iridescence"),"#endif","#if defined(USE_IRIDESCENCE_THICKNESS_COEFFICIENTS)",r("iridescenceThickness"),"#endif","#ifdef USE_ROUGHNESS_COEFFICIENTS",r("roughness"),"#endif","#ifdef USE_GLOSSINESS_COEFFICIENTS",r("glossiness"),"#endif","#ifdef USE_ANISOTROPY_COEFFICIENTS",r("anisotropy"),"#endif","#ifdef USE_ANISOTROPYANGLE_COEFFICIENTS",r("anisotropyAngle"),"#endif","#ifdef USE_CC_COEFFICIENTS",r("clearCoat"),"#endif","#if defined(USE_CC_NORMAL_COEFFICIENTS) && defined(DSPBR)",i("clearCoatNormal"),"#endif","#if defined(USE_CC_COLOR_COEFFICIENTS) && defined(SPECGLOSS)",i("clearCoatColor"),"#endif","#ifdef USE_CC_ROUGHNESS_COEFFICIENTS",r("clearCoatRoughness"),"#endif","#ifdef USE_CC_GLOSSINESS_COEFFICIENTS",r("coatingGlossiness"),"#endif","#if defined(USE_SHEEN_COEFFICIENTS) && !defined(DSPBR_WITH_NO_SHEEN_VALUE)",r("sheen"),"#endif","#if defined(USE_SHEEN_COLOR_COEFFICIENTS) && defined(DSPBR_WITH_SHEEN_COLOR_ROUGHNESS)",i("sheenColor"),"#endif","#if defined(USE_SHEEN_ROUGHNESS_COEFFICIENTS) && defined(DSPBR_WITH_SHEEN_COLOR_ROUGHNESS)",r("sheenRoughness"),"#endif","#ifdef USE_DSPBR_FLAKES","#ifdef USE_FLAKESCOLOR_COEFFICIENTS",i("flakesColor"),"#endif","#endif","#ifdef USE_FLAKESSIZE_COEFFICIENTS",r("flakesSize"),"#endif","#ifdef USE_FLAKESCOVERAGE_COEFFICIENTS",r("flakesCoverage"),"#endif","#ifdef USE_FLAKESROUGHNESS_COEFFICIENTS",r("flakesRoughness"),"#endif","#if defined(USE_NORMALSCALE_COEFFICIENTS) && defined(SPECGLOSS)",r("normalScale"),"#endif","#if defined(USE_BUMPSCALE_COEFFICIENTS) && defined(SPECGLOSS)",r("bumpScale"),"#endif","#if defined(USE_THICKNESS_COEFFICIENTS)",r("thickness"),"#endif","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","#ifdef USE_FLIPFLOP_COLOR_COEFFICIENTS",i("flipFlopColor"),"#endif","#ifdef USE_FLIPFLOP_COEFFICIENTS",r("flipFlop"),"#endif","#endif"].join("\n"),l=["#if MAX_DIR_LIGHTS > 0","uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];","uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];","#endif","#if MAX_DIR_IBL_LIGHTS > 0 && defined(USE_ENVMAP) && defined(USE_SUBSURFACE)","uniform vec3 directionalIBLLightColor[ MAX_DIR_IBL_LIGHTS ];","uniform vec3 directionalIBLLightDirection[ MAX_DIR_IBL_LIGHTS ];","#endif","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];","#ifdef PHONG_PER_PIXEL","uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];","uniform int pointLightPhysicalAttenuation[ MAX_POINT_LIGHTS ];","uniform float pointLightDistance[ MAX_POINT_LIGHTS ];","#else","varying vec4 vPointLight[ MAX_POINT_LIGHTS ];","#endif","#endif","#if MAX_IES_LIGHTS > 0","uniform vec3 iesLightColor[ MAX_IES_LIGHTS ];","uniform sampler2D iesLightTexture[ MAX_IES_LIGHTS ];","uniform mat4 matrixWorldInv[MAX_IES_LIGHTS];","#ifdef PHONG_PER_PIXEL","uniform vec3 iesLightPosition[ MAX_IES_LIGHTS ];","uniform float iesLightDistance[ MAX_IES_LIGHTS ];","#else","varying vec4 viesLight[ MAX_IES_LIGHTS ];","#endif","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];","uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];","uniform float spotLightInnerAngleCos[ MAX_SPOT_LIGHTS ];","#ifdef PHONG_PER_PIXEL","uniform int spotLightPhysicalAttenuation[ MAX_SPOT_LIGHTS ];","uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","#else","varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];","#endif","#endif","#if MAX_SPHERE_LIGHTS > 0","uniform vec3 sphereLightColor[ MAX_SPHERE_LIGHTS ];","uniform vec3 sphereLightPosition[ MAX_SPHERE_LIGHTS ];","uniform vec3 sphereLightData[ MAX_SPHERE_LIGHTS ];","#endif","#if MAX_DISK_LIGHTS > 0","uniform vec3 diskLightColor[ MAX_DISK_LIGHTS ];","uniform vec3 diskLightPosition[ MAX_DISK_LIGHTS ];","uniform vec3 diskLightNormal[ MAX_DISK_LIGHTS ];","uniform vec3 diskLightUp[ MAX_DISK_LIGHTS ];","uniform vec3 diskLightData[ MAX_DISK_LIGHTS ];","#endif","#if MAX_AREA_LIGHTS > 0","uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];","uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];","uniform vec3 areaLightNormal[ MAX_AREA_LIGHTS ];","uniform vec3 areaLightUp[ MAX_AREA_LIGHTS ];","uniform vec3 areaLightData[ MAX_AREA_LIGHTS ];","#endif","#if MAX_TUBE_LIGHTS > 0","uniform vec3 tubeLightColor[ MAX_TUBE_LIGHTS ];","uniform vec3 tubeLightPosition[ MAX_TUBE_LIGHTS ];","uniform vec3 tubeLightRight[ MAX_TUBE_LIGHTS ];","uniform vec3 tubeLightData[ MAX_TUBE_LIGHTS ];","#endif","#if MAX_TUBE_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || MAX_DISK_LIGHTS > 0 || MAX_SPHERE_LIGHTS > 0","#define HAS_AREA_LIGHTS","#endif","#ifdef HAS_AREA_LIGHTS","uniform sampler2D precomputedAreaGGX1texture;","uniform sampler2D precomputedAreaGGX2texture;","#ifdef USE_SHEEN","#if defined(USE_VELVET)","uniform sampler2D precomputedAreaAshikmintexture;","#endif","#if defined(USE_SOFT_VELVET)","uniform sampler2D precomputedAreaEsteveztexture;","#endif","#if defined(USE_SATIN)","uniform sampler2D precomputedAreaBeckmanntexture;","#endif","#endif","#endif","#ifdef USE_LIGHTMAP","uniform sampler2D lightMap;","uniform mat3 lightMapUvTransform;","uniform int lightMapUvSlot;","#endif","uniform vec3 ambientLightColor;"].join("\n"),s=function(e,t,o){return["uniform "+e+" "+t+";","#ifdef "+o,"uniform sampler2D "+t+"Map;","uniform mat3 "+t+"UvTransform;","uniform int "+t+"UvSlot;","#endif"].join("\n")},f=function(e,t){return s("vec3",e,t)},c=function(e,t){return s("float",e,t)};t=[e?l:"",["uniform vec3 diffuse;","#ifdef USE_MAP","uniform mat3 diffuseUvTransform;","uniform int _colorOverride;","uniform int diffuseUvSlot;","#if defined(USE_DIFFUSEMAP_BORDER_COLOR_U) || defined(USE_DIFFUSEMAP_BORDER_COLOR_V)","uniform vec4 diffuseBorderColor;","#endif","#endif",f("specular","USE_SPECULARMAP"),f("emissionColor","USE_EMISSIONCOLORMAP"),"uniform float emissionValue;",c("transparency","USE_TRANSPARENCYMAP"),c("opacity","USE_OPACITYMAP"),"#if defined(USE_OPACITYMAP_BORDER_COLOR_U) || defined(USE_OPACITYMAP_BORDER_COLOR_V)","uniform float opacityBorderValue;","#endif",c("metalness","USE_METALNESSMAP"),c("specularContrib","USE_SPECULARCONTRIBMAP"),"uniform float ior;","uniform float roughness;","#ifdef USE_ROUGHNESSMAP","uniform sampler2D roughnessMap;","#endif","#ifdef USE_GLOSSINESSMAP","uniform sampler2D glossinessMap;","#endif","#if defined(USE_ROUGHNESSMAP) || defined(USE_GLOSSINESSMAP)","uniform mat3 roughnessUvTransform;","uniform int roughnessUvSlot;","#endif","#ifdef USE_ANISOTROPY",c("anisotropy","USE_ANISOTROPYMAP"),c("anisotropyAngle","USE_ANISOTROPYANGLEMAP"),"#endif","#ifdef USE_SHEEN","#ifndef DSPBR_WITH_NO_SHEEN_VALUE",c("sheen","USE_SHEEN_MAP"),"#endif","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS",c("sheenRoughness","USE_SHEEN_ROUGHNESS_MAP"),f("sheenColor","USE_SHEEN_COLOR_MAP"),"#endif","#ifdef USE_ENVMAP_SHEEN","uniform sampler2D envMapSheen;","#endif","#endif","#ifdef CLEAR_COAT",c("clearCoat","CLEAR_COAT_MAP"),"#ifdef CLEAR_COAT_NORMALMAP","uniform sampler2D clearCoatNormalMap;","uniform mat3 clearCoatNormalUvTransform;","uniform int clearCoatNormalUvSlot;","#endif","#ifdef SPECGLOSS","uniform float clearCoatNormalScale;",f("clearCoatColor","CLEAR_COAT_COLORMAP"),"#endif","uniform float clearCoatRoughness;","#ifdef USE_CC_ROUGHNESSMAP","uniform sampler2D clearCoatRoughnessMap;","#endif","#ifdef USE_CC_GLOSSINESSMAP","uniform sampler2D coatingGlossinessMap;","#endif","#if defined(USE_CC_ROUGHNESSMAP) || defined(USE_CC_GLOSSINESSMAP)","uniform mat3 clearCoatRoughnessUvTransform;","uniform int clearCoatRoughnessUvSlot;","#endif","#ifdef USE_ORANGE_PEEL","uniform float orangePeelScale;","#endif","#endif","#ifdef USE_SPECGLOSS_FLAKES","uniform vec3 flakesColor;","uniform float flakesDensity;","uniform float flakesBump;","uniform vec3 flakesColorMulCoef;","uniform vec3 flakesColorAddCoef;","uniform vec3 pearlFlakesColor;","uniform float pearlFlakesDensity;","uniform float pearlFlakesBump;","uniform vec3 pearlFlakesColorMulCoef;","uniform vec3 pearlFlakesColorAddCoef;","uniform float flakesRoughness;","uniform float flakesScale;","#endif","#ifdef USE_DSPBR_FLAKES",f("flakesColor","USE_FLAKESCOLOR_MAP"),c("flakesCoverage","USE_FLAKESCOVERAGE_MAP"),c("flakesRoughness","USE_FLAKESROUGHNESS_MAP"),c("flakesSize","USE_FLAKESSIZE_MAP"),"#ifdef DSPBR_WITH_FLIPFLOP_COLOR",f("flipFlopColor","USE_FLIPFLOP_COLOR_MAP"),c("flipFlop","USE_FLIPFLOP_MAP"),"#endif","#endif","#ifdef SPECGLOSS","#ifdef USE_NORMALSCALEMAP","uniform sampler2D normalScaleMap;","uniform mat3 normalScaleUvTransform;","uniform int normalScaleUvSlot;","#endif","#ifdef USE_BUMPSCALEMAP","uniform sampler2D bumpScaleMap;","uniform mat3 bumpScaleUvTransform;","uniform int bumpScaleUvSlot;","#endif","#ifdef USE_BUMPMAP","uniform mat3 bumpUvTransform;","uniform int bumpUvSlot;","#endif","#endif","#ifdef DSPBR_WITH_TRANSLUCENCY",c("translucency","USE_TRANSLUCENCYMAP"),"#endif","#ifdef DSPBR_WITH_TRANSLUCENCY_COLOR",f("translucencyColor","USE_TRANSLUCENCY_COLOR_MAP"),"#endif","#ifdef USE_IRIDESCENCE","uniform float iridescenceIoR;",c("iridescence","USE_IRIDESCENCE_MAP"),c("iridescenceThickness","USE_IRIDESCENCE_THICKNESS_MAP"),"#endif","#ifdef USE_SUBSURFACE","#ifdef USE_SSSLUT","uniform vec3 maxTranslucencyDepth;","uniform sampler2D sssLUT;","#else","uniform vec3 absorptionCoefficients;","#endif","#endif","#ifdef USE_THICKNESS",c("thickness","USE_THICKNESSMAP"),"#endif","#ifdef USE_NORMALMAP","uniform mat3 normalUvTransform;","uniform int normalUvSlot;","#endif"].join("\n"),n,"#if defined(NEED_OBJECT_SPACE_DATA)","varying vec3 vObjectSpacePosition;","varying vec3 vObjectSpaceNormal;","#endif"].join("\n");var v=["vec3 FresnelSchlick(vec3 iSr0Color, float ctheta) {","float Fc = pow(1.0 - ctheta, 5.0);","return Fc + (1.0 - Fc) * iSr0Color;","}","vec3 FresnelSchlick(in vec3 iSr0Color, in vec3 iSr90Color, in float ctheta) {","float power = pow5(1.0 - ctheta);","return  mix(iSr0Color, iSr90Color, power);","}","float FresnelSchlick(in float iSr0Color, in float iSr90Color, in float ctheta) {","float power = pow5(1.0 - ctheta);","return  mix(iSr0Color, iSr90Color, power);","}","vec2 FresnelSchlick(in float ctheta) {","float power = pow5(1. - ctheta);","return vec2((1.0-power),power);","}","vec3 F0FromFresnelSchlick(in vec3 iFresnel, const vec3 iSr90Color, in float ctheta) {","float power = pow5(1.0 - ctheta);","power = clamp(power, 0.0, 1.0 - 1e-6);","return (iFresnel - iSr90Color * power) / (1.0 - power);","}","float SpecGlossEnergyConservationTerm(in float NoL, in float NoV, in vec3 iSr0Color, in vec3 iSr90Color) {","#ifdef SPECGLOSS_NRE","return 1.0 - dot(FresnelSchlick(iSr0Color, iSr90Color, NoL), luminanceVector);","#else","return 1.0 - vMax(max(FresnelSchlick(iSr0Color, iSr90Color, NoL), FresnelSchlick(iSr0Color, iSr90Color, NoV)));","#endif","}","float SpecGlossEnergyConservationTerm(in vec3 fresnel) {","return 1.0 - dot(fresnel, luminanceVector);","}","#ifndef GEOMETRIC_FAST","float GeometricLambda(float a2, float cosTheta) {","return sqrt(1.0 - a2 + a2/max(cosTheta * cosTheta, 1e-6));","}","float GeometricSchlick(float roughness, float NoV, float NoL) {","#ifdef PBR_FROM_GAS","float a2 = 0.01336336;","#else","float a = roughness * roughness;","float a2 = a * a;","#endif","return 2.0 / (GeometricLambda(a2, NoL) + GeometricLambda(a2, NoV));","}","#else","float GeometricLambda(float a, float cosTheta) {","return 1.0 - a + a/max(cosTheta, 1e-6);","}","float GeometricSchlick(float roughness, float NoV, float NoL) {","#ifdef PBR_FROM_GAS","float a = 0.1156;","#else","float a = roughness * roughness;","#endif","return 2.0 / (GeometricLambda(a, NoL) + GeometricLambda(a, NoV));","}","#endif","float GGXVisibility(float roughness, float NoV, float NoL) {","float factor = 0.25 / max(abs(NoL * NoV), 1e-3);","return factor * GeometricSchlick(roughness, NoV, NoL);","}","float DistributionGGX(float roughness, float NoH) {","#ifdef PBR_FROM_GAS","float alpha2 = 0.01336336;","#else","float alpha = roughness * roughness;","float alpha2 = alpha * alpha;","#endif","float NoH2 = NoH * NoH;","float d = max((alpha2 - 1.0) * NoH2 + 1.0, 1e-6);","return alpha2* INV_PI / (d * d);","}","#ifdef DSPBR","float DirectionalMultipleAlbedo(in float cosTheta, in float roughness) {","float a2 = pow4(roughness);","float res = 3.09507 + cosTheta * (-9.11369 + cosTheta * (15.8884 + cosTheta * (-13.70343 + 4.51786 * cosTheta)));","res *= (-0.20277 + a2 * (2.772 + a2 * (-2.6175 + 0.73343*a2)));","res *= 1.4594 * a2 * cosTheta;","return 1.0  - res;","}","float AverageDirectionalMultipleAlbedo(in float roughness) {","float a2 = pow4(roughness);","return 1.0 + a2 * (-0.133 + a2 * (-1.8695 + a2 * (2.2268 - 0.83397*a2)));","}","vec3 AverageMultipleFresnel(in vec3 iSr0Color, in vec3 iSr90Color) {","return mix(iSr90Color, iSr0Color, 0.95238095238);","}","float DirectionalAlbedo(in float F0, in vec3 specularTint, in float cosTheta, in float roughness) {","float a2 = pow4(roughness);","float E0 = F0 * vMax(specularTint);","return vLerp(E0 + (1.0 - E0) * pow5(1.0 - cosTheta), 0.04762 + 0.95238*E0, 1.0 - pow5(1.0 - a2));","}","float AverageDirectionalAlbedo(in float F0, in vec3 specularTint, in float roughness) {","float a2 = pow4(roughness);","float E0 = F0 * vMax(specularTint);","return E0 + (-0.33263 * a2 - 0.072359) * (1.0 - E0) * E0;","}","#endif","#if defined(USE_ANISOTROPY) || defined(USE_SPECULAR_AA)","float AnisotropicGeometricSchlick(float roughnessX, in float roughnessY, float NoV, float NoL, in float iAnisotropyAngle) {","float ax = roughnessX * roughnessX;","float ay = roughnessY * roughnessY;","float a2 = pow2(cos(iAnisotropyAngle)*ax) + pow2(sin(iAnisotropyAngle)*ay);","float G1 = sqrt(1.0-a2+a2/max(NoL*NoL,1e-6));","float G2 = sqrt(1.0-a2+a2/max(NoV*NoV,1e-6));","return 2.0 / (G1+G2);","}","float AnisotropicGGXVisibility(float roughnessX, in float roughnessY, float NoV, float NoL, in float iAnisotropyAngle) {","float factor = 0.25 / max(abs(NoL * NoV), 1e-3);","return factor * AnisotropicGeometricSchlick(roughnessX, roughnessY, NoV, NoL, iAnisotropyAngle);","}","float AnisotropicDistributionGGX(vec3 T, vec3 B, vec3 N, vec3 H, float NoH, in float iRoughnessX, in float iRoughnessY, float iAnisotropyAngle) {","vec3 rot_X = cos(2.0 * PI * iAnisotropyAngle) * T + sin(2.0 * PI * iAnisotropyAngle) * B;","vec3 rot_Y = cross(N, rot_X);","float dot_t_h = dot(rot_X, H);","float dot_b_h = dot(rot_Y, H);","float alpha_T = iRoughnessX;","float alpha_B = iRoughnessY;","alpha_T = max(pow2(alpha_T), 1e-3);","alpha_B = max(pow2(alpha_B), 1e-3);","float a = dot_t_h / alpha_T;","float b = dot_b_h / alpha_B;","float D = a * a + b * b + NoH * NoH;","D = PI * alpha_T * alpha_B * D * D;","D = 1.0 / max(D, kEpsilon);","return D;","}","float ComputeAnisotropicRoughness(in vec3 T, in vec3 B, in vec3 N,in vec3 H, in float iRoughness, in float anisotropy, in float anisotropyAngle) {","vec3  rot_X = cos(anisotropyAngle *2. * PI) * T + sin(anisotropyAngle * 2.* PI) * B;","vec3  rot_Y = cross(N, rot_X);","float dot_t_h = dot(rot_X, H);","float dot_b_h = dot(rot_Y, H);","float alpha_T = iRoughness;","float alpha_B = iRoughness * (1.0 - anisotropy) ;","alpha_T = max(pow2(alpha_T), kEpsilon);","alpha_B = max(pow2(alpha_B), kEpsilon);","float tmp =  sign(dot_b_h) * sign(dot_t_h);","dot_t_h = max(abs(dot_t_h),0.05) * tmp;","dot_b_h = max(abs(dot_b_h),0.05);","float phi = atan(dot_t_h,dot_b_h);","float a = pow2(cos(phi) / alpha_T);","float b = pow2(sin(phi) / alpha_B);","float a2 = 1.0/ (a+b);","float roughness = saturate(sqrt(sqrt(a2)));","return clamp(roughness, ROUGHNESS_CLAMP_MIN, ROUGHNESS_CLAMP_MAX) ;","}","#endif"].join("\n"),d=["vec3 doEmission(in float NoV, in vec3 V, in vec3 color, in float value) {","vec3 res = vec3(0.0);","#ifndef USE_NORMALIZED_EMISSION","res = color * value;","#else","vec3 aux = vec3(0.2126729,0.7151522,0.0721750);","res = color/max(dot(color,aux),1e-6) * value;","#endif","#ifdef DSPBR_WITH_CLEAR_COAT_ABOVE_EMISSIVE","#ifdef CLEAR_COAT","vec3 Nc = surfaceData.clearCoatNormal;","float NcoV = saturate(dot(Nc,V));","float fresnelEnergy = 1.0 - materialData.clearCoat * vMax(FresnelSchlick(materialData.clearCoatSR0Color, materialData.clearCoatSR90Color, NcoV));","res *= fresnelEnergy;","#endif","return res/3.14159;","#elif defined(DSPBR)","return res/3.14159;","#else","return res;","#endif","}"].join("\n"),u=["#ifdef USE_SHEEN","float SheenVisGeometricSchlick(in float NoV, in float NoL) {","float div = 4.0 * max(NoL + NoV - NoL*NoV, 1e-6);","return 1.0 / div;","}","float DirectionalSheenAlbedo(in float cosTheta, in float roughness) {","#ifdef DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS","float a = roughness * roughness;","#else","float a = roughness;","#endif","return 0.04495972 + 0.47479907 * (sqrt(1.0 - cosTheta) + (1.0 - cosTheta) * sqrt(1.0 - sqrt(a)));","}","float SheenDistribution(in float NoH, in float sheenValue) {","float cosine2 = max(NoH * NoH,kEpsilon);","float sine2 = max(1.0-cosine2,kEpsilon);","float D = 1.0;","float normalisationTerm = 0.31830988618379;","#if defined(USE_VELVET)","float a2 = sheenValue * sheenValue;","normalisationTerm *= 1.0/(4.0*a2+1.0);","float sine4 = max(pow2(sine2),kEpsilon);","float cotan2 = cosine2/sine2;","float value = -cotan2 / a2;","D = 1.0+4.0 * exp(value)/ sine4;","#endif","#if defined(USE_SOFT_VELVET)","#if defined(DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS)","float a = pow2(sheenValue);","#else","float a = sheenValue;","#endif","a = max(a, 1e-3);","normalisationTerm *= 0.5;","float sine = sqrt(sine2);","D = (2.0 + 1.0 /a ) * pow(sine, 1.0 / a);","#endif","#if defined(USE_SATIN)","float a2 = 0.0081;","normalisationTerm *= 1.0/(8.0*a2);","float cosine4 = max(pow2(cosine2),kEpsilon);","float tan2 = sine2/cosine2;","float value = -tan2/( a2*8.0);","D = exp(value) / cosine4 ;","#endif","return D * normalisationTerm;","}","void sheenModel(inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","vec3 H = normalize(L+V);","float NoH = saturate(dot(N,H));","float NoL = saturate(dot(N,L));","float NoV = saturate(dot(N,V));","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","vec3 sheenColor = materialData.sheen * materialData.sheenColor * SheenDistribution(NoH, materialData.sheenRoughness)* SheenVisGeometricSchlick(NoL,NoV);","float blending = 1.0 - materialData.sheenEnergyConservationConstant;","specular *= blending;","diffuse *= blending;","specular += sheenColor;","#else","float sheen = SheenDistribution(NoH,materialData.sheen) * SheenVisGeometricSchlick(NoL,NoV);","float blending = 1.0 - pow5(1.0-materialData.sheen);","diffuse *= PI * sheen * blending + (1.0 - blending);","#endif","}","#endif"].join("\n"),p=["#if defined(USE_SPECGLOSS_FLAKES)","#define FREQUENCY 0.6","struct flakes {","float flakesRoughness;","vec3 flakesSR0Color;","vec3 flakesWorldNormal;","vec3 flakesNormal;","};","flakes metal;","flakes metalFlakes;","flakes pearlFlakes;","void specGlossFlakesModel(inout vec3 diffuse, inout vec3 specular, in vec3 V, in vec3 L) {","vec3 H = normalize(L+V);","float NoH = saturate(dot(metalFlakes.flakesNormal,H));","float NoV = saturate(dot(metalFlakes.flakesNormal,V));","float NoL = saturate(dot(metalFlakes.flakesNormal,L));","float VoH = saturate(dot(V,H));","float distrib = DistributionGGX( metalFlakes.flakesRoughness, NoH);","float geomVis = GGXVisibility( metalFlakes.flakesRoughness, NoV, NoL);","vec3 fresnel = FresnelSchlick(metalFlakes.flakesSR0Color, vec3(0.0), VoH);","float fresnelEnergy = SpecGlossEnergyConservationTerm(NoL, NoV, metalFlakes.flakesSR0Color, vec3(0.0));","diffuse *= fresnelEnergy;","specular *= fresnelEnergy;","specular += distrib * fresnel * geomVis;","NoH = saturate(dot(metal.flakesNormal,H));","NoV = saturate(dot(metal.flakesNormal,V));","NoL = saturate(dot(metal.flakesNormal,L));","distrib = DistributionGGX( metal.flakesRoughness, NoH);","geomVis = GGXVisibility( metal.flakesRoughness, NoV, NoL);","fresnel = FresnelSchlick(metal.flakesSR0Color, vec3(0.0), VoH);","fresnelEnergy = SpecGlossEnergyConservationTerm(NoL, NoV, metal.flakesSR0Color, vec3(0.0));","diffuse *= fresnelEnergy;","specular *= fresnelEnergy;","specular += distrib * fresnel * geomVis;","#ifdef PEARL_FLAKES_ACTIVATED","NoH = saturate(dot(pearlFlakes.flakesNormal,H));","NoV = saturate(dot(pearlFlakes.flakesNormal,V));","NoL = saturate(dot(pearlFlakes.flakesNormal,L));","distrib = DistributionGGX( pearlFlakes.flakesRoughness, NoH);","geomVis = GGXVisibility( pearlFlakes.flakesRoughness, NoV, NoL);","fresnel = FresnelSchlick(pearlFlakes.flakesSR0Color, vec3(0.0), VoH);","fresnelEnergy = SpecGlossEnergyConservationTerm(NoL, NoV, pearlFlakes.flakesSR0Color, vec3(0.0));","diffuse *= fresnelEnergy;","specular *= fresnelEnergy;","specular += distrib * fresnel * geomVis;","#endif","}","void flakesVisibility(in vec3 currentWorldNormal, out float flakesLODLevel, out float metallicFlakesBlending, out float flakesMask, in float scaling, in vec3 worldPosition) {","mat3 mat = transposeMatrix(mat3(modelMatrix));","vec3 worldScaling = 1.0/vec3(length(mat[0]),length(mat[1]),length(mat[2]));","vec3 V = cameraPosition - worldPosition; ","float dist = length(worldScaling * V);","V = normalize(V);","float NdotV = dot(currentWorldNormal, V); ","float locality = (NdotV > 0.0) ? 1.0 : 0.0;","if (locality == 0.0) {","flakesLODLevel = 0.0;","metallicFlakesBlending = 0.0;","flakesMask = 0.0;","return;","}","float normDist = saturate(scaling * dist * 0.00125);","float shortDist = 1.0 - normDist;","flakesLODLevel = scaling * dist;","#ifdef ADVANCED_FLAKES_BLENDING","metallicFlakesBlending = normDist * (0.5 * flakesDensity + 0.25);","#else","metallicFlakesBlending = normDist * 0.5 ;","#endif","flakesMask = shortDist;","}","void computeMetallicFlakes(out float metallicFlakesPresence, out vec3 metallicFlakesBaseColor,","in float presenceNoise, in float presenceNoise2, in float noisePositive, in float noiseNegative,","in vec3 T, in vec3 B) {","if (length(flakesColorMulCoef) < kEpsilon) {","return;","}","metallicFlakesPresence = pow5(presenceNoise);","float aux = pow5(presenceNoise2);","metallicFlakesPresence += mix( - aux, aux, flakesDensity);","metallicFlakesPresence *= 5.0;","metallicFlakesPresence = saturate(metallicFlakesPresence);","metallicFlakesBaseColor = mix(2.0 * flakesColor, vec3(0.0), affine(noiseNegative, 0.5, 1.0));","float theta = metallicFlakesPresence * noisePositive* PI * 0.125;","float phi =  metallicFlakesPresence * noiseNegative * PI * 0.125;","metalFlakes.flakesWorldNormal = Rotate3D(metalFlakes.flakesWorldNormal, theta, B);","metalFlakes.flakesWorldNormal = Rotate3D(metalFlakes.flakesWorldNormal, phi, T);","}","void computePearlFlakes(out float pearlFlakesPresence, out vec3 pearlFlakesBaseColor, ","in float presenceNoise, in float presenceNoise2, in float noisePositive, in float noiseNegative,","in vec3 T, in vec3 B) {","if (length(pearlFlakesColorMulCoef) < kEpsilon) {","return;","}","pearlFlakesPresence = pow3(pow6(presenceNoise2));","float aux = pow3(pow6(presenceNoise));","pearlFlakesPresence += mix( - aux, aux, pearlFlakesDensity);","pearlFlakesPresence *= 6.0;","pearlFlakesPresence = saturate(pearlFlakesPresence);","pearlFlakesBaseColor = mix(2.0 * pearlFlakesColor, vec3(0.0), affine(noisePositive, 0.5, 1.0));","float theta = pearlFlakesPresence * noisePositive * PI * 0.25;","float phi =  pearlFlakesPresence * noiseNegative * PI * 0.25;","pearlFlakes.flakesWorldNormal = Rotate3D(pearlFlakes.flakesWorldNormal, theta, B);","pearlFlakes.flakesWorldNormal = Rotate3D(pearlFlakes.flakesWorldNormal, phi, T);","}","void blendMetalFlakes(in vec3 currentWorldNormal, in float flakesMask, in float metallicFlakesBlending, in float metallicFlakesPresence, in vec3 metallicFlakesBaseColor) {","if (length(flakesColorMulCoef) < kEpsilon) {","return;","}","float metallicFlakesStrength = flakesMask * metallicFlakesPresence;","#ifdef FLAKES_NORMAL_PERTURBATION","float metalPerturbateNormal = 0.1 * flakesBump;","#else","float metalPerturbateNormal = 0.0;","#endif","metalFlakes.flakesRoughness = 1.0 - mix(0.75,0.55,flakesRoughness);","metal.flakesRoughness = metalFlakes.flakesRoughness + metalPerturbateNormal;","metal.flakesSR0Color = flakesColorMulCoef * metallicFlakesBlending * flakesColor;","metalFlakes.flakesSR0Color = flakesColorMulCoef * metallicFlakesBaseColor * metallicFlakesStrength;","metalPerturbateNormal *= 10.0 * flakesMask;","metalFlakes.flakesWorldNormal = normalize(currentWorldNormal + metalPerturbateNormal * metalFlakes.flakesWorldNormal);","}","void blendPearlFlakes(in vec3 currentWorldNormal, in float flakesMask, in float pearlFlakesPresence, in vec3 pearlFlakesBaseColor) {","if (length(pearlFlakesColorMulCoef) < kEpsilon) {","return;","}","float pearlFlakesStrength = flakesMask * pearlFlakesPresence;","#ifdef FLAKES_NORMAL_PERTURBATION","float pearlPerturbateNormal = 0.05 * pearlFlakesBump;","#else","float pearlPerturbateNormal = 0.0;","#endif","pearlFlakes.flakesRoughness = 0.25;","pearlFlakes.flakesSR0Color = pearlFlakesColorMulCoef * pearlFlakesBaseColor * pearlFlakesStrength;","pearlPerturbateNormal *= 10.0 * sqrt(flakesMask);","pearlFlakes.flakesWorldNormal = normalize(currentWorldNormal + pearlPerturbateNormal * pearlFlakes.flakesWorldNormal);","}","void doFlakes(in vec3 currentWorldNormal, in vec3 worldPosition, in vec3 objectSpacePosition) { ","float flakesMask = 0.0;","float flakesLODLevel = 0.0;","float scaling = mix(0.0, 0.9, atan(3.14*flakesScale)*2.0/3.14);","vec3 T = getGeomT(currentWorldNormal);","vec3 B = getGeomB(currentWorldNormal, T);","float metallicFlakesBlending = 0.0;","float metallicFlakesPresence = 0.0;","vec3 metallicFlakesBaseColor = vec3(0.0);","metal.flakesRoughness = 0.0;","metal.flakesSR0Color = vec3(0.0);","metal.flakesWorldNormal = currentWorldNormal;","metalFlakes.flakesRoughness = 0.0;","metalFlakes.flakesSR0Color = vec3(0.0);","metalFlakes.flakesWorldNormal = currentWorldNormal;","float pearlFlakesPresence = 0.0;","vec3 pearlFlakesBaseColor = vec3(0.0);","#ifdef PEARL_FLAKES_ACTIVATED","pearlFlakes.flakesRoughness = 0.0;","pearlFlakes.flakesSR0Color = vec3(0.0);","pearlFlakes.flakesWorldNormal = currentWorldNormal;","#endif","flakesVisibility(currentWorldNormal, flakesLODLevel, metallicFlakesBlending, flakesMask, scaling, worldPosition);","if (length(pearlFlakesColorMulCoef) < kEpsilon && length(flakesColorMulCoef) < kEpsilon) {","return;","}","if (flakesMask < kEpsilon) {","blendMetalFlakes(currentWorldNormal, flakesMask, metallicFlakesBlending, metallicFlakesPresence, metallicFlakesBaseColor);","#ifdef PEARL_FLAKES_ACTIVATED","blendPearlFlakes(currentWorldNormal, flakesMask, pearlFlakesPresence, pearlFlakesBaseColor);","#endif","return;","}","vec3 tex = scaling * objectSpacePosition;","tex.y = -abs(tex.y);","tex.x = -abs(tex.x);","#ifdef FLAKES_NORMAL_PERTURBATION","float noisePositive = arrayFBMMixer(0.85 * tex, flakesLODLevel, FREQUENCY,1.0,2.0);","float noiseNegative = arrayFBMMixer(0.85 * tex.yxz, flakesLODLevel, FREQUENCY,1.0,2.0);","#else","float noisePositive = 0.0;","float noiseNegative = 0.0;","#endif","float presenceNoise = affine(arrayFBMMixer(tex, flakesLODLevel, FREQUENCY,1.0,3.0), 0.5, 1.0 );","#ifdef ADVANCED_PRESENCE_NOISE","float presenceNoise2 = affine(arrayFBMMixer(tex.yxz, flakesLODLevel, FREQUENCY,1.0,3.0), 0.5, 1.0);","#else","float presenceNoise2 = 0.0;","#endif","computeMetallicFlakes(metallicFlakesPresence, metallicFlakesBaseColor, presenceNoise, presenceNoise2, noisePositive, noiseNegative, T, B);","#ifdef PEARL_FLAKES_ACTIVATED","computePearlFlakes(pearlFlakesPresence,pearlFlakesBaseColor,presenceNoise, presenceNoise2, noisePositive,noiseNegative,T,B);","#endif","blendMetalFlakes(currentWorldNormal, flakesMask, metallicFlakesBlending, metallicFlakesPresence, metallicFlakesBaseColor);","#ifdef PEARL_FLAKES_ACTIVATED","blendPearlFlakes(currentWorldNormal, flakesMask, pearlFlakesPresence, pearlFlakesBaseColor);","#endif","}","#endif"].join("\n"),m=["#if defined(USE_DSPBR_FLAKES)","#ifdef DSPBR_FLAKES_FULL_GRID","#define HALF_MAXF_GRID_SIZE 2.0","#define FLAKES_PER_CELL 4","#else","#define HALF_MAXF_GRID_SIZE 1.0","#define FLAKES_PER_CELL 2","#endif","#define DSPBRFLAKES_STO_SMOOTH_TRANSITION 256.0","#define DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION 4.0","#define DSPBRFLAKES_CLOSE_STO_TRANSITION 0.25","#if (defined(USE_ENVMAP) || defined(HAS_AREA_LIGHTS)) && defined(USE_LIGHTING)","#define FLAKES_HEMISPHERE_APPROX;","#endif","struct rstGridData {","float minX;","float minY;","float maxX;","float maxY;","float deltaDDx;","float deltaDDy;","float dyLeftBound;","float dxLeftBound;","float dyRightBound;","float dxRightBound;","};","rstGridData rasterizedGridData;","rstGridData rasterizedGridDataClose;","struct flData {","float flakesRoughness;","float flakesCoverage;","vec3 flakesColor;","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","vec3 flipFlopColor;","float flipFlop;","#endif","float flakesCosConeAngle;","float flakesConeSolidAngle;","vec3 closeupFlakesReflect;","vec3 closeupFlakesNormal;","#ifdef FLAKES_HEMISPHERE_APPROX","vec3 stochasticHemisphereFlakesNormal;","vec3 stochasticHemisphereFlakesReflect;","vec3 stochasticHemisphereFlakesColor;","#endif","float baseWeight;","float smoothWeight;","vec3 smoothFlakesColor;","float closeupWeight;","vec3 closeupFlakesColor;","float stochasticWeight;","vec2 footprintPos;","vec2 footprintDx;","vec2 footprintDy;","float footprintArea;","float cellsInFootPrint;","float expectedFlakes;","float invDet;","float seedRes;","};","flData flakesData;","void reorientParallelogram(in vec2 pos, in vec2 dx, in vec2 dy, out vec2 nPos, out vec2 nDx, out vec2 nDy) {","nPos = vec2(pos);","if ((dy.x * dx.y - dy.y * dx.x) > 0.0) {","nDx = vec2(dy); ","nDy = vec2(dx); ","} else {","nDx = vec2(dx);","nDy = vec2(dy);","}","if (nDy.y < 0.0) {","nPos = nPos + nDy;","vec2 aux = vec2(nDy);","nDy = nDx;","nDx = - aux;","}","if (nDy.y < 0.0) {","nPos = nPos + nDy;","vec2 aux = vec2(nDy);","nDy = nDx;","nDx = - aux;","}","if (nDx.y <= 0.0) {","nPos = nPos + nDx;","vec2 aux = vec2(nDx);","nDx = nDy;","nDy = - aux;","}","if (nDx.y <= 0.0) {","nPos = nPos + nDx;","vec2 aux = vec2(nDx);","nDx = nDy;","nDy = - aux;","}","}","vec4 parallelogramBBox(in vec2 pos,in vec2 dx,in vec2 dy) {","vec2 corner1 = pos;","vec2 corner2 = pos + dx;","vec2 corner3 = pos + dy;","vec2 corner4 = pos + dx + dy;","vec2 minBBox = vec2(vMin(vec4(corner1.x,corner2.x,corner3.x,corner4.x)), vMin(vec4(corner1.y,corner2.y,corner3.y,corner4.y)));","vec2 maxBBox = vec2(vMax(vec4(corner1.x,corner2.x,corner3.x,corner4.x)), vMax(vec4(corner1.y,corner2.y,corner3.y,corner4.y)));","return vec4(minBBox, maxBBox);","}","void prepareFlakesGrid(out rstGridData gridData, in bool close) {","vec2 pos;","vec2 dx;","vec2 dy;","if (close) {","float nodeSize = 1.25 / flakesData.seedRes;","pos = flakesData.footprintPos - nodeSize;","dx = vec2(2.0 * nodeSize, 0.0);","dy = vec2(0.0, 2.0 * nodeSize);","} else {","pos = flakesData.footprintPos;","dx = flakesData.footprintDx;","dy = flakesData.footprintDy;","}","vec4 bbox = parallelogramBBox(pos, dx, dy);","vec2 gridMin = floor(flakesData.seedRes * bbox.xy);","vec2 gridMax = ceil(flakesData.seedRes * bbox.zw);","vec2 footPrintCenter = flakesData.seedRes * (pos + 0.5 * (dx + dy));","gridMin = clamp(gridMin, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);","gridMin = clamp(gridMin,  footPrintCenter - vec2(flakesData.seedRes), footPrintCenter + vec2(flakesData.seedRes));","gridMax = clamp(gridMax, footPrintCenter - HALF_MAXF_GRID_SIZE, footPrintCenter + HALF_MAXF_GRID_SIZE);","gridMax = clamp(gridMax,  footPrintCenter - vec2(flakesData.seedRes), footPrintCenter + vec2(flakesData.seedRes));","gridMax += vec2(1.0);","{","vec2 opos = pos * flakesData.seedRes;","vec2 odx = dx * flakesData.seedRes;","vec2 ody = dy * flakesData.seedRes;","reorientParallelogram(opos, odx, ody, pos, dx, dy);","}","float deltaDDx = dx.x / abs(dx.y);","float deltaDDy = dy.x / abs(dy.y);","vec2 sum = dx + dy;","float minX = max(min(pos.x, min(pos.x + dy.x, pos.x + sum.x)),gridMin.x);","float maxX = min(max(pos.x, max(pos.x + dx.x, pos.x + sum.x)),gridMax.x);","float minY = floor(max(gridMin.y, pos.y));","float maxY = ceil(min(gridMax.y, pos.y + sum.y));","float dyLeftBound =  pos.x +\t\t\t\t(minY - pos.y\t\t\t+ (dy.x < 0.0 ? 1.0 : 0.0)) * deltaDDy;","float dxLeftBound =  pos.x + dy.x +\t\t(minY - pos.y - dy.y\t+ (dx.x < 0.0 ? 1.0 : 0.0)) * deltaDDx;","float dyRightBound = pos.x + dx.x +\t\t(minY - pos.y - dx.y\t+ (dy.x > 0.0 ? 1.0 : 0.0)) * deltaDDy;","float dxRightBound = pos.x +\t\t\t\t(minY - pos.y\t\t\t+ (dx.x > 0.0 ? 1.0 : 0.0)) * deltaDDx;","gridData.minX = minX;","gridData.maxX = maxX;","gridData.minY = minY;","gridData.maxY = maxY;","gridData.dyLeftBound = dyLeftBound;","gridData.dxLeftBound = dxLeftBound;","gridData.dyRightBound = dyRightBound;","gridData.dxRightBound = dxRightBound;","gridData.deltaDDx = deltaDDx;","gridData.deltaDDy = deltaDDy;","}","vec2 triplanarMapping(in vec3 p, in vec3 n, in float scale) {","vec2 uv;","if (abs(n.x) >= abs(n.y) && abs(n.x) >= abs(n.z)) {","uv = vec2(-p.z,-p.y);","} else if (abs(n.y) >= abs(n.z)) {","uv = vec2( p.x, p.z);","} else {","uv = vec2( p.x,-p.y);","}","return uv * scale;","}","void computeFlakesRoughness(in float flakesRoughness) {","float targetConeAngle = 0.122173;","float targetConeSolidAngle = 2.0 * 3.14159265359 * (1.0 - cos(targetConeAngle));","float targetConeRoughness2 = targetConeSolidAngle / (4.0 * 3.14159265359 - targetConeSolidAngle);","float totalFlakeRoughness2 = pow2(flakesRoughness);","float flakeConeRoughness2 = min(targetConeRoughness2, 0.5 * totalFlakeRoughness2);","flakesData.flakesCosConeAngle = clamp(1.0 - 2.0 * flakeConeRoughness2 / (1.0 + flakeConeRoughness2), 0.0, 0.99984769502);","flakesData.flakesConeSolidAngle = 2.0 * 3.14159265359 * (1.0 - flakesData.flakesCosConeAngle);","flakesData.flakesRoughness = sqrt(totalFlakeRoughness2 - flakeConeRoughness2);","}","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","void initFlakesData(in vec3 p, in vec3 N, in float flakesSize, in float flakesCoverage, in vec3 flakesColor, in float flakesRoughness, in float flipFlop, in vec3 flipFlopColor) {","#else","void initFlakesData(in vec3 p, in vec3 N, in float flakesSize, in float flakesCoverage, in vec3 flakesColor, in float flakesRoughness) {","#endif","mat3 mat = transposeMatrix(mat3(modelMatrix));","vec3 worldScaling = vec3(length(mat[0]),length(mat[1]),length(mat[2]));","vec3 scaledP = p * worldScaling;","flakesData.flakesColor = flakesColor;","flakesData.flakesCoverage = flakesCoverage;","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","flakesData.flipFlopColor = flipFlopColor;","flakesData.flipFlop = pow2(1.0 / max(flipFlop, 1e-6));","#endif","computeFlakesRoughness(flakesRoughness);","vec3 x =  dFdx(scaledP);","vec3 y =  dFdy(scaledP);","flakesData.footprintPos = triplanarMapping(scaledP,N,1e-3);","flakesData.footprintDx = triplanarMapping(x ,N,1e-3);","flakesData.footprintDy = triplanarMapping(y,N,1e-3);","flakesData.footprintArea = flakesData.footprintDx.x * flakesData.footprintDy.y - flakesData.footprintDx.y * flakesData.footprintDy.x;","flakesData.invDet = 1.0 / flakesData.footprintArea;","float cellsPerArea = 1.5396e6 / pow2(flakesSize);","flakesData.cellsInFootPrint = abs(flakesData.footprintArea) * cellsPerArea;","float flakesPerArea = flakesCoverage * cellsPerArea;","flakesData.expectedFlakes = abs(flakesData.footprintArea) * flakesPerArea;","flakesData.seedRes = max(float(FLAKES_PER_CELL), vRound(sqrt(cellsPerArea/float(FLAKES_PER_CELL))));","prepareFlakesGrid(rasterizedGridData, false);","prepareFlakesGrid(rasterizedGridDataClose, true);","}","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","vec3 computeFlakesTint(float NoV) {","float coeff = pow(saturate(NoV), flakesData.flipFlop);","return mix(flakesData.flakesColor, flakesData.flipFlopColor, coeff);","}","vec3 computeFlakesTint(vec3 V, vec3 N) {","return computeFlakesTint(dot(N,V));","}","#else","vec3 computeFlakesTint() {","return flakesData.flakesColor;","}","#endif","vec2 rnGenerator(inout int seed) {","int rn = modI(1140671485 * seed + 12820163,16777216);","seed = modI(1140671485 * rn + 12820163,16777216);","return vec2(float(rn) /16777216.0 ,float(seed) / 16777216.0);","}","void generateFlakes(inout int seed, in vec3 V, in vec3 N, out vec2 pos, out vec3 refl, out bool opaque) {","pos = rnGenerator(seed);","vec2 uvs = rnGenerator(seed);","refl = TangentToWorldGeom(ImportanceSampleGGX(uvs.xy,flakesData.flakesRoughness), N);","refl = 2.0 * dot(V,refl) * refl - V;","opaque = rnGenerator(seed).x < flakesData.flakesCoverage;","}","int getSeed(float i, float j) {","float iWrapped = i;","float jWrapped = j;","return int(length(vec2(iWrapped,jWrapped)* 16892.0));","}","bool midFlakeInFootPrint(in vec2 center) {","if (abs(flakesData.footprintArea) < 1e-10) {","return false;","} else {","vec2 pp = center - flakesData.footprintPos;","vec2 uv = flakesData.invDet * vec2(dot(vec2(-pp.y,pp.x),flakesData.footprintDy), dot(vec2(pp.y,-pp.x),flakesData.footprintDx));","return 0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0;","}","}","vec2 contributingStochasticFlakes(in vec3 V, in vec3 L, in vec3 N, in float limit) {","float contributing = 0.0;","float flakesInFootPrint = 0.0;","float deltaDDx = rasterizedGridData.deltaDDx;","float deltaDDy = rasterizedGridData.deltaDDy;","float minX = rasterizedGridData.minX;","float maxX = rasterizedGridData.maxX;","float minY = rasterizedGridData.minY;","float maxY = rasterizedGridData.maxY;","float dyLeftBound =  rasterizedGridData.dyLeftBound;","float dxLeftBound =  rasterizedGridData.dxLeftBound;","float dyRightBound = rasterizedGridData.dyRightBound;","float dxRightBound = rasterizedGridData.dxRightBound;","float i = 0.0;","float maxI = -1.0;","float j = minY;","float jEnd = maxY;","float nodeSize = 1.0 / flakesData.seedRes;","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","vec3 totalRefl = vec3(0.0);","#endif","for (int loop = 0; loop < 150; loop++) {","if (i >= maxI) {","float boundaryLeft = max(minX, max(dyLeftBound, dxLeftBound));","i = floor(boundaryLeft);","float boundaryRight = min(maxX, min(dyRightBound, dxRightBound));","maxI = ceil(boundaryRight);","dyLeftBound += deltaDDy;","dxLeftBound += deltaDDx;","dyRightBound += deltaDDy;","dxRightBound += deltaDDx;","}","int seed = getSeed(i,j);","for (int cell = 0; cell < FLAKES_PER_CELL; cell++) {","vec2 fPos;","vec3 fRefl;","bool fOpaque;","generateFlakes(seed,V,N,fPos,fRefl, fOpaque);","if (fOpaque) {","vec2 flakeUV = nodeSize * (vec2(i, j) + fPos);","if (midFlakeInFootPrint(flakeUV)) {","float val = step(0.0, dot(fRefl,L) - limit);","flakesInFootPrint++;","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","totalRefl += val * fRefl;","#endif","contributing += val;","}","}","}","i++;","if (i >= maxI) {","j++;","}","if (j >= jEnd) {","break;","}","}","float coeff = contributing / max(1.0,flakesInFootPrint);","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","vec3 flakesN = normalize(vNormalize(totalRefl) + V);","return vec2(coeff, dot(V, flakesN));","#else","return vec2(coeff, 0.0);","#endif","}","vec3 stochasticFlakesPattern(in vec3 V, in vec3 L, in vec3 N, in float limit) {","vec2 c = contributingStochasticFlakes(V,L,N, limit);","float d = c.x;","#ifdef DSPBR_WITH_FLIPFLOP_COLOR","return computeFlakesTint(c.y) * d;","#else","return computeFlakesTint() * d;","#endif","}","vec3 stochasticFlakesBRDF(in vec3 V, in vec3 L, in vec3 N, in float VoH, in float NoL, in float NoV) {","float g = GeometricSchlick(flakesData.flakesRoughness, NoL,NoV );","return VoH * g * stochasticFlakesPattern(V, L, N, flakesData.flakesCosConeAngle)/ max(NoL*NoV * flakesData.flakesConeSolidAngle,1e-6) ;","}","#ifdef FLAKES_HEMISPHERE_APPROX","vec3 contributingStochasticHemisphereFlakes(in vec3 V, in vec3 N) {","vec3 stochasticFlakesOrientation = vec3(0.0);","float deltaDDx = rasterizedGridData.deltaDDx;","float deltaDDy = rasterizedGridData.deltaDDy;","float minX = rasterizedGridData.minX;","float maxX = rasterizedGridData.maxX;","float minY = rasterizedGridData.minY;","float maxY = rasterizedGridData.maxY;","float dyLeftBound =  rasterizedGridData.dyLeftBound;","float dxLeftBound =  rasterizedGridData.dxLeftBound;","float dyRightBound = rasterizedGridData.dyRightBound;","float dxRightBound = rasterizedGridData.dxRightBound;","float i = 0.0;","float maxI = -1.0;","float j = minY;","float jEnd = maxY;","float nodeSize = 1.0 / flakesData.seedRes;","for (int loop = 0; loop < 150; loop++) {","if (i >= maxI) {","float boundaryLeft = max(minX, max(dyLeftBound, dxLeftBound));","i = floor(boundaryLeft);","float boundaryRight = min(maxX, min(dyRightBound, dxRightBound));","maxI = ceil(boundaryRight);","dyLeftBound += deltaDDy;","dxLeftBound += deltaDDx;","dyRightBound += deltaDDy;","dxRightBound += deltaDDx;","}","int seed = getSeed(i,j);","for (int cell = 0; cell < FLAKES_PER_CELL; cell++) {","vec2 fPos;","vec3 fRefl;","bool fOpaque;","generateFlakes(seed,V,N,fPos,fRefl, fOpaque);","float val = dot(fRefl,N);","stochasticFlakesOrientation += step(0.1, val) * fRefl;","}","i++;","if (i >= maxI) {","j++;","}","if (j >= jEnd) {","break;","}","}","float len = length(stochasticFlakesOrientation);","return len > 1e-6 ? stochasticFlakesOrientation / len : reflect(V , N);","}","#endif","vec3 contributingCloseFlakes(in vec3 V, in vec3 N) {","float deltaDDx = rasterizedGridDataClose.deltaDDx;","float deltaDDy = rasterizedGridDataClose.deltaDDy;","float minX = rasterizedGridDataClose.minX;","float maxX = rasterizedGridDataClose.maxX;","float minY = rasterizedGridDataClose.minY;","float maxY = rasterizedGridDataClose.maxY;","float dyLeftBound =  rasterizedGridDataClose.dyLeftBound;","float dxLeftBound =  rasterizedGridDataClose.dxLeftBound;","float dyRightBound = rasterizedGridDataClose.dyRightBound;","float dxRightBound = rasterizedGridDataClose.dxRightBound;","float i = 0.0;","float maxI = -1.0;","float j = minY;","float jEnd = maxY;","float nodeSize = 1.0 / flakesData.seedRes;","float bestDistance = 1e10;","vec3 res = vec3(0.0);","for (int loop = 0; loop < 150; loop++) {","if (i >= maxI) {","float boundaryLeft = max(minX, max(dyLeftBound, dxLeftBound));","i = floor(boundaryLeft);","float boundaryRight = min(maxX, min(dyRightBound, dxRightBound));","maxI = ceil(boundaryRight);","dyLeftBound += deltaDDy;","dxLeftBound += deltaDDx;","dyRightBound += deltaDDy;","dxRightBound += deltaDDx;","}","int seed = getSeed(i,j);","for (int cell = 0; cell < FLAKES_PER_CELL; cell++) {","vec2 fPos;","vec3 fRefl;","bool fOpaque;","generateFlakes(seed,V,N,fPos,fRefl, fOpaque);","vec2 flakeUV = nodeSize * (vec2(i, j)  + fPos);","vec2 prel = flakesData.footprintPos + 0.5* (flakesData.footprintDx + flakesData.footprintDy) - flakeUV;","float curDistance = dot(prel, prel);","if (curDistance < bestDistance) {","bestDistance = curDistance;","res = fOpaque ? fRefl : vec3(0.0);","}","}","i++;","if (i >= maxI) {","j++;","}","if (j >= jEnd) {","break;","}","}","return vNormalize(res);","}","float closeFlakesPattern(in vec3 L, in float limit) {","return step(0.0, dot(flakesData.closeupFlakesReflect, L) - limit);","}","float closeFlakesBRDF(in vec3 L, in float NoL) {","return closeFlakesPattern(L, flakesData.flakesCosConeAngle) / max(flakesData.flakesConeSolidAngle  * NoL, 1e-6);","}","void dspbrFlakesModel(inout vec3 diffuse, inout vec3 specular, in vec3 V, in vec3 L, in vec3 N) {","vec3 H = normalize(V+L);","float VoH = dot(V,H);","float NoL = saturate(dot(N,L));","float NoV = saturate(dot(N,V));","float NoH = saturate(dot(N,H));","vec3 res = flakesData.smoothFlakesColor * SpecularBRDF(flakesData.flakesRoughness,NoV,NoL,NoH);","if (flakesData.stochasticWeight > 0.0) {","res += flakesData.stochasticWeight * stochasticFlakesBRDF(V,L,N,VoH,NoL,NoV);","}","if (flakesData.closeupWeight > 0.0) {","res += flakesData.closeupFlakesColor * closeFlakesBRDF(L,NoL);","}","diffuse *= flakesData.baseWeight;","specular *= flakesData.baseWeight;","specular += res;","}","void initFlakesWeights(in vec3 V, in vec3 N) {","flakesData.closeupFlakesReflect = vec3(0.0);","float flakesHit = 0.0;","#ifdef DSPBR_FLAKES_THREE_LAYERS","float closeupStochasticTransition = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);","float closeupSmoothTransition = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);","float stochasticSmoothTransition = log(DSPBRFLAKES_STO_SMOOTH_TRANSITION);","float logCellsInFootPrint = log(flakesData.cellsInFootPrint);","if (logCellsInFootPrint < closeupSmoothTransition) {","flakesData.closeupFlakesReflect = contributingCloseFlakes(V, N);","flakesHit = dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0 ? 1.0 : 0.0;","if (logCellsInFootPrint < closeupStochasticTransition) {","flakesData.closeupWeight = flakesHit;","flakesData.stochasticWeight = 0.0;","flakesData.baseWeight = 1.0 - flakesHit;","} else {","flakesData.stochasticWeight = smoothstep(closeupStochasticTransition, closeupSmoothTransition, logCellsInFootPrint);","flakesData.closeupWeight = flakesHit * (1.0 - flakesData.stochasticWeight);","flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.stochasticWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.stochasticWeight;","}","flakesData.smoothWeight = 0.0;","} else {","flakesData.closeupWeight = 0.0;","if (logCellsInFootPrint < stochasticSmoothTransition) {","flakesData.smoothWeight = smoothstep(closeupSmoothTransition, stochasticSmoothTransition, logCellsInFootPrint);","flakesData.stochasticWeight = 1.0 - flakesData.smoothWeight;","} else {","flakesData.smoothWeight = 1.0;","flakesData.stochasticWeight = 0.0;","}","flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;","}","#endif","#ifdef DSPBR_FLAKES_TWO_LAYERS","flakesData.stochasticWeight = 0.0;","float fullCloseUp = log(DSPBRFLAKES_CLOSE_STO_TRANSITION);","float fullSmooth = log(DSPBRFLAKES_CLOSE_SMOOTH_TRANSITION);","float logCellsInFootPrint = log(flakesData.cellsInFootPrint);","flakesData.smoothWeight = smoothstep(fullCloseUp,fullSmooth, logCellsInFootPrint);","flakesData.closeupWeight = 0.0;","flakesData.baseWeight = 1.0 - flakesData.flakesCoverage;","if (logCellsInFootPrint < fullSmooth) {","flakesData.closeupFlakesReflect = contributingCloseFlakes(V, N);","flakesHit = dot(flakesData.closeupFlakesReflect, flakesData.closeupFlakesReflect) > 0.0 ? 1.0 : 0.0;","if (logCellsInFootPrint < fullCloseUp) {","flakesData.closeupWeight = flakesHit;","flakesData.baseWeight = 1.0 - flakesHit;","} else {","flakesData.closeupWeight = flakesHit * (1.0 - flakesData.smoothWeight);","flakesData.baseWeight = (1.0 - flakesHit) * (1.0 - flakesData.smoothWeight) + (1.0 - flakesData.flakesCoverage) * flakesData.smoothWeight;","}","}","#endif","#ifdef DSPBR_FLAKES_ONE_LAYER","flakesData.stochasticWeight = 0.0;","flakesData.closeupWeight = 0.0;","flakesData.smoothWeight = 1.0;","flakesData.baseWeight = (1.0 - flakesData.flakesCoverage);","#endif","#ifdef FLAKES_HEMISPHERE_APPROX","flakesData.stochasticHemisphereFlakesNormal = N;","flakesData.stochasticHemisphereFlakesReflect = reflect(V, N);","if (flakesData.stochasticWeight > 0.0) {","flakesData.stochasticHemisphereFlakesReflect = contributingStochasticHemisphereFlakes(V, N);","flakesData.stochasticHemisphereFlakesNormal = normalize(V + flakesData.stochasticHemisphereFlakesReflect);","}","#endif","if (dot(flakesData.closeupFlakesReflect, N) < 0.0) {","flakesData.closeupFlakesReflect = flakesData.closeupFlakesReflect - 2.0 * dot(flakesData.closeupFlakesReflect, N) * N;","}","flakesData.closeupFlakesNormal = normalize(V + flakesData.closeupFlakesReflect);","flakesData.stochasticWeight *= flakesData.flakesCoverage;","flakesData.smoothWeight *= flakesData.flakesCoverage;","#ifndef DSPBR_WITH_FLIPFLOP_COLOR","flakesData.smoothFlakesColor = flakesData.smoothWeight * computeFlakesTint();","flakesData.closeupFlakesColor = flakesData.closeupWeight * computeFlakesTint();","#ifdef FLAKES_HEMISPHERE_APPROX","flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * computeFlakesTint();","#endif","#else","flakesData.smoothFlakesColor = flakesData.smoothWeight * computeFlakesTint(V, N);","flakesData.closeupFlakesColor = flakesData.closeupWeight * computeFlakesTint(V, flakesData.closeupFlakesNormal);","#ifdef FLAKES_HEMISPHERE_APPROX","flakesData.stochasticHemisphereFlakesColor = flakesData.stochasticWeight * computeFlakesTint(V, flakesData.stochasticHemisphereFlakesNormal);","#endif","#endif","}","#endif"].join("\n"),S=["#ifdef CLEAR_COAT","void clearCoatModel(inout vec3 diffuse, inout vec3 specular, in vec3 V, in vec3 L) {","vec3 N = surfaceData.clearCoatNormal;","float r = materialData.clearCoatRoughness;","vec3 H = normalize(L+V);","float NoH = saturate(dot(N,H));","float NoV = saturate(dot(N,V));","float NoL = saturate(dot(N,L));","float VoH = saturate(dot(V,H));","float distrib = DistributionGGX( r, NoH);","float geomVis = GGXVisibility( r, NoV, NoL);","vec3 fresnel = FresnelSchlick(materialData.clearCoatSR0Color, materialData.clearCoatSR90Color, VoH);","#ifdef DSPBR","float fresnelEnergy = 1.0 - materialData.clearCoat * vMax(max(FresnelSchlick(materialData.clearCoatSR0Color, materialData.clearCoatSR90Color, NoL),FresnelSchlick(materialData.clearCoatSR0Color, materialData.clearCoatSR90Color, NoV)));","#else","float fresnelEnergy = SpecGlossEnergyConservationTerm(NoL, NoV, materialData.clearCoatSR0Color, materialData.clearCoatSR90Color);","#endif","diffuse *= fresnelEnergy;","specular *= fresnelEnergy;","specular += materialData.clearCoat * distrib * fresnel * geomVis;","}","#ifdef CLEAR_COAT_NORMALMAP","vec3 perturbNormal3ArbCoat( vec3 surf_norm, vec3 surf_tgt, vec3 surf_binorm, vec2 uv ) {","vec3 N = normalize(surf_norm);","vec3 T = normalize(surf_tgt);","T = normalize(T - dot(T, N) * N);","vec3 B = normalize(surf_binorm);","vec3 mapN = texture2D( clearCoatNormalMap, uv ).xyz * 2.0 - 1.0;","#ifdef DSPBR","#ifdef USE_CC_NORMAL_COEFFICIENTS","mapN = mapN * clearCoatNormalMulCoef + clearCoatNormalAddCoef;","#endif","mapN.z = abs(mapN.z);","#else","#ifdef CLEAR_COAT_NORMALMAPFLIPY","mapN.y = - mapN.y;","#endif","mapN.xy = clearCoatNormalScale * mapN.xy;","#endif","mat3 tbn = mat3(T, B, N);","return normalize(tbn * mapN);","}","#endif","#ifdef USE_ORANGE_PEEL","void orangePeelVisibility(in vec3 currentWorldNormal, out float peelMask, in float scaling, in vec3 worldPosition) {","mat3 mat = transposeMatrix(mat3(modelMatrix));","vec3 worldScaling = 1.0/vec3(length(mat[0]),length(mat[1]),length(mat[2]));","vec3 V = cameraPosition - worldPosition;","float dist = length(worldScaling * V);","V = normalize(V);","float NdotV = dot(currentWorldNormal, V);","float locality = (NdotV > 0.0) ? 1.0 : 0.0;","if (locality == 0.0) {","peelMask = 0.0;","return;","}","float normDist = saturate(scaling * dist * 0.00125);","float shortDist = saturate(1.0 - normDist);","peelMask = shortDist;","}","void doOrangePeel(vec3 currentWorldNormal, inout vec3 orangePeelWorldNormal, in vec3 worldPosition, in vec3 objectSpacePosition) {","float peelMask = 0.0;","float peelScaling = 0.01/max(orangePeelScale,1e-3);","orangePeelVisibility(currentWorldNormal, peelMask, peelScaling, worldPosition);","#ifdef DSPBR","float ccNScale = 1.0;","#ifdef USE_CC_NORMAL_COEFFICIENTS","ccNScale = saturate(vMax(clearCoatNormalMulCoef));","#endif","#else","float ccNScale = clearCoatNormalScale;","#endif","if (ccNScale < kEpsilon || peelMask < kEpsilon) {","return;","}","vec3 tex = peelScaling * objectSpacePosition;","tex.y = -abs(tex.y);","tex.x = -abs(tex.x);","float noise = FBM(tex);","vec3 peelNormal = vec3(noise);","orangePeelWorldNormal = normalize(orangePeelWorldNormal + 0.05 *ccNScale *peelMask* peelNormal);","}","#endif","#endif"].join("\n"),_=["#ifdef USE_SUBSURFACE","#ifdef USE_SSSLUT","#define maxSSSRadiusR 0.5 * maxTranslucencyDepth.x","#define minSSSRadiusR maxSSSRadiusR / 15.0","#define maxSSSRadiusG 0.5 * maxTranslucencyDepth.y","#define minSSSRadiusG maxSSSRadiusG / 15.0","#define maxSSSRadiusB 0.5 * maxTranslucencyDepth.z","#define minSSSRadiusB maxSSSRadiusB / 15.0","#define E_64_OVER_74 0.86486486486","#define E_66_OVER_74 0.89189189189","#define E_69_OVER_74 0.93243243243","#define E_71_OVER_74 0.95945945945","#define E_74_OVER_74 1.0","#define SINGLE_LINE_SAMPLING_LINEAR 0.5","vec4 SSSLUT = vec4(1.0,E_64_OVER_74, 0.0, 0.0);","vec4 SSSIBLLUT = vec4(1.0,E_69_OVER_74 - E_66_OVER_74, 0.0, E_66_OVER_74);","vec4 SSSTranslucencyLUT = vec4(1.0,E_74_OVER_74 - E_71_OVER_74, 0.0, E_71_OVER_74);","vec3 sampleSSSLUT(vec2 coord, vec4 factor) {","return texture2D(sssLUT, factor.xy * coord + factor.zw).xyz;","}","#endif","vec3 getScattering(in float NoL, in float c) {","float cNoL = affine(NoL,0.5,1.0);","#ifdef USE_SSSLUT","float rr = toTexCoord(1.0/c,minSSSRadiusR,maxSSSRadiusR);","float rg = toTexCoord(1.0/c,minSSSRadiusG,maxSSSRadiusG);","float rb = toTexCoord(1.0/c,minSSSRadiusB,maxSSSRadiusB);","vec2 coordR = vec2(cNoL,rr);","vec2 coordG = vec2(cNoL,rg);","vec2 coordB = vec2(cNoL,rb);","return vec3(sampleSSSLUT(coordR, SSSLUT).r,sampleSSSLUT(coordG, SSSLUT).g,sampleSSSLUT(coordB, SSSLUT).b);","#else","return vec3(saturate(NoL));","#endif","}","vec3 SssLUTSampling(in float c) {","#ifdef USE_SSSLUT","float rr = toTexCoord(1.0/c,minSSSRadiusR,maxSSSRadiusR);","float rg = toTexCoord(1.0/c,minSSSRadiusG,maxSSSRadiusG);","float rb = toTexCoord(1.0/c,minSSSRadiusB,maxSSSRadiusB);","vec2 coordR = vec2(rr,SINGLE_LINE_SAMPLING_LINEAR);","vec2 coordG = vec2(rg,SINGLE_LINE_SAMPLING_LINEAR);","vec2 coordB = vec2(rb,SINGLE_LINE_SAMPLING_LINEAR);","return vec3(sampleSSSLUT(coordR, SSSIBLLUT).r,sampleSSSLUT(coordG, SSSIBLLUT).g,sampleSSSLUT(coordB, SSSIBLLUT).b);","#else","return vec3(1.0);","#endif","}","vec3 GetTransmittance(in float s) {","#ifdef USE_SSSLUT","vec2 coordR = vec2(toTexCoord(s,0.0,maxTranslucencyDepth.x),SINGLE_LINE_SAMPLING_LINEAR);","vec2 coordG = vec2(toTexCoord(s,0.0,maxTranslucencyDepth.y),SINGLE_LINE_SAMPLING_LINEAR);","vec2 coordB = vec2(toTexCoord(s,0.0,maxTranslucencyDepth.z),SINGLE_LINE_SAMPLING_LINEAR);","return vec3(sampleSSSLUT(coordR, SSSTranslucencyLUT).r,sampleSSSLUT(coordG, SSSTranslucencyLUT).g,sampleSSSLUT(coordB, SSSTranslucencyLUT).b);","#else","return exp(-absorptionCoefficients * s);","#endif","}","#endif","#if defined(USE_SUBSURFACE) && (defined(USE_SHADOWMAP) || defined(USE_SHADOWMAP_CUBE) || defined(USE_THICKNESS))","#define TRANSMITTANCE","#if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED) ","#define ONEOVER80 0.0125","#endif","#ifdef USE_SHADOWMAP","#define MAP_TRANSMITTANCE","#endif","#if MAX_DIR_IBL_LIGHTS > 0 && defined(USE_ENVMAP) && defined(USE_SUBSURFACE) && defined(MAP_TRANSMITTANCE)","#define USE_IBL_LIGHT","#endif","#ifdef USE_SHADOWMAP_CUBE","#define CUBE_TRANSMITTANCE","#endif","#if defined(MAP_TRANSMITTANCE) || defined(CUBE_TRANSMITTANCE)","#define DEPTHMAP_BASED_TRANSMITTANCE","#endif","#if defined(USE_THICKNESS)","#define THICKNESS_BASED_TRANSMITTANCE","#endif","#endif","#ifdef TRANSMITTANCE","#ifdef DEPTHMAP_BASED_TRANSMITTANCE","#define TRANS_PERFMODE 2","float _clipToEyePers(in float iNearPlane, in float iFarPlane, in float iZClipSpace)","{","return (2.0 * iNearPlane * iFarPlane) / (iFarPlane + iNearPlane - iZClipSpace * (iFarPlane - iNearPlane));","}","float _clipToEyeOrtho(in float iNearPlane, in float iFarPlane, in float iZClipSpace)","{","return 0.5 * ((iFarPlane - iNearPlane) * iZClipSpace + iFarPlane + iNearPlane);","}","float clipToEye(in float z, in vec2 lightInfo, in bool ortho)","{","return ortho ? _clipToEyeOrtho(lightInfo.x, lightInfo.y, z) : _clipToEyePers(lightInfo.x, lightInfo.y, z) ;","}","#if TRANS_PERFMODE == 0","#define TRANS_SAMPLE 64","#define TRANS_POISSON_DISK(i)  poisson64[i]","vec2 poisson64[64];","void initDisk() {","poisson64[0] = vec2(-0.934812, 0.366741);","poisson64[1] = vec2(-0.918943, -0.0941496);","poisson64[2] = vec2(-0.873226, 0.62389);","poisson64[3] = vec2(-0.8352, 0.937803);","poisson64[4] = vec2(-0.822138, -0.281655);","poisson64[5] = vec2(-0.812983, 0.10416);","poisson64[6] = vec2(-0.786126, -0.767632);","poisson64[7] = vec2(-0.739494, -0.535813);","poisson64[8] = vec2(-0.681692, 0.284707);","poisson64[9] = vec2(-0.61742, -0.234535);","poisson64[10] = vec2(-0.601184, 0.562426);","poisson64[11] = vec2(-0.607105, 0.847591);","poisson64[12] = vec2(-0.581835, -0.00485244);","poisson64[13] = vec2(-0.554247, -0.771111);","poisson64[14] = vec2(-0.483383, -0.976928);","poisson64[15] = vec2(-0.476669, -0.395672);","poisson64[16] = vec2(-0.439802, 0.362407);","poisson64[17] = vec2(-0.409772, -0.175695);","poisson64[18] = vec2(-0.367534, 0.102451);","poisson64[19] = vec2(-0.35313, 0.58153);","poisson64[20] = vec2(-0.341594, -0.737541);","poisson64[21] = vec2(-0.275979, 0.981567);","poisson64[22] = vec2(-0.230811, 0.305094);","poisson64[23] = vec2(-0.221656, 0.751152);","poisson64[24] = vec2(-0.214393, -0.0592364);","poisson64[25] = vec2(-0.204932, -0.483566);","poisson64[26] = vec2(-0.183569, -0.266274);","poisson64[27] = vec2(-0.123936, -0.754448);","poisson64[28] = vec2(-0.0859096, 0.118625);","poisson64[29] = vec2(-0.0610675, 0.460555);","poisson64[30] = vec2(-0.0234687, -0.962523);","poisson64[31] = vec2(-0.00485244, -0.373394);","poisson64[32] = vec2(0.0213324, 0.760247);","poisson64[33] = vec2(0.0359813, -0.0834071);","poisson64[34] = vec2(0.0877407, -0.730766);","poisson64[35] = vec2(0.14597, 0.281045);","poisson64[36] = vec2(0.18186, -0.529649);","poisson64[37] = vec2(0.188208, -0.289529);","poisson64[38] = vec2(0.212928, 0.063509);","poisson64[39] = vec2(0.23661, 0.566027);","poisson64[40] = vec2(0.266579, 0.867061);","poisson64[41] = vec2(0.320597, -0.883358);","poisson64[42] = vec2(0.353557, 0.322733);","poisson64[43] = vec2(0.404157, -0.651479);","poisson64[44] = vec2(0.410443, -0.413068);","poisson64[45] = vec2(0.413556, 0.123325);","poisson64[46] = vec2(0.46556, -0.176183);","poisson64[47] = vec2(0.49266, 0.55388);","poisson64[48] = vec2(0.506333, 0.876888);","poisson64[49] = vec2(0.535875, -0.885556);","poisson64[50] = vec2(0.615894, 0.0703452);","poisson64[51] = vec2(0.637135, -0.637623);","poisson64[52] = vec2(0.677236, -0.174291);","poisson64[53] = vec2(0.67626, 0.7116);","poisson64[54] = vec2(0.686331, -0.389935);","poisson64[55] = vec2(0.691031, 0.330729);","poisson64[56] = vec2(0.715629, 0.999939);","poisson64[57] = vec2(0.8493, -0.0485549);","poisson64[58] = vec2(0.863582, -0.85229);","poisson64[59] = vec2(0.890622, 0.850581);","poisson64[60] = vec2(0.898068, 0.633778);","poisson64[61] = vec2(0.92053, -0.355693);","poisson64[62] = vec2(0.933348, -0.62981);","poisson64[63] = vec2(0.95294, 0.156896);","}","#elif TRANS_PERFMODE == 1","#define TRANS_SAMPLE 32","#define TRANS_POISSON_DISK(i)  poisson32[i]","vec2 poisson32[TRANS_SAMPLE];","void initDisk() {","poisson32[0] = vec2(-0.975402, -0.0711386);","poisson32[1] = vec2(-0.920347, -0.41142);","poisson32[2] = vec2(-0.883908, 0.217872);","poisson32[3] = vec2(-0.884518, 0.568041);","poisson32[4] = vec2(-0.811945, 0.90521);","poisson32[5] = vec2(-0.792474, -0.779962);","poisson32[6] = vec2(-0.614856, 0.386578);","poisson32[7] = vec2(-0.580859, -0.208777);","poisson32[8] = vec2(-0.53795, 0.716666);","poisson32[9] = vec2(-0.515427, 0.0899991);","poisson32[10] = vec2(-0.454634, -0.707938);","poisson32[11] = vec2(-0.420942, 0.991272);","poisson32[12] = vec2(-0.261147, 0.588488);","poisson32[13] = vec2(-0.211219, 0.114841);","poisson32[14] = vec2(-0.146336, -0.259194);","poisson32[15] = vec2(-0.139439, -0.888668);","poisson32[16] = vec2(0.0116886, 0.326395);","poisson32[17] = vec2(0.0380566, 0.625477);","poisson32[18] = vec2(0.0625935, -0.50853);","poisson32[19] = vec2(0.125584, 0.0469069);","poisson32[20] = vec2(0.169469, -0.997253);","poisson32[21] = vec2(0.320597, 0.291055);","poisson32[22] = vec2(0.359172, -0.633717);","poisson32[23] = vec2(0.435713, -0.250832);","poisson32[24] = vec2(0.507797, -0.916562);","poisson32[25] = vec2(0.545763, 0.730216);","poisson32[26] = vec2(0.56859, 0.11655);","poisson32[27] = vec2(0.743156, -0.505173);","poisson32[28] = vec2(0.736442, -0.189734);","poisson32[29] = vec2(0.843562, 0.357036);","poisson32[30] = vec2(0.865413, 0.763726);","poisson32[31] = vec2(0.872005, -0.927);","}","#else","#define TRANS_SAMPLE 25","#define TRANS_POISSON_DISK(i)  poisson25[i]","vec2 poisson25[TRANS_SAMPLE];","void initDisk() {","poisson25[0] = vec2(-0.978698, -0.0884121);","poisson25[1] = vec2(-0.841121, 0.521165);","poisson25[2] = vec2(-0.71746, -0.50322);","poisson25[3] = vec2(-0.702933, 0.903134);","poisson25[4] = vec2(-0.663198, 0.15482);","poisson25[5] = vec2(-0.495102, -0.232887);","poisson25[6] = vec2(-0.364238, -0.961791);","poisson25[7] = vec2(-0.345866, -0.564379);","poisson25[8] = vec2(-0.325663, 0.64037);","poisson25[9] = vec2(-0.182714, 0.321329);","poisson25[10] = vec2(-0.142613, -0.0227363);","poisson25[11] = vec2(-0.0564287, -0.36729);","poisson25[12] = vec2(-0.0185858, 0.918882);","poisson25[13] = vec2(0.0381787, -0.728996);","poisson25[14] = vec2(0.16599, 0.093112);","poisson25[15] = vec2(0.253639, 0.719535);","poisson25[16] = vec2(0.369549, -0.655019);","poisson25[17] = vec2(0.423627, 0.429975);","poisson25[18] = vec2(0.530747, -0.364971);","poisson25[19] = vec2(0.566027, -0.940489);","poisson25[20] = vec2(0.639332, 0.0284127);","poisson25[21] = vec2(0.652089, 0.669668);","poisson25[22] = vec2(0.773797, 0.345012);","poisson25[23] = vec2(0.968871, 0.840449);","poisson25[24] = vec2(0.991882, -0.657338);","}","#endif","#ifdef MAP_TRANSMITTANCE","float getDepthValue(in sampler2D shadowMap, in vec2 coord) {","#if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED) ","return 2.0 * (ONEOVER80*log(unpackDepthESM(texture2D(shadowMap, coord)))) - 1.0;","#else","return 2.0*unpackDepth(texture2D(shadowMap, coord) ) - 1.0;","#endif","}","vec3 multiSampleTransmittance(in vec4 shadowMapCoord, in vec2 shadowNearFar, in vec2 shadowMapSize, in sampler2D shadowMap, in bool ortho) {","vec3 depthMapCoord = shadowMapCoord.xyz/shadowMapCoord.w;","vec2 currentCoord;","float currentDepth = clipToEye(2.0*depthMapCoord.z-1.0,shadowNearFar, ortho);","float s = max( currentDepth - clipToEye( getDepthValue(shadowMap,depthMapCoord.xy),shadowNearFar, ortho),0.0);","vec2 multiplier = saturate(vec2(2.0 / shadowMapSize));","for (int i = 0; i < TRANS_SAMPLE; i++) {","vec2 offset =  multiplier* TRANS_POISSON_DISK(i);","currentCoord.xy = saturate(depthMapCoord.xy + offset);","float depth = getDepthValue(shadowMap,currentCoord.xy);","s += max( currentDepth - clipToEye(depth,shadowNearFar, ortho),0.0);","}","return GetTransmittance(s / float(TRANS_SAMPLE + 1));","}","#endif","#ifdef CUBE_TRANSMITTANCE","float getCubeDepthValue(in samplerCube shadowCubeMap, in vec3 coord) {","#if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED) ","return 2.0 * (ONEOVER80*log(unpackDepthESM(textureCube(shadowCubeMap, coord)))) - 1.0;","#else","return 2.0*unpackDepth(textureCube(shadowCubeMap, coord) ) - 1.0;","#endif","}","vec3 multiSampleCubeTransmittance(in vec3 worldPos, in vec3 lightPosition, in vec2 shadowNearFar, in float shadowCubeSize, in samplerCube shadowCube, in bool ortho) {","vec3 pointVector = worldPos.xyz - lightPosition.xyz;","vec3 absVector = abs(pointVector);","float localZComp = max(absVector.x,max(absVector.y,absVector.z));","float normZComp = (shadowNearFar.y + shadowNearFar.x) / (shadowNearFar.y - shadowNearFar.x) - (2.0 * shadowNearFar.y * shadowNearFar.x) / (shadowNearFar.y - shadowNearFar.x) / localZComp;","normZComp = (normZComp + 1.0) * 0.5;","vec3 cubeMapCoord = normalize( pointVector );","float currentDepth = length(pointVector);","float s = max( currentDepth - clipToEye( getCubeDepthValue(shadowCube,cubeMapCoord),shadowNearFar, ortho),0.0);","float pixelSize = 4.0 / shadowCubeSize;","vec3 right = getGeomT(cubeMapCoord.xyz) * pixelSize;","vec3 up = getGeomB(cubeMapCoord.xyz, right) * pixelSize;","vec3 currentCoord;","for (int i = 0; i < TRANS_SAMPLE; i++) {","vec2 offset =  TRANS_POISSON_DISK(i);","currentCoord = normalize(cubeMapCoord + offset.x * right + offset.y * up);","float depth = getCubeDepthValue(shadowCube,currentCoord);","s += max( currentDepth - clipToEye(depth,shadowNearFar, ortho),0.0);","}","return GetTransmittance(s / float(TRANS_SAMPLE + 1));","}","#endif","#endif","#endif"].join("\n"),h=function(){return["vec3 Lt = L - 2.0 * dot(L,N) * N;","float NoLt = saturate(dot(N, Lt));","vec3 brdf = DiffuseLambertBRDF(color);","#ifdef SPECGLOSS","float NoV = saturate(dot(N,V));","float fTrans = SpecGlossEnergyConservationTerm(NoLt, NoV, materialData.sr0Color,materialData.sr90Color);","#else","float fTrans = materialData.diffuseEnergyConservationConstant;","#endif"].join("\n")},x=function(){return["vec3 Lt = L - 2.0 * dot(L,N) * N;","float NoLt = saturate(dot(N,Lt));","float NoV = saturate(dot(N,V));","#ifndef THIN_WALLED","vec3 Ht = normalize(Lt * materialData.ior +V);","float NoHt = saturate(dot(N,Ht));","float VoHt = saturate(dot(V,Ht));","float LtoHt = saturate(dot(Lt,Ht));","#ifdef USE_ANISOTROPY","float rX = materialData.roughness;","float rY = rX * (1.0 - materialData.anisotropy);","vec3 brdf = color * TransmissionAnisoBRDF(rX, rY, NoV, NoLt, NoHt, VoHt, LtoHt, N, Ht, surfaceData.tangent, surfaceData.binormal, materialData.anisotropyAngle);","#else","vec3 brdf = color * TransmissionBRDF(materialData.roughness, NoV, NoLt, NoHt, VoHt, LtoHt);","#endif","#else","vec3 Ht = normalize(Lt+V);","float NoHt = saturate(dot(N,Ht));","float VoHt = saturate(dot(V,Ht));","#ifdef USE_ANISOTROPY","float rX = materialData.roughness;","float rY = rX * (1.0 - materialData.anisotropy);","vec3 brdf = color * SpecularAnisoBRDF(rX, rY, NoV, NoLt, NoHt, N, Ht, surfaceData.tangent, surfaceData.binormal, materialData.anisotropyAngle );","#else","vec3 brdf = color * SpecularBRDF(materialData.roughness, NoV, NoLt, NoHt);","#endif","#endif","#ifdef DSPBR","float fTrans = (1.0 - materialData.specularContribution * vMax(FresnelSchlick(materialData.specularBlendingSR0, vec3(1.0), VoHt)));","#else","vec3 sr0Color = materialData.sr0Color;","vec3 sr90Color = materialData.sr90Color;","float fTrans = (1.0 - vMax(FresnelSchlick(sr0Color, sr90Color, VoHt)));","#endif"].join("\n")},g=["#ifdef USE_IRIDESCENCE","const mat3 XYZ_TO_REC709 = mat3(","3.2404542, -0.9692660,  0.0556434,","-1.5371385,  1.8760108, -0.2040259,","-0.4985314,  0.0415560,  1.0572252",");","vec3 evalSensitivity(float OPD, vec3 shift) {","float phase = 2.0 * PI * OPD * 1.0e-9;","vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);","vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);","vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);","vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow2(phase) * var);","xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow2(phase));","xyz /= 1.0685e-7;","vec3 rgb = XYZ_TO_REC709 * xyz;","return rgb;","}","float IoRToFresnel0( float transmittedIoR, float incidentIoR ) {","return pow2( (transmittedIoR - incidentIoR) / (transmittedIoR + incidentIoR) );","}","vec3 IoRToFresnel0( vec3 transmittedIoR, float incidentIoR ) {","return vec3(IoRToFresnel0(transmittedIoR.r, incidentIoR), IoRToFresnel0(transmittedIoR.g, incidentIoR), IoRToFresnel0(transmittedIoR.b, incidentIoR));","}","vec3 Fresnel0ToIoR( vec3 fresnel0 ) {","vec3 sqrtF0 = sqrt( fresnel0 );","return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );","}","vec3 computeIridescence(in float outsideIoR, in float iridescenceIoR, in vec3 sr0Color, in float iridescenceThickness, in float cosTheta1) {","float sinTheta2Sq = pow2( outsideIoR / iridescenceIoR ) * ( 1.0 - pow2( cosTheta1 ) );","float cosTheta2Sq = 1.0 - sinTheta2Sq;","if ( cosTheta2Sq < 0.0 ) {","return vec3( 1.0 );","}","float cosTheta2 = sqrt(cosTheta2Sq);","float R0 = IoRToFresnel0(iridescenceIoR, outsideIoR);","float R12 = FresnelSchlick(R0, 1.0, cosTheta1);","float R21 = R12;","float T121 = 1.0 - R12;","float phi12 = 0.0;","if (iridescenceIoR < outsideIoR) phi12 = PI;","float phi21 = PI - phi12;","vec3 baseIoR = Fresnel0ToIoR(sr0Color + 1e-6);","vec3 R1 = IoRToFresnel0(baseIoR, iridescenceIoR);","vec3 R23 = FresnelSchlick(R1, vec3(1.0), cosTheta2);","vec3 phi23 = vec3(0.0);","if (baseIoR.x < iridescenceIoR) phi23.x = PI;","if (baseIoR.y < iridescenceIoR) phi23.y = PI;","if (baseIoR.z < iridescenceIoR) phi23.z = PI;","float OPD = 2.0 * iridescenceIoR * iridescenceThickness * cosTheta2;","vec3 phi = vec3( phi21 ) + phi23;","vec3 R123 = clamp( R12 * R23, 1e-6, 1.0 - 1e-6 );","vec3 r123 = sqrt( R123 );","vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );","vec3 C0 = R12 + Rs;","vec3 I = C0;","vec3 Cm = Rs - T121;","for (int m = 1; m <= 2; ++m) {","Cm *= r123;","vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);","I += Cm * Sm;","}","return max(I, vec3(0.0));","}","#endif"].join("\n"),D=["vec3 DiffuseLambertBRDF(vec3 diffuseColor) {","return (diffuseColor * INV_PI);","}","#ifdef USE_SPECULAR_AA","vec2 AxisAlignedNDFFiltering(vec3 halfvectorTS, vec2 roughness2) {","vec2 halfvector2D = halfvectorTS.xy;","vec2 bounds = fwidth(halfvector2D);","float SIGMA2 = 0.15915494;","vec2 kernelRoughness2 = 2.0 * SIGMA2 * (bounds * bounds);","float KAPPA = 0.18;","vec2 clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);","vec2 filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);","return filteredRoughness2;","}","#endif","#if defined(USE_ANISOTROPY) || defined(USE_SPECULAR_AA)","float TransmissionAnisoBRDF(in float roughnessX, in float roughnessY, in float NoV, in float NoL, in float NoH, in float VoH, in float LoH, in vec3 iNormal, in vec3 H, in vec3 iTangent, in vec3 iBinormal, in float iAnisotropyAngle) {","float ior2 = materialData.ior * materialData.ior;","float coeff = abs(LoH * VoH) / max(abs(NoL*NoV),1e-3);","coeff *= ior2;","coeff /= materialData.ior * LoH + ior2 *VoH*VoH;","float distrib = AnisotropicDistributionGGX(iTangent, iBinormal, iNormal, H, NoH, roughnessX, roughnessY, iAnisotropyAngle);","float geomVis = AnisotropicGGXVisibility( roughnessX, roughnessY, NoV, NoL, iAnisotropyAngle);","return coeff*distrib*geomVis;","}","float SpecularAnisoBRDF(in float roughnessX, in float roughnessY, in float NoV, in float NoL, in float NoH, in vec3 iNormal, in vec3 H, in vec3 iTangent, in vec3 iBinormal, in float iAnisotropyAngle) {","float distrib = AnisotropicDistributionGGX(iTangent, iBinormal, iNormal, H, NoH, roughnessX, roughnessY, iAnisotropyAngle);","float geomVis = AnisotropicGGXVisibility( roughnessX, roughnessY, NoV, NoL, iAnisotropyAngle);","return distrib*geomVis;","}","#endif","#if defined(USE_ANISOTROPY)","void coreModelAniso(inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","float r = materialData.roughness;","vec3 sr0Color = materialData.sr0Color;","vec3 sr90Color = materialData.sr90Color;","float NoL = saturate(dot(N,L));","float NoV = saturate(dot(N,V));","vec3 H = normalize(L+V);","float NoH = saturate(dot(N,H));","float VoH = saturate(dot(V,H));","float rX = r;","float rY = r * (1.0 - materialData.anisotropy);","specular = FresnelSchlick(sr0Color, sr90Color, VoH);","#ifdef USE_SPECULAR_AA","mat3 TBN = surfaceData.TBNMatrixForSpecularAA;","vec3 Htbn = TBN * H;","vec2 roughnesses = AxisAlignedNDFFiltering(Htbn, vec2(rX, rY));","specular *= SpecularAnisoBRDF(roughnesses.x, roughnesses.y, NoV, NoL, NoH, N, H, surfaceData.tangent, surfaceData.binormal, materialData.anisotropyAngle);","#else","specular *= SpecularAnisoBRDF(rX, rY, NoV, NoL, NoH, N, H, surfaceData.tangent, surfaceData.binormal, materialData.anisotropyAngle);","#endif","#ifdef DSPBR","diffuse = DiffuseLambertBRDF(materialData.diffuseColor) * materialData.diffuseEnergyConservationConstant;","specular += DiffuseLambertBRDF(materialData.specularEnergyConservationConstant);","#else","diffuse = DiffuseLambertBRDF(materialData.diffuseColor) * SpecGlossEnergyConservationTerm(NoL, NoV, sr0Color, sr90Color);","#endif","}","#endif","float SpecularBRDF(in float roughness, in float NoV, in float NoL, in float NoH) {","float distrib = DistributionGGX( roughness, NoH);","float geomVis = GGXVisibility( roughness, NoV, NoL);","return distrib*geomVis;","}","float TransmissionBRDF(in float roughness, in float NoV, in float NoL, in float NoH, in float VoH, in float LoH) {","float ior2 = pow2(materialData.ior);","float coeff = abs(LoH * VoH) / (max(abs(NoL), 1e-3) * max(abs(NoV),1e-3));","coeff *= ior2;","coeff /= max(pow2(materialData.ior*LoH + VoH), 1e-3);","float distrib = DistributionGGX( roughness, NoH);","float geomVis = GeometricSchlick( roughness, NoV, NoL);","return coeff*distrib*geomVis;","}","void coreModel(inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","vec3 sr0Color = materialData.sr0Color;","vec3 sr90Color = materialData.sr90Color;","float NoL = saturate(dot(N,L));","float NoV = saturate(dot(N,V));","vec3 H = normalize(L+V);","float NoH = saturate(dot(N,H));","float VoH = saturate(dot(V,H));","specular = FresnelSchlick(sr0Color, sr90Color, VoH);","#ifdef USE_SPECULAR_AA","mat3 TBN = surfaceData.TBNMatrixForSpecularAA;","vec3 Htbn = TBN * H;","vec2 roughnesses = AxisAlignedNDFFiltering(Htbn, vec2(materialData.roughness, materialData.roughness));","specular *= SpecularAnisoBRDF(roughnesses.x, roughnesses.y, NoV, NoL, NoH, N, H, surfaceData.TForSpecularAA, surfaceData.BForSpecularAA, 0.0);","#else","specular *= SpecularBRDF(materialData.roughness, NoV, NoL, NoH) ;","#endif","#ifdef DSPBR","diffuse = DiffuseLambertBRDF(materialData.diffuseColor) * materialData.diffuseEnergyConservationConstant;","specular += DiffuseLambertBRDF(materialData.specularEnergyConservationConstant);","#else","diffuse = DiffuseLambertBRDF(materialData.diffuseColor) * SpecGlossEnergyConservationTerm(NoL, NoV, sr0Color, sr90Color);","#endif","}","vec3 TranslucencyDiffuseModel(in vec3 N, in vec3 L, in vec3 V, in vec3 color) {",h(),"return NoLt * brdf * fTrans;","}","vec3 TranslucencySpecularModel(in vec3 N, in vec3 L, in vec3 V, in vec3 color) {",x(),"return brdf * NoLt * fTrans;","}","vec3 _TranslucencySpecularModel(in vec3 N, in vec3 L, in vec3 V, in vec3 color) {",x(),"return brdf * fTrans;","}","vec3 _TranslucencyDiffuseModel(in vec3 N, in vec3 L, in vec3 V, in vec3 color) {",h(),"return brdf * fTrans;","}"].join("\n"),C=["struct areaLightingData","{","mat3 Minv;","vec2 fresnel;","#ifdef CLEAR_COAT","mat3 MinvCC;","vec2 fresnelCC;","#endif","#ifdef USE_SHEEN","mat3 MinvSheen;","#endif","#ifdef USE_SPECGLOSS_FLAKES","mat3 MinvMetal;","vec2 fresnelMetal;","mat3 MinvMetalFlakes;","vec2 fresnelMetalFlakes;","#ifdef PEARL_FLAKES_ACTIVATED","mat3 MinvPearlFlakes;","vec2 fresnelPearlFlakes;","#endif","#endif","#ifdef USE_DSPBR_FLAKES","mat3 MinvMetal;","vec2 fresnelMetal;","mat3 MinvMetalSto;","vec2 fresnelMetalSto;","mat3 MinvMetalClose;","vec2 fresnelMetalClose;","#endif","};","areaLightingData areaData;","#define LUT_SIZE 64.0","#define LUT_SCALE (LUT_SIZE - 1.0)/LUT_SIZE","#define LUT_BIAS 0.5/LUT_SIZE","#ifdef USE_SHEEN","void setAreaSheenData(in float roughness, in float NoV, out mat3 Minv) {","vec2 uvAr = vec2(roughness, 1.0 - sqrt(1.0 - NoV)) * LUT_SCALE + LUT_BIAS;","#if defined(USE_VELVET)","vec4 t1 = texture2D(precomputedAreaAshikmintexture, uvAr);","#endif","#if defined(USE_SOFT_VELVET)","vec4 t1 = texture2D(precomputedAreaEsteveztexture, uvAr);","#endif","#if defined(USE_SATIN)","vec4 t1 = texture2D(precomputedAreaBeckmanntexture, uvAr);","#endif","Minv = mat3(","vec3(t1.x,  0, t1.y),","vec3(  0, 1.0,   0),","vec3(t1.z,  0, t1.w)",");","}","#endif","void setAreaGGXData(in float roughness, in float NoV, out vec2 fresnel, out mat3 Minv) {","vec2 uvAr = vec2(roughness, 1.0 - sqrt(1.0 - NoV)) * LUT_SCALE + LUT_BIAS;","vec4 t1 = texture2D(precomputedAreaGGX1texture, uvAr);","vec4 t2 = texture2D(precomputedAreaGGX2texture, uvAr);","Minv = mat3(","vec3(t1.x,  0, t1.y),","vec3(  0, 1.0,   0),","vec3(t1.z,  0, t1.w)",");","fresnel = vec2(t2.z,t2.y);","}","vec3 IntegrateEdgeVec(in vec3 v1, in vec3 v2)","{","float x = dot(v1, v2);","float y = abs(x);","float a = 0.8543985 + (0.4965155 + 0.0145206*y)*y;","float b = 3.4175940 + (4.1616724 + y)*y;","float v = a / b;","float theta_sintheta = (x > 0.0) ? v : 0.5*inversesqrt(1.0 - x*x) - v;","return cross(v1, v2)*theta_sintheta;","}","float areaRectangleLight(in vec3 N, in vec3 V, in vec3 P,in mat3 Minv, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3) {","vec3 dir = p0 - P;","vec3 lightNormal = cross(p1 - p0, p3 - p0);","bool behind = (dot(dir, lightNormal) < 0.0);","if (behind) {","return 0.0;","}","vec3 T = normalize(V-N*dot(V,N));","vec3 B = cross(N,T);","mat3 M = Minv*transposeMatrix(mat3(T,B,N));","vec3 L[4];","L[0] = normalize(M * (p0 - P));","L[1] = normalize(M * (p1 - P));","L[2] = normalize(M * (p2 - P));","L[3] = normalize(M * (p3 - P));","vec3 F = IntegrateEdgeVec(L[0], L[1]);","F += IntegrateEdgeVec(L[1], L[2]);","F += IntegrateEdgeVec(L[2], L[3]);","F += IntegrateEdgeVec(L[3], L[0]);","float formFactor = length(F);","float z = F.z/formFactor;","vec2 uv = vec2(z*0.5 + 0.5, 1.0 - formFactor);","uv = uv*LUT_SCALE + LUT_BIAS;","float scale = texture2D(precomputedAreaGGX2texture, uv).w;","return saturate(scale * formFactor);","}","vec3 SolveCubic(vec4 Coefficient) {","Coefficient.xyz /= Coefficient.w;","Coefficient.yz /= 3.0;","float A = Coefficient.w;","float B = Coefficient.z;","float C = Coefficient.y;","float D = Coefficient.x;","vec3 Delta = vec3(","-Coefficient.z*Coefficient.z + Coefficient.y,","-Coefficient.y*Coefficient.z + Coefficient.x,","dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)",");","float Discriminant = dot(vec2(4.0*Delta.x, -Delta.y), Delta.zy);","vec3 RootsA, RootsD;","vec2 xlc, xsc;","{","float A_a = 1.0;","float C_a = Delta.x;","float D_a = -2.0*B*Delta.x + Delta.y;","float Theta = atan(sqrt(Discriminant), -D_a)/3.0;","float x_1a = 2.0*sqrt(-C_a)*cos(Theta);","float x_3a = 2.0*sqrt(-C_a)*cos(Theta + (2.0/3.0)*3.14159265);","float xl;","if ((x_1a + x_3a) > 2.0*B)","xl = x_1a;","else","xl = x_3a;","xlc = vec2(xl - B, A);","}","{","float A_d = D;","float C_d = Delta.z;","float D_d = -D*Delta.y + 2.0*C*Delta.z;","float Theta = atan(D*sqrt(Discriminant), -D_d)/3.0;","float x_1d = 2.0*sqrt(-C_d)*cos(Theta);","float x_3d = 2.0*sqrt(-C_d)*cos(Theta + (2.0/3.0)*3.14159265);","float xs;","if (x_1d + x_3d < 2.0*C)","xs = x_1d;","else","xs = x_3d;","xsc = vec2(-D, xs + C);","}","float E =  xlc.y*xsc.y;","float F = -xlc.x*xsc.y - xlc.y*xsc.x;","float G =  xlc.x*xsc.x;","vec2 xmc = vec2(C*F - B*G, -B*F + C*E);","vec3 Root = vec3(xsc.x/xsc.y, xmc.x/xmc.y, xlc.x/xlc.y);","if (Root.x < Root.y && Root.x < Root.z)","Root.xyz = Root.yxz;","else if (Root.z < Root.x && Root.z < Root.y)","Root.xyz = Root.xzy;","return Root;","}","float areaDiskLight(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 p0, vec3 p1, vec3 p2) {","vec3 T = normalize(V-N*dot(V,N));","vec3 B = cross(N,T);","mat3 R = transposeMatrix(mat3(T, B, N));","vec3 L[3];","L[0] = R * (p0 - P);","L[1] = R * (p1 - P);","L[2] = R * (p2 - P);","vec3 c  = Minv *(0.5 * (L[0] + L[2]));","vec3 v1 = Minv *(0.5 * (L[1] - L[2]));","vec3 v2 = Minv *(0.5 * (L[1] - L[0]));","if(dot(cross(v1, v2), c) < 0.0)","return 0.0;","float a, b;","float d11 = dot(v1, v1);","float d22 = dot(v2, v2);","float d12 = dot(v1, v2);","if (abs(d12)/sqrt(d11*d22) > 0.005) {","float tr = d11 + d22;","float det = -d12*d12 + d11*d22;","det = sqrt(det);","float u = 0.5*sqrt(tr - 2.0*det);","float v = 0.5*sqrt(tr + 2.0*det);","float e_max = pow2(u + v);","float e_min = pow2(u - v);","vec3 v1_, v2_;","if (d11 > d22) {","v1_ = d12*v1 + (e_max - d11)*v2;","v2_ = d12*v1 + (e_min - d11)*v2;","}","else {","v1_ = d12*v2 + (e_max - d22)*v1;","v2_ = d12*v2 + (e_min - d22)*v1;","}","a = 1.0 / e_max;","b = 1.0 / e_min;","v1 = normalize(v1_);","v2 = normalize(v2_);","}","else {","a = 1.0 / dot(v1, v1);","b = 1.0 / dot(v2, v2);","v1 *= sqrt(a);","v2 *= sqrt(b);","}","vec3 v3 = normalize(cross(v1, v2));","if (dot(c, v3) < 0.0)","v3 *= -1.0;","float L_  = dot(v3, c);","float x0 = dot(v1, c) / L_;","float y0 = dot(v2, c) / L_;","float E1 = inversesqrt(a);","float E2 = inversesqrt(b);","a *= L_*L_;","b *= L_*L_;","float c0 = a*b;","float c1 = a*b*(1.0 + x0*x0 + y0*y0) - a - b;","float c2 = 1.0 - a*(1.0 + x0*x0) - b*(1.0 + y0*y0);","float c3 = 1.0;","vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));","float e1 = roots.x;","float e2 = roots.y;","float e3 = roots.z;","vec3 avgDir = vec3(a*x0/(a - e2), b*y0/(b - e2), 1.0);","mat3 rotate = mat3(v1, v2, v3);","avgDir = rotate*avgDir;","avgDir = normalize(avgDir);","float L1 = sqrt(-e2/e3);","float L2 = sqrt(-e2/e1);","float formFactor = L1*L2*inversesqrt((1.0 + L1*L1)*(1.0 + L2*L2));","vec2 uv = vec2(avgDir.z*0.5 + 0.5, 1.0 - formFactor);","uv = uv*LUT_SCALE + LUT_BIAS;","float scale = texture2D(precomputedAreaGGX2texture, uv).w;","float res = formFactor*scale;","return saturate(res);","}","void getSphereLightPoints(inout vec3 lP, in vec3 P, in float radius, out vec3 p0, out vec3 p1, out vec3 p2) {","vec3 toUse = vNormalize(P - lP);","lP += radius * toUse;","vec3 right = getGeomT(toUse.xyz);","vec3 up = getGeomB(toUse.xyz, right);","p0 = lP.xyz + right * radius - up * radius;","p1 = lP.xyz - right * radius - up * radius;","p2 = lP.xyz - right * radius + up * radius;","}","vec3 getSpecularDominantDir(in vec3 N, in vec3 R, in float r){","return normalize(mix(N, R, 1.0-r));","}","float solidAngleRect(in vec3 viewPos, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3) {","vec3 v0 = p0 - viewPos;","vec3 v1 = p1 - viewPos;","vec3 v2 = p2 - viewPos;","vec3 v3 = p3 - viewPos;","vec3 n0 = normalize(cross(v0,v1));","vec3 n1 = normalize(cross(v1,v2));","vec3 n2 = normalize(cross(v2,v3));","vec3 n3 = normalize(cross(v3,v0));","float g0 = acos(dot(-n0,n1));","float g1 = acos(dot(-n1,n2));","float g2 = acos(dot(-n2,n3));","float g3 = acos(dot(-n3,n0));","return g0 + g1 + g2 + g3 - 2.0 * 3.14159;","}","vec3 closestOnLine(in vec3 a, in vec3 b, in vec3 c) {","vec3 ab = b - a;","float t = dot(c - a , ab) / dot(ab,ab);","return a + t * ab;","}","vec3 closestOnSegment(in vec3 a, in vec3 b, in vec3 c) {","vec3 ab = b - a;","float t = dot(c - a, ab) / dot(ab,ab);","return a + saturate(t) * ab;","}","vec3 closestPointSphere(in vec3 L, in vec3 R, in float radius) {","vec3 centerToRay = dot(L, R) * R - L;","vec3 closestPoint = L + centerToRay * saturate(radius / length(centerToRay));","return normalize(closestPoint);","}","vec3 closestPointTube(in vec3 P0, in vec3 P1,in vec3 N, in vec3 R, in vec3 P, in vec3 Lp, in float radius) {","vec3 L0 = P0 - P;","vec3 L1 = P1 - P;","vec3 Ld = L1 - L0;","float coeff = dot(R,L0)*dot(R,Ld) - dot(L0,Ld);","coeff /= dot(Ld,Ld) - pow2(dot(R,Ld));","vec3 L = L0 + saturate(coeff) * Ld;","return closestPointSphere(L,R,radius);","}","float cropRectangleLight(in vec3 lP, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 P, in vec3 N) {","float A = dot(vNormalize(lP - P), N);","float B = dot(vNormalize(p0 - P), N);","float C = dot(vNormalize(p1 - P), N);","float D = dot(vNormalize(p2 - P), N);","float E = dot(vNormalize(p3 - P), N);","return max(A, max(B, max(C, max(D,E)))) <= 1e-6 ? 0.0 : 1.0;","}","float cropDiskLight(in vec3 lP, in vec3 p0, in vec3 p1, in vec3 P, in vec3 N) {","vec3 p2 = lP - (p0 - lP);","vec3 p3 = lP - (p1 - lP);","return cropRectangleLight(lP, p0, p1, p2, p3, P, N);","}"].join("\n"),P=function(e,t){return["#ifdef USE_SUBSURFACE","#ifdef SPECGLOSS","diffuse *= materialData.scatteringColor;","#else","vec3 baseDiffuseValue = diffuse;","#ifdef DSPBR_WITH_TRANSLUCENCY","diffuse = mix(diffuse, materialData.scatteringColor * baseDiffuseValue, materialData.translucency);","#endif","diffuse = mix(diffuse, materialData.scatteringColor * baseDiffuseValue, materialData.transparency);","#endif","#ifdef THICKNESS_BASED_TRANSMITTANCE","vec3 attenuation = materialData.transmittanceColor;","#ifdef DSPBR_WITH_TRANSLUCENCY","transmissive = materialData.translucency * materialData.translucencyColor * attenuation * "+e+"(-N,V,P,mat3(1.0), "+t+") * materialData.diffuseEnergyConservationConstant;","#endif","#ifdef DSPBR","float fTrans = 1.0 - materialData.specularContribution * vMax(materialData.specularBlendingSR0 * areaData.fresnel.x + areaData.fresnel.y);","#else","float fTrans = 1.0 - vMax(fresnelCore);","#endif","transmissive += attenuation * materialData.transparentColor * fTrans * "+e+"(-N,coreView,P,areaData.Minv, "+t+");","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","diffuse *= (1.0 - materialData.translucency);","transmissive = materialData.translucency * materialData.translucencyColor * "+e+"(-N,V,P,mat3(1.0), "+t+") * materialData.diffuseEnergyConservationConstant;","#endif"].join("\n")},E=function(e,t){return["#ifdef USE_SPECGLOSS_FLAKES","vec3 fresnelMetal = metalFlakes.flakesSR0Color * areaData.fresnelMetalFlakes.x;","vec3 flakesVal = fresnelMetal;","flakesVal *= "+e+"(N,V,P,areaData.MinvMetalFlakes, "+t+");","float energyFlakes = SpecGlossEnergyConservationTerm(fresnelMetal);","specular *= energyFlakes;","diffuse *= energyFlakes;","transmissive *= energyFlakes;","specular += flakesVal;","fresnelMetal = metal.flakesSR0Color * areaData.fresnelMetal.x;","flakesVal = fresnelMetal;","flakesVal *= "+e+"(N,V,P,areaData.MinvMetal, "+t+");","energyFlakes = SpecGlossEnergyConservationTerm(fresnelMetal);","specular *= energyFlakes;","diffuse *= energyFlakes;","transmissive *= energyFlakes;","specular += flakesVal;","#ifdef PEARL_FLAKES_ACTIVATED","fresnelMetal = pearlFlakes.flakesSR0Color * areaData.fresnelPearlFlakes.x;","flakesVal = fresnelMetal;","flakesVal *= "+e+"(N,V,P,areaData.MinvPearlFlakes, "+t+");","energyFlakes = SpecGlossEnergyConservationTerm(fresnelMetal);","specular *= energyFlakes;","diffuse *= energyFlakes;","transmissive *= energyFlakes;","specular += flakesVal;","#endif","#endif"].join("\n")},y=function(e,t){return["#ifdef USE_DSPBR_FLAKES","vec3 flakesVal = vec3(0.0);","if (flakesData.smoothWeight > 0.0) {","flakesVal += flakesData.smoothFlakesColor * "+e+"(N,V,P,areaData.MinvMetal, "+t+");","}","if (flakesData.stochasticWeight > 0.0) {","vec3 normalStoFlakes = flakesData.stochasticHemisphereFlakesNormal;","flakesVal += flakesData.stochasticHemisphereFlakesColor * "+e+"(normalStoFlakes,V,P,areaData.MinvMetalSto, "+t+");","}","if (flakesData.closeupWeight > 0.0) {","vec3 normalCloseUpFlakes = flakesData.closeupFlakesNormal;","flakesVal += flakesData.closeupFlakesColor * "+e+"(normalCloseUpFlakes,V,P,areaData.MinvMetalClose, "+t+");","}","diffuse *= flakesData.baseWeight;","specular *= flakesData.baseWeight;","transmissive *= flakesData.baseWeight;","specular += flakesVal;","#endif"].join("\n")},A=function(e,t){return["#ifdef CLEAR_COAT","vec3 fresnelCoat = materialData.clearCoatSR0Color * areaData.fresnelCC.x + materialData.clearCoatSR90Color * areaData.fresnelCC.y;","#ifdef DSPBR","float fresnelEnergy = 1.0 - materialData.clearCoat * vMax(FresnelSchlick(materialData.clearCoatSR0Color, materialData.clearCoatSR90Color, saturate(dot(surfaceData.clearCoatNormal,V))));","#else","float fresnelEnergy = SpecGlossEnergyConservationTerm(fresnelCoat);","#endif","vec3 coat = fresnelCoat;","coat *= "+e+"(N,V,P,areaData.MinvCC, "+t+");","diffuse *= fresnelEnergy;","specular *= fresnelEnergy;","transmissive *= fresnelEnergy;","specular += materialData.clearCoat * coat;","#endif"].join("\n")},M=function(e,t){return["vec3 coreView = V;","vec3 fresnelCore = materialData.sr0Color * areaData.fresnel.x + materialData.sr90Color * areaData.fresnel.y;","specular = fresnelCore;","specular *= "+e+"(N,coreView,P,areaData.Minv, "+t+");","float diffuseValue = "+e+"(N,V,P,mat3(1.0), "+t+");","#ifdef DSPBR","specular += diffuseValue * materialData.specularEnergyConservationConstant;","diffuseValue *= materialData.diffuseEnergyConservationConstant;","#else","diffuseValue *= SpecGlossEnergyConservationTerm(fresnelCore);","#endif","diffuse = materialData.diffuseColor * diffuseValue;"].join("\n")},T=function(e,t){return["#if defined(USE_SHEEN) && defined(DSPBR_WITH_SHEEN_COLOR_ROUGHNESS)","vec3 sheen = vec3("+e+"(N,V,P,areaData.MinvSheen, "+t+"));","float sheenBlending = 1.0 - materialData.sheenEnergyConservationConstant;","diffuse *= sheenBlending;","specular *= sheenBlending;","transmissive *= sheenBlending;","specular += materialData.sheen * sheen * materialData.sheenColor;","#endif"].join("\n")},N=function(e,t){return["#if defined(USE_SHEEN) && !defined(DSPBR_WITH_SHEEN_COLOR_ROUGHNESS)","vec3 sheen = vec3("+e+"(N,V,P,areaData.MinvSheen, "+t+"));","float sheenBlending = 1.0 - pow5(1.0-materialData.sheen);","diffuse *= PI * sheen * sheenBlending + (1.0 - sheenBlending);","#endif"].join("\n")},U=["void areaRectangleLightModel(out vec3 specular, out vec3 diffuse, out vec3 transmissive, in vec3 N,in vec3 V, in vec3 P, in vec3 p0,in vec3 p1,in vec3 p2,in vec3 p3) {",M("areaRectangleLight","p0,p1,p2,p3"),N("areaRectangleLight","p0,p1,p2,p3"),P("areaRectangleLight","p0,p1,p2,p3"),T("areaRectangleLight","p0,p1,p2,p3"),E("areaRectangleLight","p0,p1,p2,p3"),y("areaRectangleLight","p0,p1,p2,p3"),A("areaRectangleLight","p0,p1,p2,p3"),"}","void areaDiskLightModel(out vec3 specular, out vec3 diffuse, out vec3 transmissive, in vec3 N,in vec3 V, in vec3 P, in vec3 p0,in vec3 p1,in vec3 p2) {",M("areaDiskLight","p0,p1,p2"),N("areaDiskLight","p0,p1,p2"),P("areaDiskLight","p0,p1,p2"),T("areaDiskLight","p0,p1,p2"),E("areaDiskLight","p0,p1,p2"),y("areaDiskLight","p0,p1,p2"),A("areaDiskLight","p0,p1,p2"),"}","float illuminanceRectangle(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3,in vec3 lightPosition, in vec3 viewPosition, in vec3 N) {","float angle = solidAngleRect(viewPosition, p0,p1,p2,p3);","float coeff = saturate(dot(normalize(lightPosition - viewPosition),N));","coeff += saturate(dot(normalize(p0 - viewPosition),N)) + saturate(dot(normalize(p1 - viewPosition),N));","coeff += saturate(dot(normalize(p2 - viewPosition),N)) + saturate(dot(normalize(p3 - viewPosition),N));","return angle * 0.2*coeff;","}","float illuminanceTube(in vec3 P0, in vec3 P1, in vec3 lightPosition, in vec3 viewPosition, in vec3 N, in vec3 lRight, in float lHWidth, in float lRadius) {","vec3 forw = normalize(closestOnLine(P0,P1,viewPosition) - viewPosition);","vec3 right = lRight;","vec3 up = cross(right, forw);","vec3 p0 = lightPosition.xyz + right * lHWidth + up * lRadius;","vec3 p1 = lightPosition.xyz + right * lHWidth + up * -lRadius;","vec3 p2 = lightPosition.xyz + right * -lHWidth + up * -lRadius;","vec3 p3 = lightPosition.xyz + right * -lHWidth + up * lRadius;","float illu = illuminanceRectangle(p0,p1,p2,p3,lightPosition,viewPosition,N);","vec3 sphPos = closestOnSegment(P0,P1, viewPosition);","vec3 sphNorm = sphPos - viewPosition;","vec3 sphL = normalize(sphNorm);","float sqrSphDist = dot(sphNorm, sphNorm);","float illu2 = 3.14159 * saturate(dot(sphL, N)) * ((lRadius*lRadius)/sqrSphDist);","return illu+illu2;","}"].join("\n");o=[v,D,e?g:"",e?d:"",e?u:"",e?p:"",e?m:"",e?S:"",_,"#ifdef HAS_AREA_LIGHTS",e?C:"",e?U:"","#endif"].join("\n");var L=["void _doCommonLightingModel(inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","#ifdef USE_ANISOTROPY","coreModelAniso(diffuse,specular, N,V,L);","#else","coreModel(diffuse,specular, N,V,L);","#endif","#ifdef DEBUG_SHADOW","return;","#endif","#ifdef USE_SHEEN","sheenModel(diffuse, specular, N, V, L);","#endif","#ifdef USE_SPECGLOSS_FLAKES","specGlossFlakesModel(diffuse,specular, V,L);","#endif","#ifdef USE_DSPBR_FLAKES","dspbrFlakesModel(diffuse,specular,V,L,N);","#endif","#ifdef CLEAR_COAT","clearCoatModel(diffuse,specular, V, L);","#endif","}","vec3 doShadowApplication(in vec3 light,in float shadowExposure) {","return  light*shadowExposure;","}","vec3 doFullShadowApplication(in vec3 light, in vec3 lightColor, in float shadowExposure,in vec4 transparentExposure) {","vec3 intensity = max(light / lightColor,vec3(0.0));","return  intensity * min(lightColor,transparentExposure.rgb)*min(shadowExposure,transparentExposure.a);","return lightColor;","}","void doLightingModel(in vec3 E, inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","#ifdef DEBUG_SHADOW","N = L;","#endif","_doCommonLightingModel(diffuse,specular,N,V,L);","#ifdef INVISIBLE_PLANE_MATERIAL","vec3 ENoL = PI * E * (step(0.0, dot(N, L)));","#else","vec3 ENoL = E * saturate(dot(N, L));","#endif","#ifdef DEBUG_SHADOW","diffuse *= ENoL;","specular *= 0.0;","return;","#endif","#ifdef USE_SUBSURFACE","vec3 sssENoL = E * getScattering(dot(N, L), surfaceData.curvature);","#ifdef SPECGLOSS","diffuse *= sssENoL;","#else","vec3 baseDiffuseValue = diffuse;","#ifdef DSPBR_WITH_TRANSLUCENCY","diffuse *= mix(ENoL, sssENoL, materialData.translucency);","#else","diffuse *= ENoL;","#endif","diffuse = mix(diffuse, sssENoL * baseDiffuseValue, materialData.transparency);","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","diffuse *= ENoL * (1.0 - materialData.translucency);","#else","diffuse *= ENoL;","#endif","specular *= ENoL;","}","void doAreaLightingModel(in vec3 E, inout vec3 diffuse, inout vec3 specular, in vec3 N, in vec3 V, in vec3 L) {","_doCommonLightingModel(diffuse,specular,N,V,L);","#ifdef USE_SUBSURFACE","vec3 sssE = E * materialData.scatteringColor;","#ifdef SPECGLOSS","diffuse *= sssE;","#else","vec3 baseDiffuseValue = diffuse;","#ifdef DSPBR_WITH_TRANSLUCENCY","diffuse *= mix(E, sssE, materialData.translucency);","#else","diffuse *= E;","#endif","diffuse = mix(diffuse, sssE * baseDiffuseValue, materialData.transparency);","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","diffuse *= E * (1.0 - materialData.translucency);","#else","diffuse *= E;","#endif","specular *= E;","}"].join("\n"),I=["float computeHorizonFade(in vec3 R, in vec3 N, in float roughness) {","float coeff = mix(0.5, 1.0, 1.0 - pow2(roughness));","return clamp(1.0 + coeff * dot(R, N), 0.0, 1.0);","}","#if defined(REFLECTIVITY_ENVMAP) && defined(USE_LIGHTING)","#define USE_REFLECTIVITY_ENVMAP","#ifndef USE_ENVMAP","uniform int combine;","uniform float reflectivity;","#endif","uniform sampler2D reflectivityEnvMap;","vec3 sampleReflectivityEnvMap(in vec3 reflectVec, in vec3 color) {","vec3 endColor;","float probeR = INV_PI * acos( reflectVec.z ) / length(reflectVec.xy);","vec3 mapColor = convertToLinear(texture2D( reflectivityEnvMap, 0.5 * (probeR * reflectVec.xy + 1.0)).xyz);","if ( combine == 1 ) {","endColor = mix( color.xyz, mapColor,  reflectivity );","} else if ( combine == 2 ) {","endColor = color + mapColor * reflectivity;","} else {","endColor = mix( color.xyz, color.xyz * mapColor, reflectivity );","}","return endColor;","}","#endif","#if defined(USE_ENVMAP) || defined(USE_SSLREFLECTION) || defined(USE_SSLREFRACTION)","uniform sampler2D precomputedTexture;","#define E_130_OVER_258 0.50387596899","vec2 PRECOMPUTED_TEXTURE_1 = E_130_OVER_258 * vec2(0.0,1.0);","vec2 PRECOMPUTED_TEXTURE_2 = E_130_OVER_258 * vec2(1.0,1.0);","vec2 PRECOMPUTED_TEXTURE_3 = E_130_OVER_258 * vec2(0.0,0.0);","vec4 sampleBRDFTexture(in float NdotV, in float roughness, in vec2 offset) {","vec2 uv = 0.496124031 * vec2(max(NdotV,1e-2),roughness) + offset;","return texture2D(precomputedTexture, uv);","}","#endif","#ifdef USE_ENVMAP","uniform sampler2D envMap2;","#endif","#ifdef USE_REFLECTION_PROBE","uniform sampler2D reflectionProbe;","uniform sampler2D reflectionProbeMips;","uniform vec3 reflectionProbeProxyMin;","uniform vec3 reflectionProbeProxyMax;","uniform vec3 reflectionProbePos;","#endif","#ifdef USE_FINITE_ENVMAP","uniform vec3 sphereCenter;","uniform vec3 projectionCenter;","uniform float sphereRadius;","#endif","#if defined(USE_SSLREFLECTION) || defined(USE_SSLREFRACTION)","uniform vec2 invScreenSize;","#endif","#if defined(USE_SSLREFLECTION)","uniform sampler2D reflectionColorTexture;","#endif","#if defined(USE_SSLREFRACTION)","uniform sampler2D refractionColorTexture;","#endif","#if defined(USE_ENVMAP) || defined(USE_SSLREFLECTION) || defined(USE_SSLREFRACTION)","const float oneOverMax16int = 0.000015259021896696422;","float unpackFrom16(vec2 pack) {","return 255.0 * oneOverMax16int * (256.0 * pack.x + pack.y);","}","#endif","#if defined(USE_ENVMAP)","vec2 getMips(in float roughnessValue) {","float mipValue = max(6.0 + 1.15 * log2(roughnessValue + 0.0000001), 0.0);","float mipCoef = fract(mipValue);","if (mipValue > 6.0) {","mipValue = 6.0;","mipCoef = 1.0;","}","return vec2(mipValue,mipCoef);","}","vec2 getMipsLinearInverted(in float roughnessValue) {","float mipValue = max(5.0 * (1.0 - roughnessValue) + 1.0, 0.0);","float mipCoef = fract(mipValue);","if (mipValue > 6.0) {","mipValue = 6.0;","mipCoef = 1.0;","}","return vec2(mipValue,mipCoef);","}","vec2 getMipsLinear(in float roughnessValue) {","float mipValue = max(5.0 * (roughnessValue) + 1.0, 0.0);","float mipCoef = fract(mipValue);","if (mipValue > 6.0) {","mipValue = 6.0;","mipCoef = 1.0;","}","return vec2(mipValue,mipCoef);","}","vec2 getEnvMapUV(in vec3 vector) {","vector = normalize((ambienceMatrix*vec4(vector,0.0)).xyz);","if (abs(vector.x) < 1e-6) {","vector.x = 1e-6;","}","float phi = atan(vector.y, vector.x);","float theta = acos(vector.z);","return vec2(fract(0.5 + 0.5 * INV_PI * phi), 1.0 - INV_PI * theta);","}","vec2 getUVFromMips(float mip, vec2 uv, vec2 texelSize) {","float t10 = pow(2.0, -floor(log2(mip + 1.0)));","float t11 = 2.0 - (mip + 2.0) * t10;","float t12 = 0.5 * t10;","return vec2(t11 + 1.5 * texelSize.x + (2.0 * t12 - 3.0 * texelSize.x) * uv.x, t12 + 1.5 * texelSize.x + (t12 - 3.0 * texelSize.x) * uv.y);","}","vec4 getUVBoxFromMips(float mip, vec2 texelSize) {","float t10 = pow(2.0, -floor(log2(mip + 1.0)));","float t11 = 2.0 - (mip + 2.0) * t10;","float t12 = 0.5 * t10;","return vec4(t11, t12 + 1.5 * texelSize.x , 2.0 * t12, t12 - 3.0 * texelSize.x);","}","vec4 sampleMipMapRoughness(vec2 uv, float mip, float coef, sampler2D map0, sampler2D map1) {","vec4 color1;","vec4 color2;","vec4 uv1;","vec4 uv2;","#ifdef USE_ENVMAP_HDR","if (mip < 1.0) {","#ifdef USE_ENVMAP_RGB_HDR","color1 = texture2D(map0, uv);","#ifdef USE_ENVMAP_RGB_SRGB","color1.xyz *= color1.xyz;","#endif","#else","color1 = texture2DBilinearFromRGBE(map0, uv, hdrSize, hdrTexelSize);","#endif","} else {","float level1 = clamp(floor(mip) - 1.0, 0.0, 4.0);","#ifdef NON_REPEAT_IBL_SAMPLING","uv1.xy = getUVFromMips(level1, uv, mipsTexelSize);","#else","uv1 = getUVBoxFromMips(level1, mipsTexelSize);","#endif","color1 = texture2DBilinearFromRGBEwBox(map1, uv1, uv, mipsSize, mipsTexelSize);","}","float level2 = clamp(floor(mip), 0.0, 5.0);","#ifdef NON_REPEAT_IBL_SAMPLING","uv2.xy = getUVFromMips(level2, uv, mipsTexelSize);","#else","uv2 = getUVBoxFromMips(level2, mipsTexelSize);","#endif","color2 = texture2DBilinearFromRGBEwBox(map1, uv2, uv, mipsSize, mipsTexelSize);","return mix(color1, color2, coef);","#else","return texture2D(map1, uv);","#endif","}","#if defined(USE_SHEEN) && defined(USE_ENVMAP_SHEEN)","vec4 sampleMipMapRoughnessSheen(vec2 uv, float mip, float coef, sampler2D map1) {","vec4 color1;","vec4 color2;","vec4 uv1;","vec4 uv2;","float level1 = clamp(floor(mip) - 1.0, 0.0, 4.0);","#ifdef NON_REPEAT_IBL_SAMPLING","uv1.xy = getUVFromMips(level1, uv, mipsTexelSize);","#else","uv1 = getUVBoxFromMips(level1, mipsTexelSize);","#endif","color1 = texture2DBilinearFromRGBEwBox(map1, uv1, uv, mipsSize, mipsTexelSize);","float level2 = clamp(floor(mip), 0.0, 5.0);","#ifdef NON_REPEAT_IBL_SAMPLING","uv2.xy = getUVFromMips(level2, uv, mipsTexelSize);","#else","uv2 = getUVBoxFromMips(level2, mipsTexelSize);","#endif","color2 = texture2DBilinearFromRGBEwBox(map1, uv2, uv, mipsSize, mipsTexelSize);","return mix(color1, color2, coef);","}","#endif","#endif","#ifdef USE_REFLECTION_PROBE","vec3 correctParallax(vec3 worldPos, vec3 reflectVec) {","vec3 rbmax = (reflectionProbeProxyMax - worldPos) / reflectVec;","vec3 rbmin = (reflectionProbeProxyMin - worldPos) / reflectVec;","vec3 rbminmax = max(rbmax, rbmin);","float distance = min(min(rbminmax.x, rbminmax.y), rbminmax.z);","vec3 intersectPos = worldPos + reflectVec * distance;","return normalize(intersectPos - reflectionProbePos);","}","#endif","#ifdef USE_FINITE_ENVMAP","vec3 correctParallaxFinite(vec3 center, vec3 projection, float radius, vec3 rayDir, vec3 rayOrig) {","float t = 0.0;","vec3 dist = rayOrig - center;","float B = 2.0*dot(rayDir, dist);","float C = dot(dist, dist) - radius*radius;","float disc = B*B - 4.0*C;","if (disc < 0.0) {","    t = -1.0;","} else {","t = (-B + sqrt(disc)) / 2.0; }","vec3 hitPos = rayOrig + t*rayDir;","vec3 sn = (hitPos - projection);","return normalize(sn);","}","#endif"].join("\n");return[t,e?I:"",o,e?L:"","#ifdef DSPBR","float adjustTransparency(in float transparencyValue, in vec3 albedo, in float roughness) {","float adjust = sqrt(dot(albedo, luminanceVector));","adjust *= exp(-0.125 * roughness * roughness);","return transparencyValue * adjust;","}","#endif","float ApplyTransparency(inout float transparencyValue, in float metalnessValue, in vec3 albedo, in float NoV) {","#if defined(USE_SSLREFRACTION)","#ifndef USE_LIGHTING","transparencyValue = 0.0;","#endif","return 1.0;","#else","vec3 Ft = FresnelSchlick(materialData.sr0Color, materialData.sr90Color, NoV);","#ifndef SPECGLOSS","transparencyValue = adjustTransparency(transparencyValue, albedo, materialData.roughness);","#endif","float transToDivide = max(1.0 - (1.0 - metalnessValue) * transparencyValue * (1.0 - 0.3333*(Ft.x + Ft.y + Ft.z)), 1e-6);","gl_FragColor.a *= transToDivide;","#if defined(SKIP_TRANSPARENT)","if ( gl_FragColor.a < 1.0 - 1e-3) discard;","#endif","return transToDivide;","#endif","}"].join("\n")}(t),e.ShaderChunk.bumpmap_pars_fragment,e.ShaderChunk.normalmap_pars_fragment,"#ifdef USE_NORMALMAP","vec3 perturbNormal3Arb( vec3 surf_norm, vec3 surf_tgt, vec3 surf_binorm, vec2 normalUV, in vec2 scale ) {","vec3 N = normalize(surf_norm);","vec3 T = normalize(surf_tgt);","T = normalize(T - dot(T, N) * N);","vec3 B = normalize(surf_binorm);","vec3 mapN = texture2D( normalMap, normalUV ).xyz * 2.0 - 1.0;","#ifndef DSPBR","mapN.xy = scale * mapN.xy;","#ifdef NORMALFLIPY","mapN.y = - mapN.y;","#endif","#else","#ifdef USE_NORMAL_COEFFICIENTS","mapN = mapN * normalMulCoef + normalAddCoef;","#endif","mapN.z = abs(mapN.z);","#endif","mat3 tbn = mat3(T, B, N);","return normalize(tbn * mapN);","}","#endif","#if defined(USE_BUMPMAP) && defined(SPECGLOSS)","vec2 dHdxy_fwd(in vec2 bumpMapUv, in float scale) {","vec2 dSTdx = dFdx( bumpMapUv );","vec2 dSTdy = dFdy( bumpMapUv );","float Hll = scale * texture2D( bumpMap, bumpMapUv ).x;","float dBx = scale * texture2D( bumpMap, bumpMapUv + dSTdx ).x - Hll;","float dBy = scale * texture2D( bumpMap, bumpMapUv + dSTdy ).x - Hll;","return vec2( dBx, dBy );","}","#endif",e.DeferredShaderChunk.oit_pars_fragment,!t&&W?e.DeferredShaderChunk.picking_pars_fragment:"",!t&&W?e.DeferredShaderChunk.picking_instancing_pars_fragment:"",!t&&W?e.DeferredShaderChunk.depth_pars_fragment:"",!t&&W?e.DeferredShaderChunk.decal_normal_depth_pars_fragment:"",!t&&W?e.DeferredShaderChunk.shadowmap_pars_fragment:"",!t&&W?e.DeferredShaderChunk.highlight_pars_fragment:"",!t&&W?e.DeferredShaderChunk.texcoord_pars_fragment:"",V,e.ShaderChunk.postprocess_pars_fragment,e.ShaderChunk.fog_pars_fragment,"void main() {","#ifndef USE_ENVMAP_HDR","vec2 envMapHDRSize;","float envMapHDRToMipsRatio = 1.0;","#endif","#if defined( USE_MAP_HDR ) || defined( USE_ENVMAP_HDR )","hdrSize = vec2(envMapHDRSize);","hdrTexelSize = vec2(1.0 / envMapHDRSize);","mipsSize = envMapHDRToMipsRatio * vec2(1.0, 2.0) * hdrSize;","mipsTexelSize = vec2(1.0 / mipsSize);","#endif","#ifdef PDSFX",e.ShaderChunk.PDSFX_map_fragment,e.ShaderChunk.PDSFX_mapping_fragment,"ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,e.ShaderChunk.PDSFX_viewNormal_fragment,"vViewPosition = -ComputeViewPosition();","#endif","gl_FragColor = vec4( 1.0 );",z,e.ShaderChunk.clip_fragment,w,e.ShaderChunk.tangent_Binormal_fragment,o,function(e){var t;if(e){var o=["#if MAX_AREA_LIGHTS > 0 && !defined(DEBUG_SHADOW)","for (int i = 0; i < MAX_AREA_LIGHTS; i++) {","vec3 transmissive = vec3(0.0);","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","vec4 lPosition = viewMatrix *vec4( areaLightPosition[ i ], 1.0 );","vec4 lNormal = viewMatrix *vec4( areaLightNormal[ i ], 0.0 );","float hw = 0.5*areaLightData[i].x;","float hh = 0.5*areaLightData[i].y;","vec3 up = (viewMatrix * vec4( areaLightUp[i],0.0)).xyz;","vec3 right = normalize(cross(lNormal.xyz, up));","vec3 p0 = lPosition.xyz + right * hw - up * hh;","vec3 p1 = lPosition.xyz - right * hw - up * hh;","vec3 p2 = lPosition.xyz - right * hw + up * hh;","vec3 p3 = lPosition.xyz + right * hw + up * hh;","areaRectangleLightModel(specular, diffuse, transmissive, surfaceData.viewNormal,surfaceData.view, -surfaceData.viewPosition, p0,p1,p2,p3);","float attenuation = cropRectangleLight(lPosition.xyz, p0, p1, p2, p3, -surfaceData.viewPosition.xyz, surfaceData.viewNormal);","totalDiffuse += attenuation * areaLightColor[i] * diffuse;","totalSpecular += attenuation * areaLightColor[i] * specular;","totalTransmissive += transmissive * areaLightColor[i]* cropRectangleLight(lPosition.xyz, p0, p1, p2, p3, -surfaceData.viewPosition.xyz, -surfaceData.viewNormal);","}","#endif"].join("\n"),a=["#if MAX_SPHERE_LIGHTS > 0 && !defined(DEBUG_SHADOW)","for (int i = 0; i < MAX_SPHERE_LIGHTS; i++) {","vec3 transmissive = vec3(0.0);","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","vec4 lPosition = viewMatrix * vec4( sphereLightPosition[ i ], 1.0 );","float radius = sphereLightData[i].x;","vec3 p0, p1, p2;","getSphereLightPoints(lPosition.xyz, -surfaceData.viewPosition.xyz, radius, p0,p1,p2);","areaDiskLightModel(specular, diffuse, transmissive, surfaceData.viewNormal,surfaceData.view, -surfaceData.viewPosition.xyz, p0, p1, p2);","float attenuation = cropDiskLight(lPosition.xyz, p0, p1, -surfaceData.viewPosition.xyz, surfaceData.viewNormal);","totalDiffuse += attenuation * sphereLightColor[i]*diffuse;","totalSpecular += attenuation * sphereLightColor[i]*specular;","totalTransmissive += transmissive * sphereLightColor[i]* cropDiskLight(lPosition.xyz, p0, p1, -surfaceData.viewPosition.xyz, -surfaceData.viewNormal);","}","#endif"].join("\n"),i=["#if MAX_DISK_LIGHTS > 0 && !defined(DEBUG_SHADOW)","for (int i = 0; i < MAX_DISK_LIGHTS; i++) {","vec3 transmissive = vec3(0.0);","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","vec4 lPosition = viewMatrix * vec4( diskLightPosition[ i ], 1.0 );","vec4 lNormal = viewMatrix * vec4( diskLightNormal[ i ], 0.0 );","float radius = diskLightData[i].x;","vec3 up = (viewMatrix * vec4( diskLightUp[i],0.0)).xyz;","vec3 right = normalize(cross(lNormal.xyz, up));","vec3 p0 = lPosition.xyz + right * radius - up * radius;","vec3 p1 = lPosition.xyz - right * radius - up * radius;","vec3 p2 = lPosition.xyz - right * radius + up * radius;","areaDiskLightModel(specular, diffuse, transmissive, surfaceData.viewNormal,surfaceData.view, -surfaceData.viewPosition.xyz, p0,p1,p2);","float attenuation = cropDiskLight(lPosition.xyz, p0, p1, -surfaceData.viewPosition.xyz, surfaceData.viewNormal);","totalDiffuse += attenuation * diskLightColor[i]*diffuse;","totalSpecular += attenuation * diskLightColor[i]*specular;","totalTransmissive += transmissive * diskLightColor[i]*cropDiskLight(lPosition.xyz, p0, p1, -surfaceData.viewPosition.xyz, -surfaceData.viewNormal);","}","#endif"].join("\n"),r=["#if MAX_TUBE_LIGHTS > 0 && !defined(DEBUG_SHADOW)","for (int i = 0; i < MAX_TUBE_LIGHTS; i++) {","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","vec4 lPosition = viewMatrix * vec4( tubeLightPosition[ i ], 1.0 );","float lRadius = tubeLightData[i].x;","float lWidth = tubeLightData[i].y;","vec3 lRight = (viewMatrix * vec4( tubeLightRight[i],0.0)).xyz;","vec3 P0 = lPosition.xyz - lRight * lWidth * 0.5;","vec3 P1 = lPosition.xyz + lRight * lWidth * 0.5;","vec3 E = tubeLightColor[i] * illuminanceTube(P0,P1,lPosition.xyz,-surfaceData.viewPosition.xyz,surfaceData.viewNormal,lRight,0.5*lWidth,lRadius);","vec3 closestPoint = closestPointTube(P0,P1,surfaceData.viewNormal,viewReflect,-surfaceData.viewPosition.xyz, lPosition.xyz,lRadius);","doAreaLightingModel(E, diffuse, specular, surfaceData.viewNormal, surfaceData.view, closestPoint);","#ifdef USE_SUBSURFACE","#ifdef THICKNESS_BASED_TRANSMITTANCE","vec3 tubeAttenuation = tubeLightColor[i] * illuminanceTube(P0,P1,lPosition.xyz,-surfaceData.viewPosition.xyz,-surfaceData.viewNormal,lRight,0.5*lWidth,lRadius)  * materialData.transmittanceColor;","totalTransmissive += tubeAttenuation * _TranslucencySpecularModel( surfaceData.viewNormal, closestPoint, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * tubeAttenuation * _TranslucencyDiffuseModel( surfaceData.viewNormal, closestPoint, surfaceData.view, materialData.translucencyColor);","#endif","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","totalTransmissive += materialData.translucency * tubeLightColor[i] * illuminanceTube(P0,P1,lPosition.xyz,-surfaceData.viewPosition.xyz,-surfaceData.viewNormal,lRight,0.5*lWidth,lRadius) * _TranslucencyDiffuseModel( surfaceData.viewNormal, closestPoint, surfaceData.view, materialData.translucencyColor);","#endif","totalDiffuse += diffuse;","totalSpecular += specular;","}","#endif"].join("\n"),n=function(e){return["vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ "+e+" ], 0.0 );","vec3 lVector = normalize( lDirection.xyz );","float shadowExposure = 1.0;","vec4 transparentExposure = vec4(1.0);","#ifdef USE_SHADOWMAP","#ifdef SHADOWMAP_CASCADE","0"===e?"shadowExposure = getExposureCascaded(vShadowCoord,shadowMap,shadowBias,shadowMapSize,transparentExposure);":"","#else","if("+e+"<SHADOWS_DIR_END){","shadowExposure = getExposureFromIndex("+e+");","#ifdef USE_TRANSPARENTSHADOWMAP","transparentExposure = getTransparentExposureFromIndex("+e+");","#endif","}","#endif","#endif","vec3 lightColor = directionalLightColor[ "+e+" ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColor = vec3(vMax(lightColor));","lightNormalizationFactor += lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));","#endif","#if defined(USE_SHADOWMAP) && defined(USE_TRANSPARENTSHADOWMAP)","vec3 lightColorNoIntensity = directionalLightColorNoIntensity[ "+e+" ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColorNoIntensity = vec3(vMax(lightColorNoIntensity));","#endif","vec3 E = doFullShadowApplication(lightColor,lightColorNoIntensity,shadowExposure,transparentExposure);","#else","vec3 E = doShadowApplication(lightColor,shadowExposure);","#endif","doLightingModel(E, diffuse, specular, surfaceData.viewNormal, surfaceData.view, lVector);","#ifdef USE_SUBSURFACE","bool doThicknessBasedTransmittance = true;","#ifdef MAP_TRANSMITTANCE","if ("+e+" < SHADOWS_DIR_END) {","vec3 dirAttenuation = lightColor *  multiSampleTransmittance(vShadowCoord[ "+e+" ], vec2(shadowMapNear["+e+"], shadowMapFar["+e+"]), shadowMapSize[ "+e+" ], shadowMap[ "+e+" ], true);","totalTransmissive += dirAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * dirAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","doThicknessBasedTransmittance = false;","}","#endif","#if defined(THICKNESS_BASED_TRANSMITTANCE)","if (doThicknessBasedTransmittance) {","vec3 dirAttenuation = lightColor *  materialData.transmittanceColor;","totalTransmissive += dirAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * dirAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","}","#endif","#else","#if defined(DSPBR_WITH_TRANSLUCENCY)","totalTransmissive += materialData.translucency * lightColor * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","#endif","totalDiffuse += diffuse ;","totalSpecular += specular;"].join("\n")},l=["#if MAX_DIR_LIGHTS > 0","{",n("0"),"}","if(MAX_DIR_LIGHTS>1){","for( int i = 1; i < MAX_DIR_LIGHTS; i ++ ) {",n("i"),"}","}","#endif"].join("\n"),s=["#if defined(USE_IBL_LIGHT) && !defined(DEBUG_SHADOW)","for( int i = 0; i < MAX_DIR_IBL_LIGHTS; i ++ ) {","if (directionalIBLLightColor[i].r < 1e-6) {","continue;","}","vec4 lWorldDirection = vec4( directionalIBLLightDirection[ i ], 0.0 );","vec4 lDirection = viewMatrix * lWorldDirection;","vec3 lVector = normalize( lDirection.xyz );","vec2 normalUV = getEnvMapUV(normalize(lWorldDirection.xyz));","#if defined(USE_ENVMAP_DIFFUSE) && !defined(USE_REFLECTION_PROBE)","float diffMip = 6.0;","#else","float diffMip = 5.0;","#endif","#ifdef USE_REFLECTION_PROBE","vec4 diffuseColor = texture2DBilinearFromRGBE(reflectionProbeMips, getUVFromMips(diffMip, normalUV, mipsTexelSize), mipsSize, mipsTexelSize);","#else","vec4 diffuseColor = texture2DBilinearFromRGBE(envMap2, getUVFromMips(diffMip, normalUV, mipsTexelSize), mipsSize, mipsTexelSize);","#endif","vec3 E = PI * diffuseColor.rgb * directionalIBLLightColor[i] * envMapExposureDiffuse;","if (i + SHADOWS_DIR_IBL_START < SHADOWS_DIR_IBL_END) {","vec3 dirAttenuation = multiSampleTransmittance(vShadowCoord[ i + SHADOWS_DIR_IBL_START], vec2(shadowMapNear[i+ SHADOWS_DIR_IBL_START], shadowMapFar[i+ SHADOWS_DIR_IBL_START]), shadowMapSize[ i+ SHADOWS_DIR_IBL_START ], shadowMap[ i+ SHADOWS_DIR_IBL_START], true);","totalTransmissive += dirAttenuation * E *  TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * dirAttenuation * E * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","}","}","#endif"].join("\n"),f=["#if MAX_POINT_LIGHTS > 0","for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","#ifdef PHONG_PER_PIXEL","vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz + surfaceData.viewPosition.xyz;","float lAttenuation = 1.0;","if (pointLightPhysicalAttenuation[ i ]> 0){","lAttenuation = 1.0 / (dot(lVector,lVector) * pointLightDistance[ i ]);","}else {","if ( pointLightDistance[ i ] > 0.0 )","lAttenuation = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","}","lVector = normalize( lVector );","#else","vec3 lVector = normalize( vPointLight[ i ].xyz );","float lAttenuation = vPointLight[ i ].w;","#endif","float shadowExposure = 1.0;","vec4 transparentExposure = vec4(1.0);","#ifdef USE_SHADOWMAP_CUBE","if (i<MAX_SHADOWS_CUBE){","shadowExposure = getExposureFromIndexCube(i);","#ifdef USE_TRANSPARENTSHADOWMAP","transparentExposure = getTransparentExposureFromIndexCube(i);","#endif","}","#endif","vec3 lightColor = pointLightColor[ i ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColor = vec3(vMax(lightColor));","lightNormalizationFactor += lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));","#endif","#if defined(USE_SHADOWMAP_CUBE) && defined(USE_TRANSPARENTSHADOWMAP)","vec3 lightColorNoIntensity = pointLightColorNoIntensity[ i ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColorNoIntensity = vec3(vMax(lightColorNoIntensity));","#endif","vec3 E = lAttenuation * doFullShadowApplication(lightColor,lightColorNoIntensity,shadowExposure,transparentExposure);","#else","vec3 E = lAttenuation * doShadowApplication(lightColor,shadowExposure);","#endif","doLightingModel(E, diffuse, specular, surfaceData.viewNormal, surfaceData.view, lVector);","#ifdef USE_SUBSURFACE","bool doThicknessBasedTransmittance = true;","#ifdef CUBE_TRANSMITTANCE","if (i < MAX_SHADOWS_CUBE) {","vec3 pointAttenuation = lAttenuation * lightColor * multiSampleCubeTransmittance(surfaceData.worldPosition, shadowPointPosition[i], vec2(shadowNearCube[i], shadowFarCube[i]), shadowMapSizeCube[i], shadowMapCube[i], false);","totalTransmissive += pointAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * pointAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","doThicknessBasedTransmittance = false;","}","#endif","#if defined(THICKNESS_BASED_TRANSMITTANCE)","if(doThicknessBasedTransmittance) {","vec3 pointAttenuation = lAttenuation * lightColor * materialData.transmittanceColor;","totalTransmissive += pointAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * pointAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","}","#endif","#else","#if defined(DSPBR_WITH_TRANSLUCENCY)","totalTransmissive +=  materialData.translucency * lAttenuation * lightColor * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","#endif","totalDiffuse += diffuse;","totalSpecular += specular;","}","#endif"].join("\n");t=["#ifdef USE_LIGHTING","vec3 totalDiffuse = vec3(0.0);","vec3 totalSpecular = vec3(0.0);","vec3 totalTransmissive = vec3(0.0);","#ifdef INVISIBLE_PLANE_MATERIAL","vec3 lightNormalizationFactor = vec3(0.0);","#endif",["#if MAX_SPOT_LIGHTS > 0","for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","#ifdef PHONG_PER_PIXEL","vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz + surfaceData.viewPosition.xyz;","float lAttenuation = 1.0;","if (spotLightPhysicalAttenuation[ i ]> 0){","lAttenuation =1.0 / (dot(lVector,lVector) * spotLightDistance[ i ]);","}else {","if ( spotLightDistance[ i ] > 0.0 )","lAttenuation = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );","}","lVector = normalize( lVector );","#else","vec3 lVector = normalize( vSpotLight[ i ].xyz );","float lAttenuation = vSpotLight[ i ].w;","#endif","float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - surfaceData.worldPosition ) );","if ( spotEffect > spotLightAngleCos[ i ] ) {","float shadowExposure = 1.0;","vec4 transparentExposure = vec4(1.0);","#ifdef USE_SHADOWMAP","if((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END){","shadowExposure = getExposureFromIndex(i + SHADOWS_SPOT_START);","#ifdef USE_TRANSPARENTSHADOWMAP","transparentExposure = getTransparentExposureFromIndex(i + SHADOWS_SPOT_START);","#endif","}","#endif","spotEffect = 1.0 - smoothstep( spotLightInnerAngleCos[ i ],spotLightAngleCos[ i ],spotEffect );","vec3 lightColor = spotLightColor[ i ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColor = vec3(vMax(lightColor));","lightNormalizationFactor += spotEffect * lAttenuation * lightColor * step(0.0, dot(surfaceData.viewNormal, lVector));","#endif","#if defined(USE_SHADOWMAP) && defined(USE_TRANSPARENTSHADOWMAP)","vec3 lightColorNoIntensity = spotLightColorNoIntensity[ i ];","#ifdef INVISIBLE_PLANE_MATERIAL","lightColorNoIntensity = vec3(vMax(lightColorNoIntensity));","#endif","vec3 E = spotEffect * lAttenuation * doFullShadowApplication(lightColor,lightColorNoIntensity,shadowExposure,transparentExposure);","#else","vec3 E = spotEffect * lAttenuation * doShadowApplication(lightColor,shadowExposure);","#endif","doLightingModel(E, diffuse, specular, surfaceData.viewNormal, surfaceData.view, lVector);","#ifdef USE_SUBSURFACE","bool doThicknessBasedTransmittance = true;","#ifdef MAP_TRANSMITTANCE","if ((i + SHADOWS_SPOT_START)<SHADOWS_SPOT_END) {","vec3 spotAttenuation = lightColor * lAttenuation * spotEffect *  multiSampleTransmittance(vShadowCoord[ i + SHADOWS_SPOT_START ], vec2(shadowMapNear[i + SHADOWS_SPOT_START], shadowMapFar[i + SHADOWS_SPOT_START]), shadowMapSize[ i + SHADOWS_SPOT_START ], shadowMap[ i + SHADOWS_SPOT_START], false);","totalTransmissive += spotAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * spotAttenuation *  TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","doThicknessBasedTransmittance = false;","}","#endif","#if defined(THICKNESS_BASED_TRANSMITTANCE)","if (doThicknessBasedTransmittance) {","vec3 spotAttenuation = lightColor * lAttenuation * spotEffect * materialData.transmittanceColor;","totalTransmissive += spotAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * spotAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","}","#endif","#else","#if defined(DSPBR_WITH_TRANSLUCENCY)","totalTransmissive += materialData.translucency * lightColor * lAttenuation * spotEffect *  TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","#endif","totalDiffuse += diffuse;","totalSpecular += specular;","}","}","#endif"].join("\n"),["#if MAX_IES_LIGHTS > 0 && !defined(DEBUG_SHADOW)","for ( int i = 0; i < MAX_IES_LIGHTS; i ++ ) {","vec3 diffuse  = vec3( 0.0 );","vec3 specular = vec3( 0.0 );","#ifdef PHONG_PER_PIXEL","vec4 lPosition = viewMatrix * vec4( iesLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz + surfaceData.viewPosition.xyz;","float lDistance = 1.0;","if ( iesLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / iesLightDistance[ i ] ), 1.0 );","lVector = normalize( lVector );","#else","vec3 lVector = normalize( viesLight[ i ].xyz );","float lDistance = viesLight[ i ].w;","#endif","vec3 E = iesLightColor[ i ] * lDistance * 3.14159;","vec4 coordInIESWorld = normalize(matrixWorldInv[i] * vec4(surfaceData.worldPosition,1.0));","float stepTexture = 1.0/128.0*72.0;","const float PI = 3.14159265359;","const float invTwoPi = 1.0/PI;","float phi = acos(-coordInIESWorld.z)/3.14159;","float theta = myAtan2(coordInIESWorld.x,-coordInIESWorld.y)*invTwoPi;","if(theta<0.0) theta *= -1.0;","E *= texture2D(iesLightTexture[i],vec2(phi,theta)).x;","doLightingModel(E, diffuse, specular, surfaceData.viewNormal, surfaceData.view, lVector);","#ifdef USE_SUBSURFACE","#ifdef THICKNESS_BASED_TRANSMITTANCE","vec3 iesAttenuation = E * materialData.transmittanceColor;","totalTransmissive += iesAttenuation * TranslucencySpecularModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.transparentColor);","#ifdef DSPBR_WITH_TRANSLUCENCY","totalTransmissive += materialData.translucency * iesAttenuation * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","totalTransmissive += materialData.translucency * E * TranslucencyDiffuseModel( surfaceData.viewNormal, lVector, surfaceData.view, materialData.translucencyColor);","#endif","totalDiffuse  += diffuse;","totalSpecular += specular;","}","#endif"].join("\n"),f,l,s,o,a,r,i,"#if defined(USE_LIGHTMAP) && defined(LIGHTMAP_IRRADIANCE_MODE)","totalDiffuse = vec3(0.0);","totalSpecular *= clamp(aoValue, 0.0, 1.0);","#endif","gl_FragColor.xyz = totalDiffuse + totalSpecular;","#endif","vec3 totalEmission = doEmission(NoV, surfaceData.view, emissionColorValue, emissionValue);"].join("\n")}else t=["vec3 totalDiffuse = vec3(0.0);","vec3 totalSpecular = vec3(0.0);","vec3 totalTransmissive = vec3(0.0);","vec3 totalEmission = vec3(0.0);"].join("\n");return t}(t),function(e){var t;if(e){var o=["vec3 specularIBLValue = vec3(0.0);","#ifdef PBR_FROM_GAS","vec2 mips = vec2(4.21, 0.21);","#else","vec2 mips = getMips(materialData.roughness);","#endif","vec4 cubeColor;","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_REFLECTION_PROBE","reflectVec = correctParallax(surfaceData.worldPosition, reflectVec);","#endif","#ifdef USE_FINITE_ENVMAP","reflectVec = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, reflectVec, surfaceData.worldPosition);","#endif","vec2 reflectionUV = getEnvMapUV(reflectVec);","#ifdef USE_REFLECTION_PROBE","cubeColor = envMapExposureSpecular * sampleMipMapRoughness( reflectionUV, mips.x, mips.y, reflectionProbe, reflectionProbeMips);","#else","cubeColor = envMapExposureSpecular * sampleMipMapRoughness( reflectionUV, mips.x, mips.y, envMap, envMap2);","#endif","#endif","#ifdef USE_NORMALMAP","float hOcclusion = computeHorizonFade(reflectVec, worldVertexNormal, materialData.roughness);","hOcclusion *= hOcclusion;","#else","float hOcclusion = 1.0;","#endif","vec4 preCompGGX = sampleBRDFTexture(NdotV, materialData.roughness, PRECOMPUTED_TEXTURE_1);","vec3 GFresnelVoH = materialData.sr0Color* unpackFrom16(preCompGGX.xy) + materialData.sr90Color * unpackFrom16(preCompGGX.zw);","specularIBLValue = cubeColor.xyz * GFresnelVoH;","#ifdef USE_SSLREFLECTION","vec4 ssrColor = texture2D(reflectionColorTexture, gl_FragCoord.xy * invScreenSize);","ssrColor.xyz *= GFresnelVoH;","specularIBLValue = mix(specularIBLValue, ssrColor.xyz, ssrColor.w);","#endif","specularIBLValue *= hOcclusion;","#if defined(USE_SSLREFRACTION)","if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {","#ifdef THIN_WALLED","vec3 refractVec = refract(cameraToVertex, surfaceData.worldNormal, 1.0);","#else","vec3 refractVec = refract(cameraToVertex, surfaceData.worldNormal, 1.0/materialData.adjustedIoR);","#endif","#ifdef USE_REFLECTION_PROBE","refractVec = correctParallax(surfaceData.worldPosition, refractVec);","#endif","#ifdef USE_FINITE_ENVMAP","refractVec = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, refractVec, surfaceData.worldPosition);","#endif","vec2 refractionUV = getEnvMapUV(refractVec);","#ifdef USE_REFLECTION_PROBE","vec4 cubeRefractColor = envMapExposureSpecular * sampleMipMapRoughness( refractionUV, mips.x, mips.y, reflectionProbe, reflectionProbeMips);","#else","vec4 cubeRefractColor = envMapExposureSpecular * sampleMipMapRoughness( refractionUV, mips.x, mips.y, envMap, envMap2);","#endif","float GRefract = unpackFrom16(sampleBRDFTexture(-NdotV,  materialData.roughness, PRECOMPUTED_TEXTURE_3).xy);","vec4 ssrefractionColor = texture2D(refractionColorTexture, gl_FragCoord.xy * invScreenSize);","cubeRefractColor.xyz = mix(cubeRefractColor.xyz, ssrefractionColor.xyz, ssrefractionColor.w);","#ifdef DSPBR","float fTransRefraction = 1.0 - materialData.specularContribution * vMax(FresnelSchlick(materialData.specularBlendingSR0, vec3(1.0), NdotV));","#else","float fTransRefraction = 1.0 - vMax(FresnelSchlick(materialData.sr0Color, materialData.sr90Color, NdotV));","#endif","cubeRefractColor.xyz *= GRefract * materialData.transparentColor * fTransRefraction;","#ifdef USE_SUBSURFACE","#ifdef THICKNESS_BASED_TRANSMITTANCE","cubeRefractColor.xyz *= materialData.transmittanceColor;","#elif defined(USE_SSSLUT)","cubeRefractColor.xyz *= GetTransmittance(vMax(maxTranslucencyDepth)/ 15.0);","#else","cubeRefractColor.xyz *= GetTransmittance(1.0 / vMax(absorptionCoefficients));","#endif","#endif","specularIBLValue += cubeRefractColor.xyz;","}","#endif","vec3 diffuseIBLValue = vec3(0.0);","vec4 diffuseTexelColor = vec4(0.0);","vec3 diffuseInvIBLValue = vec3(0.0);","#if defined( USE_LATLONGMAP )","vec2 normalUV = getEnvMapUV(normalize(surfaceData.worldNormal));","#if defined(USE_ENVMAP_DIFFUSE) && !defined(USE_REFLECTION_PROBE)","float diffMip = 6.0;","#else","float diffMip = 5.0;","#endif","vec4 diffUVBox;","#ifdef NON_REPEAT_IBL_SAMPLING","diffUVBox.xy = getUVFromMips(diffMip, normalUV, mipsTexelSize);","#else","diffUVBox = getUVBoxFromMips(diffMip, mipsTexelSize);","#endif","#ifdef USE_REFLECTION_PROBE","diffuseTexelColor = envMapExposureDiffuse * texture2DBilinearFromRGBEwBox(reflectionProbeMips, diffUVBox, normalUV, mipsSize, mipsTexelSize);","#else","diffuseTexelColor = envMapExposureDiffuse * texture2DBilinearFromRGBEwBox(envMap2, diffUVBox, normalUV, mipsSize, mipsTexelSize);","#endif","#ifdef DSPBR","specularIBLValue += diffuseTexelColor.rgb * materialData.specularEnergyConservationConstant;","diffuseTexelColor *= materialData.diffuseEnergyConservationConstant;","#else","diffuseTexelColor *= SpecGlossEnergyConservationTerm(GFresnelVoH);","#endif","diffuseIBLValue = materialData.diffuseColor * diffuseTexelColor.xyz  ;","#if defined(DSPBR_WITH_TRANSLUCENCY) && (!defined(USE_SUBSURFACE) || defined(THICKNESS_BASED_TRANSMITTANCE))","if (materialData.translucency > 1e-6) {","vec2 normalInvUV = getEnvMapUV(normalize(-surfaceData.worldNormal));","#ifdef USE_REFLECTION_PROBE","vec4 diffuseInvTexelColor = envMapExposureDiffuse * texture2DBilinearFromRGBEwBox(reflectionProbeMips, diffUVBox, normalInvUV, mipsSize, mipsTexelSize);","#else","vec4 diffuseInvTexelColor = envMapExposureDiffuse * texture2DBilinearFromRGBEwBox(envMap2, diffUVBox, normalInvUV, mipsSize, mipsTexelSize);","#endif","diffuseInvIBLValue = materialData.translucencyColor * diffuseInvTexelColor.rgb * materialData.diffuseEnergyConservationConstant;","}","#endif","#endif"].join("\n"),a=["#if defined(USE_SHEEN) && defined(USE_ENVMAP_SHEEN)","vec3 sheenIBLValue = vec3(0.0);","#ifdef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","float sheenRough_IBL = materialData.sheenRoughness;","#ifdef DSPBR_WITH_SQUARED_ESTEVEZKULLA_ROUGHNESS","sheenRough_IBL *= sheenRough_IBL;","#endif","#else","float sheenRough_IBL = materialData.sheen;","#endif","#if defined(USE_SATIN)","sheenRough_IBL = 0.3;","#endif","#if defined(USE_VELVET) || defined(USE_SOFT_VELVET)","vec2 mipsF = getMipsLinearInverted(sheenRough_IBL);","#if defined(USE_VELVET)","float GFab = unpackFrom16(sampleBRDFTexture(NdotV, sheenRough_IBL, PRECOMPUTED_TEXTURE_2).zw);","#else","float GFab = unpackFrom16(sampleBRDFTexture(NdotV, sheenRough_IBL, PRECOMPUTED_TEXTURE_3).zw);","#endif","#else","vec2 mipsF = getMipsLinear(sheenRough_IBL);","float GFab = unpackFrom16(sampleBRDFTexture(NdotV, sheenRough_IBL, PRECOMPUTED_TEXTURE_2).xy);","#endif","vec4 sheenColor = sampleMipMapRoughnessSheen( reflectionUV, mipsF.x, mipsF.y, envMapSheen);","sheenIBLValue = GFab * sheenColor.rgb;","#ifndef DSPBR_WITH_SHEEN_COLOR_ROUGHNESS","float sheenBlending = 1.0 - pow5(1.0-materialData.sheen);","diffuseIBLValue *= PI * sheenBlending * sheenIBLValue.rgb + (1.0 - sheenBlending);","#else","float sheenBlending = 1.0 - materialData.sheenEnergyConservationConstant;","diffuseIBLValue *= sheenBlending;","specularIBLValue *= sheenBlending;","specularIBLValue +=  materialData.sheen * materialData.sheenColor * sheenIBLValue.rgb;","#endif","#endif"].join("\n"),i=["#ifdef CLEAR_COAT","vec3 clearCoatIBLValue = vec3(0.0);","float NdotVcoating = dot(surfaceData.clearCoatNormal, surfaceData.view);","vec3 reflectVecCoating = reflect( cameraToVertex, surfaceData.clearCoatWorldNormal );","vec2 mipsC = getMips(materialData.clearCoatRoughness);","vec4 cubeColorcoating;","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_REFLECTION_PROBE","reflectVecCoating = correctParallax(surfaceData.worldPosition, reflectVecCoating);","#endif","#ifdef USE_FINITE_ENVMAP","reflectVecCoating = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, reflectVecCoating, surfaceData.worldPosition);","#endif","vec2 reflectionUVcoating = getEnvMapUV(reflectVecCoating);","#ifdef USE_REFLECTION_PROBE","cubeColorcoating = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVcoating, mipsC.x, mipsC.y, reflectionProbe, reflectionProbeMips);","#else","cubeColorcoating = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVcoating, mipsC.x, mipsC.y, envMap, envMap2);","#endif","#endif","#ifdef CLEAR_COAT_NORMALMAP","float chOcclusion = computeHorizonFade(reflectVecCoating, worldVertexNormal, materialData.clearCoatRoughness);","chOcclusion *= chOcclusion;","#else","float chOcclusion = 1.0;","#endif","vec4 precompCoat = sampleBRDFTexture(NdotVcoating, materialData.clearCoatRoughness, PRECOMPUTED_TEXTURE_1);","vec3 GFresnelVoHCoat = unpackFrom16(precompCoat.xy) * materialData.clearCoatSR0Color + unpackFrom16(precompCoat.zw) * materialData.clearCoatSR90Color;","clearCoatIBLValue = cubeColorcoating.xyz * GFresnelVoHCoat;","#ifdef DSPBR","float energyCoating = 1.0 - materialData.clearCoat* vMax(FresnelSchlick(materialData.clearCoatSR0Color,materialData.clearCoatSR90Color,saturate(NdotVcoating)));","#else","float energyCoating = SpecGlossEnergyConservationTerm(GFresnelVoHCoat);","#endif","specularIBLValue.xyz *= energyCoating;","diffuseIBLValue.xyz *= energyCoating;","specularIBLValue.xyz += clearCoatIBLValue * materialData.clearCoat * chOcclusion;","#endif"].join("\n");t=["#ifndef DEBUG_SHADOW","#if defined(USE_ENVMAP) && defined(USE_LIGHTING)","vec3 cameraToVertex;","if (projectionMatrix[3][3] > 0.5) {","cameraToVertex = normalize( vec3( vec4( 0.0,0.0,-1.0, 0.0 ) * viewMatrix ) );","} else {","cameraToVertex = normalize( surfaceData.worldPosition - cameraPosition );","}","vec3 worldVertexNormal = normalize( vec3( vec4( vertexNormal, 0.0 ) * viewMatrix ) );","float NdotV = dot(surfaceData.viewNormal, surfaceData.view);","#ifdef USE_ANISOTROPY","vec3 bitangent = normalize(vec3(vec4(sin(2.0 * PI * materialData.anisotropyAngle) * surfaceData.tangent + cos(2.0 * PI * materialData.anisotropyAngle) * surfaceData.binormal, 0.0) * viewMatrix));","vec3 anisotropicTangent = cross(bitangent, -cameraToVertex);","vec3 anisotropicNormal = cross(anisotropicTangent, bitangent);","vec3 bentNormal = normalize(mix(surfaceData.worldNormal, anisotropicNormal, 0.22*materialData.anisotropy));","vec3 reflectVec = reflect( cameraToVertex, bentNormal );","#else","vec3 reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );","#endif",o,"#ifdef USE_ANISOTROPY","reflectVec = reflect( cameraToVertex, surfaceData.worldNormal );","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_REFLECTION_PROBE","reflectVec = correctParallax(surfaceData.worldPosition, reflectVec);","#endif","#ifdef USE_FINITE_ENVMAP","reflectVec = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, reflectVec, surfaceData.worldPosition);","#endif","reflectionUV = getEnvMapUV(reflectVec);","#endif","#endif",["#ifdef USE_SUBSURFACE","#ifdef SPECGLOSS","diffuseIBLValue.rgb *= materialData.scatteringColor;","#else","vec3 baseDiffuseIBLValue = diffuseIBLValue.rgb;","#ifdef DSPBR_WITH_TRANSLUCENCY","diffuseIBLValue.rgb = mix(diffuseIBLValue.rgb, materialData.scatteringColor * baseDiffuseIBLValue, materialData.translucency);","#ifdef THICKNESS_BASED_TRANSMITTANCE","diffuseIBLValue.rgb = mix(diffuseIBLValue.rgb,  materialData.transmittanceColor * diffuseInvIBLValue.rgb, materialData.translucency);","#endif","#endif","diffuseIBLValue.rgb = mix(diffuseIBLValue.rgb, materialData.scatteringColor * baseDiffuseIBLValue, materialData.transparency);","#endif","#elif defined(DSPBR_WITH_TRANSLUCENCY)","diffuseIBLValue.rgb = mix(diffuseIBLValue.rgb, diffuseInvIBLValue.rgb, materialData.translucency);","#endif"].join("\n"),a,[["#if defined(USE_DSPBR_FLAKES)","vec2 mipsDSPBRFlakes = getMips(flakesData.flakesRoughness);","vec3 flakesIBLValue = vec3(0.0);","if (flakesData.smoothWeight > 0.0) {","vec2 reflectionUVSmoothFlakes = reflectionUV;","#ifdef USE_REFLECTION_PROBE","vec4 cubeColorSmoothFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVSmoothFlakes, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, reflectionProbe, reflectionProbeMips);","#else","vec4 cubeColorSmoothFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVSmoothFlakes, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, envMap, envMap2);","#endif","float GSmoothFlakes = unpackFrom16(sampleBRDFTexture(NdotV, flakesData.flakesRoughness, PRECOMPUTED_TEXTURE_3).xy);","flakesIBLValue += cubeColorSmoothFlakes.xyz * GSmoothFlakes * flakesData.smoothFlakesColor;","}","if (flakesData.stochasticWeight > 0.0) {","vec3 worldReflStoFlakes = normalize( vec3( vec4( flakesData.stochasticHemisphereFlakesReflect, 0.0 ) * viewMatrix ) );","vec3 stoNormal = flakesData.stochasticHemisphereFlakesNormal;","float NdotVSto = dot(stoNormal, surfaceData.view);","#ifdef USE_REFLECTION_PROBE","worldReflStoFlakes = correctParallax(surfaceData.worldPosition, worldReflStoFlakes);","#endif","#ifdef USE_FINITE_ENVMAP","worldReflStoFlakes = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, worldReflStoFlakes, surfaceData.worldPosition);","#endif","float GStoFlakes = unpackFrom16(sampleBRDFTexture(NdotVSto, flakesData.flakesRoughness, PRECOMPUTED_TEXTURE_3).xy);","vec2 stoFlakesEnvMapUV = getEnvMapUV(worldReflStoFlakes);","#ifdef USE_REFLECTION_PROBE","vec4 stoFlakesTexelColor = envMapExposureSpecular * sampleMipMapRoughness( stoFlakesEnvMapUV, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, reflectionProbe, reflectionProbeMips);","#else","vec4 stoFlakesTexelColor = envMapExposureSpecular * sampleMipMapRoughness( stoFlakesEnvMapUV, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, envMap, envMap2);","#endif","flakesIBLValue += flakesData.stochasticHemisphereFlakesColor * stoFlakesTexelColor.xyz * GStoFlakes;","}","if (flakesData.closeupWeight > 0.0) {","vec3 worldReflCloseFlakes = normalize( vec3( vec4( flakesData.closeupFlakesReflect, 0.0 ) * viewMatrix ) );","vec3 closeNormal = flakesData.closeupFlakesNormal;","float NdotVClose = dot(closeNormal, surfaceData.view);","#ifdef USE_REFLECTION_PROBE","worldReflCloseFlakes = correctParallax(surfaceData.worldPosition, worldReflCloseFlakes);","#endif","float GCloseFlakes = unpackFrom16(sampleBRDFTexture(NdotVClose, flakesData.flakesRoughness, PRECOMPUTED_TEXTURE_3).xy);","#ifdef USE_FINITE_ENVMAP","worldReflCloseFlakes = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, worldReflCloseFlakes, surfaceData.worldPosition);","#endif","vec2 closeFlakesEnvMapUV = getEnvMapUV(worldReflCloseFlakes);","#ifdef USE_REFLECTION_PROBE","vec4 closeFlakesTexelColor = envMapExposureSpecular * sampleMipMapRoughness( closeFlakesEnvMapUV, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, reflectionProbe, reflectionProbeMips);","#else","vec4 closeFlakesTexelColor = envMapExposureSpecular * sampleMipMapRoughness( closeFlakesEnvMapUV, mipsDSPBRFlakes.x, mipsDSPBRFlakes.y, envMap, envMap2);","#endif","flakesIBLValue += flakesData.closeupFlakesColor * closeFlakesTexelColor.xyz * GCloseFlakes;","}","diffuseIBLValue *= flakesData.baseWeight;","specularIBLValue *= flakesData.baseWeight;","specularIBLValue += flakesIBLValue;","#endif"].join("\n"),["#if defined(USE_SPECGLOSS_FLAKES)","float NdotVMetalFlakes = dot(metalFlakes.flakesNormal, surfaceData.view);","vec3 reflectVecMetalFlakes = reflect( cameraToVertex, metalFlakes.flakesWorldNormal );","float NdotRMetalFlakes = max(dot(metalFlakes.flakesWorldNormal, reflectVecMetalFlakes), 0.0);","float NdotVMetal = NdotV;","vec2 mipsMetalFlakes = getMips(metalFlakes.flakesRoughness);","vec2 mipsMetal = getMips(metal.flakesRoughness);","vec4 cubeColorMetal;","vec4 cubeColorMetalFlakes;","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_REFLECTION_PROBE","reflectVecMetalFlakes = correctParallax(surfaceData.worldPosition, reflectVecMetallicFlakes);","#endif","#ifdef USE_FINITE_ENVMAP","reflectVecMetalFlakes = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, reflectVecMetalFlakes, surfaceData.worldPosition);","#endif","vec2 reflectionUVMetalFlakes = getEnvMapUV(reflectVecMetalFlakes);","vec2 reflectionUVMetal = reflectionUV;","#ifdef USE_REFLECTION_PROBE","cubeColorMetalFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVMetalFlakes, mipsMetalFlakes.x, mipsMetalFlakes.y, reflectionProbe, reflectionProbeMips);","cubeColorMetal = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVMetal, mipsMetal.x, mipsMetal.y, reflectionProbe, reflectionProbeMips);","#else","cubeColorMetalFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVMetalFlakes, mipsMetalFlakes.x, mipsMetalFlakes.y, envMap, envMap2);","cubeColorMetal = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVMetal, mipsMetal.x, mipsMetal.y, envMap, envMap2);","#endif","#endif","float mFhOcclusion = computeHorizonFade(reflectVecMetalFlakes, worldVertexNormal, metalFlakes.flakesRoughness);","mFhOcclusion *= mFhOcclusion;","vec3 metalFlakesIBLValue = vec3(0.0);","vec3 metalIBLValue = vec3(0.0);","vec4 precompMetalFlakes = sampleBRDFTexture(NdotVMetalFlakes, metalFlakes.flakesRoughness, PRECOMPUTED_TEXTURE_1);","vec4 precompMetal = sampleBRDFTexture(NdotVMetal, metal.flakesRoughness, PRECOMPUTED_TEXTURE_1);","vec3 GFresnelVoHMetalFlakes = unpackFrom16(precompMetalFlakes.xy) * metalFlakes.flakesSR0Color ;","vec3 GFresnelVoHMetal = unpackFrom16(precompMetal.xy) * metal.flakesSR0Color ;","metalFlakesIBLValue = cubeColorMetalFlakes.xyz * GFresnelVoHMetalFlakes;","metalIBLValue = cubeColorMetal.xyz * GFresnelVoHMetal;","float energyMetalFlakes = SpecGlossEnergyConservationTerm(GFresnelVoHMetalFlakes);","diffuseIBLValue *= energyMetalFlakes;","specularIBLValue *= energyMetalFlakes;","specularIBLValue += mFhOcclusion*metalFlakesIBLValue;","float energyMetal = SpecGlossEnergyConservationTerm(GFresnelVoHMetal);","diffuseIBLValue *= energyMetal;","specularIBLValue *= energyMetal;","specularIBLValue += hOcclusion*metalIBLValue;","#endif"].join("\n"),["#if defined(USE_SPECGLOSS_FLAKES) && defined(PEARL_FLAKES_ACTIVATED)","float NdotVPearlFlakes = dot(pearlFlakes.flakesNormal, surfaceData.view);","vec3 reflectVecPearlFlakes = reflect( cameraToVertex, pearlFlakes.flakesWorldNormal );","vec2 mipsPearl = getMips(pearlFlakes.flakesRoughness);","vec4 cubeColorPearlFlakes;","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_REFLECTION_PROBE","reflectVecPearlFlakes = correctParallax(surfaceData.worldPosition, reflectVecPearlFlakes);","#endif","#ifdef USE_FINITE_ENVMAP","reflectVecPearlFlakes = correctParallaxFinite(sphereCenter, projectionCenter, sphereRadius, reflectVecPearlFlakes, surfaceData.worldPosition);","#endif","vec2 reflectionUVPearlFlakes = getEnvMapUV(reflectVecPearlFlakes);","#ifdef USE_REFLECTION_PROBE","cubeColorPearlFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVPearlFlakes, mipsPearl.x, mipsPearl.y, reflectionProbe, reflectionProbeMips);","#else","cubeColorPearlFlakes = envMapExposureSpecular * sampleMipMapRoughness( reflectionUVPearlFlakes, mipsPearl.x, mipsPearl.y, envMap, envMap2);","#endif","#endif","float pFhOcclusion = computeHorizonFade(reflectVecPearlFlakes, worldVertexNormal, pearlFlakes.flakesRoughness);","pFhOcclusion *= pFhOcclusion;","vec3 pearlFlakesIBLValue = vec3(0.0);","vec4 precompPearlFlakes = sampleBRDFTexture(NdotVPearlFlakes, pearlFlakes.flakesRoughness, PRECOMPUTED_TEXTURE_1);","vec3 GFresnelVoHPearlFlakes = unpackFrom16(precompPearlFlakes.xy) * pearlFlakes.flakesSR0Color ;","pearlFlakesIBLValue = cubeColorPearlFlakes.xyz * GFresnelVoHPearlFlakes;","float energyPearlFlakes = SpecGlossEnergyConservationTerm(GFresnelVoHPearlFlakes);","diffuseIBLValue *= energyPearlFlakes;","specularIBLValue *= energyPearlFlakes;","specularIBLValue += pFhOcclusion*pearlFlakesIBLValue;","#endif"].join("\n")].join("\n"),i,"#ifdef INVISIBLE_PLANE_MATERIAL","diffuseIBLValue = vec3(vMax(diffuseIBLValue));","lightNormalizationFactor += diffuseIBLValue;","#endif","vec3 totalIBLValue = specularIBLValue + diffuseIBLValue;","#ifdef USE_LIGHTMAP","#ifdef LIGHTMAP_IRRADIANCE_MODE","totalIBLValue *= clamp(aoValue, 0.0, 1.0);","#else","totalIBLValue *= aoValue;","#endif","#endif","gl_FragColor.xyz += totalIBLValue;","#ifdef INVISIBLE_PLANE_MATERIAL","if (length(lightNormalizationFactor) < 1e-6) {","gl_FragColor.xyz = vec3(1.0);","} else {","gl_FragColor.xyz /= lightNormalizationFactor;","}","#endif","#elif !defined(USE_LIGHTING)","#ifdef USE_LIGHTMAP","gl_FragColor.xyz = aoValue * albedo;","#else","gl_FragColor.xyz = albedo;","#endif","#ifdef USE_SUBSURFACE","gl_FragColor.xyz *= materialData.scatteringColor;","#endif","#ifdef INVISIBLE_PLANE_MATERIAL","gl_FragColor.xyz = vec3(1.0);","#endif","#else","vec3 ambientTerm = ambientLightColor;","#ifdef INVISIBLE_PLANE_MATERIAL","ambientTerm = vec3(vMax(ambientTerm));","lightNormalizationFactor += ambientTerm;","#endif","vec3 ambientColor = albedo;","#ifdef USE_SUBSURFACE","ambientColor *= materialData.scatteringColor;","#endif","vec3 specularColor = vec3(0.0);","#if defined(USE_SSLREFLECTION) || defined(USE_SSLREFRACTION)","float NdotV = dot(surfaceData.viewNormal, surfaceData.view);","#endif","#ifdef USE_SSLREFLECTION","vec4 preCompGGX = sampleBRDFTexture(NdotV, materialData.roughness, PRECOMPUTED_TEXTURE_1);","vec3 GFresnelVoH = materialData.sr0Color* unpackFrom16(preCompGGX.xy) + materialData.sr90Color * unpackFrom16(preCompGGX.zw);","vec4 ssrColor = texture2D(reflectionColorTexture, gl_FragCoord.xy * invScreenSize);","ssrColor.xyz *= GFresnelVoH;","specularColor += ssrColor.w * ssrColor.xyz;","#endif","#if defined(USE_SSLREFRACTION)","if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {","float GRefract = unpackFrom16(sampleBRDFTexture(-NdotV,  materialData.roughness, PRECOMPUTED_TEXTURE_3).xy);","vec4 ssrefractionColor = texture2D(refractionColorTexture, gl_FragCoord.xy * invScreenSize);","ssrefractionColor.xyz *= GRefract * materialData.transparentColor * (1.0 - materialData.specularContribution * vMax(FresnelSchlick(materialData.specularBlendingSR0, vec3(1.0), NdotV)));","specularColor += ssrefractionColor.w * ssrefractionColor.xyz;","}","#endif","#ifdef USE_LIGHTMAP","#ifdef LIGHTMAP_IRRADIANCE_MODE","gl_FragColor.xyz +=  aoValue * ambientColor;","#else","gl_FragColor.xyz +=  aoValue * ambientColor  * ambientTerm;","#endif","#else","gl_FragColor.xyz += ambientColor * ambientTerm;","#endif","gl_FragColor.xyz += specularColor;","#ifdef INVISIBLE_PLANE_MATERIAL","if (length(lightNormalizationFactor) < 1e-6) {","gl_FragColor.xyz = vec3(1.0);","} else {","gl_FragColor.xyz /= lightNormalizationFactor;","}","#endif","#endif","#endif"].join("\n")}else t=["#ifdef USE_LIGHTMAP","gl_FragColor.xyz = aoValue * albedo;","#else","gl_FragColor.xyz = albedo;","#endif"].join("\n");return t}(t),N,e.ShaderChunk.postprocess_fragment,e.ShaderChunk.linear_to_gamma_fragment,e.ShaderChunk.PDSFX_end_fragment,e.ShaderChunk.fog_fragment,e.ShaderChunk.backgroundviewmode_lowlight_fragment,e.DeferredShaderChunk._debug_common_face_fragment,e.DeferredShaderChunk.oit_fragment,!t&&W?e.DeferredShaderChunk.picking_fragment:"",!t&&W?e.DeferredShaderChunk.picking_instancing_fragment:"",!t&&W?e.DeferredShaderChunk.depth_fragment_face:"",!t&&W?e.DeferredShaderChunk.normal_fragment:"",!t&&W?e.DeferredShaderChunk.normal_depth_fragment:"",!t&&W?e.DeferredShaderChunk.shadowmap_fragment:"",!t&&W?e.DeferredShaderChunk.highlight_fragment_face:"",!t&&W?e.DeferredShaderChunk.texcoord_fragment:"","}"].join("\n")};return{uniforms:e.UniformsUtils.merge([e.UniformsLib.common,e.UniformsLib.bump,e.UniformsLib.normalmap,e.UniformsLib.lights,e.UniformsLib.shadowmap,e.UniformsLib.clipPlanes,e.UniformsLib.postprocess,W?e.UniformsLib.deferred:{},X]),vertexShader:Z(!0),vertexShaderNoLight:Z(!1),fragmentShader:Y(!0),fragmentShaderNoLight:Y(!1)}});var toto=function(){return null};define("DS/Shaders/BokehDOFShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{textureWidth:{type:"f",value:512},textureHeight:{type:"f",value:512},focalDepth:{type:"f",value:1},focalLength:{type:"f",value:64},fstop:{type:"f",value:.9},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},sensorSize:{type:"f",value:24},sceneScale:{type:"f",value:1},maxCoC:{type:"f",value:1},tDiffuse:{type:"t",value:null},tNormalDepth:{type:"t",value:null},maxblur:{type:"f",value:5},showFocus:{type:"i",value:0},manualdof:{type:"i",value:0},threshold:{type:"f",value:.5},gain:{type:"f",value:2},bias:{type:"f",value:.5},fringe:{type:"f",value:.7},noise:{type:"i",value:1},dithering:{type:"f",value:1e-4},shaderFocus:{type:"i",value:0},focusCoords:{type:"v2",value:new e.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform mat4 realProjectionMatrixInverse;","uniform sampler2D tDiffuse;","uniform sampler2D tNormalDepth;","uniform float textureWidth;","uniform float textureHeight;","const float PI = 3.14159265;","uniform float focalDepth;  ","uniform float focalLength; ","uniform float fstop; ","uniform float sensorSize;","uniform float sceneScale;","uniform float maxCoC;","uniform bool showFocus; ","const int samples = SAMPLES; ","const int rings = RINGS; ","const int maxringsamples = rings * samples;","uniform bool manualdof; ","float ndofstart = 1.0; ","float ndofdist = 2.0; ","float fdofstart = 1.0; ","float fdofdist = 3.0; ","float CoC = 0.03; ","uniform bool shaderFocus;","uniform vec2 focusCoords;","uniform float maxblur;","uniform float threshold; ","uniform float gain; ","uniform float bias; ","uniform float fringe; ","uniform bool noise; ","uniform float dithering;","float getZ(vec2 coords){","vec4 normalDepth = texture2D( tNormalDepth, coords );","float z = normalDepth.w;","#if DOF_BEHAVIOUR == 3","if ( z == 0.0 ) return 0.0;","#else","if ( z == 0.0 ) z=1.0;","#endif","return z;","}","float getDepth(vec2 coords, float z ) {","vec2 xy = coords * 2.0 - 1.0;","vec4 vertexPositionProjected = vec4( xy, 2.0 * z - 1.0, 1.0 );","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","vertexPositionVS.w = 1.0;","return -vertexPositionVS.z*sceneScale;","}","vec3 color(vec2 coords, float blur) {","vec3 col = texture2D(tDiffuse, coords).rgb;","return col;","}","vec2 rand(vec2 coord) {","float noiseX = ((fract(1.0-coord.s*(textureWidth/2.0))*0.25)+(fract(coord.t*(textureHeight/2.0))*0.75))*2.0-1.0;","float noiseY = ((fract(1.0-coord.s*(textureWidth/2.0))*0.75)+(fract(coord.t*(textureHeight/2.0))*0.25))*2.0-1.0;","if (noise) {","noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;","noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;","}","return vec2(noiseX, noiseY);","}","vec3 debugFocus(vec3 col, float blur, float depth) {","float edge = 0.002*depth; ","float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);","float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);","col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);","col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);","return col;","}","float getMaximumPhysicalBlurSize(){","float effectiveAperture = focalLength/fstop;","float magnification = clamp(focalLength/(focalDepth-focalLength),0.0,1.0);","return effectiveAperture*magnification;","}","float getPhysicalBlurSize(float depth){","if(depth>=focalDepth){","float maxBlur = getMaximumPhysicalBlurSize();","float distToFocus = abs(depth-focalDepth);","float focusRatio = distToFocus/depth;","return maxBlur*focusRatio;","}else if(depth>=focalLength){","float currFocal = depth*focalLength/(depth-focalLength);","float focusFocal = focalDepth*focalLength/(focalDepth-focalLength);","float distToFocus = abs(currFocal-focusFocal);","float focusRatio = distToFocus/currFocal;","return focalLength/fstop * focusRatio;","}else {","return focalLength/fstop;","}","}","float getScreenRadius(float physicalRadius){","float sensorToScreenSizeRatio = float(textureHeight)/sensorSize;","return sensorToScreenSizeRatio*physicalRadius;","}","float getOffsetLength(float i){","return i;","}","vec2 getOffsetedUV(vec2 uv,float length,float j,float w,float h,float steps){","float pw = cos(j*steps)*length;","float ph = sin(j*steps)*length;","vec2 res_uv =uv + vec2(pw*w, ph*h);","res_uv.x = floor(0.5+(res_uv.x*textureWidth))/float(textureWidth);","res_uv.y = floor(0.5+(res_uv.y*textureHeight))/float(textureHeight);","return res_uv;","}","float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {","float rings2 = float(rings);","float step = PI*2.0 / float(ringsamples);","float pw = cos(j*step)*i;","float ph = sin(j*step)*i;","float weight = mix(1.0, i/rings2, bias);","col += color(vUv.xy + vec2(pw*w, ph*h), blur) * weight;","return weight;","}","void main() {","float pixelZ = getZ(vUv.xy);","float depth = getDepth(vUv.xy,pixelZ);","float fDepth = focalDepth;","vec4 colAlpha = texture2D(tDiffuse, vUv.xy);","vec3 col = colAlpha.rgb;","#if DOF_BEHAVIOUR==3","float blur = 0.0;","if (manualdof) {","float a = depth - fDepth;","float b = (a - fdofstart) / fdofdist;","float c = (- a - ndofstart) / ndofdist;","blur = (a > 0.0) ? b : c;","} else {","float f = focalLength;","float d = fDepth;","float o = depth;","float a = (o * f) / (o - f);","float b = (d * f) / (d - f);","float c = (d - f) / (d * fstop * CoC);","blur = abs(a - b) * c;","}","blur = clamp(blur, 0.0, 1.0);","vec2 noise = rand(vUv.xy) * dithering * blur;","float w = (1.0 / textureWidth) * blur * maxblur + noise.x;","float h = (1.0 / textureHeight) * blur * maxblur + noise.y;","#else","float sensorBlurRadius = getPhysicalBlurSize(depth)/2.0;","float blurRadius = min(getScreenRadius(sensorBlurRadius),maxCoC*float(textureHeight));","vec2 noise = rand(vUv.xy) * dithering;","float hBlur = blurRadius/float(textureWidth)+noise.x;","float vBlur = blurRadius/float(textureHeight)+noise.y;","float maxSensorBlurRadius = getMaximumPhysicalBlurSize()/2.0;","float maxBlurRadius =  min(getScreenRadius(maxSensorBlurRadius),maxCoC*float(textureHeight));","float maxHBlur = maxBlurRadius/float(textureWidth)+noise.x;","float maxVBlur = maxBlurRadius/float(textureHeight)+noise.y;","#endif","float s = 1.0;","int ringsamples;","float rings2 = float(rings);","#if DOF_BEHAVIOUR==3","for (int i = 1; i <= rings; i++) {","ringsamples = i * samples;","for (int j = 0 ; j < maxringsamples ; j++) {","if (j >= ringsamples) break;","s += gather(float(i), float(j), ringsamples, col, w, h, blur);","}","}","#else","for (int i = 1; i <= rings; i++) {","ringsamples = i * samples;","float iRatio = float(i)/float(rings);","float dist =iRatio*maxBlurRadius;","for (int j = 0 ; j < maxringsamples ; j++) {","if (j >= ringsamples) break;","float weight = mix(1.0, iRatio, bias);","float step = PI*2.0 / float(ringsamples);","#if PHYSIC == 1","vec2 uv = getOffsetedUV(vUv.xy,getOffsetLength(iRatio),float(j),hBlur,vBlur,step);","float sampleZ=getZ(uv);","float takeSample = (sampleZ>=pixelZ)?1.0:0.0;","col += takeSample*texture2D(tDiffuse, uv).rgb * weight;","s+= takeSample*weight;","#else","vec2 uvMax = getOffsetedUV(vUv.xy,getOffsetLength(iRatio),float(j),maxHBlur,maxVBlur,step);","float sampleZMax=getZ(uvMax);","float currentDepth = getDepth(uvMax.xy,sampleZMax);","float currentsensorBlurRadius = getPhysicalBlurSize(currentDepth)/2.0;","float currentblurRadius = getScreenRadius(currentsensorBlurRadius);","if(currentblurRadius>=dist){","float takeSample = 1.0;","col += takeSample*texture2D(tDiffuse, uvMax).rgb * weight;","s+= takeSample*weight;","}","#endif","}","}","#endif","col /= s;","gl_FragColor.rgb = col;","gl_FragColor.a = colAlpha.a;","} "].join("\n")}}),define("Shaders/BokehDOFShader",["DS/Shaders/BokehDOFShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/BokehDOFShader"),e}),define("DS/Shaders/DisplayPassShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},tDiffuse4:{type:"t",value:null},offset:{type:"v2",value:new e.Vector2(.505,.01)},scale:{type:"f",value:.485},offset2:{type:"v2",value:new e.Vector2(.01,.01)},scale2:{type:"f",value:.485},offset3:{type:"v2",value:new e.Vector2(.505,.505)},scale3:{type:"f",value:.485},offset4:{type:"v2",value:new e.Vector2(.01,.505)},scale4:{type:"f",value:.485}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","uniform sampler2D tDiffuse3;","uniform sampler2D tDiffuse4;","uniform vec2 offset;","uniform float scale;","uniform vec2 offset2;","uniform float scale2;","uniform vec2 offset3;","uniform float scale3;","uniform vec2 offset4;","uniform float scale4;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv2 = (vUv - offset) / scale;","vec2 vUv3 = (vUv - offset2) / scale2;","vec2 vUv4 = (vUv - offset3) / scale3;","vec2 vUv5 = (vUv - offset4) / scale4;","if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    gl_FragColor = vec4(texture2D( tDiffuse2, vUv2 ).xyz, 1.0); return;","} else if (vUv3.x > 0.0 && vUv3.y > 0.0 && vUv3.x < 1.0 && vUv3.y < 1.0) {","    gl_FragColor = vec4(texture2D( tDiffuse3, vUv3 ).xyz, 1.0); return;","} else if (vUv4.x > 0.0 && vUv4.y > 0.0 && vUv4.x < 1.0 && vUv4.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse4, vUv4 );","    gl_FragColor = vec4(vec3(normalDepth.w), 1.0); return;","} else if (vUv5.x > 0.0 && vUv5.y > 0.0 && vUv5.x < 1.0 && vUv5.y < 1.0) {","    vec4 normalDepth = texture2D( tDiffuse4, vUv5 );","    gl_FragColor = vec4(normalDepth.xyz, 1.0); return;","}","}"].join("\n")}}),define("Shaders/DisplayPassShader",["DS/Shaders/DisplayPassShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/DisplayPassShader"),e}),define("DS/Shaders/ConvertLatLongToDualParaboloidShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=function(t,o){var a={defines:{SCALE:1.2},uniforms:{map:{type:"t",value:null},size:{type:"v2",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D map;","uniform vec2 size;","varying vec2 vUv;","const float PI = 3.14159265358979323846264;","float atan2(float y, float x) {","if (x > 0.0) return sign(y) * atan(abs(y/x));","else if (x < 0.0) return sign(y) * (PI - atan(abs(y/x)));","return 0.5 * PI * sign(y);","}",e._DefaultShaderChunk.rgbe_sample_methods,"void main() {","gl_FragColor = vec4(0.0);","vec2 uv = vec2(fract(2.0 * vUv.x), vUv.y);","float phi = atan2(2.0 * uv.y - 1.0, 2.0 * uv.x - 1.0);","float theta;","float u;","if (vUv.x < 0.5) {","theta = 2.0 * atan(cos(phi) / (SCALE * (2.0 * uv.x - 1.0)));","u = fract(0.5*phi / PI);","} else {","theta = 2.0 * atan(SCALE * (1.0 - 2.0 * uv.x) / cos(phi));","phi += 1.0*PI;","u = fract(0.5*phi / PI);","}","float v = abs(theta / PI);"].join("\n")};return a.fragmentShader=t?[a.fragmentShader,"gl_FragColor = texture2DBilinearFromRGBE(map, vec2(u, v), size, vec2(1.0)/size);",o?"gl_FragColor.xyz *= gl_FragColor.xyz;":"","}"].join("\n"):[a.fragmentShader,"gl_FragColor = texture2D(map, vec2(u, v));",o?"gl_FragColor.xyz *= gl_FragColor.xyz;":"","}"].join("\n"),a};return{ConvertLatLongRGBEToDualParaboloid:t(!0,!1),ConvertLatLongRGBEToDualParaboloidsRGB:t(!0,!0),ConvertLatLongToDualParaboloid:t(!1,!1),ConvertLatLongToDualParaboloidsRGB:t(!1,!0)}}),define("DS/Shaders/AdaptativeBlurShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=["vec3 decodeOct22Normal(in vec2 iEncodedNormal) {","float x = iEncodedNormal.x/2047.0*2.0 - 1.0;","float y = iEncodedNormal.y/2047.0*2.0 - 1.0;","vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));","if (v.z <= 0.0) {","vec2 sgn = signNotZero(v.xy);","v.xy = - abs(v.yx)*sgn + sgn;","}","return normalize(v);","}","vec4 getNormalDepth(in vec2 uv) {","vec4 normalDepth = texture2D( tNormalDepth, uv );","#ifndef RENDER_TO_FLOAT_TEXTURE","return vec4(decodeOct22Normal(normalDepth.xy), (normalDepth.z * 4096.0 + normalDepth.w) / 8388608.0);","#else","return vec4(normalDepth.xyz * 2.0 - 1.0, normalDepth.w);","#endif","}"].join("\n"),o={defines:{NB_SAMPLES:1,STEP:"1.5"},uniforms:{tDiffuse:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","float result = 0.0;","float total = 0.0;","for (int i = -NB_SAMPLES; i <= NB_SAMPLES; ++i) {","for (int j = -NB_SAMPLES; j <= NB_SAMPLES; ++j) {","vec2 offset = STEP * invSize * vec2(float(i), float(j));","float weight = 1.0 / (1.0 + dot(offset, offset));","result += weight * texture2D(tDiffuse, vUv + offset).x;","total += weight;","}","}","result /= total;","gl_FragColor = vec4(vec3(result), 1.0);","}"].join("\n")};return{H:{defines:{NB_SAMPLES:4,STEP:1.5},uniforms:{tDiffuse:{type:"t",value:null},tNormalDepth:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","uniform sampler2D tNormalDepth;","varying vec2 vUv;",t,"void main() {","vec2 screenPos = vUv;","vec4 normalDepth = getNormalDepth(vUv);","float depth = normalDepth.w;","vec3 normal = normalDepth.xyz;","float result = texture2D(tDiffuse, vUv).x;","float total = 1.0;","for (int i = -NB_SAMPLES; i <= NB_SAMPLES; ++i) {","if (i != 0) {","vec2 pos = vUv + STEP * vec2(invSize.x * float(i), 0.0);","vec4 normalDepth2 = getNormalDepth(pos);","float depth2 = normalDepth2.w;","vec3 normal2 = normalDepth2.xyz;","float weightDepth = 1.0 / (1.0 + 100.0*abs(depth2 - depth));","float weightNormal = clamp(dot(normal, normal2), 0.0, 1.0);","result += weightDepth * weightNormal * texture2D(tDiffuse, pos).x;","total += weightDepth * weightNormal;","}","}","result /= total;","gl_FragColor = vec4(vec3(result), 1.0);","}"].join("\n")},V:{defines:{NB_SAMPLES:4,STEP:1.5},uniforms:{tDiffuse:{type:"t",value:null},tNormalDepth:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform vec2 invSize;","uniform sampler2D tDiffuse;","uniform sampler2D tNormalDepth;",t,"varying vec2 vUv;","void main() {","vec2 screenPos = vUv;","vec4 normalDepth = getNormalDepth( vUv);","float depth = normalDepth.w;","vec3 normal = normalDepth.xyz;","float result = texture2D(tDiffuse, vUv).x;","float total = 1.0;","for (int i = -NB_SAMPLES; i <= NB_SAMPLES; ++i) {","if (i != 0) {","vec2 pos = vUv + STEP * vec2(0.0, invSize.y * float(i));","vec4 normalDepth2 = getNormalDepth(pos );","float depth2 = normalDepth2.w;","vec3 normal2 = normalDepth2.xyz;","float weightDepth = 1.0 / (1.0 + 100.0*abs(depth2 - depth));","float weightNormal = clamp(dot(normal, normal2), 0.0, 1.0);","result += weightDepth * weightNormal * texture2D(tDiffuse, pos).x;","total += weightDepth * weightNormal;","}","}","result /= total;","gl_FragColor = vec4(vec3(result), 1.0);","}"].join("\n")},HV:o}}),define("Shaders/AdaptativeBlurShader",["DS/Shaders/AdaptativeBlurShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/AdaptativeBlurShader"),e}),define("DS/Shaders/TAAShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{TAA:{defines:{FEEDBACK_MIN:.88,FEEDBACK_MAX:.97},uniforms:{screenSize:{type:"v2",value:new e.Vector2(512,512)},tNormalDepth:{type:"t",value:null},tDiffuse:{type:"t",value:null},prevMap:{type:"t",value:null},numIteration:{type:"f",value:0},previousViewProjectionMatrix:{type:"m4",value:new e.Matrix4},currentViewProjectionMatrix:{type:"m4",value:new e.Matrix4},currentProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},currentViewMatrixInverse:{type:"m4",value:new e.Matrix4}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#define NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y) if(d < dmin.z) dmin = vec3(x, y, d);","#define NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y) d = texture2D(tNormalDepth, uv + vec2(x,y)).w; if (d < 0.1) d = 1.0;","#define FIND_NEIGHBOUR_MIN(d, x, y) NEIGHBOUR_CREATE_FROM_OFFSET(d, x, y); NEIGHBOUR_SET_IF_DMIN_Z_GREATER(d, x, y)","#define CLOSEST_9TAP","uniform vec2 screenSize;","uniform sampler2D tNormalDepth;","uniform sampler2D tDiffuse;","uniform sampler2D prevMap;","uniform float numIteration;","uniform mat4 previousViewProjectionMatrix;","uniform mat4 currentViewProjectionMatrix;","uniform mat4 currentProjectionMatrixInverse;","uniform mat4 currentViewMatrixInverse;","varying vec2 vUv;","float luminance_RGB(vec3 iColor) {","   vec3 luminance_weight = vec3(0.176204, 0.812985, 0.0108109);","   return dot(iColor, luminance_weight);","}","vec3 getPositionWS(vec3 ndc) {","   vec4 vertexPositionProjected = vec4(ndc, 1.0);","   vec4 vertexPositionVS = currentProjectionMatrixInverse * vertexPositionProjected;","   vertexPositionVS.xyz /= vertexPositionVS.w;","   vertexPositionVS.w = 1.0;","   return (currentViewMatrixInverse * vertexPositionVS).xyz;","}","vec3 closestFragment(vec2 uv, vec2 texelSize) {","    float d;","    vec2 size = 2.0 * texelSize;","    vec3 dmin = vec3(0.0, 0.0, 0.0);","    NEIGHBOUR_CREATE_FROM_OFFSET(dmin.z, 0.0, 0.0);","    FIND_NEIGHBOUR_MIN(d, -size.x, size.y);","    FIND_NEIGHBOUR_MIN(d, size.x, size.y);","    FIND_NEIGHBOUR_MIN(d, -size.x, -size.y);","    FIND_NEIGHBOUR_MIN(d, size.x, -size.y);","    #ifdef CLOSEST_9TAP","        FIND_NEIGHBOUR_MIN(d, 0.0, size.y);","        FIND_NEIGHBOUR_MIN(d, -size.x, 0.0);","        FIND_NEIGHBOUR_MIN(d, size.x, 0.0);","        FIND_NEIGHBOUR_MIN(d, 0.0, -size.y);","    #endif","    return vec3(uv + dmin.xy, dmin.z);","}","vec4 clip_aabb_opti(const in vec4 minimum, const in vec4 maximum, const in vec4 color) {","    const float eps = 0.00000001;","    vec4 center = 0.5 * (maximum + minimum);","    vec4 extents = 0.5 * (maximum - minimum) + eps;","    vec4 offset = color - center;","    vec4 ts = abs(offset / extents);","    float t = max(max(ts.r, ts.g), max(ts.b, ts.a));","    return center + offset / max(1.0, t);","}","vec4 taa(const in vec2 ssVel, const in vec2 texelSize) {","    vec4 tl = texture2D(tDiffuse, vUv + vec2(-texelSize.x, texelSize.y));","    vec4 t  = texture2D(tDiffuse, vUv + vec2(0.0, texelSize.y));","    vec4 tr = texture2D(tDiffuse, vUv + vec2(texelSize.x, texelSize.y));","    vec4 ml = texture2D(tDiffuse, vUv + vec2(-texelSize.x, 0.0));","    vec4 m  = texture2D(tDiffuse, vUv);","    vec4 mr = texture2D(tDiffuse, vUv + vec2(texelSize.x, 0.0));","    vec4 bl = texture2D(tDiffuse, vUv + vec2(-texelSize.x, -texelSize.y));","    vec4 b  = texture2D(tDiffuse, vUv + vec2(0.0, -texelSize.y));","    vec4 br = texture2D(tDiffuse, vUv + vec2(texelSize.x, -texelSize.y));","    vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * m;","    m += (m - (corners * 0.166667)) * 2.718282 * 0.3;","    m = max(vec4(0.0), m);","    vec4 cmin5 = min(mr, min(m, min(ml, min(t, b))));","    vec4 cmin = min(cmin5, min(tl, min(tr, min(bl, br))));","    vec4 cmax5 = max(mr, max(m, max(ml, max(t, b))));","    vec4 cmax = max(cmax5, max(tl, max(tr, max(bl, br))));","    cmin = 0.5 * (cmin + cmin5);","    cmax = 0.5 * (cmax + cmax5);","    vec4 previousColor = texture2D(prevMap, vUv - ssVel);","    previousColor = clip_aabb_opti(cmin, cmax, previousColor);","    float lum0 = luminance_RGB(m.rgb);","    float lum1 = luminance_RGB(previousColor.rgb);","    float diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));","    float unbiased_weight = 1.0 - diff;","    float feedback = mix(FEEDBACK_MIN, FEEDBACK_MAX, unbiased_weight * unbiased_weight);","    return mix(m, previousColor, feedback);","}","vec2 computeSSVelocity(const in vec3 wsPos) {","    vec4 ssCurrentPos = currentViewProjectionMatrix * vec4(wsPos, 1.0);","    vec4 ssPrevPos =   previousViewProjectionMatrix * vec4(wsPos, 1.0);","    vec2 ndcCurrent = ssCurrentPos.xy / ssCurrentPos.w;","    vec2 ndcPrev = ssPrevPos.xy / ssPrevPos.w;","    if(ndcPrev.x >= 1.0 || ndcPrev.x <= -1.0 || ndcPrev.x >= 1.0 || ndcPrev.y <= -1.0) {","        return vec2(0.0);","    }","    return 0.5 * (ndcCurrent - ndcPrev);","}","void main() {","if (numIteration > 0.0) {","   vec4 prevColor = texture2D( prevMap, vUv );","   vec4 currColor = texture2D( tDiffuse, vUv );","   gl_FragColor = vec4((prevColor * numIteration + currColor) / (numIteration + 1.0));","   return;","}","vec2 texelSize = vec2(1.0) / screenSize;","vec3 closest = closestFragment(vUv, texelSize);","if (closest.z == 0.0) {","   gl_FragColor = texture2D( tDiffuse, vUv );","   return;","}","vec3 ws = getPositionWS(2.0 * closest - 1.0);","vec2 ssVel = computeSSVelocity(ws);","gl_FragColor = taa(ssVel, texelSize);","}"].join("\n")},Transfer:{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","gl_FragColor = texture2D( tDiffuse2, vUv );","}"].join("\n")}}}),define("DS/Shaders/CompareModelsShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{defines:{POSTPRO:1,MODE:0},uniforms:{tDiffuse:{type:"t",value:null},tCommonColor:{type:"t",value:null},tDepthOld:{type:"t",value:null},tDepthNew:{type:"t",value:null},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},tolerance:{type:"f",value:1e-4}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#if (POSTPRO == 1)","uniform sampler2D tDiffuse;","#endif","uniform sampler2D tCommonColor;","uniform sampler2D tDepthOld;","uniform sampler2D tDepthNew;","uniform mat4 realProjectionMatrixInverse;","uniform float tolerance;","varying vec2 vUv;","float getLinearDepth(vec2 iUV, float iDepth) {","vec2 xy = iUV * 2.0 - 1.0;","vec4 posProjected = vec4(xy, 2.0 * iDepth - 1.0, 1.0);","vec4 posVS = realProjectionMatrixInverse * posProjected;","return posVS.z / posVS.w;","}","void main() {","vec4 _common = texture2D(tCommonColor, vUv);","float depthOld = unpackRGBA(texture2D(tDepthOld, vUv));","float depthNew = unpackRGBA(texture2D(tDepthNew, vUv));","#if (MODE == 1)","float isDifferent = step(depthOld*depthNew, 0.0) - step(abs(depthOld) + abs(depthNew), 0.0);","#else","float diff = abs(getLinearDepth(vUv, depthOld) - getLinearDepth(vUv, depthNew));","float isDifferent = step(tolerance, diff);","#endif","#if (POSTPRO == 1)","vec4 color = texture2D(tDiffuse, vUv);","gl_FragColor = mix(vec4(mix(color.rgb, _common.rgb, _common.a), color.a), color, isDifferent);","#else","gl_FragColor = vec4(_common.rgb, _common.a * (1.0 - isDifferent));","#endif","}"].join("\n")}}),define("Shaders/CompareModelsShader",["DS/Shaders/CompareModelsShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/CompareModelsShader"),e}),define("DS/Shaders/CATCrDImageTextureShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(t,o){t.force=!0,t.useLighting=!1,t.activatePDSFX(),t.transparent=!0,t.side=e.DoubleSide;var a=["vec4 commonFinalColor;"].join("\n");t.setPDSFXGlobalShaderCode("",a);var i={CrD_Image_UniformColor:{type:"v4",value:o.Color},CrD_Image_UniformOpacity:{type:"f",value:o.Opacity},RefImage2DMap:{type:"t2",value:o.RefImage2DMap.map}};t.setPDSFXUniforms(i);t.setPDSFXVaryings({vTexCoord:{type:"v3"}});var r={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},n={ComputeCommonValues:["void ComputeCommonValues() {","commonFinalColor = texture2D(RefImage2DMap, vTexCoord.xy);","commonFinalColor.a = commonFinalColor.a * CrD_Image_UniformOpacity;","commonFinalColor.a = clamp(commonFinalColor.a, 0.0, 1.0);","float rangeMin = 0.03;","float rangeMax = 0.97;","float factor = 0.0;","if(CrD_Image_UniformColor.a > 0.0)","{","if (vTexCoord.x < rangeMin) {","if (vTexCoord.y < rangeMin && vTexCoord.x > vTexCoord.y) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax && vTexCoord.y > vTexCoord.x * ((rangeMax - 1.0) / rangeMin) + 1.0) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","else {","factor = 1.0 - (vTexCoord.x / rangeMin);","}","}","else if (vTexCoord.x > rangeMax) {","if (vTexCoord.y < rangeMin && vTexCoord.y < (rangeMin / (1.0 - rangeMax)) * (1.0 - vTexCoord.x)) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax && vTexCoord.x < vTexCoord.y) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","else {","factor = (vTexCoord.x - rangeMax) / (1.0 - rangeMax);","}","}","else if (vTexCoord.y < rangeMin) {","factor = 1.0 - (vTexCoord.y / rangeMin);","}","else if (vTexCoord.y > rangeMax) {","factor = (vTexCoord.y - rangeMax) / (1.0 - rangeMax);","}","if ((commonFinalColor.a < 10e-3) && factor > 0.0) {","commonFinalColor = vec4(1.0, 1.0, 1.0, 1.0);","factor = (factor * 0.6) + 0.4;","}","commonFinalColor = mix(commonFinalColor, CrD_Image_UniformColor, factor);","}","if (commonFinalColor.a < 10e-3) {","discard;","}","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return t.setPDSFXOverridableFunctions(r,n),t.needsUpdate=!0,t}}),define("DS/Shaders/ExtractIBLLightShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),o={map:{type:"t",value:null},size:{type:"v2",value:null}},a=function(a){return{defines:{},uniforms:o,vertexShader:t,fragmentShader:["uniform sampler2D map;","uniform vec2 size;","varying vec2 vUv;",e._DefaultShaderChunk.rgbe_sample_methods,"void main() {",a?"gl_FragColor.xyz = texture2DBilinearFromRGBE(map, vUv, size, vec2(1.0)/size).xyz;":"gl_FragColor.xyz = texture2D(map, vUv).xyz;","gl_FragColor.a = dot(gl_FragColor.xyz, vec3(0.299, 0.587, 0.114));","}"].join("\n")}};return{ExtractIBLIntensityShaderRGBE:a(!0),ExtractIBLIntensityShader:a(!1)}}),define("DS/Shaders/EncodeHDRShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{map:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D map;","varying vec2 vUv;","void main() {","vec3 color = texture2D(map, vUv).rgb;","float value = max(color.r, max(color.g, color.b));","int exponent = 0;","float mantissa = 0.0;","if (value > 1.0) {","for (int i = 1; i <= 127; i++) {","value /= 2.0;","exponent++;","if (value < 1.0) { break; }","}","} else if (value < 1.0) {","int j = 1;","for (int i = 1; i <= 129; i++) {","value *= 2.0;","exponent--;","if (value > 1.0) { j = 0; break; }","}","value /= 2.0;","exponent++;","if (j > 0) {","color = vec3(0.0);","exponent = 0;","}","}","gl_FragColor = vec4(color * pow(2.0, float(-exponent)), float(exponent + 128) / 255.0);","}"].join("\n")}}),define("Shaders/EncodeHDRShader",["DS/Shaders/EncodeHDRShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/EncodeHDRShader"),e}),define("DS/Shaders/FlareShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{FinalBlending:{uniforms:{tDiffuse:{type:"t",value:null},tBlur:{type:"t",value:null},tLensColor:{type:"t",value:null},tLensDirt:{type:"t",value:null},invSize:{type:"v2",value:new e.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tBlur;","uniform sampler2D tLensColor;","uniform sampler2D tLensDirt;","uniform vec2 invSize;","const float ghostDispersal = 0.25;","const int ghosts = 8;","const float distortion = 5.0;","const float haloWidth = 1.0;","const float one_over_sqrt2 = 0.70710678;","varying vec2 vUv;","vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion) {","   return vec4(","      texture2D(tex, texcoord + direction * distortion.r).r,","      texture2D(tex, texcoord + direction * distortion.g).g,","      texture2D(tex, texcoord + direction * distortion.b).b,","      1.0","   );","}","void main() {","   vec4 color = texture2D( tDiffuse, vUv );","   vec2 flippedUV = vec2(1.0) - vUv;","   vec2 uvToCenter = vec2(0.5) - flippedUV;","   vec3 distort = vec3(-invSize.x * distortion, 0.0, invSize.x * distortion);","   vec2 ghostVec = uvToCenter * ghostDispersal;","   vec4 flare = vec4(0.0);","   for (int i = 0; i < ghosts; ++i) {","      vec2 offset = fract(flippedUV + ghostVec * float(i));","      float ghostHeight = length(vec2(0.5) - offset) / one_over_sqrt2;","      ghostHeight = pow(1.0 - ghostHeight, 10.0);","      flare += textureDistorted(tBlur, offset, normalize(ghostVec), distort) * ghostHeight;","   }","   flare *= texture2D(tLensColor, vec2(length(uvToCenter) / one_over_sqrt2, 0.5));","   float dirt = texture2D( tLensDirt, vUv ).r;","   flare *= vec4(0.5) + dirt;","   gl_FragColor = vec4(color.rgb + flare.rgb, color.a);","}"].join("\n")}}}),define("Shaders/FlareShaders",["DS/Shaders/FlareShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/FlareShaders"),e}),define("DS/Shaders/MSAAShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{Blending:{uniforms:{tDiffuse:{type:"t",value:null},prevMap:{type:"t",value:null},numIteration:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D prevMap;","uniform float numIteration;","varying vec2 vUv;","void main() {","vec4 prevColor = texture2D( prevMap, vUv );","vec4 currColor = texture2D( tDiffuse, vUv );","gl_FragColor = vec4((prevColor * numIteration + currColor) / (numIteration + 1.0));","}"].join("\n")},Transfer:{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","gl_FragColor = texture2D( tDiffuse2, vUv );","}"].join("\n")}}}),define("DS/Shaders/SSLRBlendShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","  vec4 color  = texture2D(  tDiffuse, vUv );","  vec4 color2 = texture2D( tDiffuse2, vUv );","  gl_FragColor = vec4((1.0 - color2.a) * color.xyz + color2.a * color2.xyz, color.a);","}"].join("\n")}}),define("Shaders/SSLRBlendShader",["DS/Shaders/SSLRBlendShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/SSLRBlendShader"),e}),define("DS/Shaders/LowLightShaders",[],function(){"use strict";return{backgroundviewmode_lowlight_fragment:"\n\t\t\t#ifdef USE_BACKGROUNDVIEWMODE_LOWLIGHT\n\t\t\t\tif(background_view_mode_control.w > 0.0)\n\t\t\t\t{\n\t\t\t\t\tgl_FragColor.xyz *= 0.55;\n\t\t\t\t}\n\t\t\t#endif\n\t\t"}}),define("DS/Shaders/ResizeShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{Resize:{uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","gl_FragColor = texture2D( tDiffuse, vUv );","}"].join("\n")}}}),define("ShadersDebug/ResizeShaders",["DS/Shaders/ResizeShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("ShadersDebug/ResizeShaders"),e}),define("DS/Shaders/AdvancedHighlightShader",["DS/Visualization/ThreeJS_R57"],function(e){"use strict";var t=["#if HIGHLIGHT_POLITE == 1","#ifdef NOZ_OBJECT","const int noZ = 1;","#else","const int noZ = 0;","#endif","const float highlightBack = 0.66;","const float highlightFront = 0.33;","float depthSampleTest(in vec2 coord, in float depth) {","float fDepth = unpackRGBA(texture2D(rgbaDepth, coord));","if ( fDepth  < depth) return highlightBack;","return highlightFront;","}","float getDepthTestResult(float depth) {","vec2 coord = 0.5 + 0.5*cP.xy/cP.w;","return depthSampleTest(coord, depth - 2.38418579e-7);","}","float getFaceDepthValue() {","if (noZ == 1) {","return highlightFront;","}","float depth = 0.5 + 0.5*cP.z/cP.w ;","float faceDepth = depth;","#if defined(GL_OES_standard_derivatives) || defined(GLSL300ES)","float dx = dFdx (depth);","float dy = dFdy (depth);","#if defined(MOBILE_HIGHLIGHT_MODE) && !defined(MOBILE_DEVICE_MODE)","faceDepth += 0.5 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);","#else","faceDepth += 0.9 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);","#endif","#else","faceDepth += 1.5*DEPTH_PRECISION;","#endif","return getDepthTestResult(faceDepth);","}","float getDepthValue() {","if (noZ == 1) {","return highlightFront;","}","float depth = 0.5 + 0.5*cP.z/cP.w ;","return getDepthTestResult(depth);","}","#endif"].join("\n"),o="true"===localStorage.getItem("__1x3HL__"),a={uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},rgbaDepth:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)},highlightID:{type:"f",value:1}}]),vertexShaderPars:["varying vec3 vMVNormal;","varying vec3 vMVPosition;","uniform float highlightID;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#if HIGHLIGHT_POLITE == 1","varying vec4 cP;","#endif"].join("\n"),vertexShaderBody:["    vMVNormal = mvNormal;","    vMVPosition = -mvPosition.xyz;","#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif","#if HIGHLIGHT_POLITE == 1","cP = gl_Position;","#endif"].join("\n"),fragmentShaderPars:["varying vec3 vMVNormal;","varying vec3 vMVPosition;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#if HIGHLIGHT_POLITE == 1","uniform sampler2D rgbaDepth;","varying vec4 cP;","#endif",t,"uniform float highlightID;"].join("\n"),fragmentShaderBody:["#ifdef USE_MAP_ALPHATEST","   float alpha = texture2D( map, vUvMap ).w;","   if ( alpha < ALPHATEST ) discard;","#endif","vec3 I = vec3(0.0, 0.0, 1.0);","    if (!(projectionMatrix[3][3] > 0.0)) {","       I = normalize( vMVPosition.xyz );","    }","float reflectionFactor = abs(dot(normalize(vMVNormal),I));","#if HIGHLIGHT_POLITE == 1","float depthValue = getFaceDepthValue();","reflectionFactor = noZ == 1 ? 0.8 : depthValue < 0.5 ? (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141 : reflectionFactor;","gl_FragColor = vec4( highlightID / 255.0, reflectionFactor, depthValue , 0.0 );","#else","reflectionFactor = 1.0 - reflectionFactor;","  gl_FragColor = vec4( highlightID / 255.0, reflectionFactor * reflectionFactor, 0.0, 0.0 );","#endif"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"#ifndef PDSFX","varying vec3 vMVNormal;","varying vec3 vMVPosition;","#endif","uniform float highlightID;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","#if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)","varying vec4 cP;","#endif","void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,"#ifdef PDSFX","transformedNormal = _viewTangentSpace.Normal;","#else","vMVNormal = transformedNormal;","vMVPosition = -mvPosition.xyz;","#endif","#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif","    gl_Position = projectionMatrix * mvPosition;",e.ShaderChunk.clip_vertex,"#if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)","cP = gl_Position;","#endif",e.ShaderChunk.PDSFX_end_vertex,"#ifdef PDSFX_USE_MAP","vUv = uv;","#endif","}"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"#ifndef PDSFX","varying vec3 vMVNormal;","varying vec3 vMVPosition;","#endif","uniform float highlightID;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","#if HIGHLIGHT_POLITE == 1","uniform sampler2D rgbaDepth;","#ifndef PDSFX","varying vec4 cP;","#else","vec4 cP;","#endif","#endif",t,"void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,e.ShaderChunk.PDSFX_viewNormal_fragment,"vec3 mvPosition = ComputeViewPosition();","vec3 I = vec3(0.0, 0.0, 1.0);","    if (!(projectionMatrix[3][3] > 0.0)) {","       I = normalize( -mvPosition.xyz );","    }","float reflectionFactor = abs( dot( I, _DSvNormal ) );","#if HIGHLIGHT_POLITE == 1","cP = _DSclipPosition;","#endif","#else","vec3 I = vec3(0.0, 0.0, 1.0);","if (!(projectionMatrix[3][3] > 0.0)) {","I = normalize( vMVPosition.xyz );","}","float reflectionFactor = abs(dot(normalize(vMVNormal), I));","#endif",e.ShaderChunk.clip_fragment,"#ifdef USE_MAP_ALPHATEST","   float alpha = texture2D( map, vUvMap ).w;","   if ( alpha < ALPHATEST ) discard;","#endif","#if HIGHLIGHT_POLITE == 1","float depthValue = getFaceDepthValue();","reflectionFactor = noZ == 1 ? 0.8 : depthValue < 0.5 ? (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141 : reflectionFactor;","gl_FragColor = vec4( highlightID / 255.0, reflectionFactor, depthValue , 0.0 );","#else","reflectionFactor = 1.0 - reflectionFactor;","  gl_FragColor = vec4( highlightID / 255.0, reflectionFactor * reflectionFactor , 0.0, 0.0 );","#endif","}"].join("\n")},i={tAdd:{type:"t",value:null},tDiffuse:{type:"t",value:null},empty:{type:"i",value:0},h:{type:"f",value:1/1024},v:{type:"f",value:1/1024},poisson:{type:"fv1",value:[]},iHaloColors:{type:"fv",value:[]},iLineicHaloColors:{type:"fv",value:[]},iHaloIntensities:{type:"fv1",value:[]},iColors:{type:"fv",value:[]},iColorIntensities:{type:"fv2",value:[]},iOutlineColors:{type:"fv",value:[]},iLineicOutlineColors:{type:"fv",value:[]},iOutlineAlphas:{type:"fv1",value:[]},iOutlineThicknesses:{type:"fv1",value:[]}},r={POSTPRO:1,NB_CONFIG:0,HALO_THICKNESS:2,HAS_POLITE:0,QA_AUTOMATION:0},n=["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),l=["#if (POSTPRO == 1)","uniform sampler2D tDiffuse;","#endif","uniform sampler2D tAdd;","uniform float h;","uniform float v;","uniform float poisson[24];","uniform float iHaloIntensities[NB_CONFIG];","uniform vec3 iHaloColors[NB_CONFIG];","uniform vec3 iLineicHaloColors[NB_CONFIG];","uniform vec3 iOutlineColors[NB_CONFIG];","uniform vec3 iLineicOutlineColors[NB_CONFIG];","uniform float iOutlineAlphas[NB_CONFIG];","uniform float iOutlineThicknesses[NB_CONFIG];","uniform vec3 iColors[NB_CONFIG];","uniform vec2 iColorIntensities[NB_CONFIG];","uniform int empty;","varying vec2 vUv;","struct highlightConfig {","bool colorEnabled;","vec3 color;","vec2 colorIntensity;","bool outlineEnabled;","vec3 outlineColor;","vec3 lineicOutlineColor;","float outlineAlpha;","float outlineThickness;","};","highlightConfig emptyConfig;","const float outlineCheck = 8.0;","int GetID(in float texR) {","return int(floor(255.0 * texR + 0.5));","}"].join("\n"),s=["highlightConfig GetHighlightConfig(in float texR) {","return GetHighlightConfig(GetID(texR));","}","float CheckIfOutlines(in vec4 center, in highlightConfig config) {","int curID = GetID(center.r);","float tx = config.outlineThickness * h;","float ty = config.outlineThickness * v;","int northWest1 = GetID(texture2D( tAdd, vec2( vUv.x - tx, vUv.y + ty)).r);","int north1     = GetID(texture2D( tAdd, vec2( vUv.x     , vUv.y + ty)).r);","int northEast1 = GetID(texture2D( tAdd, vec2( vUv.x + tx, vUv.y + ty)).r);","int west1      = GetID(texture2D( tAdd, vec2( vUv.x - tx, vUv.y)).r);","int east1      = GetID(texture2D( tAdd, vec2( vUv.x + tx, vUv.y)).r);","int southWest1 = GetID(texture2D( tAdd, vec2( vUv.x - tx, vUv.y - ty)).r);","int south1     = GetID(texture2D( tAdd, vec2( vUv.x     , vUv.y - ty)).r);","int southEast1 = GetID(texture2D( tAdd, vec2( vUv.x + tx, vUv.y - ty)).r);","float r1 = dot(vec4(curID == northWest1 ? 1.0 : 0.0,curID == north1 ? 1.0 : 0.0, curID == northEast1 ? 1.0 : 0.0, curID == west1 ? 1.0 : 0.0), vec4(1.0));","float r2 = dot(vec4(curID == east1 ? 1.0 : 0.0, curID == southWest1 ? 1.0 : 0.0, curID == south1 ? 1.0 : 0.0, curID == southEast1 ? 1.0 : 0.0), vec4(1.0));","return (r1+r2);","}"," vec4 ComputeHaloColor() {","vec4 haloColor = vec4(0.0);","float count = 0.0;","float tx = float(HALO_THICKNESS) * h;","float ty = float(HALO_THICKNESS) * v;","{","float stx = 1.5 * h;","float sty = 1.5 * v;","count+= texture2D( tAdd, vec2( vUv.x - stx, vUv.y + sty)).r;","count+= texture2D( tAdd, vec2( vUv.x    , vUv.y + sty)).r;","count+= texture2D( tAdd, vec2( vUv.x + stx, vUv.y + sty)).r;","count+= texture2D( tAdd, vec2( vUv.x - stx, vUv.y)).r;","count+= texture2D( tAdd, vec2( vUv.x + stx, vUv.y)).r;","count+= texture2D( tAdd, vec2( vUv.x - stx, vUv.y - sty)).r;","count+= texture2D( tAdd, vec2( vUv.x    , vUv.y - sty)).r;","count+= texture2D( tAdd, vec2( vUv.x + stx, vUv.y - sty)).r;","for (int p = 0; p < 24; p += 2) {","count += texture2D(tAdd, vec2(vUv.x + tx * poisson[p], vUv.y + ty * poisson[p+1])).r;","}","}","if (count > 0.0) {","vec4 aux;","float hit = 0.0;","for (int halo = 1; halo <= HALO_THICKNESS ; halo++) {","tx = float(halo) * h;","ty = float(halo) * v;","for (int p = 0; p < 24; p += 2) {","vec4 tex = texture2D(tAdd, vec2(vUv.x + tx * poisson[p], vUv.y + ty * poisson[p+1]));","aux = GetHaloData(GetID(tex.r), tex.w);","haloColor += aux;","hit += aux.a > 0.0 ? 1.0 : 0.0;","}","}","haloColor.a *= 0.08333333333 / float(HALO_THICKNESS);","haloColor.rgb /= max(hit, 1.0);","}","return haloColor;","}","float GetLineicAlpha(in bool isEdge) {",o?"return 0.8;":"return isEdge ? 0.6 : 0.8;","}","float ComputePoliteColorAlpha(in highlightConfig config, in bool isMarker, in bool isEdge, in bool back) {","return isMarker || isEdge ? GetLineicAlpha(isEdge) : (back ? config.colorIntensity.y : config.colorIntensity.x);","}","float ComputeHaloColorAlpha(in highlightConfig config, in float factor) {","return (0.6 * factor + 0.2) * config.colorIntensity.x;","}"].join("\n"),f=["vec4 GetHaloData(in int index, in float glType){","vec4 res = vec4(0.0);","#if HAS_POLITE == 1","if (GetID(glType) == 2 || GetID(glType) == 4) {","return res;","}","#endif","float factor = (GetID(glType) <= 2 ? ceil(glType) : 0.0);","if (index > 0) {","#if NB_CONFIG == 1","res.a = (1.0 + factor) * iHaloIntensities[0];","res.rgb = iHaloColors[0];","#else","MAIN_HALO_DATA_LOOP","#endif","}","return res;","}","vec4 GetLineicHaloData(in int index){","vec4 res = vec4(0.0);","if (index > 0) {","#if NB_CONFIG == 1","res.rgb = iLineicHaloColors[0];","#else","LINEIC_HALO_DATA_LOOP","#endif","}",o?"res.a = 0.45;":"res.a = 0.8;","return res;","}","highlightConfig GetHighlightConfig(in int index) {","if (index > 0) {","highlightConfig res;","#if NB_CONFIG == 1","res.color = iColors[0];","res.colorIntensity = iColorIntensities[0];","res.outlineColor = iOutlineColors[0];","res.lineicOutlineColor = iLineicOutlineColors[0];","res.outlineAlpha = iOutlineAlphas[0];","res.outlineThickness = iOutlineThicknesses[0];","#else","HIGHLIGHT_CONFIG_LOOP","#endif","return res;","} else {","return emptyConfig;","}","}"].join("\n"),c=["if (empty == 0) {","#if (POSTPRO == 1)","gl_FragColor = texture2D( tDiffuse, vUv );","#else","gl_FragColor = vec4(0.0);","#endif","return;","}","emptyConfig.color = vec3(0.0);","emptyConfig.colorIntensity = vec2(0.0, -1.0);","emptyConfig.outlineColor = vec3(0.0);","emptyConfig.lineicOutlineColor = vec3(0.0);","emptyConfig.outlineAlpha = 0.0;","emptyConfig.outlineThickness = 0.0;","vec4 center = texture2D(tAdd, vUv);","vec4 finalColor = vec4(0.0);"].join("\n"),v=["int qaAutomationID = GetID(center.r);","if (qaAutomationID > 0) {","int qaAutomationGeomID = GetID(center.w);","finalColor.a = 1.0;","if (qaAutomationGeomID == 0) {","finalColor.rgb = vec3(0.0,0.61,0.61);","} else if (qaAutomationGeomID < 3) {","finalColor.rgb = qaAutomationGeomID == 2 ? vec3(1.0,0.0,0.0) : vec3(0.0,0.78,0.78);","} else {","finalColor.rgb = vec3(0.0,0.78,0.78);","}","}"].join("\n"),d=["highlightConfig config = GetHighlightConfig(center.r);","float isOutline = 8.0;","if (config.outlineAlpha > -0.5 && !forceBasePostProOff) {","isOutline = CheckIfOutlines(center, config);","}","if (forceOutlineOn && config.outlineAlpha > -0.5) {","finalColor = vec4(config.lineicOutlineColor.rgb, GetLineicAlpha(isEdge));","} else if (isOutline < outlineCheck) {","finalColor = vec4(config.outlineColor.rgb, config.outlineAlpha);","} else {","if (center.r == 0.0 && !forceBasePostProOff) {","finalColor = ComputeHaloColor();","} else if (forceHaloOn) {","finalColor.rgba = GetLineicHaloData(GetID(center.r));","} else if (config.colorIntensity.x > 1e-6 || config.colorIntensity.y > 1e-6) {","if (config.colorIntensity.y > -0.5) {","float alpha = ComputePoliteColorAlpha(config, isMarker, isEdge, center.b > 0.5);","finalColor = vec4(center.g * config.color.rgb, alpha);","} else {","float alpha = ComputeHaloColorAlpha(config, center.g);","finalColor = vec4(config.color.rgb, alpha);","}","}","}"].join("\n"),u=["finalColor.a = min(finalColor.a, 1.0);","float coef = finalColor.a;","#if (POSTPRO == 1)","vec4 add = texture2D( tDiffuse, vUv );","gl_FragColor = vec4(coef * finalColor.rgb + (1.0 - coef) * add.rgb, add.a);","#else","gl_FragColor = vec4(finalColor.rgb, coef);","#endif"].join("\n"),p=["for (int i = 0; i < NB_CONFIG; i++) {","if (i + 1 == index) {","res.color = iColors[i];","res.colorIntensity = iColorIntensities[i];","res.outlineColor = iOutlineColors[i];","res.lineicOutlineColor = iLineicOutlineColors[i];","res.outlineAlpha = iOutlineAlphas[i];","res.outlineThickness = iOutlineThicknesses[i];","break;","}","}"].join("\n"),m=["for (int i = 0; i < NB_CONFIG; i++) {","if (i + 1 == index) {","res.rgb = iLineicHaloColors[i];","break;","}","}"].join("\n"),S=["for (int i = 0; i < NB_CONFIG; i++) {","if (i + 1 == index) {","res.a = (1.0 + factor) * iHaloIntensities[i];","res.rgb = iHaloColors[i];","break;","}","}"].join("\n"),_={defines:{},uniforms:{},vertexShader:n,fragmentShader:[l,f.replace("HIGHLIGHT_CONFIG_LOOP",p).replace("LINEIC_HALO_DATA_LOOP",m).replace("MAIN_HALO_DATA_LOOP",S),"#if HAS_POLITE == 1","bool DoPoliteMarkers(inout vec4 center, out bool forceOutlineOn,  out bool forceHaloOn, out bool isMarker) {","bool forceBasePostProOff = false;","vec4 oldCenter = center;","int curID = 0;","float curDistance = 1e6;","bool curBack = false;","bool outer = false;","bool outerOutline = false;","bool inner = false;","bool innerOuter = false;","bool innerOutline = false;","for (int i = -2; i <= 2 ; i++) {","for (int j = -2; j <= 2 ; j++) {","vec2 offsetFactor = vec2(float(i), float(j));","float dist = length(offsetFactor);","vec2 uv = vUv + offsetFactor * vec2(h,v);","vec4 auxCenter = texture2D(tAdd, uv);","if (GetID(auxCenter.w) == 4 && auxCenter.b > 0.0) {","int auxID = GetID(auxCenter.r);","if (dist < curDistance || (abs(dist - curDistance) < 1e-6)) {","if (curID > 0 && auxCenter.b > 0.5 && !curBack) {","continue;","}","center = auxCenter;","curID = auxID;","curDistance = dist;","curBack = auxCenter.b > 0.5;","outer = any(greaterThan(abs(offsetFactor), vec2(1.5,1.5)));","outerOutline = outer;","inner = all(lessThan(abs(offsetFactor), vec2(1.5,1.5)));","innerOuter = inner;","innerOutline = any(greaterThan(abs(offsetFactor), vec2(0.5,0.5)));","forceBasePostProOff = true;","}","}","}","}","if (curBack && !inner){","center = oldCenter;","} else {","forceOutlineOn = (curBack && !innerOutline) || (!curBack && !outerOutline && innerOutline);","forceHaloOn = (curBack && innerOutline) || (!curBack && outerOutline);","isMarker = GetID(center.w) == 4;","}","return forceBasePostProOff;","}","bool DoPoliteEdges(inout vec4 center, out bool forceOutlineOn,  out bool forceHaloOn, out bool isEdge) {","bool forceBasePostProOff = false;","vec4 oldCenter = center;","int curID = 0;","float curDistance = 1e6;","bool curBack = false;","bool outer = false;","bool outerOutline = false;","bool inner = false;","bool innerOuter = false;","bool innerOutline = false;","for (int i = -2; i <= 2 ; i++) {","for (int j = -2; j <= 2 ; j++) {","vec2 offsetFactor = vec2(float(i), float(j));","float dist = length(offsetFactor);","vec2 uv = vUv + offsetFactor * vec2(h,v);","vec4 auxCenter = texture2D(tAdd, uv);","if (GetID(auxCenter.w) == 2 && auxCenter.b > 0.0) {","int auxID = GetID(auxCenter.r);","if (dist < curDistance || (abs(dist - curDistance) < 1e-6)) {","if (curID > 0 && auxCenter.b > 0.5 && !curBack) {","continue;","}","center = auxCenter;","curID = auxID;","curDistance = dist;","curBack = auxCenter.b > 0.5;","outer = any(greaterThan(abs(offsetFactor), vec2(1.5,1.5)));","outerOutline = outer;","inner = all(lessThan(abs(offsetFactor), vec2(1.5,1.5)));","innerOuter = inner;","innerOutline = any(greaterThan(abs(offsetFactor), vec2(0.5,0.5)));","forceBasePostProOff = true;","}","}","}","}","if (curBack && !inner){","center = oldCenter;","} else {","forceOutlineOn = (curBack && !innerOutline) || (!curBack && !outerOutline && innerOutline);","forceHaloOn = (curBack && innerOutline) || (!curBack && outerOutline);","isEdge = GetID(center.w) == 2;","}","return forceBasePostProOff;","}","#endif",s,"void main() {",c,"#if QA_AUTOMATION == 1",v,"#else","bool forceHaloOn = false;","bool forceOutlineOn = false;","bool forceBasePostProOff = false;","bool isMarker = false;","bool isEdge = false;","#if HAS_POLITE == 1","forceBasePostProOff = GetID(center.w) == 4 || GetID(center.w) == 2;","forceOutlineOn = forceBasePostProOff && center.b > 0.5;","if (!forceBasePostProOff) {","forceBasePostProOff = DoPoliteMarkers(center, forceOutlineOn, forceHaloOn, isMarker);","}","if (!forceBasePostProOff) {","forceBasePostProOff = DoPoliteEdges(center, forceOutlineOn, forceHaloOn, isEdge);","}","#endif",d,"#endif",u,"}"].join("\n")};Object.assign(_.defines,r),Object.assign(_.uniforms,i);return{_computeDepthChunk:t,HighlightFace:a,FinalBlending:_,FinalMobileBlending:function(e){var t=function(t){for(var o=[],a=0;a<e;a++)o.push("if ("+a+" + 1 == index) {"),o.push("const int i = "+a+";"),o.push(t),o.push("}");return o.join("\n")},o=t("res.color = iColors[i];res.colorIntensity = iColorIntensities[i];res.outlineColor = iOutlineColors[i];res.lineicOutlineColor = iLineicOutlineColors[i];res.outlineAlpha = iOutlineAlphas[i];res.outlineThickness = iOutlineThicknesses[i];"),a=t("res.rgb = iLineicHaloColors[i];"),p=t("res.a = (1.0 + factor) * iHaloIntensities[i];res.rgb = iHaloColors[i];"),m={defines:{},uniforms:{},vertexShader:n,fragmentShader:["#if HAS_POLITE == 1","#undef HAS_POLITE","#define HAS_POLITE 0","#endif",l,f.replace("HIGHLIGHT_CONFIG_LOOP",o).replace("LINEIC_HALO_DATA_LOOP",a).replace("MAIN_HALO_DATA_LOOP",p),s,"void main() {",c,"#if QA_AUTOMATION == 1",v,"#else","bool forceHaloOn = false;","bool forceOutlineOn = false;","bool forceBasePostProOff = false;","bool isMarker = false;","bool isEdge = false;",d,"#endif",u,"}"].join("\n")};return Object.assign(m.defines,r),Object.assign(m.uniforms,i),m}}}),define("Shaders/AdvancedHighlightShader",["DS/Shaders/AdvancedHighlightShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/AdvancedHighlightShader"),e}),define("DS/Shaders/AutoExposureShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{WeightedLuminance:{defines:{},uniforms:{tDiffuse2:{type:"t",value:null},tWeight:{type:"t",value:null},clampMin:{type:"f",value:-10},clampMax:{type:"f",value:20}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse2;","uniform float clampMin;","uniform float clampMax;","#if defined(USE_WEIGHT_TEXTURE)","uniform sampler2D tWeight;","#endif","varying vec2 vUv;","   float luminance(vec3 iColor) {","\t\tvec3 luminance_weight=vec3(0.176204,0.812985,0.0108109);","\t\treturn dot(iColor,luminance_weight);","\t}","void main() {","    vec4 color = texture2D( tDiffuse2, vUv );","    float weight = 1.0;","#if defined(USE_WEIGHT_TEXTURE)","\t weight = texture2D( tWeight, vUv ).r;","#endif","float value = weight * clamp(log(luminance(color.xyz)),clampMin,clampMax);","gl_FragColor = vec4(value,weight,0.0, 1.0);","}"].join("\n")},PixelSum:{uniforms:{tDiffuse:{type:"t",value:null},tDiffuseSize:{type:"v2",value:null},currentSize:{type:"v2",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 tDiffuseSize;","uniform vec2 currentSize;","varying vec2 vUv;","void main() {","vec2 currentPixel = floor(vUv*currentSize);","vec2 sums = vec2(0.0);","vec2 loopSize = vec2(float(LOOP_SIZE_X),float(LOOP_SIZE_Y));","vec2 uvDiffuse = (0.5+currentPixel*loopSize)/tDiffuseSize;","vec2 currUv;","if(currentPixel.x<(currentSize.x-1.0)){","for(int i=0;i<LOOP_SIZE_X;i++){","currUv = uvDiffuse + vec2(float(i)/tDiffuseSize.x,0.0);","if(currentPixel.y<(currentSize.y-1.0)){","for(int j=0;j<LOOP_SIZE_Y;j++){","currUv.y += 1.0/tDiffuseSize.y;","sums+=texture2D(tDiffuse,currUv).rg;","}","}else{","for(int j=0;j<LOOP_SIZE_Y_FINAL;j++){","currUv.y += 1.0/tDiffuseSize.y;","sums+=texture2D(tDiffuse,currUv).rg;","}","}","}","}else{","for(int i=0;i<LOOP_SIZE_X_FINAL;i++){","currUv = uvDiffuse + vec2(float(i)/tDiffuseSize.x,0.0);","if(currentPixel.y<(currentSize.y-1.0)){","for(int j=0;j<LOOP_SIZE_Y;j++){","currUv.y += 1.0/tDiffuseSize.y;","sums+=texture2D(tDiffuse,currUv).rg;","}","}else{","for(int j=0;j<LOOP_SIZE_Y_FINAL;j++){","currUv.y += 1.0/tDiffuseSize.y;","sums+=texture2D(tDiffuse,currUv).rg;","}","}","}","}","    gl_FragColor = vec4(sums, 0.0, 1.0);","}"].join("\n")}}}),define("Shaders/AutoExposureShaders",["DS/Shaders/AutoExposureShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/AutoExposureShaders"),e}),define("DS/Shaders/CATCrDBallPointShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return function(t,o){t.activatePDSFX(),t.transparent=!0,t.side=e.DoubleSide,t.setPDSFXPolygonOffset("Frontward1");var a=["vec4 commonFinalColor;","vec3 selectorColor = vec3(0., 0.45, 0.75);","float bezierBlend(float t)","{","return clamp((3.0 * t * t * (1.0 - t) + t * t * t), 0.0, 1.0);","}"].join("\n");t.setPDSFXGlobalShaderCode("",a);var i={CrD_Base_UniformColor:{type:"v4",value:new e.Vector4(o.Color[0],o.Color[1],o.Color[2],o.Color[3])},CrD_Base_UniformCutByPlane:{type:"f",value:o.CutByPlane},CrD_Base_UniformScreenPlane:{type:"f",value:o.ScreenPlane},CrD_Base_UniformPlanePosition:{type:"v3",value:new e.Vector3(o.PlanePosition[0],o.PlanePosition[1],o.PlanePosition[2])},CrD_Base_UniformPlaneNormal:{type:"v3",value:new e.Vector3(o.PlaneNormal[0],o.PlaneNormal[1],o.PlaneNormal[2])},CrD_BallPoint_UniformCircleSelection:{type:"f",value:0},CrD_BallPoint_UniformRadius:{type:"v2",value:new e.Vector2(0,0)},CrD_BallPoint_UniformCenter:{type:"v2",value:new e.Vector2(0,0)}};t.setPDSFXUniforms(i);t.setPDSFXVaryings({vTexCoord:{type:"v3"}});var r={ComputeObjectPosition:["vec3 ComputeObjectPosition() {","return vGetAttribPosition();","}"].join("\n"),ComputeVaryingValues:["void ComputeVaryingValues() {","vTexCoord = vGetAttribTexCoord0().xyz;","}"].join("\n")},n={ComputeCommonValues:["void ComputeCommonValues() {","vec2 cornerUV = vTexCoord.xy;","float alpha    = CrD_Base_UniformColor.a;","float pressure = clamp(1.02 * 1.0, 0.0, 1.0); // if pressure > 0.98 => pressure = 1.0","cornerUV.y = 2.0 * (cornerUV.y - 0.5);","float xUVTest1 = clamp(sign(0.25 - cornerUV.x), 0.0, 1.0); // if cornerUV.x<0.25f","float xUVTest2 = clamp(sign(cornerUV.x - 0.75), 0.0, 1.0); // if cornerUV.x>0.75f","cornerUV.x = mix(cornerUV.x, 1.0 - cornerUV.x * 4.0, xUVTest1); // if cornerUV.x<0.25f => cornerUV.x = 1.0 - cornerUV.x * 4.0","cornerUV.x = mix(cornerUV.x, (cornerUV.x - 0.75) * 4.0, xUVTest2); // if cornerUV.x>0.75f => cornerUV.x = (cornerUV.x - 0.75) * 4.0","float inTheCorner = xUVTest1 + xUVTest2; // 0 if 0.25 < u < 0.75, else 1        ","float corner = cornerUV.x * cornerUV.x + cornerUV.y * cornerUV.y;","if(inTheCorner * corner > 1.0) // true only if inTheCorner = 1 and corner > 1 as inTheCorner can only be 0 or 1","{","discard;","}","float falloffU = bezierBlend(cornerUV.x);","// if inTheCorner is 1. then corner is <= 1.0 else we would have already discarded the fragment, so next line is equivalent to:","// if(inTheCorner>0.0 && corner <= 1.0) => alpha = mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * bezierBlend(corner))","// else alpha = alpha","alpha = mix(alpha, mix(0.7 * alpha, alpha, (1.0 - falloffU) * 1.0 - falloffU * bezierBlend(corner)), inTheCorner);","//-----------------------------------------------------------------------------------------------","// Handle cut by plane","//-----------------------------------------------------------------------------------------------","float cutByPlaneActivated = clamp(sign(CrD_Base_UniformCutByPlane), 0.0, 1.0); // 0 if CutByPlane <= 0, 1 if CutByPlane > 0        ","float screenActivated = clamp(sign(CrD_Base_UniformScreenPlane), 0.0, 1.0); // 0 if ScreenPlane <= 0, 1 if ScreenPlane > 0","// We do the work in the view space","// We compute the plane's equation: ax + by + cz + d = 0   => Normal(a, b, c), d = -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition)","vec4 viewPlaneEq = vGetWorldViewInvTranspMatrix() * vec4(CrD_Base_UniformPlaneNormal, -dot(CrD_Base_UniformPlaneNormal, CrD_Base_UniformPlanePosition));","// eye and Fragment position","vec4 fragPos = vec4(vGetViewPosition(), 1.0);","vec4 eyePos = vec4(0.0, 0.0, 0.0, 1.0);","// The sign of the plane's equation applied to the previous position gives the side of each point","float eyeClip = dot(viewPlaneEq, eyePos); // => d","float fragClip = dot(viewPlaneEq, fragPos) + sign(eyeClip) * 10e-2;","// cutByPlaneActivated == 0 => hide = 0.0","// If both values have the same sign, they are on the same side => hide = 0.0","// If there signs are different, they are on opposite side      => hide = 1.0","float hide = mix(0.0, clamp(-1.0 * sign(fragClip * eyeClip), 0.0, 1.0), cutByPlaneActivated);","commonFinalColor = vec4(CrD_Base_UniformColor.xyz, pressure * alpha * mix(1.0, 0.25, hide));","//-----------------------------------------------------------------------------------------------","// handle circle selection","//-----------------------------------------------------------------------------------------------","float circleSelectActivated = clamp(sign(CrD_BallPoint_UniformCircleSelection), 0.0, 1.0); // if CircleSelection > 0 => circleSelectActivated = 1 else circleSelectActivated = 0","// screen coordinates of current fragment - circle center coordinates","vec2 vect = vGetFragCoord().xy - CrD_BallPoint_UniformCenter.xy;","float circleValue = pow(vect.x, 2.0) / pow(CrD_BallPoint_UniformRadius.x, 2.0) + pow(vect.y, 2.0) / pow(CrD_BallPoint_UniformRadius.y, 2.0);","// at the end, coeff is 0 if circleSelectActivated is 0 or if we are outside the selection circle","//             coeff is 1 at the middle of the circle, slowly decreases afterward and reaches 0 on the circle border","float coeff = circleSelectActivated * (1.0 - clamp(circleValue, 0.0, 1.0));","float selectionAlpha = 0.3 * coeff + 0.7;","vec4 blendResult;","blendResult.a = selectionAlpha + commonFinalColor.a * (1.0 - selectionAlpha);","blendResult.rgb = (selectorColor * selectionAlpha + commonFinalColor.xyz * commonFinalColor.a * (1.0 - selectionAlpha)) / selectionAlpha;","commonFinalColor = mix(commonFinalColor, blendResult, sign(coeff));","}"].join("\n"),ComputeAlbedo:["vec3 ComputeAlbedo() {","return commonFinalColor.xyz;","}"].join("\n"),ComputeOpacity:["float ComputeOpacity() {","return commonFinalColor.a;","}"].join("\n")};return t.setPDSFXOverridableFunctions(r,n),t.needsUpdate=!0,t}}),define("DS/Shaders/ReplaceBlendShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","vec3 color  = texture2D(  tDiffuse, vUv ).xyz;","vec4 color2 = texture2D( tDiffuse2, vUv );","gl_FragColor = vec4((1.0 - color2.a) * color + color2.a * color2.xyz, 1.0);","}"].join("\n")}}),define("Shaders/ReplaceBlendShader",["DS/Shaders/ReplaceBlendShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/ReplaceBlendShader"),e}),define("DS/Shaders/PreComputeShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=["#define CLAMP_VALUE 1000.0","uniform sampler2D tEnvMap;","uniform float roughness;","const float PI = 3.14159265358979323846264;","varying vec2 vUv;","#define INV_GOLDEN_RATIO 0.6180339887","float ComputeIndex(float id, float N) {","float val = id * N * 24.0;","float n = val / N;","float m = mod(val, N);","return n + m;","}","vec2 LowDiscrepancy2D(float i, float N)","{","float id = ComputeIndex(i, N);","return vec2(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));","}","vec2 vLogComplex(in float value) {","float real = log(abs(value));","float im = atan(0.0,value);","return vec2(real,im);","}","vec2 invComplex(in vec2 value) {","return vec2(value.x,-value.y)/(value.x * value.x + value.y * value.y);","}","float AshikminDistribution(in float NoH, in float sheenValue) {","float cosine2 = max(NoH * NoH,1e-6);","float sine2 = max(1.0-cosine2,1e-6);","float D = 1.0;","float normalisationTerm = 1.0;","float a2 = sheenValue * sheenValue;","normalisationTerm *= 1.0/(4.0*a2+1.0);","float sine4 = max(sine2 * sine2,1e-6);","float cotan2 = cosine2/sine2;","float value = -cotan2 / a2;","D = 1.0+4.0 * exp(value)/ sine4;","return D * normalisationTerm;","}","vec3 GetLightVector(in vec3 N, in vec3 H) {","#if MODE == 3","return H;","#else","return 2.0 * dot(N, H) * H - N;","#endif","}","float GetWeight(in float NoL) {","#if MODE != 0 && MODE != 3","return NoL > 0.0 ? 1.0 : 0.0;","#else","return NoL > 0.0 ? NoL : 0.0;","#endif","}","vec3 ImportanceSample(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","#if MODE == 0","float a = roughness * roughness;","float a2 = a*a;","float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));","float SinTheta = sqrt(1.0 - CosTheta * CosTheta);","#endif","#if MODE == 2","float a = roughness * roughness;","float a2 = a*a;","float loga = 8.0*a2*log(1.0-Xi.y);","float value = loga / (loga - 1.0);","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","#endif","#if MODE == 3 || MODE == 1","float value = Xi.y;","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","#endif","#if MODE == 4","float a = roughness;","a = max(a, 1e-3);","float SinTheta = pow(Xi.y, a / (2.0 * a + 1.0));","float CosTheta = sqrt(1.0 - SinTheta*SinTheta);","#endif","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","vec3 TangentToWorld(vec3 Vec, vec3 TangentZ) {","vec3 UpVector = abs(TangentZ.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);","vec3 TangentX = normalize(cross(UpVector, TangentZ));","vec3 TangentY = cross(TangentZ, TangentX);","return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;","}","float computeLODFromDirection(vec3 dir, float pdf) {","float d = 2.0 * DP_SCALE;","d *= (1.0 + abs(dir.z));","d *= d;","float lod = 0.5 * log2(pdf * d);","return max(LOD_CST - lod, 0.0);","}","vec3 sampleLatLongFromLocation(vec3 dir) {","float theta = acos(dir.z);","float phi = atan(dir.y, dir.x);","float u = 0.5 + 0.5 * phi / PI;","float v = theta / PI;","vec4 texelRGBE = texture2D(tEnvMap, vec2(u, v));","return texelRGBE.rgb * pow(2.0, 255.0 * texelRGBE.w - 128.0);","}","vec4 ImportanceSamplePDF(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float D = 0.0;","float normalisationTerm = 1.0/PI;","#if MODE == 0","float a = roughness * roughness;","float a2 = a*a;","float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));","float SinTheta = sqrt(1.0 - CosTheta * CosTheta);","float d = (a2 - 1.0) * CosTheta*CosTheta + 1.0;","D = a2 / (PI * d * d);","#endif","#if MODE == 2","float a = roughness * roughness;","float a2 = a*a;","float loga = 8.0*a2*log(1.0-Xi.y);","float value = loga / (loga - 1.0);","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","float cosine2 = max(CosTheta*CosTheta,1e-6);","float sine2 = max(SinTheta*SinTheta,1e-6);","normalisationTerm *= 1.0/(8.0*a2);","float cosine4 = max(cosine2 * cosine2,1e-6);","float tan2 = sine2/cosine2;","float value2 = -tan2/(a2*8.0);","D = exp(value2) / cosine4 ;","D *= normalisationTerm ;","#endif","#if MODE == 3 || MODE == 1","float value = Xi.y;","float SinTheta = sqrt(value);","float CosTheta = sqrt(1.0 - value);","D = normalisationTerm;","#endif","#if MODE == 4","float a = roughness;","a = max(a, 1e-3);","float SinTheta = max(pow(Xi.y, a / (2.0 * a + 1.0)),1e-3);","float CosTheta = sqrt(1.0 - SinTheta*SinTheta);","normalisationTerm *= 0.5;","D = (2.0 + 1.0 / a) * pow(SinTheta, 1.0 / a) ;","D *= normalisationTerm ;","#endif","float PDF = D * CosTheta;","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return vec4(H, PDF);","}","vec3 sampleDualParaboloidFromLocation(vec3 dir, float lod) {","vec2 st = vec2(0.5);","if (dir.z < 0.0) {","st *= 0.5 * (1.0 - dir.xy / (DP_SCALE * (1.0 - dir.z)));","} else {","st *= 0.5 * (1.0 + dir.xy / (DP_SCALE * (1.0 + dir.z)));","st.x += 0.5;","}","float mipValue = floor(lod);","float mipNextValue = mipValue + 1.0;","float mipCoef = fract(lod);","if (lod >= float(MAX_LOD)) {","mipValue = float(MAX_LOD);","mipNextValue = float(MAX_LOD);","mipCoef = 1.0;","}","vec3 color1;","vec3 color2;","vec2 uv1 = st;","vec2 uv2 = st;","float scale1 = pow(2.0, -mipValue);","float scale2 = pow(2.0, -mipNextValue);","uv1 *= scale1;","uv2 *= scale2;","uv1.y += 1.0 - scale1;","uv2.y += 1.0 - scale2;","color1 = texture2D(tEnvMap, uv1).xyz;","color2 = texture2D(tEnvMap, uv2).xyz;","return mix(color1, color2, mipCoef);","}","vec3 GetFilteredColor(in vec3 L, in vec4 perturbedZ_PDF, in vec3 H, in vec3 N, in float roughness, in float NoL) {","#if MODE == 3","float lod = computeLODFromDirection(L, perturbedZ_PDF.w);","#else","float lod = computeLODFromDirection(L, perturbedZ_PDF.w/ (4.0 * clamp(dot(L,H),1e-6,1.0)));","#endif","vec3 filteredColor = min(sampleDualParaboloidFromLocation(L, lod),vec3(CLAMP_VALUE));","#if MODE == 1","filteredColor *= AshikminDistribution(clamp(dot(N,H),1e-6,1.0), roughness);","#endif","return filteredColor;","}"].join("\n");return{ComputeMipMapRoughness:{defines:{NB_SAMPLES:256,DP_SCALE:1.2,MODE:0,MAX_LOD:9},uniforms:{tEnvMap:{type:"t",value:null},roughness:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[t,"vec3 prefilterEnvMap(float roughness, vec3 N, vec2 UV) {","vec3 filteredColor;","float weight = 0.0;","for (int i = 0; i < NB_SAMPLES; i++) {","vec2 E = LowDiscrepancy2D(i,NB_SAMPLES);","vec3 perturbedZ = ImportanceSample(E, roughness);","vec3 H = TangentToWorld(perturbedZ, N);","vec3 L = GetLightVector(N,H);","float NoL = clamp(dot(N, L), 0.0, 1.0);","float w = GetWeight(NoL);","filteredColor += w * min(sampleLatLongFromLocation(L), vec3(CLAMP_VALUE));","weight += w;","}","return filteredColor / max(weight, 0.001);","}","void main() {","gl_FragColor = vec4(0.0);","float phi = PI * (2.0 * vUv.x - 1.0);","float theta = PI * vUv.y;","vec3 N;","N.x = sin(theta) * cos(phi);","N.y = sin(theta) * sin(phi);","N.z = cos(theta);","gl_FragColor = vec4(prefilterEnvMap(roughness, N, vUv), 1.0);","}"].join("\n")},ComputeMipMapRoughnessFIS:{defines:{NB_SAMPLES:256,DP_SCALE:1.2,LOD_CST:7.707519,MODE:0,MAX_LOD:9},uniforms:{tEnvMap:{type:"t",value:null},roughness:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:[t,"vec3 prefilterEnvMap(float roughness, vec3 N, vec2 UV) {","vec3 filteredColor;","float weight = 0.0;","for (int i = 0; i < NB_SAMPLES; i++) {","vec2 E = LowDiscrepancy2D(float(i),float(NB_SAMPLES));","vec4 perturbedZ_PDF = ImportanceSamplePDF(E, roughness);","vec3 H = TangentToWorld(perturbedZ_PDF.xyz, N);","vec3 L = GetLightVector(N,H);","float NoL = clamp(dot(N, L), 0.0, 1.0);","float w = GetWeight(NoL);","filteredColor += w * GetFilteredColor(L, perturbedZ_PDF, H, N, roughness, NoL);","weight += w;","}","return filteredColor / max(weight, 0.001);","}","void main() {","gl_FragColor = vec4(0.0);","float phi = PI * (2.0 * vUv.x - 1.0);","float theta = PI * vUv.y;","vec3 N;","N.x = sin(theta) * cos(phi);","N.y = sin(theta) * sin(phi);","N.z = cos(theta);","gl_FragColor = vec4(prefilterEnvMap(roughness, N, vUv), 1.0);","}"].join("\n")},ComputeMipMapRoughnessIterative:{defines:{NB_SAMPLES:256,NB_SAMPLES_IT:256,DP_SCALE:1.2,LOD_CST:7.707519,MODE:0,MAX_LOD:9},uniforms:{prevMap:{type:"t",value:null},tEnvMap:{type:"t",value:null},roughness:{type:"f",value:0},firstSample:{type:"i",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D prevMap;","uniform int firstSample;",t,"vec4 prefilterEnvMap(float roughness, vec3 N, vec2 UV) {","vec3 filteredColor;","float weight = 0.0;","for (int i = 0; i < NB_SAMPLES_IT; i++) {","float newI = float(firstSample + i);","vec2 E = LowDiscrepancy2D(newI,float(NB_SAMPLES));","vec4 perturbedZ_PDF = ImportanceSamplePDF(E, roughness);","vec3 H = TangentToWorld(perturbedZ_PDF.xyz, N);","vec3 L = GetLightVector(N,H);","float NoL = clamp(dot(N, L), 0.0, 1.0);","float w = GetWeight(NoL);","filteredColor +=  w * GetFilteredColor(L, perturbedZ_PDF, H, N, roughness, NoL);","weight += w;","}","return vec4(filteredColor / max(weight, 0.001),max(weight, 0.001));","}","void main() {","gl_FragColor = vec4(0.0);","float phi = PI * (2.0 * vUv.x - 1.0);","float theta = PI * vUv.y;","vec3 N;","N.x = sin(theta) * cos(phi);","N.y = sin(theta) * sin(phi);","N.z = cos(theta);","vec4 prevTex = texture2D(prevMap, vUv);","vec4 res = prefilterEnvMap(roughness, N, vUv);","gl_FragColor = vec4((prevTex.rgb * prevTex.a + res.rgb * res.a) / (prevTex.a + res.a), prevTex.a + res.a);","}"].join("\n")}}}),define("DS/Shaders/SSLRShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t={computeReflectionCoef:["vec4 normalDepth = texture2D( tNormalDepthIoRRoughness, vUv );","float reflectionCoef = normalDepth.z;"].join("\n"),computeVertexPositionVS:["float z = normalDepth.w;","if ( z == 0.0 ) return;","vec2 xy = vUv * 2.0 - 1.0;","vec4 vertexPositionProjected = vec4( xy, 2.0 * z - 1.0, 1.0 );","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","vertexPositionVS.w = 1.0;"].join("\n"),computeNormal:["vec3 normal = decodeOct24Normal(normalDepth.x);"].join("\n")};return{uniforms:{tDiffuse2:{type:"t",value:null},tNormalDepthIoRRoughness:{type:"t",value:null},tRandomTex:{type:"t",value:null},size:{type:"v2",value:new e.Vector2(512,512)},realProjectionMatrix:{type:"m4",value:new e.Matrix4},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},radius:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","  vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform mat4 realProjectionMatrix;","uniform mat4 realProjectionMatrixInverse;","uniform sampler2D tDiffuse2;","uniform sampler2D tNormalDepthIoRRoughness;","uniform sampler2D tRandomTex;","uniform vec2 size;","uniform float radius;","varying vec2 vUv;","const float roughness = 0.0;","const vec3 unitY = vec3(0.0, 1.0, 0.0);","const vec3 unitZ = vec3(0.0, 0.0, 1.0);","vec2 getScreenPos(vec3 pos) {","  vec4 offset = realProjectionMatrix * vec4(pos, 1.0);","  offset.xy /= offset.w;","  offset.xy = offset.xy * 0.5 + 0.5;","  return offset.xy;","}","vec3 getScreenPos3(vec3 pos) {","  vec4 offset = realProjectionMatrix * vec4(pos, 1.0);","  offset.xyz /= offset.w;","  offset.xy = offset.xy * 0.5 + 0.5;","  return offset.xyz;","}","float random(vec3 scale, float seed) {","  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","void main() {","  vec2 screenPos = vUv;","  gl_FragColor = vec4(0.0);",t.computeReflectionCoef,"  if (reflectionCoef > 0.0) {",t.computeVertexPositionVS,t.computeNormal,"    vec3 origin = vertexPositionVS.xyz;","    vec3 I = normalize(origin);","    vec3 vReflect = normalize(reflect(I, normal));","    vec3 ptReflect = origin + radius * vReflect;","    vec3 originScreenPos = vec3(vUv, 2.0 * z - 1.0);","    vec3 endReflectScreenPos = getScreenPos3( ptReflect );","    vec3 reflectScreenPos = endReflectScreenPos - originScreenPos;","    reflectScreenPos /= length(endReflectScreenPos.xy - originScreenPos.xy);","    vec2 stepsToBorder = vec2(size * vUv / abs(reflectScreenPos.xy));","    if (reflectScreenPos.x > 0.0) stepsToBorder.x = size.x * (1.0 - vUv.x) / abs(reflectScreenPos.x);","    if (reflectScreenPos.y > 0.0) stepsToBorder.y = size.y * (1.0 - vUv.y) / abs(reflectScreenPos.y);","    float stepsToScreenBorder = min(stepsToBorder.x, stepsToBorder.y);","    reflectScreenPos /= size.x;","    float prevDepth = originScreenPos.z;","    float ray_marching_step = 16.0;","    float j = ray_marching_step;","    for (int i = 0; i < 64; ++i) {","      if (j > stepsToScreenBorder) { break; }","      vec3 sampleScreenPos = originScreenPos + j * reflectScreenPos;","      vec4 normalDepth = texture2D( tNormalDepthIoRRoughness, sampleScreenPos.xy );","      float z = 2.0 * normalDepth.w - 1.0;","      vec3 n = decodeOct24Normal(normalDepth.x);","      float diffZ = sampleScreenPos.z - z;","      if (diffZ > 0.0) {","        if (ray_marching_step == 1.0) {","          if (abs(diffZ) < 10.0*abs(sampleScreenPos.z - prevDepth)) {","            float reflectAttenuation = clamp(-dot(n, vReflect), 0.0, 1.0) * ((stepsToScreenBorder - j) / stepsToScreenBorder);","            gl_FragColor = vec4( texture2D( tDiffuse2, sampleScreenPos.xy ).xyz, reflectAttenuation * reflectionCoef );","          }","          return;","        } else {","          ray_marching_step *= 0.5;","          j -= ray_marching_step;","        }","      } else {","        prevDepth = sampleScreenPos.z;","        j += ray_marching_step;","      }","    }","  }","}"].join("\n")}}),define("Shaders/SSLRShader",["DS/Shaders/SSLRShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/SSLRShader"),e}),define("DS/Shaders/SSLRShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=["uniform sampler2D tColor;","uniform sampler2D tNormalDepthIoRRoughness;","uniform sampler2D tColorNormalDepth;","uniform mat4 realProjectionMatrix;","uniform mat4 realProjectionMatrixInverse;","uniform vec4 frustumPlanes[6];","uniform float sceneSize;","uniform vec2 screenSize;","uniform int renderIteration;","#define MAX_RAY 4","#define MAX_RAY_F 4.0","#define I_MAX_RAY_F 0.25","const float PI = 3.14159265359;","#define INV_GOLDEN_RATIO 0.6180339887","#define CLAMP_VALUE vec3(3.0)","vec3 toViewPos(vec2 uv, float depth) {","vec4 vertexPositionProjected = vec4(uv * 2.0 - 1.0, depth, 1.0);","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","vertexPositionVS.w = 1.0;","return vertexPositionVS.xyz;","}","vec3 toViewPos(vec2 uv) {","float z = texture2D(tColorNormalDepth, uv).w;","if (z == 0.0) z = 1.0;","return toViewPos(uv, 2.0 * z - 1.0);","}","vec3 getScreenPos3(vec3 pos) {","vec4 offset = realProjectionMatrix * vec4(pos, 1.0);","offset.xyz /= offset.w;","offset.xy = offset.xy * 0.5 + 0.5;","return offset.xyz;","}","vec4 sampleColorScene(vec2 uv) {","vec4 color = texture2D(tColor, uv);","#if defined(NO_COMPOSITING)","return vec4(convertToLinear(color.rgb), color.a);","#else","return color;","#endif","}","float random(vec3 scale, float seed) {","return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","float Random1D(float seed) {","return random(vec3(12.9898, 78.233, 151.7182), seed);","}","vec3 GetLightVector(in vec3 N, in vec3 H) {","return 2.0 * dot(N, H) * H - N;","}","float ComputeIndex(float id, float N) {","float val = id * N * 24.0;","float n = val / N;","float m = mod(val, N);","return n + m;","}","vec2 LowDiscrepancy2D(float i, float N)","{","float id = ComputeIndex(i, N);","return vec2(fract((id + 0.5) / N* INV_GOLDEN_RATIO), fract(id * INV_GOLDEN_RATIO));","}","vec3 TangentToWorld(vec3 Vec, vec3 TangentZ) {","vec3 UpVector = abs(TangentZ.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);","vec3 TangentX = normalize(cross(UpVector, TangentZ));","vec3 TangentY = cross(TangentZ, TangentX);","return TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;","}","vec3 ImportanceSampleGGX(vec2 Xi, float roughness) {","vec3 H;","float Phi = 2.0 * PI * Xi.x;","float a = roughness * roughness;","float a2 = a * a;","float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y));","float SinTheta = sqrt(1.0 - CosTheta * CosTheta);","H.x = SinTheta * cos(Phi);","H.y = SinTheta * sin(Phi);","H.z = CosTheta;","return H;","}","void ClipByPlane(vec3 origin, vec3 direction, vec4 plane, inout float t) {","float clipVal = dot(plane, vec4(origin, 1.0));","float k = -clipVal / dot(plane.xyz, direction);","if (k < 0.0) return;","t = min(t, k);","}","float ClipByFrustum(vec3 origin, vec3 direction) {","float t = 1000000000000.0;","for (int k = 0; k < 6; ++k) {","ClipByPlane(origin, direction, frustumPlanes[k], t);","}","return t;","}"].join("\n"),o=function(e){return["float roughness = normalDepth.z;","float z = normalDepth.w;","if ( z == 0.0 ) return;","vec3 normal = decodeOct24Normal(normalDepth.x);","vec3 origin = toViewPos(vUv, 2.0 * z - 1.0);","vec3 V = realProjectionMatrix[3][3] > 0.5 ? vec3(0.0,0.0,1.0) : normalize(-origin);","vec3 L;","float hitDistance = 0.0;","if (renderIteration > 2 ) {","for (int i = 0; i < MAX_RAY; i++) {","vec2 E = LowDiscrepancy2D(float(i + 1) * float(renderIteration - 2), MAX_RAY_F * 125.0);","vec3 perturbedZ = ImportanceSampleGGX(E, roughness);","vec3 H = TangentToWorld(perturbedZ, normal);",e?"vec3 Vflip = reflect(GetLightVector(V, H), normal);":"",e?"L = refract(Vflip, normal, 1.0/ior);":"L = GetLightVector(V, H);","gl_FragColor += RayMarchNew(origin, L, hitDistance);","}","gl_FragColor *= I_MAX_RAY_F;","} else {","vec3 H = normal;",e?"vec3 Vflip = reflect(GetLightVector(V, H), normal);":"",e?"L = refract(Vflip, normal, 1.0/ior);":"L = GetLightVector(V, H);","gl_FragColor = RayMarchNew(origin, L, hitDistance);","}","gl_FragColor.rgb = min(gl_FragColor.rgb,CLAMP_VALUE);"].join("\n")},a={tColor:{type:"t",value:null},tNormalDepthIoRRoughness:{type:"t",value:null},tColorNormalDepth:{type:"t",value:null},screenSize:{type:"v2",value:new e.Vector2(512,512)},realProjectionMatrix:{type:"m4",value:new e.Matrix4},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},renderIteration:{type:"i",value:0},frustumPlanes:{type:"fv4",value:[]},sceneSize:{type:"f",value:100}},i={uniforms:a,defines:{RAYMARCHING_STEPS:16},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;",t,"vec4 RayMarchNew(vec3 origin, vec3 direction, out float hitDistance) {","vec4 outColor = vec4(0.0);","hitDistance = sceneSize;","float maxRayLength = sceneSize;","float t = ClipByFrustum(origin, direction);","if (t <= 0.0) {","return outColor;","}","vec3 endPos = origin + min(t, maxRayLength) * direction;","vec3 uviz0 = getScreenPos3(origin);","vec3 uviz1 = getScreenPos3(endPos);","vec2 uvDir = uviz1.xy - uviz0.xy;","float nbSteps = max(1.0, length(screenSize * uvDir));","float ray_marching_step = 16.0;","float j = ray_marching_step;","for (int i = 0; i < 1024; ++i) {","if (j > nbSteps) { break; }","vec3 sampleScreenPos = mix(uviz0, uviz1, j / nbSteps);","vec4 normalDepth = texture2D(tColorNormalDepth, sampleScreenPos.xy);","float z = 2.0 * normalDepth.w - 1.0;","float diffZ = sampleScreenPos.z - z;","if (normalDepth.w > 0.0 && diffZ > 0.0) {","if (ray_marching_step == 1.0) {","vec3 hit = toViewPos(sampleScreenPos.xy, sampleScreenPos.z);","float zOrigin = toViewPos(sampleScreenPos.xy).z;","if (abs(1.0 - hit.z / zOrigin) < 1e-2) {","hitDistance = length(hit - origin);","outColor = sampleColorScene(sampleScreenPos.xy);","}","break;","} else {","ray_marching_step *= 0.5;","j -= ray_marching_step;","}","} else {","j += (0.5 + 0.5 * Random1D(float(renderIteration) + j)) * ray_marching_step;","}","}","return outColor;","}","void main() {","vec2 screenPos = vUv;","gl_FragColor = vec4(0.0);","vec4 normalDepth = texture2D(tNormalDepthIoRRoughness, vUv);",o(!1),"}"].join("\n")},r={uniforms:a,defines:{RAYMARCHING_STEPS:16},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;",t,"vec4 RayMarchNew(vec3 origin, vec3 direction, out float hitDistance) {","direction = normalize(direction);","vec4 outColor = vec4(0.0);","hitDistance = sceneSize;","float t = ClipByFrustum(origin, direction);","float maxRayLength = min(t, sceneSize);","vec3 director = maxRayLength * direction;","vec3 endPos = origin + director;","vec3 uviz0 = getScreenPos3(origin);","vec3 uviz1 = getScreenPos3(endPos);","vec2 uvDir = uviz1.xy - uviz0.xy;","float nbSteps = length(screenSize * uvDir);","if (nbSteps < 1.0) {","vec3 curPt = toViewPos(uviz1.xy);","vec3 curOnSegment = toViewPos(uviz1.xy, uviz1.z);","if (curPt.z > curOnSegment.z) {","hitDistance = length(curPt - origin);","outColor = sampleColorScene(uviz1.xy);","}","return outColor;","}","nbSteps = ceil(nbSteps);","float j = 0.0;","float prevDepth = 1.0;","float prevSegmentDepth = 1.0;","for (int i = 0; i < 1024; i++) {","vec3 sampleScreenPos = mix(uviz0, uviz1, j / nbSteps);","vec3 curOnSegment = toViewPos(sampleScreenPos.xy, sampleScreenPos.z);","vec3 curPt = toViewPos(sampleScreenPos.xy);","if (abs(1.0 - curPt.z/curOnSegment.z) < 5e-3) {","hitDistance = length(curPt - origin);","outColor = sampleColorScene(sampleScreenPos.xy);","break;","}","else if (prevSegmentDepth >= prevDepth && curOnSegment.z <= curPt.z) {","hitDistance = length(curPt - origin);","vec3 sampleScreenPosToUse = mix(uviz0, uviz1, (j - 1.0) / nbSteps);","outColor = sampleColorScene(sampleScreenPosToUse.xy);","break;","}","prevDepth = curPt.z;","prevSegmentDepth = curOnSegment.z;","if (j >= nbSteps) { break; }","j += 1.0;","}","return outColor;","}","void main() {","vec2 screenPos = vUv;","gl_FragColor = vec4(0.0);","vec4 normalDepth = texture2D(tNormalDepthIoRRoughness, vUv);","float ior = normalDepth.y;","if (ior < 1.0) {","return;","}",o(!0),"}"].join("\n")},n={uniforms:{tMip0:{type:"t",value:null},tMip1:{type:"t",value:null},tMip2:{type:"t",value:null},tMip3:{type:"t",value:null},tMip4:{type:"t",value:null},tMip5:{type:"t",value:null},tMip6:{type:"t",value:null},tMip7:{type:"t",value:null},sceneSize:{type:"f",value:100},renderIteration:{type:"i",value:0},tNormalDepthIoRRoughness:{type:"t",value:null},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4}},defines:{RAYMARCHING_STEPS:16},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n")},l=["uniform sampler2D tMip0;","uniform sampler2D tMip1;","uniform sampler2D tMip2;","uniform sampler2D tMip3;","uniform sampler2D tMip4;","uniform sampler2D tMip5;","uniform sampler2D tMip6;","uniform sampler2D tMip7;","uniform float sceneSize;","uniform int renderIteration;","uniform sampler2D tNormalDepthIoRRoughness;","uniform mat4 realProjectionMatrixInverse;","varying vec2 vUv;","vec3 toViewPos(vec2 uv, float depth) {","vec4 vertexPositionProjected = vec4(uv * 2.0 - 1.0, depth, 1.0);","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","vertexPositionVS.w = 1.0;","return vertexPositionVS.xyz;","}","vec2 mipValues = vec2(0.0,0.0);","vec4 sampleScene(vec2 uv) {","if (mipValues.x == 0.0) {return mix(texture2D(tMip0, uv), texture2D(tMip1, uv), mipValues.y);}","if (mipValues.x == 1.0) {return mix(texture2D(tMip1, uv),texture2D(tMip2, uv), mipValues.y);}","if (mipValues.x == 2.0) {return mix(texture2D(tMip2, uv),texture2D(tMip3, uv), mipValues.y);}","if (mipValues.x == 3.0) {return mix(texture2D(tMip3, uv),texture2D(tMip4, uv), mipValues.y);}","if (mipValues.x == 4.0) {return mix(texture2D(tMip4, uv),texture2D(tMip5, uv), mipValues.y);}","if (mipValues.x == 5.0) {return mix(texture2D(tMip5, uv),texture2D(tMip6, uv), mipValues.y);}","if (mipValues.x == 6.0) {return mix(texture2D(tMip6, uv),texture2D(tMip7, uv), mipValues.y);}","if (mipValues.x == 7.0) {return texture2D(tMip7, uv);}","return texture2D(tMip7, uv);","}"].join("\n"),s=["float roughness = normalDepth.z;","mipValues.x = 7.0 * pow(roughness, renderIteration > 2 ? 1.8 : 0.8);","mipValues.y = fract(mipValues.x);","mipValues.x = floor(mipValues.x);","gl_FragColor = sampleScene(vUv);"].join("\n");return{SSLRefraction:r,SSLRefractionMipSolver:Object.assign({fragmentShader:[l,"void main() {","vec2 screenPos = vUv;","gl_FragColor = vec4(0.0);","vec4 normalDepth = texture2D(tNormalDepthIoRRoughness, vUv);","float ior = normalDepth.y;","if (ior < 1.0) {","return;","}",s,"}"].join("\n")},n),SSLReflectionMipSolver:Object.assign({fragmentShader:[l,"void main() {","vec2 screenPos = vUv;","gl_FragColor = vec4(0.0);","vec4 normalDepth = texture2D(tNormalDepthIoRRoughness, vUv);",s,"}"].join("\n")},n),SSLReflection:i}}),define("DS/Shaders/CopyShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")}}),define("Shaders/CopyShader",["DS/Shaders/CopyShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/CopyShader"),e}),define("DS/Shaders/CompositeShader",[],function(){"use strict";return{defines:{USE_BLOOM:0},uniforms:{tDiffuse:{type:"t",value:null},gradingMap:{type:"t",value:null},gradingDepth:{type:"f",value:16},brightness:{type:"f",value:0},tAutoExposure:{type:"t",value:null},fAutoExposure:{type:"f",value:1},gamma:{type:"f",value:2.2},crushblacks:{type:"f",value:0},burnhighlights:{type:"f",value:0},saturation:{type:"f",value:1},colorCorrection:{type:"v3",value:{x:1,y:1,z:1}},power:{type:"f",value:0},sensorSize:{type:"f",value:35},screenRatio:{type:"f",value:1},focalLength:{type:"f",value:38.6}},fragmentShader:["varying vec2 texCoord;","uniform sampler2D tDiffuse;","uniform float brightness;","#if(USE_AUTO_EXPOSURE > 0)","\tuniform sampler2D tAutoExposure;","\tuniform float fAutoExposure;","#endif","#if defined( COLOR_GRADING )","uniform sampler2D gradingMap;","uniform float gradingDepth;","#endif","uniform float gamma;","uniform float crushblacks;","uniform float burnhighlights;","uniform float saturation;","uniform vec3 colorCorrection;","uniform float power;","uniform float sensorSize;","uniform float screenRatio;","uniform float focalLength;","#if defined (TONEMAP_FILMIC)","\t#define FILMIC_NRE_A 0.22","\t#define FILMIC_NRE_B 0.3","\t#define FILMIC_NRE_C 0.1","\t#define FILMIC_NRE_D 0.2","\t#define FILMIC_NRE_E 0.01","\t#define FILMIC_NRE_F 0.3","\t#define FILMIC_NRE_W 11.2","#endif","#if defined (TONEMAP_PHOTOGRAPHIC)","   float luminance_RGB (vec3 iColor) {","\t\tvec3 luminance_weight=vec3(0.176204,0.812985,0.0108109);","\t\treturn dot(iColor,luminance_weight);","\t}","#endif","#ifdef TONEMAP_UNCHARTED","   const float A = 0.15;","   const float B = 0.50;","   const float C = 0.10;","   const float D = 0.20;","   const float E = 0.02;","   const float F = 0.30;","   const float W = 11.2;","   vec3 Uncharted2Tonemap( vec3 x ) {","       return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;","   }","#endif","float dither = 0.004;","float random(vec3 scale, float seed) {","  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","vec3 Random3D(float seed) {","vec3 res;","res.x = random(vec3(12.9898, 78.233, 151.7182), seed);","res.y = random(vec3(63.7264, 10.873, 623.6736), seed);","res.z = random(vec3(125.5736, 34.485, 437.2873), seed);","return res;","}","vec4 chromaticAberration(const in sampler2D tex, const in vec2 uv, const in float factor) {","vec2 dist = uv - 0.5;","vec2 offset = factor * dist * length(dist);","vec4 col;","col.r  = texture2D(tex, uv - offset).r;","col.ga = texture2D(tex, uv).ga;","col.b  = texture2D(tex, uv + offset).b;","return col;","}","float RGBToL(const in vec3 color) {","float fmin = min(min(color.r, color.g), color.b);","float fmax = max(max(color.r, color.g), color.b);","return (fmax + fmin) / 2.0;","}","vec3 colorBalance(const in vec3 color, const in vec3 lrgb, const in vec3 mrgb, const in vec3 hrgb) {","float lightness = RGBToL(color);","lightness = (1.5 * lightness) / (lightness + 0.5);","float a = 0.25;","float b = 0.333;","float scale = 0.7;","vec3 low = lrgb * clamp((lightness - b) / -a + 0.5, 0.0, 1.0);","vec3 mid = mrgb * clamp((lightness - b) / a + 0.5, 0.0, 1.0) * clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0);","vec3 high = hrgb * clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0);","vec3 newColor = color + (low + mid + high) * scale;","newColor = clamp(newColor, 0.0, 1.0);","return normalize(newColor) * length(color);","}","void main() {","   vec4 inColorAlpha = texture2D( tDiffuse, texCoord );","   vec3 inColor = inColorAlpha.xyz;","inColor *= pow(2.0,brightness);","#if (USE_AUTO_EXPOSURE > 0)","\tvec2 ae_uv = vec2(0.0);","\tvec2 sums = vec2(0.0);","\tfor(int i = 0;i < USE_AUTO_EXPOSURE;i++){","\t\tae_uv.x = (0.5+float(i))/float(USE_AUTO_EXPOSURE);","\t\tfor(int j = 0;j < USE_AUTO_EXPOSURE;j++){","\t\t\tae_uv.y = (0.5+float(j))/float(USE_AUTO_EXPOSURE);","\t\t\tsums += texture2D(tAutoExposure,ae_uv).rg;","\t\t}","\t}","\tfloat fAuto = 0.2176/exp(sums.x/sums.y);","\tinColor *=fAuto;","#endif","vec2 pos = texCoord - 0.5;","pos.y = pos.y * screenRatio;"," float f2 = focalLength*focalLength;"," float s2 = sensorSize*sensorSize;"," float vignetting = pow(f2/(s2*(pos.x*pos.x+pos.y*pos.y)+f2),power);"," inColor = inColor * vignetting;"," inColorAlpha.a = max(inColorAlpha.a, (1.0-sqrt(vignetting)));","   vec3 outColor;","   #if defined( TONEMAP_REINHARD )","       outColor = inColor / ( 1.0 + inColor );","   #elif defined( TONEMAP_FILMIC )","\t\tvec4 tmpCol = vec4(inColor.xyz, FILMIC_NRE_W);","\t\ttmpCol = ((tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_C*FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_E)","\t\t/(tmpCol*(FILMIC_NRE_A*tmpCol+FILMIC_NRE_B)+FILMIC_NRE_D*FILMIC_NRE_F))","\t\t-FILMIC_NRE_E/FILMIC_NRE_F;","\t\toutColor = tmpCol.xyz/tmpCol.w;","   #elif defined( TONEMAP_UNCHARTED )","       float ExposureBias = 2.0;","       vec3 curr = Uncharted2Tonemap( ExposureBias * inColor );","       vec3 whiteScale = vec3( 1.0 ) / Uncharted2Tonemap( vec3( W ) );","       vec3 color = curr * whiteScale;","   #elif defined( TONEMAP_PHOTOGRAPHIC )","\t\tvec3 c = inColor.xyz * colorCorrection;","\t\tc *= (c*burnhighlights+1.0)/(c+1.0); ","\t\tc = mix(vec3(luminance_RGB(c)),c,saturation);","\t\tfloat intens = luminance_RGB(c);","\t\tif(intens<1.0){","\t\t\tfloat _crushblacks = 2.0* crushblacks +1.0;","\t\t\tintens = sqrt(intens);","\t\t\tfloat oms2 = 1.0 - intens;"," \t\t\tc.x = c.x*intens + pow(c.x,_crushblacks)*oms2;","\t\t\tc.y = c.y*intens + pow(c.y,_crushblacks)*oms2;"," \t\t\tc.z = c.z*intens + pow(c.z,_crushblacks)*oms2;","\t\t}","\t\toutColor = c;","   #else","       outColor = inColor;","   #endif","#if defined( GAMMA_SIMPLE )","   outColor = sqrt( outColor );","#elif defined( GAMMA_CORRECTION )","\toutColor = pow( outColor, vec3( 1.0 / gamma ) );","#elif defined( SRGB_CORRECTION )","\toutColor.r = (outColor.r < 0.0031308)    ? (outColor.r*12.92) : 1.055*pow(outColor.r,1.0/2.4)-0.055;","\toutColor.g = (outColor.g < 0.0031308)    ? (outColor.g*12.92) : 1.055*pow(outColor.g,1.0/2.4)-0.055;","\toutColor.b = (outColor.b < 0.0031308)    ? (outColor.b*12.92) : 1.055*pow(outColor.b,1.0/2.4)-0.055;","#endif","#if defined( COLOR_GRADING )","\tfloat threshold = (gradingDepth-1.0)/gradingDepth;","\tfloat halfTexelOffset = 0.5/gradingDepth;","\tfloat r = clamp (outColor.r,0.0,1.0) * threshold + halfTexelOffset;","\tfloat g = clamp (outColor.g,0.0,1.0) * threshold + halfTexelOffset;","\tfloat b = clamp (outColor.b,0.0,1.0) *(gradingDepth - 1.0);","   float bFloor = floor(b);","   float bFract = b-bFloor;","\tvec2 uv1 = vec2((bFloor+r)/(gradingDepth),g);","\tvec2 uv2 = vec2((bFloor+1.0+r)/(gradingDepth),g);","\tvec3 c1 = texture2D(gradingMap,uv1).rgb;","\tvec3 c2 = texture2D(gradingMap,uv2).rgb;","\toutColor = bFract*c2+(1.0-bFract)*c1;","\tvec2 uvtest = vec2((15.0+0.5/16.0)/16.0,0.5/16.0);","#endif","   outColor += 2.0 * dither * (Random3D(texCoord.x + texCoord.y) - vec3(0.5));","   gl_FragColor = vec4( outColor, inColorAlpha.a );","}"].join("\n"),vertexShader:["varying vec2 texCoord;","void main() {","   vec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );","   texCoord = pos.xy * vec2( 0.5 ) + 0.5;","   gl_Position = pos;","}"].join("\n")}}),define("Shaders/CompositeShader",["DS/Shaders/CompositeShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/CompositeShader"),e}),define("DS/Shaders/StereoShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{leftRight:{uniforms:{tLeftEye:{type:"t",value:null},tRightEye:{type:"t",value:null},tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform sampler2D tLeftEye;","uniform sampler2D tRightEye;","void main() {","if(vUv.x < 0.5) {","gl_FragColor = texture2D(tLeftEye, vec2(vUv.x*2.0, vUv.y));","} else {","gl_FragColor = texture2D(tRightEye, vec2((vUv.x-0.5)*2.0, vUv.y));","}","} "].join("\n")},anaglyph:{uniforms:{tLeftEye:{type:"t",value:null},tRightEye:{type:"t",value:null},tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform sampler2D tLeftEye;","uniform sampler2D tRightEye;","void main() {","vec4 cr = texture2D(tLeftEye, vUv);","vec4 cl = texture2D(tRightEye, vUv);","gl_FragColor = vec4(cl.r, cr.g, cr.b, 1.0);","} "].join("\n")},oculusDK1:{uniforms:{tLeftEye:{type:"t",value:null},tRightEye:{type:"t",value:null},tDiffuse:{type:"t",value:null},scale:{type:"v2",value:new e.Vector2(1,1)},scaleIn:{type:"v2",value:new e.Vector2(1,1)},leftLensCenter:{type:"v2",value:new e.Vector2(0,0)},hmdWarpParam:{type:"v4",value:new e.Vector4(1,0,0,0)},chromAbParam:{type:"v4",value:new e.Vector4(1,0,0,0)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform sampler2D tLeftEye;","uniform sampler2D tRightEye;","uniform vec2 scale;","uniform vec2 scaleIn;","uniform vec2 leftLensCenter;","uniform vec4 hmdWarpParam;","uniform vec4 chromAbParam;","void main() {","  if(vUv.x >= 0.5) {","    vec2 lensCenter = leftLensCenter;","    vec2 uv = (vec2((vUv.x-0.5)*2.0, vUv.y)*2.0)-1.0;","    vec2 theta = (uv-lensCenter)*scaleIn;","    float rSq = theta.x*theta.x + theta.y*theta.y;","    vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);","    vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);","    vec2 tcBlue = (lensCenter + scale * rBlue);","    tcBlue = (tcBlue+1.0)/2.0;","    if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {","      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","      return;}","    vec2 tcGreen = lensCenter + scale * rvector;","    tcGreen = (tcGreen+1.0)/2.0;","    vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);","    vec2 tcRed = lensCenter + scale * rRed;","    tcRed = (tcRed+1.0)/2.0;","    gl_FragColor = vec4(texture2D(tLeftEye, tcRed).r, texture2D(tLeftEye, tcGreen).g, texture2D(tLeftEye, tcBlue).b, 1.0);","  } else {","    vec2 lensCenter = -leftLensCenter;","    vec2 uv = (vec2(vUv.x*2.0, vUv.y)*2.0)-1.0;","    vec2 theta = (uv-lensCenter)*scaleIn;","    float rSq = theta.x*theta.x + theta.y*theta.y;","    vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);","    vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);","    vec2 tcBlue = (lensCenter + scale * rBlue);","    tcBlue = (tcBlue+1.0)/2.0;","    if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {","      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","      return;}","    vec2 tcGreen = lensCenter + scale * rvector;","    tcGreen = (tcGreen+1.0)/2.0;","    vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);","    vec2 tcRed = lensCenter + scale * rRed;","    tcRed = (tcRed+1.0)/2.0;","    gl_FragColor = vec4(texture2D(tRightEye, tcRed).r, texture2D(tRightEye, tcGreen).g, texture2D(tRightEye, tcBlue).b, 1.0);","  }","} "].join("\n")},oculusDK2:{uniforms:{tEye:{type:"t",value:null},tDiffuse:{type:"t",value:null},eyeToSourceUVScale:{type:"v2",value:new e.Vector2(.33333333,.3333333)},eyeToSourceUVOffset:{type:"v2",value:new e.Vector2(.5,.5)}},vertexShader:["varying vec2 uvr;","varying vec2 uvg;","varying vec2 uvb;","uniform vec2 eyeToSourceUVScale;","uniform vec2 eyeToSourceUVOffset;","void main() {","uvr = uv.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvg = uv2.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvb = _DStangent.xy * eyeToSourceUVScale + eyeToSourceUVOffset;","uvr.y = 1.0 - uvr.y;","uvg.y = 1.0 - uvg.y;","uvb.y = 1.0 - uvb.y;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["varying vec2 uvr;","varying vec2 uvg;","varying vec2 uvb;","uniform sampler2D tDiffuse;","uniform sampler2D tEye;","void main() {","gl_FragColor = vec4(texture2D(tEye, uvr).r, texture2D(tEye, uvg).g, texture2D(tEye, uvb).b, 1.0);","} "].join("\n")}}}),define("Shaders/MirrorShaders",["DS/Shaders/MirrorShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/MirrorShaders"),e}),define("DS/Shaders/FlipXShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","    gl_FragColor = texture2D(tDiffuse, vec2(1.0 - vUv.x, vUv.y));","}"].join("\n")}}),define("DS/Shaders/MLAAShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{EdgeDetection:{uniforms:{tDiffuse:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["varying vec2 vUv;","varying vec4 offset[3];","uniform float screenHeight;","uniform float screenWidth;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","    vUv = uv;","    offset[0] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-1.0, 0.0, 0.0, 1.0);","    offset[1] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4( 1.0, 0.0, 0.0,-1.0);","    offset[2] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-2.0, 0.0, 0.0, -2.0);",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform float screenHeight;","uniform float screenWidth;","uniform sampler2D tDiffuse;","varying vec2 vUv;","varying vec4 offset[3];","const float threshold = 0.1;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","    vec3 weights = vec3(0.2126,0.7152, 0.0722);","    float L = dot(texture2D(tDiffuse, vUv.xy).rgb, weights);","    float Lleft = dot(texture2D(tDiffuse, offset[0].xy).rgb, weights);","    float Ltop = dot(texture2D(tDiffuse, offset[0].zw).rgb, weights);","    float Lright = dot(texture2D(tDiffuse, offset[1].xy).rgb, weights);","    float Lbottom = dot(texture2D(tDiffuse, offset[1].zw).rgb, weights);","    vec4 delta = abs(vec4(L) - vec4(Lleft, Ltop, Lright, Lbottom));","    vec4 edges = step(vec4(threshold), delta);","    gl_FragColor = edges;","    gl_FragColor.ba = vec2(0.0,1.0);","}"].join("\n")},BlendingWeights:{uniforms:{tDiffuse:{type:"t",value:null},areaTex:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["varying vec2 vUv;","uniform float screenHeight;","uniform float screenWidth;","void main() {","    vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D areaTex;","uniform float screenHeight;","uniform float screenWidth;","varying vec2 vUv;","const int   MAX_SEARCH_STEPS = 7;","const int   MAX_DISTANCE     = 16;","vec2 SMAA_PIXEL_SIZE;","vec4 tex2DLod(sampler2D map, vec2 texcoord, float offset) {","    return texture2D(map, texcoord );","}","float SearchXLeft(vec2 texcoord) {","    int j;","    texcoord -= vec2(1.5, 0.0) * SMAA_PIXEL_SIZE;","    float g = 0.0;","    for (int i = 0; i < MAX_SEARCH_STEPS; i++) {","        j = i;","        g = texture2D(tDiffuse, texcoord).g;","        if (g < 0.9) break;","        texcoord -= vec2(2.0, 0.0) * SMAA_PIXEL_SIZE;","    }","    return max(-2.0 * float(j) - 2.0 * g, -2.0 * float(MAX_SEARCH_STEPS));","}","float SearchXRight(vec2 texcoord) {","    int j;","    texcoord += vec2(1.5, 0.0) * SMAA_PIXEL_SIZE;","    float g = 0.0;","    for(int i = 0; i < MAX_SEARCH_STEPS; i++) {","        j = i;","        g = texture2D(tDiffuse, texcoord).g;","        if (g < 0.9) break;","        texcoord += vec2(2.0, 0.0) * SMAA_PIXEL_SIZE;","    }","    return min(2.0 * float(j) + 2.0 * g, 2.0 * float(MAX_SEARCH_STEPS));","}","float SearchYUp(vec2 texcoord) {","    int j;","    texcoord += vec2(0.0, 1.5) * SMAA_PIXEL_SIZE;","    float r = 0.0;","    for(int i = 0; i < MAX_SEARCH_STEPS; i++) {","        j = i;","        r = texture2D(tDiffuse, texcoord).r;","        if (r < 0.9) break;","        texcoord += vec2(0.0, 2.0) * SMAA_PIXEL_SIZE;","    }","    return min(2.0 * float(j) + 2.0 * r, 2.0 * float(MAX_SEARCH_STEPS));","}","float SearchYDown(vec2 texcoord) {","    int j;","    texcoord -= vec2(0.0, 1.5) * SMAA_PIXEL_SIZE;","    float r = 0.0;","    for(int i = 0; i < MAX_SEARCH_STEPS; i++) {","        j = i;","        r = texture2D(tDiffuse, texcoord).r;","        if (r < 0.9) break;","        texcoord -= vec2(0.0, 2.0) * SMAA_PIXEL_SIZE;","    }","    return max(-2.0 * float(j) - 2.0 * r, -2.0 * float(MAX_SEARCH_STEPS));","}","vec2 _round(vec2 invec) {","    return vec2(floor(abs(invec) + vec2(0.5)) * sign(invec));","}","vec2 Area(vec2 distance, float e1, float e2) {","    float areaSize = float(MAX_DISTANCE) * 5.0;","    vec2 pixcoord = float(MAX_DISTANCE) * ","                    _round(4.0 * vec2(e1, e2)) ","                    + distance + vec2(0.5);","    vec2 texcoord = pixcoord / areaSize;","    return tex2DLod(areaTex, vec2(texcoord.x, 1.0 - texcoord.y), 0.0).rg;","}","void main() {","SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","    vec4 weights = vec4(0.0, 0.0, 0.0, 0.0);","    vec2 e = texture2D(tDiffuse, vUv).rg;","    vec2 d;","    if (e.g != 0.0) { ","        d = vec2(SearchXLeft(vUv), SearchXRight(vUv));","        vec4 coords = vec4(d.x, 0.25, d.y + 1.0, 0.25) * SMAA_PIXEL_SIZE.xyxy + vUv.xyxy;","        float e1 = tex2DLod(tDiffuse, coords.xy, 0.0).r;","        float e2 = tex2DLod(tDiffuse, coords.zw, 0.0).r;","        weights.rg = Area(abs(d), e1, e2);","    }","    if (e.r != 0.0) {","        d = vec2(SearchYUp(vUv), SearchYDown(vUv));","        vec4 coords = vec4(-0.25, d.x, -0.25, d.y - 1.0) * SMAA_PIXEL_SIZE.xyxy + vUv.xyxy;","        float e1 = texture2D(tDiffuse, coords.xy).g;","        float e2 = texture2D(tDiffuse, coords.zw).g;","        weights.ba = Area(abs(d), e1, e2);","    }","    gl_FragColor = clamp(weights, 0.0, 1.0);","}"].join("\n")},FinalBlending:{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["varying vec2 vUv;","void main() {","    vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","uniform float screenHeight;","uniform float screenWidth;","varying vec2 vUv;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","    vec4 topLeft = texture2D(tDiffuse2, vUv);","    float bottom = texture2D(tDiffuse2, vUv + vec2(0.0, -1.0) * SMAA_PIXEL_SIZE).g;","    float right = texture2D(tDiffuse2, vUv + vec2(1.0, 0.0) * SMAA_PIXEL_SIZE).a;","    vec4 a = vec4(topLeft.r, bottom, topLeft.b, right);","    vec4 w = a * a * a;","    float sum = dot(w, vec4(1.0));","    if (sum > 0.0) {","        vec4 o = a * SMAA_PIXEL_SIZE.yyxx;","        vec4 color = vec4(0.0);","        color = texture2D(tDiffuse, vUv + vec2( 0.0,  o.r)) * w.r + color;","        color = texture2D(tDiffuse, vUv + vec2( 0.0, -o.g)) * w.g + color;","        color = texture2D(tDiffuse, vUv + vec2(-o.b,  0.0)) * w.b + color;","        color = texture2D(tDiffuse, vUv + vec2( o.a,  0.0)) * w.a + color;","        gl_FragColor = color / sum;","    } else {","        gl_FragColor = texture2D(tDiffuse, vUv);","    }","}"].join("\n")}}}),define("Shaders/MLAAShaders",["DS/Shaders/MLAAShaders","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/MLAAShaders"),e}),define("DS/Shaders/OITShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{SolveAndBlendShader:{defines:{POSTPRO:1},uniforms:{tOpaque:{type:"t",value:null},tAccum:{type:"t",value:null},tReveal:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","   vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#if (POSTPRO == 1)","uniform sampler2D tOpaque;","#endif","uniform sampler2D tReveal;","uniform sampler2D tAccum;","const float inf = 1e6;","bool _isinf(float n){","   return abs(n) == inf;","}","const float threshold = 1e-6;","varying vec2 vUv;","float maxComponent(vec4 iVector) {","   return max(iVector.r,max(iVector.g,max(iVector.b,iVector.a)));","}","void main() {","#if (POSTPRO == 1)","vec4 opaque = texture2D(tOpaque, vUv);","#else","vec4 opaque = vec4(0.0);","#endif","   float reveal = texture2D(tReveal, vUv).r;","   if (reveal > 1.0 - threshold) {","       gl_FragColor = opaque;","       return;","   }","   vec4 accum = texture2D(tAccum, vUv);","   if (_isinf(maxComponent(abs(accum)))){","       accum.rgb = vec3(max(accum.a,threshold));","   }","   vec3 avgCol = accum.rgb / max(accum.a,threshold);","#if (POSTPRO == 1)","   gl_FragColor = vec4(avgCol * (1.0 - reveal) + reveal * opaque.rgb, 1.0 - reveal + opaque.a * reveal);","#else","   gl_FragColor = vec4(avgCol, 1.0 - reveal);","#endif","}"].join("\n")},SolveShader:{uniforms:{tAccum:{type:"t",value:null},tReveal:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","   vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tReveal;","uniform sampler2D tAccum;","const float inf = 1e6;","bool _isinf(float n){","   return abs(n) == inf;","}","const float threshold = 1e-6;","varying vec2 vUv;","float maxComponent(vec4 iVector) {","   return max(iVector.r,max(iVector.g,max(iVector.b,iVector.a)));","}","void main() {","vec4 opaque = vec4(0.0);","   float reveal = texture2D(tReveal, vUv).r;","   if (reveal > 1.0 - threshold) {","       gl_FragColor = opaque;","       return;","   }","   vec4 accum = texture2D(tAccum, vUv);","   if (_isinf(maxComponent(abs(accum)))){","       accum.rgb = vec3(max(accum.a,threshold));","   }","   vec3 avgCol = accum.rgb / max(accum.a,threshold);","   gl_FragColor = vec4(avgCol, 1.0 - reveal);","}"].join("\n")},BlendShader:{uniforms:{tTransparents:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","   vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tTransparents;","varying vec2 vUv;","void main() {","gl_FragColor = texture2D(tTransparents, vUv);","}"].join("\n")}}}),define("Shaders/OITShader",["DS/Shaders/OITShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/OITShader"),e}),define("DS/Shaders/VolumeRenderingShaders",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{RenderChunk:{defines:{RANDOM_STEP:!0,USE_CLIP_PLANE:!1,ISO_SURFACE:0,MAX_STEPS:"256",CHUNK_SIZE:"64.0",MAP_INVSIZE:"0.001953125"},uniforms:{tDiffuse:{type:"t",value:null},prevMap:{type:"t",value:null},tNormalDepth:{type:"t",value:null},tRandomTexture:{type:"t",value:null},nbCol:{type:"i",value:0,stage:e.FragmentStage},map0:{type:"t2",value:null},mapDim:{type:"v3",value:new e.Vector3},minDisplayValue:{type:"f",value:0},maxDisplayValue:{type:"f",value:1},rangeDisplayValue:{type:"f",value:1},minTileValue:{type:"f",value:0},maxTileValue:{type:"f",value:1},rangeTileValue:{type:"f",value:1},isoValue:{type:"f",value:.1},uTMK:{type:"f",value:128},attenuationCoeff:{type:"f",value:.01},attenuationScale:{type:"f",value:1},colorCoeff:{type:"v4",value:new e.Vector4(.737,.573,.4,1)},colorMap:{type:"t",value:null},transferFctMap:{type:"t",value:null},gridSize:{type:"v3",value:new e.Vector3},modelMatrixInv:{type:"m4",value:new e.Matrix4},realProjectionMatrix:{type:"m4",value:new e.Matrix4},realProjectionMatrixInverse:{type:"m4",value:new e.Matrix4},realModelViewMatrix:{type:"m4",value:new e.Matrix4},realModelViewMatrixInverse:{type:"m4",value:new e.Matrix4},clipPlaneEquation:{type:"v4",value:new e.Vector4},debugChunkBox:{type:"v4",value:new e.Vector4(0,0,0,0)},renderIteration:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#define TM_MIN 0.05","#define EPS 0.0001","#define PI 3.14159265","#define HALFPI 1.57079633","#define ROOTTHREE 1.73205081","uniform sampler2D tDiffuse;","uniform sampler2D prevMap;","uniform sampler2D tNormalDepth;","uniform sampler2D tRandomTexture;","uniform mat4 realProjectionMatrixInverse;","uniform mat4 realModelViewMatrix;","uniform mat4 realModelViewMatrixInverse;","#if defined(USE_CLIP_PLANE)","uniform vec4 clipPlaneEquation;","#endif","uniform vec3 gridSize;","uniform float uTMK;","uniform float attenuationCoeff;","uniform float attenuationScale;","uniform vec4 colorCoeff;","uniform sampler2D colorMap;","uniform sampler2D transferFctMap;","uniform int nbCol;","uniform vec3 mapDim;","uniform sampler2D map0;","uniform float minDisplayValue;","uniform float maxDisplayValue;","uniform float rangeDisplayValue;","uniform float minTileValue;","uniform float maxTileValue;","uniform float rangeTileValue;","uniform float isoValue;","uniform vec4 debugChunkBox;","uniform float renderIteration;","varying vec2 vUv;","float stepSize;","float stepSizeModel;","float depthVS;","const vec3 weight = vec3(1.0, 0.32, 0.08);","const vec3 lightColor = vec3(1.0, 1.0, 1.0);","const vec3 lightPos = vec3(100.0, 100.0, 100.0);","const float shininess = 40.0;","float random(vec3 scale, float seed) {","  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","float Random1D(float seed) {","return random(vec3(12.9898, 78.233, 151.7182), seed);","}","float getStepOffset() {","    return (Random1D(gl_FragCoord.x * gl_FragCoord.y) - 0.5);","}","float getStepOffset(float ii) {","    return (Random1D(gl_FragCoord.x * gl_FragCoord.y * ii) - 0.5);","}","float modI(float a, float b) {","float m = a - floor((a + 0.5) / b) * b;","return floor(m + 0.5);","}","vec3 precomputeRandom1D(vec2 coords, float ii) {","vec2 s = 0.2 * (vec2(modI(coords.x+ii*ii, 5.0), modI(coords.y+ii, 5.0)) + 0.5);","return texture2D(tRandomTexture, s).xyz;","}","float fetchDepthVS(const in vec2 uv) {","    float depth = texture2D(tNormalDepth, uv).w;","if (depth == 0.0) { depth = 1.0; };","vec4 vertexPositionProjected = vec4(uv * 2.0 - 1.0, 2.0 * depth - 1.0, 1.0);","vec4 vertexPositionVS = realProjectionMatrixInverse * vertexPositionProjected;","vertexPositionVS.xyz /= vertexPositionVS.w;","return vertexPositionVS.z;","}","float sampleVolTex(vec3 pos) {","float rowID = floor(pos.z / float(nbCol));","float rowID2 = rowID;","float colID = mod(floor(pos.z), float(nbCol));","float colID2 = mod(ceil(pos.z), float(nbCol));","if (colID2 == 0.0) { rowID2 = rowID2 + 1.0; }","float x1 = colID  * CHUNK_SIZE + pos.x + 0.5;","float x2 = colID2 * CHUNK_SIZE + pos.x + 0.5;","float y1 = rowID  * CHUNK_SIZE + pos.y + 0.5;","float y2 = rowID2 * CHUNK_SIZE + pos.y + 0.5;","vec2 mapUV  = vec2(x1 * MAP_INVSIZE, 1.0 - y1 * MAP_INVSIZE);","vec2 mapUV2 = vec2(x2 * MAP_INVSIZE, 1.0 - y2 * MAP_INVSIZE);","float alpha1 = texture2D(map0, mapUV).a;","float alpha2 = texture2D(map0, mapUV2).a;","return mix(alpha1, alpha2, fract(pos.z));","}","vec4 raymarch(vec3 ro, vec3 rd, vec4 prevData) {","vec3 ratio = (mapDim - vec3(1.0)) / gridSize;","#if defined(RANDOM_STEP)","float offset = 1.0 + 0.8 * getStepOffset(renderIteration);","#else","float offset = 1.0;","#endif","vec3 posModel = ro;","vec3 posGrid = (ro + 0.5 * gridSize) * ratio;","vec3 stepModel = offset * rd * stepSizeModel;","vec3 stepGrid = stepModel * ratio;","vec3 col = prevData.rgb;","float tm = prevData.a;","for (int i=0; i<MAX_STEPS; ++i) {","vec4 posVS = realModelViewMatrix * vec4(posModel, 1.0);","if (posVS.z < depthVS) { break; }","#if defined(USE_CLIP_PLANE)","float clipDist = dot(posVS.xyz, clipPlaneEquation.xyz) + clipPlaneEquation.w;","if (clipDist >= 0.0) {","#endif","float normalizedDensity = sampleVolTex(posGrid.xyz);","float density = minTileValue + normalizedDensity * rangeTileValue;","float remappedDensity = (density - minDisplayValue) / rangeDisplayValue;","remappedDensity = min(max(remappedDensity, 0.0028), 0.997);","vec3 color = texture2D(colorMap, vec2(remappedDensity, 0.5)).rgb;","float opacity = texture2D(transferFctMap, vec2(remappedDensity, 0.5)).r;","opacity *= step(minDisplayValue, density) * step(-maxDisplayValue, -density);","float dtm = exp( -uTMK * stepSizeModel * attenuationCoeff * attenuationScale * opacity );","tm *= dtm;","col += (1.0 - dtm) * color * tm;","#if defined(USE_CLIP_PLANE)","}","#endif","posGrid += stepGrid;","posModel += stepModel;","if (tm < 0.0 || posGrid.x > mapDim.x - 1.0 || posGrid.x < 0.0 || posGrid.y > mapDim.y - 1.0 || posGrid.y < 0.0 || posGrid.z > mapDim.z - 1.0 || posGrid.z < 0.0)","break;","}","return vec4(col, tm);","}","vec4 add_lighting(float value, vec3 loc, vec3 step, vec3 rd) {","vec3 V = normalize(rd);","vec3 N;","float val1, val2;","val1 = sampleVolTex(loc + vec3(-step[0], 0.0, 0.0));","val2 = sampleVolTex(loc + vec3(+step[0], 0.0, 0.0));","N[0] = val1 - val2;","value = max(max(val1, val2), value);","val1 = sampleVolTex(loc + vec3(0.0, -step[1], 0.0));","val2 = sampleVolTex(loc + vec3(0.0, +step[1], 0.0));","N[1] = val1 - val2;","value = max(max(val1, val2), value);","val1 = sampleVolTex(loc + vec3(0.0, 0.0, -step[2]));","val2 = sampleVolTex(loc + vec3(0.0, 0.0, +step[2]));","N[2] = val1 - val2;","value = max(max(val1, val2), value);","float gm = length(N);","N = normalize(N);","float Nselect = float(dot(N, rd) > 0.0);","N = (2.0 * Nselect - 1.0) * N;","vec3 ambient_color = vec3(0.0);","vec3 diffuse_color = vec3(0.0);","vec3 specular_color = vec3(0.0);","vec3 L = normalize(rd);","float lightEnabled = float(length(L) > 0.0);","L = normalize(L + (1.0 - lightEnabled));","float lambertTerm = clamp(dot(N, L), 0.0, 1.0);","vec3 H = normalize(L+rd); // Halfway vector","float specularTerm = pow(max(dot(H, N), 0.0), shininess);","float mask1 = lightEnabled;","ambient_color += mask1 * ambient_color;","diffuse_color += mask1 * lambertTerm;","specular_color += mask1 * specularTerm * specular_color;","vec3 color = texture2D(colorMap, vec2(isoValue, 0.5)).rgb;","return vec4(color * (ambient_color + diffuse_color) + specular_color, 1.0);","}","vec4 raymarchIso(vec3 ro, vec3 rd, vec4 prevData) {","vec3 ratio = (mapDim - vec3(1.0)) / gridSize;","vec3 stepModel = rd * stepSizeModel;","vec3 stepGrid = stepModel * ratio;","vec3 posModel = ro;","vec3 posGrid = (ro + 0.5 * gridSize) * ratio;","vec3 dStep = 1.5 / mapDim;","vec3 col = prevData.rgb;","float tm = prevData.a;","if (tm > 0.5) { return prevData; }","for (int i=0; i<MAX_STEPS; ++i) {","float density = sampleVolTex(posGrid.xyz);","float remappedDensity = (density - minDisplayValue) / rangeDisplayValue;","remappedDensity = min(max(remappedDensity, 0.0), 1.0);","if (remappedDensity > isoValue) {","vec3 interPosGrid = posGrid - 1.0 * stepGrid;","vec3 interPosModel = posModel - 1.0 * stepModel;","vec3 smallStepGrid = 0.25 * stepGrid;","vec3 smallStepModel = 0.25 * stepModel;","for (int i=0; i<4; i++) {","density = sampleVolTex(interPosGrid.xyz);","remappedDensity = (density - minDisplayValue) / rangeDisplayValue;","remappedDensity = min(max(remappedDensity, 0.0), 1.0);","if (remappedDensity > isoValue) {","return add_lighting(remappedDensity, interPosGrid, dStep, rd);","}","interPosGrid += smallStepGrid;","interPosModel += smallStepModel;","}","}","posGrid += stepGrid;","posModel += stepModel;","if (tm < 0.0 || posGrid.x > mapDim.x - 1.0 || posGrid.x < 0.0 || posGrid.y > mapDim.y - 1.0 || posGrid.y < 0.0 || posGrid.z > mapDim.z - 1.0 || posGrid.z < 0.0)","break;","vec4 posVS = realModelViewMatrix * vec4(posModel, 1.0);","if (posVS.z < depthVS) { break; }","}","return vec4(0.0);","}","void main() {","vec4 outColor = texture2D(prevMap, vUv);","vec4 clipVec = vec4(vUv * 2.0 - 1.0, 0.0, 1.0);","vec4 posVS = realProjectionMatrixInverse * clipVec;","posVS.xyz /= posVS.w;","posVS.w = 1.0;","vec3 rd = (realModelViewMatrixInverse * posVS).xyz;","vec3 ro = (realModelViewMatrixInverse * vec4(0.0, 0.0, 0.0, 1.0)).xyz;","rd = normalize(rd - ro);","vec3 rad = 0.5 * gridSize;","vec3 m = 1.0 / rd;","vec3 n = m * ro;","vec3 k = abs(m) * rad;","vec3 t1 = -n - k;","vec3 t2 = -n + k;","float tN = max(max(t1.x, t1.y), t1.z);","float tF = min(min(t2.x, t2.y), t2.z);","if(tN <= tF && tF >= 0.0) {","vec3 intersect = ro + tN * rd;","vec4 intersectVS = realModelViewMatrix * vec4(intersect, 1.0);","depthVS = fetchDepthVS(vUv);","if (intersectVS.z >= depthVS) {","stepSize = max(mapDim.x, max(mapDim.y, mapDim.z)) * ROOTTHREE / float(MAX_STEPS);","stepSizeModel = max(gridSize.x, max(gridSize.y, gridSize.z)) * ROOTTHREE / float(MAX_STEPS);","#if ISO_SURFACE > 0","outColor = raymarchIso(intersect, rd, outColor) + debugChunkBox;","#else","outColor = raymarch(intersect, rd, outColor) + debugChunkBox;","#endif","}","}","gl_FragColor = outColor;","}"].join("\n")},Transfer:{defines:{ISO_SURFACE:0},uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","varying vec2 vUv;","void main() {","vec4 mainMap   = texture2D(tDiffuse,  vUv);","vec4 volumeMap = texture2D(tDiffuse2, vUv);","vec3 volumeCol = volumeMap.rgb;","float alpha = 1.0 - volumeMap.a;","vec4 volume = vec4(volumeCol / (alpha + 0.0000001), alpha);","#if ISO_SURFACE > 0","float blendAlpha = mix(mainMap.a, 1.0, volumeMap.a);","gl_FragColor = vec4(mix(mainMap.rgb * mainMap.a, volumeMap.rgb, volumeMap.a) / blendAlpha, blendAlpha);","#else","float blendAlpha = mix(mainMap.a, 1.0, volume.a);","gl_FragColor = vec4(mix(mainMap.rgb * mainMap.a, volume.rgb, volume.a) / blendAlpha, blendAlpha);","#endif","}"].join("\n")}}}),define("DS/Shaders/DisplayIrradianceMapShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{uniforms:{tDiffuse1:{type:"t",value:null},offset1:{type:"v2",value:new e.Vector2(0,.5)},scale1:{type:"f",value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse1;","uniform vec2 offset1;","uniform float scale1;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec2 vUv2 = (vUv - offset1) / scale1;","if (vUv2.x > 0.0 && vUv2.y > 0.0 && vUv2.x < 1.0 && vUv2.y < 1.0) {","    vec3 color = texture2D( tDiffuse1, vUv2 ).xyz;","    color = pow(color, vec3(1.0 / 2.2));","    gl_FragColor = vec4(color, 1.0); return;","}","}"].join("\n")}}),define("Shaders/DisplayIrradianceMapShader",["DS/Shaders/DisplayIrradianceMapShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/DisplayIrradianceMapShader"),e}),define("DS/Shaders/MultiplicativeBlendShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{defines:{POSTPRO:1},uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tNormalDepthIoRRoughness:{type:"t",value:null},strength:{type:"f",value:.5},contrast:{type:"f",value:2},power:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#if (POSTPRO == 1)","uniform sampler2D tDiffuse;","#endif","#if defined(SSAO) && defined(SSLREFRACTION_ENABLED)","#define REFRACTION_SKIP","uniform sampler2D tNormalDepthIoRRoughness;","#endif","uniform sampler2D tDiffuse2;","uniform float strength;","uniform float contrast;","uniform float power;","varying vec2 vUv;","void main() {","float occ = 1.0 - texture2D(tDiffuse2, vUv).x;","occ = clamp(1.0 - occ * contrast, 0.0, 1.0);","occ = pow(occ, power);","#ifdef REFRACTION_SKIP","if (texture2D(tNormalDepthIoRRoughness, vUv).y > 0.5) {","occ = 1.0;","}","#endif","#if (POSTPRO == 1)","vec4 color = texture2D(tDiffuse, vUv);","gl_FragColor = vec4(color.xyz * occ, color.a);","#else","gl_FragColor = vec4(vec3(0.0), 1.0 - sqrt(occ));","#endif","}"].join("\n")}}),define("Shaders/MultiplicativeBlendShader",["DS/Shaders/MultiplicativeBlendShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/MultiplicativeBlendShader"),e}),define("DS/Shaders/TextureBlendingShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";var t=new e.DataTexture(new Uint8Array(16),2,2,e.RGBAFormat,e.UnsignedByteType,null);return t.needsUpdate=!0,{AlphaBlendingShader:{defines:{POSTPRO:1},uniforms:{tScene:{type:"t",value:null},tTexture:{type:"t",value:t},offset:{type:"v2",value:new e.Vector2(0,0)},invSize:{type:"v2",value:new e.Vector2(1,1)}},vertexShader:["varying vec2 vUv;","void main() {","   vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["#if (POSTPRO == 1)","uniform sampler2D tScene;","#endif","uniform sampler2D tTexture;","uniform vec2 invSize;","uniform vec2 offset;","varying vec2 vUv;","void main() {","vec2 coord = (vUv - offset) * invSize;","#if (POSTPRO == 1)","vec4 scene = texture2D(tScene, coord);","#else","vec4 scene = vec4(0.0);","#endif","vec4 texture = texture2D(tTexture, coord);","vec3 color = texture.rgb;","float alpha = texture.a;","#if (POSTPRO == 1)","   gl_FragColor = vec4(color * (alpha) + (1.0 - alpha) * scene.rgb, alpha + scene.a * (1.0 - alpha));","#else","   gl_FragColor = vec4(color, alpha);","#endif","}"].join("\n")}}}),define("Shaders/TextureBlendingShader",["DS/Shaders/TextureBlendingShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/TextureBlendingShader"),e}),define("DS/Shaders/ConvertCubemapToLatlongShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{ConvertCubemapToLatlong:{defines:{ORIENTATION:0},uniforms:{cubemap:{type:"t",value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform samplerCube cubemap;","const float PI = 3.14159265358979323846264;","varying vec2 vUv;","void main() {","gl_FragColor = vec4(0.0);","vec3 N;","float phi = PI * (2.0 * vUv.x - 1.0);","#if ORIENTATION == 1","float theta = PI * vUv.y;","N.x = sin(theta) * sin(phi);","N.y = cos(theta);","N.z = sin(theta) * cos(phi);","#elif ORIENTATION == 2","float theta = PI * (1.0 - vUv.y);","N.x = sin(theta) * cos(phi);","N.z = sin(theta) * sin(phi);","N.y = -cos(theta);","#else","float theta = PI * (1.0 - vUv.y);","N.x = sin(theta) * cos(phi);","N.y = sin(theta) * sin(phi);","N.z = cos(theta);","#endif","gl_FragColor = textureCube(cubemap, N);","}"].join("\n")}}}),define("DS/Shaders/SMAAShader",["DS/Visualization/ThreeJS_DS"],function(e){"use strict";return{EdgeDetection:{uniforms:{tDiffuse:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["varying vec2 vUv;","varying vec4 offset[3];","uniform float screenHeight;","uniform float screenWidth;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth,1.0/screenHeight);","    vUv = uv;","    offset[0] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-1.0, 0.0, 0.0, 1.0);","    offset[1] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4( 1.0, 0.0, 0.0, -1.0);","    offset[2] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-2.0, 0.0, 0.0, -2.0);",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","varying vec4 offset[3];","float SMAA_THRESHOLD = 0.1;","void main() {","   vec2 threshold = vec2(SMAA_THRESHOLD, SMAA_THRESHOLD);","   vec3 weights   = vec3(0.2126,0.7152,0.0722);","   float L        = dot(texture2D(tDiffuse, vUv.xy).rgb, weights);","   float Lleft    = dot(texture2D(tDiffuse, offset[0].xy).rgb, weights);","   float Ltop     = dot(texture2D(tDiffuse, offset[0].zw).rgb, weights);","   vec4 delta;","   delta.xy   = abs(L - vec2(Lleft, Ltop));","   vec2 edges = step(threshold, delta.xy);","   float Lright   = dot(texture2D(tDiffuse, offset[1].xy).rgb, weights);","   float Lbottom  = dot(texture2D(tDiffuse, offset[1].zw).rgb, weights);","   delta.zw = abs(L - vec2(Lright, Lbottom));","   vec2 maxDelta  = max(delta.xy, delta.zw);","   maxDelta       = max(maxDelta.xx, maxDelta.yy);","   float Lleftleft = dot(texture2D(tDiffuse, offset[2].xy).rgb, weights);","   float Ltoptop   = dot(texture2D(tDiffuse, offset[2].zw).rgb, weights);","   delta.zw        = abs(vec2(Lleft, Ltop) - vec2(Lleftleft, Ltoptop));","   maxDelta = max(maxDelta.xy, delta.zw);","   edges.xy *= step(0.5 * maxDelta, delta.xy);","   gl_FragColor = vec4(edges, 0.0, 1.0);","}"].join("\n")},BlendingWeights:{uniforms:{tDiffuse:{type:"t",value:null},areaTex:{type:"t",value:null},searchTex:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["varying vec2 vUv;","varying vec4 offset[3];","uniform float screenHeight;","uniform float screenWidth;","const int SMAA_MAX_SEARCH_STEPS = 8;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","   vUv = uv;","   offset[0] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-0.25, 0.125,  1.25, 0.125);","   offset[1] = vUv.xyxy + SMAA_PIXEL_SIZE.xyxy * vec4(-0.125, 0.25, -0.125,  -1.25);","   offset[2] = vec4(offset[0].xz, offset[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * SMAA_PIXEL_SIZE.xxyy * float(SMAA_MAX_SEARCH_STEPS);",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D searchTex;","uniform sampler2D areaTex;","uniform float screenHeight;","uniform float screenWidth;","varying vec2 vUv;","varying vec4 offset[3];","vec2 SMAA_PIXEL_SIZE;","const int   SMAA_FORCE_DIAGONAL_DETECTION  = 1;","const int   SMAA_FORCE_CORNER_DETECTION    = 1;","const int   SMAA_AREATEX_MAX_DISTANCE      = 16;","const int   SMAA_AREATEX_MAX_DISTANCE_DIAG = 20;","const float SMAA_AREATEX_SUBTEX_SIZE       = 1.0 / 7.0;","const vec2  SMAA_AREATEX_PIXEL_SIZE        = vec2(1.0 / 160.0, 1.0/ 560.0);","const float  SMAA_THRESHOLD              = 0.1;","const int    SMAA_MAX_SEARCH_STEPS       = 16;","const int    SMAA_MAX_SEARCH_STEPS_DIAG  = 8;","const int    SMAA_CORNER_ROUNDING        = 25;","float SMAASearchLength(vec2 e, float bias, float scale) {","   e.r = bias + e.r * scale;","   return  255.0*texture2D(searchTex, vec2(e.x,1.0-e.y)).r;","}","float SMAASearchXLeft() {","   vec2 texCoord = vUv + SMAA_PIXEL_SIZE * vec2(-0.25, 0.125);","   float end = (vUv.x - 0.25 * SMAA_PIXEL_SIZE.x) - 2.0 * SMAA_PIXEL_SIZE.x * float(SMAA_MAX_SEARCH_STEPS);","   vec2 e = vec2(0.0, 1.0);","   for(int i = 0;i<SMAA_MAX_SEARCH_STEPS;i++){","       if((texCoord.x > end) && (e.g > 0.8281) && (e.r == 0.0)){","           e = texture2D(tDiffuse, texCoord).rg;","           texCoord.x -= 2.0 * SMAA_PIXEL_SIZE.x;","       }else","           break;","   }","   texCoord.x += 0.25 * SMAA_PIXEL_SIZE.x;","   texCoord.x += SMAA_PIXEL_SIZE.x;","   texCoord.x += 2.0 * SMAA_PIXEL_SIZE.x;","   texCoord.x -= SMAA_PIXEL_SIZE.x * SMAASearchLength(e, 0.0, 0.5);","   return texCoord.x  ;","}","float SMAASearchXRight() {","   vec2 texcoord = vUv + SMAA_PIXEL_SIZE * vec2(1.25, 0.125);","   float end = (vUv.x + 1.25 * SMAA_PIXEL_SIZE.x) + 2.0 * SMAA_PIXEL_SIZE.x * float(SMAA_MAX_SEARCH_STEPS);","   vec2 e = vec2(0.0, 1.0);","   for(int i = 0;i<SMAA_MAX_SEARCH_STEPS;i++){","       if((texcoord.x < end) && (e.g > 0.8281) && (e.r == 0.0)){","           e = texture2D(tDiffuse, texcoord).rg;","           texcoord += vec2(2.0, 0.0) * SMAA_PIXEL_SIZE;","       }else","           break;","   }","   texcoord.x -= 0.25 * SMAA_PIXEL_SIZE.x;","   texcoord.x -= SMAA_PIXEL_SIZE.x;","   texcoord.x -= 2.0 * SMAA_PIXEL_SIZE.x;","   texcoord.x += SMAA_PIXEL_SIZE.x * SMAASearchLength(e, 0.5, 0.5);","   return texcoord.x;","}","float SMAASearchYDown() {","   vec2 texcoord = vUv + SMAA_PIXEL_SIZE * vec2(-0.125, -1.25);","   float end = (vUv.y - 1.25 * SMAA_PIXEL_SIZE.y) - 2.0 * SMAA_PIXEL_SIZE.y * float(SMAA_MAX_SEARCH_STEPS);","   vec2 e = vec2(1.0, 0.0);","   for(int i = 0;i<SMAA_MAX_SEARCH_STEPS;i++){","       if((texcoord.y > end) && (e.r > 0.8281) && (e.g == 0.0)){","           e = texture2D(tDiffuse, texcoord).rg;","           texcoord -= vec2(0.0, 2.0) * SMAA_PIXEL_SIZE;","       }else","           break;","   }","   texcoord.y += 0.25 * SMAA_PIXEL_SIZE.y;","   texcoord.y += SMAA_PIXEL_SIZE.y;","   texcoord.y -= SMAA_PIXEL_SIZE.y * SMAASearchLength(e.gr ,0.5, 0.5);","   return texcoord.y ;","}","float SMAASearchYUp() {","   vec2 texcoord = vUv + SMAA_PIXEL_SIZE * vec2(-0.125, 0.25);","   float end = (vUv.y + 0.25 * SMAA_PIXEL_SIZE.y) + 2.0 * SMAA_PIXEL_SIZE.y * float(SMAA_MAX_SEARCH_STEPS);","   vec2 e = vec2(1.0, 0.0);","   for(int i = 0;i<SMAA_MAX_SEARCH_STEPS;i++){","       if((texcoord.y < end) && (e.r > 0.8281) && (e.g == 0.0)){","           e = texture2D(tDiffuse, texcoord).rg;","           texcoord += vec2(0.0, 2.0) * SMAA_PIXEL_SIZE;","       }else","           break;","   }","   texcoord.y -= 0.25 * SMAA_PIXEL_SIZE.y;","   texcoord.y -= SMAA_PIXEL_SIZE.y;","   texcoord.y -= 2.0 * SMAA_PIXEL_SIZE.y;","   texcoord.y += SMAA_PIXEL_SIZE.y * SMAASearchLength(e.gr, 0.0, 0.5);","   return texcoord.y ;","}","vec2 _round(vec2 invec) {","   return vec2(floor(abs(invec) + vec2(0.5)) * sign(invec));","}","vec2 SMAAArea(vec2 dist, float e1, float e2, float offset) {","   vec2 texcoord = float(SMAA_AREATEX_MAX_DISTANCE) * _round(4.0 * vec2(e1, e2)) + dist  ;","   texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);","   return texture2D(areaTex, vec2(texcoord.x,1.0-texcoord.y)).rg;","}","void SMAADetectHorizontalCornerPattern(vec2 weights, vec2 texcoord, vec2 d) {","   if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1 ){","       vec4 coords = vec4(d.x, 0.0, d.y, 0.0)*SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;","       vec2 e;","       e.r = texture2D(tDiffuse, (coords.xy + vec2(0.0,  -1.0))).r;","       bool left = abs(d.x) < abs(d.y);","       e.g = texture2D(tDiffuse, (coords.xy + vec2(0.0, 2.0))).r;","       if (left) weights *= clamp(float(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);","       e.r = texture2D(tDiffuse, (coords.zw + vec2(1.0,  -1.0))).r;","       e.g = texture2D(tDiffuse, (coords.zw + vec2(1.0, 2.0))).r;","       if (!left) weights *= clamp(float(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);","   }","}","void SMAADetectVerticalCornerPattern(vec2 weights, vec2 texcoord, vec2 d) {","   if (SMAA_CORNER_ROUNDING < 100 || SMAA_FORCE_CORNER_DETECTION == 1){","       vec4 coords = vec4(0.0, d.x, 0.0, d.y)*SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;","       vec2 e;","       e.r = texture2D(tDiffuse, (coords.xy + vec2( 1.0, 0.0))).g;","       bool left = abs(d.x) < abs(d.y);","       e.g = texture2D(tDiffuse, (coords.xy + vec2(-2.0, 0.0))).g;","       if (left) weights *= clamp(float(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);","       e.r = texture2D(tDiffuse, (coords.zw + vec2( 1.0, -1.0))).g;","       e.g = texture2D(tDiffuse, (coords.zw + vec2(-2.0, -1.0))).g;","       if (!left) weights *= clamp(float(SMAA_CORNER_ROUNDING) / 100.0 + 1.0 - e,0.0,1.0);","\t}","}","vec2 SMAAAreaDiag(vec2 dist, vec2 e) {","   vec2 texcoord = float(SMAA_AREATEX_MAX_DISTANCE_DIAG) * e + dist;","   texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);","   texcoord.x += 0.5;","   return texture2D(areaTex, vec2(texcoord.x,1.0-texcoord.y)).rg;","}","float SMAASearchDiag1(vec2 texcoord, vec2 dir, float c) {","   texcoord += dir * SMAA_PIXEL_SIZE;","   vec2 e = vec2(0.0, 0.0);","   int j;","   for (int i = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {","       j = i;","       e.rg = texture2D(tDiffuse, texcoord).rg;","       if (dot(e, vec2(1.0, 1.0)) < 1.9) break;","       texcoord += dir * SMAA_PIXEL_SIZE;","   }","   return float(j) + float(e.g > 0.9) * c;","}","float SMAASearchDiag2(vec2 texcoord, vec2 dir, float c) {","   texcoord += dir * SMAA_PIXEL_SIZE;","   vec2 e = vec2(0.0, 0.0);","   int j;","   for (int i = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) {","       j = i;","       e.g = texture2D(tDiffuse, texcoord).g;","       e.r = texture2D(tDiffuse, (texcoord + (vec2(1.0, 0.0)* SMAA_PIXEL_SIZE))).r;","       if (dot(e, vec2(1.0, 1.0)) < 1.9) break;","       texcoord += dir * SMAA_PIXEL_SIZE;","   }","   return float(j) + float(e.g > 0.9) * c;","}","vec2 SMAACalculateDiagWeights(vec2 texcoord, vec2 e, ivec4 subsampleIndices) {","   vec2 weights = vec2(0.0, 0.0);","   vec2 d;","   d.x = e.r > 0.0? SMAASearchDiag1(texcoord, vec2(-1.0,  -1.0), 1.0) : 0.0;","   d.y = SMAASearchDiag1(texcoord, vec2(1.0, 1.0), 0.0);","   if (d.r + d.g > 2.0) {","       vec4 coords = vec4(-d.r, -d.r, d.g, d.g) * SMAA_PIXEL_SIZE.xyxy + texcoord.xyxy;","       vec4 c;","       c.x = texture2D(tDiffuse, (coords.xy + vec2( -1.0, 0.0 )* SMAA_PIXEL_SIZE)).g;","       c.y = texture2D(tDiffuse, (coords.xy + vec2( 0.0,  0.0 )* SMAA_PIXEL_SIZE)).r;","       c.z = texture2D(tDiffuse, (coords.zw + vec2( 1.0,  0.0 )* SMAA_PIXEL_SIZE)).g;","       c.w = texture2D(tDiffuse, (coords.zw + vec2( 1.0, 1.0 )* SMAA_PIXEL_SIZE)).r;","       vec2 e = 2.0 * c.xz + c.yw;","       float t = float(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;","       e *= step(d.rg, vec2(t, t));","       weights += SMAAAreaDiag(d, e);","   }","   d.x = SMAASearchDiag2(texcoord, vec2(-1.0, 1.0), 0.0);","   float right = texture2D(tDiffuse, (texcoord + vec2(1.0, 0.0)* SMAA_PIXEL_SIZE)).r;","   d.y = right > 0.0? SMAASearchDiag2(texcoord, vec2(1.0, -1.0), 1.0) : 0.0;","   if (d.r + d.g > 2.0) { ","       vec4 coords = vec4(-d.r, d.r, d.g, -d.g)* SMAA_PIXEL_SIZE.xyxy+ texcoord.xyxy;","       vec4 c;","       c.x  = texture2D(tDiffuse, (coords.xy + vec2(-1.0,  0.0)* SMAA_PIXEL_SIZE)).g;","       c.y  = texture2D(tDiffuse, (coords.xy + vec2( 0.0, 1.0)* SMAA_PIXEL_SIZE)).r;","       c.zw = texture2D(tDiffuse, (coords.zw + vec2( 1.0,  0.0)* SMAA_PIXEL_SIZE)).gr;","       vec2 e = 2.0 * c.xz + c.yw;","       float t = float(SMAA_MAX_SEARCH_STEPS_DIAG) - 1.0;","       e *= step(d.rg, vec2(t, t));","       weights += SMAAAreaDiag(d, e).gr;","   }","   return weights;","}","void main() {","SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","\tvec2 pixcoord = vUv / SMAA_PIXEL_SIZE;","   vec4 weights = vec4(0.0, 0.0, 0.0, 0.0);","   vec2 e = texture2D(tDiffuse, vUv).rg;","   if (e.g > 0.0) {","       if (SMAA_MAX_SEARCH_STEPS_DIAG > 0 || SMAA_FORCE_DIAGONAL_DETECTION == 1)","       weights.rg = SMAACalculateDiagWeights(vUv, e, ivec4(0));","       if (dot(weights.rg, vec2(1.0, 1.0)) == 0.0) {","           vec2 d;","           vec2 coords;","           coords.x = SMAASearchXLeft();","           coords.y = vUv.y + 0.25 * SMAA_PIXEL_SIZE.y ;","           d.x = coords.x;","           float e1 = texture2D(tDiffuse, coords).r;","           coords.x = SMAASearchXRight();","           d.y = coords.x;","           d =  (d / SMAA_PIXEL_SIZE.x) - pixcoord.x ;","           vec2 sqrt_d = sqrt(abs(d));","           float e2 = texture2D(tDiffuse, (coords + vec2(1.0, 0.0)* SMAA_PIXEL_SIZE)).r;","           weights.rg = SMAAArea(sqrt_d, e1, e2, 0.0);","           SMAADetectHorizontalCornerPattern(weights.rg, vUv, d);","       } else","           e.r = 0.0;","   }","   if (e.r > 0.0) {","       vec2 d;","       vec2 coords;","       coords.y = SMAASearchYUp();","       coords.x = offset[0].x;","       d.x = coords.y;","       float e1 = texture2D(tDiffuse, coords).g;","       coords.y = SMAASearchYDown();","       d.y = coords.y;","       d = d / SMAA_PIXEL_SIZE.y - pixcoord.y;","       vec2 sqrt_d = sqrt(abs(d));","       float e2 = texture2D(tDiffuse, (coords + vec2(0.0, 1.0)* SMAA_PIXEL_SIZE)).g;","       weights.ba = SMAAArea(sqrt_d, e1, e2, 0.0);","       SMAADetectVerticalCornerPattern(weights.ba, vUv, d);","   }","   gl_FragColor=weights;","}"].join("\n")},FinalBlending:{uniforms:{tDiffuse:{type:"t",value:null},tDiffuse2:{type:"t",value:null},screenWidth:{type:"f",value:800},screenHeight:{type:"f",value:600}},vertexShader:["uniform float screenHeight;","uniform float screenWidth;","varying vec2 vUv;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","    vUv = uv;",e._DefaultShaderChunk.model_view_projection_transformation_vertex,"}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tDiffuse2;","uniform float screenHeight;","uniform float screenWidth;","varying vec2 vUv;","void main() {","vec2 SMAA_PIXEL_SIZE = vec2(1.0/screenWidth, 1.0/screenHeight);","   vec4 topLeft = texture2D(tDiffuse2, vUv);","   float bottom = texture2D(tDiffuse2, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(0.0, -1.0)).g;","   float right = texture2D(tDiffuse2, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(1.0, 0.0)).a;","   vec4 a = vec4(topLeft.r, bottom, topLeft.b, right);","   vec4 w = a * a * a;","   float sum = dot(w, vec4(1.0));","   if (sum > 0.0) {","       vec4 color = vec4(0.0);","       vec4 CurrentColor = texture2D(tDiffuse, vUv);","       vec4 ColorLeft = texture2D(tDiffuse, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(-1.0, 0.0));","       vec4 ColorTop = texture2D(tDiffuse, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(0.0, 1.0));","       vec4 ColorRight = texture2D(tDiffuse, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(1.0, 0.0));","       vec4 ColorBottom = texture2D(tDiffuse, vUv.xy + SMAA_PIXEL_SIZE.xy * vec2(0.0, -1.0));","       color = mix(CurrentColor, ColorTop, a.r) * w.r + color;","       color = mix(CurrentColor, ColorBottom, a.g) * w.g + color;","       color = mix(CurrentColor, ColorLeft, a.b) * w.b + color;","       color = mix(CurrentColor, ColorRight, a.a) * w.a + color;","       gl_FragColor = color / sum;","   } else {","       gl_FragColor = texture2D(tDiffuse,vUv);","   }","}"].join("\n")}}}),define("Shaders/SMAAShader",["DS/Shaders/SMAAShader","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/SMAAShader"),e}),define("DS/Shaders/MappingShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{map_pars_vertex:["#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","varying vec2 vUv;","uniform vec2 offsetBumpMap;","uniform vec2 repeatBumpMap;",e.map_pars_vertex,"#endif"].join("\n"),map_pars_fragment:["#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","varying vec2 vUv;",e.map_pars_fragment,"#endif","#ifdef USE_MAP","uniform sampler2D map;","#endif"].join("\n"),map_vertex:["#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","vUv = uv * repeatBumpMap + offsetBumpMap;","#if defined (MAPPING_OPERATOR)","#if defined (USE_MAPPING_OPERATOR_VERTEX)","vUv = applyMappingOperator(vUv, position, normal);","#else","localPosition=position;","localNormal=normal;","#endif","#endif","#endif"].join("\n"),uvmapping_fragment:["#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","uvToUse = vUv;","#if defined (USE_MAPPING_OPERATOR_FRAGMENT) && defined (MAPPING_OPERATOR)","uvToUse = applyMappingOperator(uvToUse, localPosition, localNormal);","#endif","#ifdef PDSFX","_uvToUse = uvToUse;","#endif","#endif"].join("\n"),map_fragment:["#if defined(USE_MAP) || defined(PDSFX_USE_MAP)","vec4 texelColor = vec4(1.0, 1.0, 1.0, 1.0);","#ifdef USE_MAP","#if defined(USE_ENVMAP_HDR) && !defined(USE_ENVMAP_RGB_HDR)","vec2 texelSizeMap = vec2(1.0 / mapHDRSize);","texelColor = texture2DBilinearFromRGBE( map, uvToUse, mapHDRSize, texelSizeMap );","#else","texelColor = texture2D( map, uvToUse );","#ifdef GAMMA_INPUT","texelColor.xyz = convertToLinear(texelColor.xyz);","#endif","#endif","#endif","#ifdef PDSFX_USE_MAP","vec4 pdsfxDiffTexel = _ComputeDiffuseTexel();","#ifdef GAMMA_INPUT","pdsfxDiffTexel.xyz = convertToLinear(pdsfxDiffTexel.xyz);","#endif","texelColor *= pdsfxDiffTexel;","#endif","gl_FragColor = gl_FragColor * texelColor;","#endif"].join("\n")}}),define("DS/Shaders/EnvMapShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{envmap_pars_fragment:["#if defined( USE_MAP_HDR ) || defined( USE_ENVMAP_HDR )","uniform vec2 mapHDRSize;","uniform vec2 envMapHDRSize;","uniform float envMapHDRToMipsRatio;",e.rgbe_sample_methods,"#endif","#ifdef USE_ENVMAP","const float PI = 3.1415926535898;","const float INV_PI = 0.31830988618;","uniform float reflectivity;","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","uniform sampler2D envMap;","uniform mat4 ambienceMatrix;","uniform float envMapExposureSpecular;","uniform float envMapExposureDiffuse;","#else","uniform samplerCube envMap;","#endif","uniform int combine;","#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHYSICALDS )","uniform bool useRefract;","uniform float refractionRatio;","#if defined( USE_REFRACTIONRATIOMAP )","uniform sampler2D refractionRatioMap;","#endif","#else","varying vec3 vReflect;","#endif","#endif"].join("\n"),envmap_fragment:["#ifdef USE_ENVMAP","vec3 reflectVec;","#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )","#ifndef DECAL","vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );","#else","vec3 cameraToVertex = normalize( dWorldPosition - cameraPosition );","#endif","vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );","if ( useRefract ) {","#if defined( USE_REFRACTIONRATIOMAP )","reflectVec = refract( cameraToVertex, worldNormal, texture2D(refractionRatioMap, uvToUse).r );","#else","reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );","#endif","} else { ","reflectVec = reflect( cameraToVertex, worldNormal );","}","#else","reflectVec = vReflect;","#endif","vec3 flipReflectVec;","#ifdef DOUBLE_SIDED","float flipNormal = 1.0;","flipReflectVec = flipNormal * reflectVec;","#else","flipReflectVec = reflectVec;","#endif","#if defined( USE_LIGHTPROBEMAP ) || defined( USE_LATLONGMAP )","#ifdef USE_LIGHTPROBEMAP","flipReflectVec = vec3(flipReflectVec.y, flipReflectVec.z, flipReflectVec.x);","flipReflectVec = (ambienceMatrix*vec4(flipReflectVec,0.0)).xyz;","float probeR = INV_PI * acos( flipReflectVec.z ) / length(flipReflectVec.xy);","#ifdef USE_ENVMAP_HDR","vec2 texelSizeEnvMap = vec2(1.0 / envMapHDRSize);","vec4 cubeColor = texture2DBilinearFromRGBE( envMap, 0.5 * (probeR * flipReflectVec.xy + 1.0), envMapHDRSize, texelSizeEnvMap );","#else","vec4 cubeColor = texture2D( envMap, 0.5 * (probeR * flipReflectVec.xy + 1.0) );","#endif","#else","flipReflectVec = (ambienceMatrix*vec4(flipReflectVec,0.0)).xyz;","float phi = atan(flipReflectVec.y, flipReflectVec.x);","float theta = acos(flipReflectVec.z);","#if defined(USE_ENVMAP_HDR) && !defined(USE_ENVMAP_RGB_HDR)","vec2 texelSizeEnvMap = vec2(1.0 / envMapHDRSize);","vec4 cubeColor = envMapExposureSpecular * texture2DBilinearFromRGBE( envMap, vec2(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta), envMapHDRSize, texelSizeEnvMap );","#else","vec4 cubeColor = envMapExposureSpecular * texture2D( envMap, vec2(0.5 + 0.5 * INV_PI * phi, 1.0 - INV_PI * theta) );","#endif","#endif","#else","#if defined(CUBEMAP_ZUP)","vec4 cubeColor = textureCube( envMap, vec3(-flipReflectVec.x, flipReflectVec.zy) );","#else","vec4 cubeColor = textureCube( envMap, flipReflectVec );","#endif","#endif","if ( combine == 1 ) {","gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );","} else if ( combine == 2 ) {","gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;","} else {","gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );","}","#endif"].join("\n"),envmap_pars_vertex:["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHYSICALDS )","varying vec3 vReflect;","uniform float refractionRatio;","uniform bool useRefract;","#if defined( USE_REFRACTIONRATIOMAP )","uniform sampler2D refractionRatioMap;","#endif","#endif"].join("\n"),envmap_vertex:["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHYSICALDS )","vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;","worldNormal = normalize( worldNormal );","vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );","if ( useRefract ) {","#if defined( USE_REFRACTIONRATIOMAP )","vReflect = refract( cameraToVertex, worldNormal, texture2D(refractionRatioMap, uvToUse).r );","#else","vReflect = refract( cameraToVertex, worldNormal, refractionRatio );","#endif","} else {","vReflect = reflect( cameraToVertex, worldNormal );","}","#endif"].join("\n"),envMaps_pars:["varying vec3 vReflect;"].join("\n"),envMaps_vertex:["vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","vec3 objectNormal = normal;","vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;","worldNormal = normalize( worldNormal );","vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );","vReflect = reflect( cameraToVertex, worldNormal );"].join("\n"),environment_fragment:["dirAmbient += vec3(0.34);","vec3 reflected_DS= vReflect;","const mat3 DS_to_OpenGL = mat3(","\t0.0, 1.0, 0.0,","\t0.0, 0.0,-1.0,","\t1.0, 0.0, 0.0",");","vec3 reflected_OpenGL = reflected_DS * DS_to_OpenGL;","vec4 texture_environment_lookup = textureCube(ReflectionCUBEMap,-reflected_OpenGL);","vec3 environment_lookup          = texture_environment_lookup.rgb;"].join("\n"),environment_blur_fragment:["dirAmbient += vec3(0.34);","vec3 reflected_DS= vReflect;","const mat3 DS_to_OpenGL = mat3(","\t0.0, 1.0, 0.0,","\t0.0, 0.0,-1.0,","\t1.0, 0.0, 0.0",");","vec3 reflected_OpenGL = reflected_DS * DS_to_OpenGL;","float ddWeight = mix(0.75,0.0,pow(refl_gloss,2.0));","vec3 reflecteddx = ddWeight*dFdx(reflected_OpenGL);","vec3 reflecteddy = ddWeight*dFdy(reflected_OpenGL);","float anisotropyRefl = 1.0/mix(0.3,1.0,pow(refl_gloss,4.0));","float anisotropydd = length(0.5*(reflecteddx+reflecteddy));","float anisotropyWeight = mix(20.0*anisotropydd,0.0,pow(refl_gloss,5.0));","float bias = anisotropydd * anisotropyRefl;","vec4 texture_environment_lookup = textureCube(ReflectionCUBEMap,-reflected_OpenGL,bias );","#ifdef USE_TANGENT_BINORMAL","if(refl_gloss<1.0) {","texture_environment_lookup  += textureCube( ReflectionCUBEMap, normalize(-reflected_OpenGL-anisotropyWeight*tangent),bias );","texture_environment_lookup  += textureCube( ReflectionCUBEMap, normalize(-reflected_OpenGL+anisotropyWeight*tangent),bias );","texture_environment_lookup  += textureCube( ReflectionCUBEMap, normalize(-reflected_OpenGL-anisotropyWeight*binormal),bias  );","texture_environment_lookup  += textureCube( ReflectionCUBEMap, normalize(-reflected_OpenGL+anisotropyWeight*binormal),bias  );","texture_environment_lookup *= 0.2;","}","#endif","vec3 environment_lookup          = texture_environment_lookup.rgb;"].join("\n")}}),define("DS/Shaders/PhongShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{lights_phong_pars_vertex:["#ifndef PHONG_PER_PIXEL","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];","uniform float pointLightDistance[ MAX_POINT_LIGHTS ];","varying vec4 vPointLight[ MAX_POINT_LIGHTS ];","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];","#endif","#endif","#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( ENV_MAP ) || defined(USE_SHADOWMAP_CUBE)","varying vec3 vWorldPosition;","#endif"].join("\n"),lights_phong_vertex:["#ifndef PHONG_PER_PIXEL","#if MAX_POINT_LIGHTS > 0","for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( pointLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","vPointLight[ i ] = vec4( lVector, lDistance );","}","#endif","#if MAX_SPOT_LIGHTS > 0","for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( spotLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );","vSpotLight[ i ] = vec4( lVector, lDistance );","}","#endif","#endif","#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( ENV_MAP ) || defined(USE_SHADOWMAP_CUBE)","vWorldPosition = worldPosition.xyz;","#endif"].join("\n"),lights_phong_pars_fragment:["uniform vec3 ambientLightColor;","#if MAX_DIR_LIGHTS > 0","uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];","uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];","#endif","#if MAX_DIR_PHONG_LIGHTS > 0","uniform vec3 directionalPhongLightColor[ MAX_DIR_PHONG_LIGHTS ];","uniform vec3 directionalPhongLightDirection[ MAX_DIR_PHONG_LIGHTS ];","#endif","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];","#ifdef PHONG_PER_PIXEL","uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];","uniform int pointLightPhysicalAttenuation[ MAX_POINT_LIGHTS ];","uniform float pointLightDistance[ MAX_POINT_LIGHTS ];","#else","varying vec4 vPointLight[ MAX_POINT_LIGHTS ];","#endif","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];","uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];","uniform float spotLightInnerAngleCos[ MAX_SPOT_LIGHTS ];","#ifdef PHONG_PER_PIXEL","uniform int spotLightPhysicalAttenuation[ MAX_SPOT_LIGHTS ];","uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","#else","varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];","#endif","#endif","#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined(USE_SHADOWMAP_CUBE)","varying vec3 vWorldPosition;","#endif","#ifdef WRAP_AROUND","uniform vec3 wrapRGB;","#endif",e.normal_viewposition_pars_fragment].join("\n"),lights_phong_fragment:[e.normal_viewposition_fragment,"#ifdef USE_NORMALMAP","normal = perturbNormal2Arb( -vPos, normal );","#elif defined( USE_BUMPMAP )","normal = perturbNormalArb( -vPos, normal, dHdxy_fwd() );","#endif","#if MAX_POINT_LIGHTS > 0","vec3 pointDiffuse  = vec3( 0.0 );","vec3 pointSpecular = vec3( 0.0 );","for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","#ifdef PHONG_PER_PIXEL","vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz + vPos.xyz;","float lDistance = 1.0;","if (pointLightPhysicalAttenuation[ i ]> 0){","lDistance = 1.0 / (dot(lVector,lVector) * pointLightDistance[ i ]);","}else {","if ( pointLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","}","lVector = normalize( lVector );","#else","vec3 lVector = normalize( vPointLight[ i ].xyz );","float lDistance = vPointLight[ i ].w;","#endif","float dotProduct = dot( normal, lVector );","#ifdef WRAP_AROUND","float pointDiffuseWeightFull = max( dotProduct, 0.0 );","float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );","#else","float pointDiffuseWeight = max( dotProduct, 0.0 );","#endif","pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;","vec3 pointHalfVector = normalize( lVector + viewPosition );","float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );","float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininessValue ), 0.0 );","pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;","}","#endif","#if MAX_SPOT_LIGHTS > 0","vec3 spotDiffuse  = vec3( 0.0 );","vec3 spotSpecular = vec3( 0.0 );","for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {","#ifdef PHONG_PER_PIXEL","vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz + vPos.xyz;","float lDistance = 1.0;","if (spotLightPhysicalAttenuation[ i ]> 0){","lDistance =1.0 / (dot(lVector,lVector) * spotLightDistance[ i ]);","}else {","if ( spotLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );","}","lVector = normalize( lVector );","#else","vec3 lVector = normalize( vSpotLight[ i ].xyz );","float lDistance = vSpotLight[ i ].w;","#endif","float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );","if ( spotEffect > spotLightAngleCos[ i ] ) {","spotEffect = 1.0 - smoothstep( spotLightInnerAngleCos[ i ],spotLightAngleCos[ i ],spotEffect );","float dotProduct = dot( normal, lVector );","#ifdef WRAP_AROUND","float spotDiffuseWeightFull = max( dotProduct, 0.0 );","float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );","#else","float spotDiffuseWeight = max( dotProduct, 0.0 );","#endif","spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;","vec3 spotHalfVector = normalize( lVector + viewPosition );","float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );","float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininessValue ), 0.0 );","spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;","}","}","#endif","#if MAX_DIR_LIGHTS > 0","vec3 dirDiffuse  = vec3( 0.0 );","vec3 dirSpecular = vec3( 0.0 );","for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {","vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );","vec3 dirVector = normalize( lDirection.xyz );","float dotProduct = dot( normal, dirVector );","#ifdef WRAP_AROUND","float dirDiffuseWeightFull = max( dotProduct, 0.0 );","float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );","#else","float dirDiffuseWeight = max( dotProduct, 0.0 );","#endif","dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;","vec3 dirHalfVector = normalize( dirVector + viewPosition );","float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );","dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;","}","#endif","#if MAX_DIR_PHONG_LIGHTS > 0","vec3 dirPhongDiffuse  = vec3( 0.0 );","vec3 dirPhongSpecular = vec3( 0.0 );","for( int i = 0; i < MAX_DIR_PHONG_LIGHTS; i ++ ) {","vec4 lDirection = viewMatrix * vec4( directionalPhongLightDirection[ i ], 0.0 );","vec3 dirVector = normalize( lDirection.xyz );","float dotProduct = dot( normal, dirVector );","#ifdef WRAP_AROUND","float dirDiffuseWeightFull = max( dotProduct, 0.0 );","float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );","#else","float dirDiffuseWeight = max( dotProduct, 0.0 );","#endif","dirPhongDiffuse  += diffuse * directionalPhongLightColor[ i ] * dirDiffuseWeight;","vec3 dirHalfVector = normalize( dirVector + viewPosition );","float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininessValue ), 0.0 );","dirPhongSpecular += specular * directionalPhongLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;","}","#endif","vec3 totalDiffuse = vec3( 0.0 );","vec3 totalSpecular = vec3( 0.0 );","#if MAX_DIR_LIGHTS > 0","totalDiffuse += dirDiffuse;","totalSpecular += dirSpecular;","#endif","#if MAX_DIR_PHONG_LIGHTS > 0","totalDiffuse += dirPhongDiffuse;","totalSpecular += dirPhongSpecular;","#endif","#if MAX_POINT_LIGHTS > 0","totalDiffuse += pointDiffuse;","totalSpecular += pointSpecular;","#endif","#if MAX_SPOT_LIGHTS > 0","totalDiffuse += spotDiffuse;","totalSpecular += spotSpecular;","#endif","#ifdef METAL","gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );","#else","#if (defined(USE_MAP) || defined(PDSFX_USE_MAP)) && TEXTURE_BLENDING != 5","vec4 texture = texelColor;","#if TEXTURE_BLENDING == 1","gl_FragColor.xyz = texture.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;","#endif","#if TEXTURE_BLENDING == 2","gl_FragColor.xyz = ((1.0-texture.xyz) * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular) + texture.xyz;","#endif","#if TEXTURE_BLENDING == 0","gl_FragColor.xyz = ((1.0-texture.a) * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular) + texture.a * texture.xyz;","#endif","#if TEXTURE_BLENDING == 3","#if TEXTURE_FORMAT == 1021","gl_FragColor.a = texture.a;","#endif","#endif","#else","gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;","#endif","#endif"].join("\n"),lights_phong_firstdironly_fragment:[e.normal_viewposition_fragment,"#ifdef USE_NORMALMAP","normal = perturbNormal2Arb( -vPos, normal );","#elif defined( USE_BUMPMAP )","normal = perturbNormalArb( -vPos, normal, dHdxy_fwd() );","#endif","#if MAX_DIR_LIGHTS > 0","vec3 dirDiffuse  = vec3( 0.0 );","vec3 dirSpecular = vec3( 0.0 );","vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );","vec3 dirVector = normalize( lDirection.xyz );","float dotProduct = dot( normal, dirVector );","#ifdef WRAP_AROUND","float dirDiffuseWeightFull = max( dotProduct, 0.0 );","float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );","#else","float dirDiffuseWeight = max( dotProduct, 0.0 );","#endif","dirDiffuse  += diffuse * 3.0 * directionalLightColor[ 0 ] * dirDiffuseWeight;","vec3 dirHalfVector = normalize( dirVector + viewPosition );","float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );","dirSpecular += specular * directionalLightColor[ 0 ] * dirSpecularWeight * dirDiffuseWeight;","#endif","vec3 totalDiffuse = vec3( 0.0 );","vec3 totalSpecular = vec3( 0.0 );","#if MAX_DIR_LIGHTS > 0","totalDiffuse += dirDiffuse;","totalSpecular += dirSpecular;","#endif","#ifdef METAL","gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );","#else","#if (defined(USE_MAP) || defined(PDSFX_USE_MAP)) && TEXTURE_BLENDING != 5","vec4 texture = texelColor;","#if TEXTURE_BLENDING == 1","gl_FragColor.xyz = texture.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;","#endif","#if TEXTURE_BLENDING == 2","gl_FragColor.xyz = ((1.0-texture.xyz) * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular) + texture.xyz;","#endif","#if TEXTURE_BLENDING == 0","gl_FragColor.xyz = ((1.0-texture.a) * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular) + texture.a * texture.xyz;","#endif","#if TEXTURE_BLENDING == 3","#if TEXTURE_FORMAT == 1021","gl_FragColor.a = texture.a;","#endif","#endif","#else","gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;","#endif","#endif"].join("\n")}}),define("DS/Shaders/ColorShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{postprocess_pars_fragment:["#if defined (GAMMA_OUTPUT) && defined(INLINED_POSTPROCESS)","uniform float brightness;","#if defined (TONEMAP_PHOTOGRAPHIC)","\tfloat luminance_RGB (vec3 iColor) {","\t\tvec3 luminance_weight=vec3(0.176204,0.812985,0.0108109);","\t\treturn dot(iColor,luminance_weight);","\t}","\tuniform float crushblacks;","\tuniform float burnhighlights;","#endif","#endif"].join("\n"),postprocess_fragment:["#if defined (GAMMA_OUTPUT) && defined(INLINED_POSTPROCESS)","   gl_FragColor.xyz *= pow(2.0,brightness);","#if defined (TONEMAP_PHOTOGRAPHIC)","\tfloat saturation = 1.0;","\tvec3 colorCorrection = vec3(1.0);","\tvec3 c = gl_FragColor.xyz * colorCorrection;","\tc *= (c*burnhighlights+1.0)/(c+1.0); ","\tc = mix(vec3(luminance_RGB(c)),c,saturation);","\tfloat intens = luminance_RGB(c);","\tif(intens<1.0){","\t\tfloat _crushblacks = 2.0* crushblacks +1.0;","\t\tintens = sqrt(intens);","\t\tfloat oms2 = 1.0 - intens;"," \t\tc.x = c.x*intens + pow(c.x,_crushblacks)*oms2;","\t\tc.y = c.y*intens + pow(c.y,_crushblacks)*oms2;"," \t\tc.z = c.z*intens + pow(c.z,_crushblacks)*oms2;","\t}","\tgl_FragColor.xyz = c;","#endif","#endif"].join("\n"),linear_to_gamma_fragment:["#ifdef GAMMA_OUTPUT","#ifdef SIMPLE_GAMMA","gl_FragColor.xyz = sqrt( gl_FragColor.xyz );","#else","\tgl_FragColor.r = (gl_FragColor.r < 0.0031308)    ? (gl_FragColor.r*12.92) : 1.055*pow(gl_FragColor.r,1.0/2.4)-0.055;","\tgl_FragColor.g = (gl_FragColor.g < 0.0031308)    ? (gl_FragColor.g*12.92) : 1.055*pow(gl_FragColor.g,1.0/2.4)-0.055;","\tgl_FragColor.b = (gl_FragColor.b < 0.0031308)    ? (gl_FragColor.b*12.92) : 1.055*pow(gl_FragColor.b,1.0/2.4)-0.055;","#endif","#endif"].join("\n"),color_pars_fragment:["#ifdef USE_COLOR","varying vec4 vColor;","#endif"].join("\n"),color_fragment:["#ifdef USE_COLOR","gl_FragColor *= vColor;","#endif"].join("\n"),color_pars_vertex:["#ifdef USE_COLOR","#ifdef OBJECT_USE_COLOR","uniform float objectColorBufferType;","#else","uniform float colorBufferType;","#endif","varying vec4 vColor;","const float VertexColorsFace = 1.0;","const float VertexColorsRGBA = 2.0;","const float VertexColorsRGB = 3.0;","const float VertexColorsA = 4.0;","const float VertexColorsR = 8.0;","const float VertexColorsG = 16.0;","const float VertexColorsB = 32.0;","vec3 GetVertexColorMult(in vec3 colorValue) {","#ifdef OBJECT_USE_COLOR","#ifndef ALLOW_OBJECT_COLOR","return vec3(1.0);","#endif","float colorTypeToUse = objectColorBufferType;","#else","float colorTypeToUse = colorBufferType;","#endif","if (colorTypeToUse <= VertexColorsRGB) {","return colorValue.rgb;","}","vec3 res = vec3(1.0);","float maskR = floor(colorTypeToUse / VertexColorsR);","if (mod(maskR, 2.0) > 0.5) {","res.r = colorValue.r;","}","float maskG = floor(colorTypeToUse / VertexColorsG);","if (mod(maskG, 2.0) > 0.5) {","res.g = colorValue.g;","}","float maskB = floor(colorTypeToUse / VertexColorsB);","if (mod(maskB, 2.0) > 0.5) {","res.b = colorValue.b;","}","return res;","}","float GetVertexAlphaMult(in float alphaValue) {","#ifdef OBJECT_USE_COLOR","#ifndef ALLOW_OBJECT_COLOR","return 1.0;","#endif","float colorTypeToUse = objectColorBufferType;","#else","float colorTypeToUse = colorBufferType;","#endif","if (colorTypeToUse < VertexColorsRGB) {","return alphaValue;","}","float maskA = floor(colorTypeToUse / VertexColorsA);","if (mod(maskA, 2.0) > 0.5) {","return alphaValue;","}","return 1.0;","}","#endif"].join("\n"),color_vertex:["#ifdef USE_COLOR","vColor = vec4(GetVertexColorMult(color.rgb), GetVertexAlphaMult(color.a));","#ifdef GAMMA_INPUT","vColor.rgba *= vColor.rgba;","#endif","#endif"].join("\n"),sRGB_conversion:["vec3 convertToLinear(in vec3 color){","vec3 res;","#ifdef SIMPLE_GAMMA","\tres = color*color;","#else","\tres.r = (color.r < 0.04045)    ? (color.r/12.92) : pow((color.r + 0.055)/1.055, 2.4);","\tres.g = (color.g < 0.04045)    ? (color.g/12.92) : pow((color.g + 0.055)/1.055, 2.4);","\tres.b = (color.b < 0.04045)    ? (color.b/12.92) : pow((color.b + 0.055)/1.055, 2.4);","#endif","return res;","}"].join("\n")}}),define("DS/Shaders/LambertShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{lights_lambert_pars_vertex:["uniform vec3 ambient;","uniform vec3 diffuse;","uniform vec3 emissive;","uniform vec3 ambientLightColor;","#if MAX_DIR_LIGHTS > 0","uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];","uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];","#endif","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];","uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];","uniform float pointLightDistance[ MAX_POINT_LIGHTS ];","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];","uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];","uniform float spotLightInnerAngleCos[ MAX_SPOT_LIGHTS ];","#endif","#ifdef WRAP_AROUND","uniform vec3 wrapRGB;","#endif"].join("\n"),lights_lambert_vertex:["vLightFront = vec3( 0.0 );","#ifdef DOUBLE_SIDED","vLightBack = vec3( 0.0 );","#endif","transformedNormal = normalize( transformedNormal );","#if MAX_DIR_LIGHTS > 0","for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {","vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );","vec3 dirVector = normalize( lDirection.xyz );","float dotProduct = dot( transformedNormal, dirVector );","vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );","#ifdef DOUBLE_SIDED","vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );","#ifdef WRAP_AROUND","vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );","#endif","#endif","#ifdef WRAP_AROUND","vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );","directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );","#ifdef DOUBLE_SIDED","directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );","#endif","#endif","vLightFront += directionalLightColor[ i ] * directionalLightWeighting;","#ifdef DOUBLE_SIDED","vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;","#endif","}","#endif","#if MAX_POINT_LIGHTS > 0","for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float lDistance = 1.0;","if ( pointLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","lVector = normalize( lVector );","float dotProduct = dot( transformedNormal, lVector );","vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );","#ifdef DOUBLE_SIDED","vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );","#ifdef WRAP_AROUND","vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );","#endif","#endif","#ifdef WRAP_AROUND","vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );","pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );","#ifdef DOUBLE_SIDED","pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );","#endif","#endif","vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;","#ifdef DOUBLE_SIDED","vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;","#endif","}","#endif","#if MAX_SPOT_LIGHTS > 0","for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {","vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );","vec3 lVector = lPosition.xyz - mvPosition.xyz;","float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );","if ( spotEffect > spotLightAngleCos[ i ] ) {","spotEffect = 1.0 - smoothstep( spotLightInnerAngleCos[ i ],spotLightAngleCos[ i ],spotEffect );","float lDistance = 1.0;","if ( spotLightDistance[ i ] > 0.0 )","lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );","lVector = normalize( lVector );","float dotProduct = dot( transformedNormal, lVector );","vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );","#ifdef DOUBLE_SIDED","vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );","#ifdef WRAP_AROUND","vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );","#endif","#endif","#ifdef WRAP_AROUND","vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );","spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );","#ifdef DOUBLE_SIDED","spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );","#endif","#endif","vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;","#ifdef DOUBLE_SIDED","vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;","#endif","}","}","#endif","vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;","#ifdef DOUBLE_SIDED","vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;","#endif"].join("\n")}}),define("DS/Shaders/DeferrableShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{picking_pars_vertex:"\n        #ifdef PICKING_MATERIAL\n          #ifdef SPECIAL_PICKING_INSTANCING\n            varying vec3 pickingColor;\n          #endif\n        #endif\n        ",picking_vertex:"\n        #ifdef PICKING_MATERIAL\n          #ifdef SPECIAL_PICKING_INSTANCING\n            pickingColor = specialMeshPicking;\n          #endif\n        #endif\n        ",picking_pars_fragment:"\n        #ifdef PICKING_MATERIAL\n          #ifdef SPECIAL_PICKING_INSTANCING\n            varying vec3 pickingColor;\n          #else\n            uniform vec3 pickingColor;\n          #endif\n        #endif\n        ",picking_fragment:"\n        #ifdef PICKING_MATERIAL\n          gl_FragColor = vec4( pickingColor, 1.0 );\n        #endif\n        ",picking_instancing_pars_vertex:"\n        #ifdef PICKING_INSTANCING_MATERIAL\n          varying vec3 vInstancePickingColor;\n        #endif\n        ",picking_instancing_vertex:"\n        #ifdef PICKING_INSTANCING_MATERIAL\n          if (instanceId > 16777215.0) vInstancePickingColor = vec3(0.0);\n          else {\n            vInstancePickingColor.r = floor(instanceId / 65536.0);\n            vInstancePickingColor.g = floor((instanceId - vInstancePickingColor.r * 65536.0) / 256.0);\n            vInstancePickingColor.b = floor(instanceId - vInstancePickingColor.r * 65536.0 - vInstancePickingColor.g * 256.0);\n            vInstancePickingColor /= 255.0;\n          }\n        #endif\n        ",picking_instancing_pars_fragment:"\n        #ifdef PICKING_INSTANCING_MATERIAL\n          varying vec3 vInstancePickingColor;\n        #endif\n        ",picking_instancing_fragment:"\n        #ifdef PICKING_INSTANCING_MATERIAL\n          gl_FragColor = vec4(vInstancePickingColor, 1.0);\n        #endif\n        ",depth_pars_vertex:"\t\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL) || defined(NORMAL_DEPTH_MATERIAL) || defined(NORMAL_DEPTH_IOR_ROUGHNESS_MATERIAL) || defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL)\t\n          #if !defined(DECAL) && !defined PDSFX\n            varying vec4 DS_clipPosition;\n          #endif\n        #endif\n        ",depth_vertex:"\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL) || defined(NORMAL_DEPTH_MATERIAL) || defined(NORMAL_DEPTH_IOR_ROUGHNESS_MATERIAL) || defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL)\t\n          #if !defined(DECAL) && !defined PDSFX\n            DS_clipPosition = gl_Position;\n          #endif\n        #endif\n        ",depth_pars_fragment:"\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL) || defined(NORMAL_DEPTH_MATERIAL) || defined(NORMAL_DEPTH_IOR_ROUGHNESS_MATERIAL) || defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL)\t\n          #if !defined(DECAL) && !defined PDSFX\n            varying vec4 DS_clipPosition;\n          #endif\n        #endif\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL)\n            float shift_right(float v, float amt) {\n              v = floor(v) + 0.5;\n              return floor(v / exp2(amt));\n                }\n\n                float shift_left(float v, float amt) {\n              return floor(v * exp2(amt) + 0.5);\n                }\n            float mask_last(float v, float bits) {\n              return mod(v, shift_left(1.0, bits));\n            }\n            float extract_bits(float num, float from, float to) {\n              from = floor(from + 0.5);\n              to = floor(to + 0.5);\n              return mask_last(shift_right(num, from), to - from);\n            }\n            vec4 encode_float(float val) {\n              if (val == 0.0)\n                return vec4(0, 0, 0, 0);\n              float sign = val > 0.0 ? 0.0 : 1.0;\n                  val = abs(val);\n                  float exponent = floor(log2(val));\n                  float biased_exponent = exponent + 127.0;\n                  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\n              float t = biased_exponent / 2.0;\n                  float last_bit_of_biased_exponent = fract(t) * 2.0;\n                  float remaining_bits_of_biased_exponent = floor(t);\n              float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\n                  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\n                  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\n                  float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n                  return vec4(byte4, byte3, byte2, byte1);\n              }\n\n            vec4 packRGBAFace( const in float depth ) {\n              float depthToUse = depth;\n              #if defined(GL_OES_standard_derivatives) || defined(GLSL300ES)\n                float dx = dFdx(depth);\n                float dy = dFdy(depth);\n                depthToUse += sqrt(dx*dx + dy*dy) + DEPTH_PRECISION;\n              #else\n                depthToUse += 2.0 *DEPTH_PRECISION;\n              #endif\n              return packRGBA(depthToUse);\n            }\n        #endif\n        ",depth_fragment_face:"\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL)\n          #ifdef DECAL\n            #ifdef DEPTH_RGBA_MATERIAL\n              vec4 encode = packRGBAFace(gl_FragDepthEXT);\n            #else\n              vec4 encode = encode_float(gl_FragDepthEXT);\n            #endif\n          #else\n            #ifdef PDSFX\n              float depthValue = 0.5 + 0.5 * _DSclipPosition.z / _DSclipPosition.w;\n            #else\n              float depthValue = 0.5 + 0.5 * DS_clipPosition.z / DS_clipPosition.w;\n            #endif\n            #ifdef DEPTH_RGBA_MATERIAL\n              vec4 encode = packRGBAFace(depthValue);\n            #else\n              vec4 encode = encode_float(depthValue);\n            #endif\n          #endif\n          gl_FragColor = encode;\n        #endif\n        ",depth_fragment:"\n        #if defined(DEPTH_MATERIAL) || defined(DEPTH_RGBA_MATERIAL)\n          #ifdef PDSFX\n            float depthValue = 0.5 + 0.5 * _DSclipPosition.z / _DSclipPosition.w;\n          #else\n            float depthValue = 0.5 + 0.5 * DS_clipPosition.z / DS_clipPosition.w;\n          #endif\n          #ifdef DEPTH_RGBA_MATERIAL\n            vec4 encode = packRGBA(depthValue);\n          #else\n            vec4 encode = encode_float(depthValue);\n          #endif\n          gl_FragColor = encode;\n        #endif\n        ",normal_fragment:"\n        #if defined(NORMAL_MATERIAL)\n          gl_FragColor.xyz = normal * 0.5 + 0.5;\n        #endif\n        ",lineic_normal_fragment:"\n        #if defined(NORMAL_MATERIAL)         \n          gl_FragColor.xyz = vec3(0.5);\n        #endif\n        ",decal_normal_depth_pars_fragment:"\n        #ifdef DECAL_NORMAL_STENCIL_DEPTH_MATERIAL\n          uniform float decalStencilValue;\n        #endif\n\n        #if defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL) || (defined(NORMAL_DEPTH_MATERIAL) && !defined(RENDER_TO_FLOAT_TEXTURE))\n          vec2 normalToOct22(in vec3 normal) {\n            float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);\n            float oNx = normal.x / manNorm;\n            float oNy = normal.y / manNorm;\n            if (normal.z < 0.0) {\n              float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);\n              float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);\n              oNx = tmpx;\n              oNy = tmpy;\n            }\n            return floor((2047.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);\n          }\n        #endif\n\n        \n        #if defined(NORMAL_DEPTH_IOR_ROUGHNESS_MATERIAL)\t\n          float normalToOct24(in vec3 normal) {\n            float manNorm = abs(normal.x) + abs(normal.y) + abs(normal.z);\n            float oNx = normal.x / manNorm;\n            float oNy = normal.y / manNorm;\n            if (normal.z < 0.0) {\n              float tmpx = (1.0 - abs(oNy)) * (oNx >= 0.0 ? 1.0 : -1.0);\n              float tmpy = (1.0 - abs(oNx)) * (oNy >= 0.0 ? 1.0 : -1.0);\n              oNx = tmpx;\n              oNy = tmpy;\n            }\n            vec2 compNormal = floor((4095.0 * (0.5 * vec2(oNx, oNy) + 0.5))+0.5);\n            return compNormal.x * 4096.0 + compNormal.y;\n          }\n        #endif\n        ",normal_depth_fragment:"\n        #if defined(NORMAL_DEPTH_MATERIAL) || defined(NORMAL_DEPTH_IOR_ROUGHNESS_MATERIAL) || defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL)\n          #if defined(DECAL_NORMAL_STENCIL_DEPTH_MATERIAL)\n            gl_FragColor.xy = normalToOct22(normal); \n            gl_FragColor.z = decalStencilValue;\n          #elif defined(NORMAL_DEPTH_MATERIAL)\n            gl_FragColor.xyz = normal * 0.5 + 0.5;\n          #else\n            gl_FragColor.x = normalToOct24(normal);\n            #if defined(DSPBR) || defined(SPECGLOSS)\n              #ifdef USE_NEWSSLR\n                gl_FragColor.z = materialData.roughness;\n              #else\n                float oldSSRFactor = materialData.roughness * materialData.roughness;\n                gl_FragColor.z = 1.0 - oldSSRFactor;\n              #endif\n              gl_FragColor.y = 0.0;\n              #if defined(DSPBR)\n                #ifndef THIN_WALLED\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                      gl_FragColor.y = materialData.adjustedIoR;\n                    }\n                #else\n                    if (materialData.transparency > 0.0 && materialData.metalness < 1.0) {\n                      gl_FragColor.y = 1.0;\n                    }\n                #endif\n              #endif\n            #else\n              gl_FragColor.y = 0.0;\n              #if defined(PHONG) \n                gl_FragColor.z = reflectionCoef;\n              #else\n                gl_FragColor.z = 0.0;\n              #endif\n            #endif\n          #endif\n          #ifdef DECAL\n            gl_FragColor.w = gl_FragDepthEXT;\n          #else\n            #ifdef PDSFX\n              float depthValue = 0.5 + 0.5 * _DSclipPosition.z / _DSclipPosition.w;\n            #else\n              float depthValue = 0.5 + 0.5 * DS_clipPosition.z / DS_clipPosition.w;\n            #endif\n            gl_FragColor.w = depthValue;\n          #endif\n          #if !defined(RENDER_TO_FLOAT_TEXTURE) && defined(NORMAL_DEPTH_MATERIAL)\n            gl_FragColor.xy = normalToOct22(normal); \n            float convertedDepth = 8388608.0 * gl_FragColor.w;\n            gl_FragColor.z = floor(convertedDepth / 4096.0);\n            gl_FragColor.w = mod(convertedDepth, 4096.0);\n          #endif\n        #endif\n        ",shadowmap_pars_fragment:"\n        #if defined(SHADOWMAP_MATERIAL)\n\n            vec4 pack_depth_esm(const in float depth) {\n              #ifdef USE_UINT_ESM\n                float esmDepth = exp(80.0*depth);\n                float exposant = ceil(log(esmDepth)/log(10.0));\n                float normDepth = esmDepth/pow(10.0,exposant);\n                return vec4(packRGB(normDepth),exposant/255.0);\n              #else\n                return vec4(exp(80.0*depth),0.0,0.0,1.0);\n              #endif\n            }\n\n          vec4 pack_depth( const in float depth ) {\n            return packRGBA(depth);\n          }\n        #endif\n        ",shadowmap_fragment:"\n        #if defined(SHADOWMAP_MATERIAL)\n          #ifndef USE_SUBSURFACE\n            if (gl_FragColor.a < 1.0 - 1e-3) {\n              discard;\n            }\n          #endif\n          vec4 finalData;\n          #ifdef DECAL\n            float depth = gl_FragDepthEXT;\n          #else\n            float depth = gl_FragCoord.z;\n          #endif\n          #if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED)\n            finalData = pack_depth_esm( depth );\n          #else\n            finalData = pack_depth( depth );\n          #endif\n          \n          #ifdef GLSL300ES\n            outFragColor = finalData;\t\t\t\t\n          #else\n            gl_FragColor = finalData;\n          #endif\n        #endif\n        #if defined(TRANSPARENT_SHADOWMAP_MATERIAL)\n          #ifdef USE_SUBSURFACE\n            discard;\n          #endif\n        #endif\n        ",highlight_pars_vertex:"\n          #ifdef HIGHLIGHT_MATERIAL\t\t\n            #if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)\n              varying vec4 DS_clipPosition;\n            #endif\n          #endif\n        ",highlight_vertex:"\n          #ifdef HIGHLIGHT_MATERIAL\t\t\n            #if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)\n              DS_clipPosition = gl_Position;;\n            #endif\n          #endif\n        ",highlight_pars_fragment:"\n          #ifdef HIGHLIGHT_MATERIAL\t\n            #ifdef MOBILE_HIGHLIGHT_MODE\n              #if defined(LINEBASIC) || defined(PARTICLEBASIC)\n                uniform vec4 iHighlightLineicColor;\n              #else\n                uniform vec4 iHighlightColor;\n              #endif\n              uniform vec2 iHighlightIntensity;\n            #else\n              uniform float highlightID;\n            #endif\n            #if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)\n              varying vec4 DS_clipPosition;\n            #else\n              vec4 DS_clipPosition;\n            #endif\n            #if HIGHLIGHT_POLITE == 1\n              #ifdef NOZ_OBJECT\n                const int noZ = 1;\n              #else\n                const int noZ = 0;\n              #endif\n              uniform sampler2D rgbaDepth;\n\n              const float highlightBack = 0.66;\n              const float highlightFront = 0.33;\n\n              float depthSampleTest(in vec2 coord, in float depth) {\n                float fDepth = unpackRGBA(texture2D(rgbaDepth, coord));\n                if ( fDepth  < depth) return highlightBack;\n                return highlightFront;\n              }\n\n              float getDepthTestResult(float depth) {\n                vec2 coord = 0.5 + 0.5*DS_clipPosition.xy/DS_clipPosition.w;\n                return depthSampleTest(coord, depth - 2.38418579e-7);\n              }\n\n              float getFaceDepthValue() {\n                if (noZ == 1) {\n                  return highlightFront;\n                }\n                #ifdef DECAL\n                  float depth = gl_FragDepthEXT;\n                #else\n                  float depth = 0.5 + 0.5 * DS_clipPosition.z / DS_clipPosition.w;\n                #endif\n                float faceDepth = depth;\n                #if defined(GL_OES_standard_derivatives) || defined(GLSL300ES)\n                  float dx = dFdx(depth);\n                  float dy = dFdy(depth);\n                  #if defined(MOBILE_HIGHLIGHT_MODE) && !defined(MOBILE_DEVICE_MODE)\n                    faceDepth += 0.5 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);\n                  #else\n                    faceDepth += 0.9 * (sqrt(dx*dx + dy*dy) + DEPTH_PRECISION);\n                  #endif\n                #else\n                  faceDepth += 1.5 *DEPTH_PRECISION;\n                #endif\n                return getDepthTestResult(faceDepth);\n              }\n\n              float getDepthValue() {\n                if (noZ == 1) {\n                  return highlightFront;\n                }\n                float depth = 0.5 + 0.5 * DS_clipPosition.z / DS_clipPosition.w;\n                return getDepthTestResult(depth);\n              }\n            #endif\n          #endif\n        ",highlight_fragment_face:"\n          #ifdef HIGHLIGHT_MATERIAL\t\t\n            vec3 I = vec3(0.0, 0.0, 1.0);\n            if (!(projectionMatrix[3][3] > 0.0)) {\n              I = normalize( vPos.xyz );\n            }\n            float reflectionFactor = abs( dot( I, normal ) );\n            #if HIGHLIGHT_POLITE == 1              \n              #ifdef PDSFX\n                DS_clipPosition = _DSclipPosition;\n              #endif\n              float depthValue = getFaceDepthValue();\n              reflectionFactor = noZ == 1 ? 0.8 : depthValue < 0.5 ? (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141 : reflectionFactor;\n              #ifdef MOBILE_HIGHLIGHT_MODE\n                gl_FragColor = vec4( iHighlightColor.xyz * reflectionFactor, depthValue > 0.5 ? iHighlightIntensity.y : iHighlightIntensity.x);\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              #else\n                gl_FragColor = vec4( highlightID / 255.0, reflectionFactor, depthValue , 0.0 );\n              #endif\n            #else\n              reflectionFactor = 1.0 - reflectionFactor;\n              #ifdef MOBILE_HIGHLIGHT_MODE\n                gl_FragColor = vec4( iHighlightColor.xyz, (0.6 * reflectionFactor*reflectionFactor + 0.2)* iHighlightIntensity.x );\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              #else\n                gl_FragColor = vec4( highlightID / 255.0, reflectionFactor * reflectionFactor , 0.0, 0.0 );\n              #endif\n            #endif\n          #endif\n        ",highlight_fragment_edge:"\n          #ifdef HIGHLIGHT_MATERIAL\t\t\n            #if HIGHLIGHT_POLITE == 1\n              #ifdef PDSFX\n                DS_clipPosition = _DSclipPosition;\n              #endif\n              #ifdef MOBILE_HIGHLIGHT_MODE\n                #ifdef USE_WIDELINE\n                gl_FragColor = vec4( iHighlightLineicColor.xyz, halfWidth > 0.5 ? 0.8 : 1.0);\n                #else\n                gl_FragColor = vec4( iHighlightLineicColor.xyz, 1.0);\n                #endif\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              #else\n                float wValue = 1.0 / 255.0;\n                #ifdef PRIMITIVE_HIGHLIGHT\n                  wValue = 2.0 / 255.0;\n                #endif\n                #ifdef ADJACENCE_HIGHLIGHT\n                  gl_FragColor = vec4( highlightID / 255.0, 1.0, highlightFront , wValue );\n                #else\n                \tgl_FragColor = vec4( highlightID / 255.0, 1.0, getDepthValue() , wValue );\n              \t#endif\n              #endif\n            #else\n              #ifdef MOBILE_HIGHLIGHT_MODE\n                gl_FragColor = vec4( iHighlightLineicColor.xyz, 0.8 * iHighlightIntensity.x );\n                gl_FragColor.a = min(gl_FragColor.a, 1.0);\n              #else              \n                float wValue = 1.0 / 255.0;\n                gl_FragColor = vec4( highlightID / 255.0, 1.0 , 0.0, wValue );\n              #endif\n            #endif\n          #endif\n        ",highlight_fragment_point:"\n          #ifdef HIGHLIGHT_MATERIAL\t\t\t\n            #ifdef MOBILE_HIGHLIGHT_MODE\t\t\n              #if HIGHLIGHT_POLITE == 1         \n                #ifdef PDSFX\n                  DS_clipPosition = _DSclipPosition;\n                #endif\n                gl_FragColor = vec4( iHighlightLineicColor.xyz, 0.8);\n              #else\n                gl_FragColor = vec4( iHighlightLineicColor.xyz, 0.8 * iHighlightIntensity.x );\n              #endif\n              gl_FragColor.a = min(gl_FragColor.a, 1.0);\n            #else\n              float wValue = 3.0 / 255.0;\n              #if HIGHLIGHT_POLITE == 1\n                #ifdef PDSFX\n                  DS_clipPosition = _DSclipPosition;\n                #endif\n                #ifdef PRIMITIVE_HIGHLIGHT\t\t\n                    wValue = 4.0 / 255.0;\n                    gl_FragColor = vec4( highlightID / 255.0, 1.0 , getDepthValue(), wValue );\n                #else\n                    gl_FragColor = vec4( highlightID / 255.0, 1.0 , 0.0, wValue);\n                #endif\n              #else\n                gl_FragColor = vec4( highlightID / 255.0, 1.0 , 0.0, wValue );\n              #endif\n            #endif\n          #endif\n        ",texcoord_pars_vertex:"\n          #ifdef TEXTURE_COORDINATES_MATERIAL\n            varying vec2 vUv_deferred;\n            varying vec2 vUv2_deferred;\n          #endif\n        ",texcoord_vertex:"\n          #ifdef TEXTURE_COORDINATES_MATERIAL\n            vUv_deferred = uv;\n            vUv2_deferred = uv2;\n          #endif\n        ",texcoord_pars_fragment:"\n          #ifdef TEXTURE_COORDINATES_MATERIAL\n            varying vec2 vUv_deferred;\n            varying vec2 vUv2_deferred;\n          #endif\n        ",texcoord_fragment:"\n            #ifdef TEXTURE_COORDINATES_MATERIAL\n              gl_FragColor = vec4( vUv_deferred.x, vUv_deferred.y ,vUv2_deferred.x, vUv2_deferred.y);\n            #endif\n        ",_debug_common_face_fragment:"\n            #ifdef DEBUG_DEPTH\n                gl_FragColor.a = 1.0;\n                gl_FragColor.rgb = vec3(gl_FragCoord.z);\n            #endif\n            #ifdef DEBUG_NORMAL\n                gl_FragColor.a = 1.0;\n                #ifdef GPU_OUTLINES\n                    gl_FragColor.rgb = vec3(0.5);\n                #else\n                    gl_FragColor.rgb = 0.5 * normalize((vec4(normal.xyz, 0.0) * viewMatrix).xyz) + 0.5;\n                #endif\n            #endif\n            #ifdef DEBUG_SHADOW\n                gl_FragColor.a = 1.0;\n                #if !defined(SPECGLOSS) && !defined(DSPBR)\n                    discard;\n                #endif\n            #endif          \n            #if defined(DEBUG_GEOM_UVS)\n                gl_FragColor.a = 1.0;\n                #ifdef NEEDS_UVTOUSE            \n                    gl_FragColor.rgb = vec3(mod(vUv.x, 1.0), mod(vUv.y, 1.0), 0.0);\n                #else\n                    gl_FragColor.rgb = vec3(0.0);\n                #endif\n            #endif\n            #if defined(DEBUG_MAPPING_UVS)\n                gl_FragColor.a = 1.0;\n                #ifdef NEEDS_UVTOUSE\n                    gl_FragColor.rgb = vec3(mod(uvToUse.x, 1.0), mod(uvToUse.y, 1.0), 0.0);\n                #else          \n                    gl_FragColor.rgb = vec3(0.0);\n                #endif\n            #endif\n            \n            #if defined(DEBUG_GEOM_UV2S)\n                gl_FragColor.a = 1.0;\n                #if defined(NEEDS_UVTOUSE) && (defined(SPECGLOSS) || defined(DSPBR))       \n                    gl_FragColor.rgb = vec3(mod(vUv2.x, 1.0), mod(vUv2.y, 1.0), 0.0);\n                #else\n                    gl_FragColor.rgb = vec3(0.0);\n                #endif\n            #endif\n            #if defined(DEBUG_MAPPING_UV2S)\n                gl_FragColor.a = 1.0;\n                #if defined(NEEDS_UVTOUSE) && (defined(SPECGLOSS) || defined(DSPBR))\n                    gl_FragColor.rgb = vec3(mod(uv2ToUse.x, 1.0), mod(uv2ToUse.y, 1.0), 0.0);\n                #else          \n                    gl_FragColor.rgb = vec3(0.0);\n                #endif\n            #endif\n        ",_debug_common_lineic_fragment:"\n            #ifdef DEBUG_DEPTH\n                gl_FragColor.a = 1.0;\n                gl_FragColor.rgb = vec3(gl_FragCoord.z);\n            #endif\n            #ifdef DEBUG_NORMAL\n                gl_FragColor.a = 1.0;\n                gl_FragColor.rgb = vec3(0.5);\n            #endif\n            #if defined(DEBUG_SHADOW) || defined(DEBUG_GEOM_UVS) || defined(DEBUG_MAPPING_UVS) || defined(DEBUG_MAPPING_UV2S) || defined(DEBUG_GEOM_UV2S)\n                discard;\n            #endif\n        ",oit_pars_vertex:["#ifdef USE_OIT","#ifdef OIT_ACCUM_MATERIAL","   varying float depthOITValue;","#endif","#endif"].join("\n"),oit_vertex:["#ifdef USE_OIT","#ifdef OIT_ACCUM_MATERIAL",e.getModelViewTransformationChunk("vec4 aux","vec4(position.xyz, 1.0)"),"   depthOITValue = aux.z;","   float normalizeValue;","       float m22 = projectionMatrix[2][2];","       float m32 = projectionMatrix[3][2];","       float near = m32 / (m22 - 1.0);","       float far = ((m22 - 1.0)*near)/(m22 + 1.0);","       normalizeValue = far + near;","   depthOITValue /= 0.5*normalizeValue;","#endif","#endif"].join("\n"),oit_vertex_point:[""].join("\n"),oit_pars_fragment:["#ifdef USE_OIT","#ifdef OIT_ACCUM_MATERIAL","   varying float depthOITValue;","   float getOITWeight() {","       float distanceTerm = 0.3/ (1e-3 + pow(abs(depthOITValue), 4.0));","       distanceTerm = clamp(distanceTerm, 1e-3, 3e3);","       float alphaTerm = gl_FragColor.a ;","       return alphaTerm * alphaTerm * distanceTerm;","   }","#endif","#endif"].join("\n"),oit_fragment:["#ifdef DEBUG_DECAL","if (length(dViewPosition) < 2e-6) {","gl_FragColor.rgba = vec4(1.0,0.0,0.0, 0.5);","}","#endif","#ifdef USE_OIT","#if defined(OIT_ACCUM_MATERIAL) || defined(OIT_REVEAL_MATERIAL)","if (gl_FragColor.a > 1.0 - 1e-2) {","discard;","}","#elif defined(ORIGINAL_MATERIAL)","if (gl_FragColor.a < 1.0 - 1e-2){","discard;","}","gl_FragColor.a = 1.0;","#endif","#if defined(OIT_ACCUM_MATERIAL)","gl_FragColor = vec4(gl_FragColor.rgb, 1.0)* getOITWeight();","#elif defined(OIT_REVEAL_MATERIAL)","gl_FragColor.r = gl_FragColor.a;","#endif","#endif"].join("\n"),oit_fragment_point:["#ifdef USE_OIT","   #if defined(OIT_ACCUM_MATERIAL) || defined(OIT_REVEAL_MATERIAL)","      discard;","   #endif","#endif"].join("\n")}}),define("DS/Shaders/AlphaShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{alphatest_fragment:["#if defined(ALPHATEST)","if ( gl_FragColor.a < ALPHATEST ) discard;","#endif","#ifdef DISCARD_OR_OPAQUE","gl_FragColor.a = 1.0;","#endif","#if defined(SKIP_TRANSPARENT)","if ( gl_FragColor.a < 1.0 - 1e-3) discard;","#endif"].join("\n")}}),define("DS/Shaders/ClipShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{clip_pars_vertex:["#ifdef USE_CLIPPINGPLANES","uniform lowp int nbClipPlanes;","uniform vec4 clipPlaneEquations[ 6 ];","varying float clipDist[ 6 ];","vec4 getClipPlaneEquation(in int index) {","if (index == 0) return clipPlaneEquations[0];","if (index == 1) return clipPlaneEquations[1];","if (index == 2) return clipPlaneEquations[2];","if (index == 3) return clipPlaneEquations[3];","if (index == 4) return clipPlaneEquations[4];","if (index == 5) return clipPlaneEquations[5];","return clipPlaneEquations[0];","}","#endif","#ifdef USE_CLIPPINGPOLYGON","// UNROLL_CLIPPINGPOLYGON","varying vec2 extrusionPlaneUV/*#i*/[NB_CLIPPINGPOLYGON/*#i*/];","uniform vec3 extrusionPlaneU/*#i*/[NB_CLIPPINGPOLYGON/*#i*/];","uniform vec3 extrusionPlaneV/*#i*/[NB_CLIPPINGPOLYGON/*#i*/];","// UNROLL_CLIPPINGPOLYGON_END","#endif","#ifdef USE_CLIPPINGCYLINDER","// UNROLL_CLIPPINGCYLINDER","varying vec2 cylinderAxisUV/*#i*/;","uniform vec3 cylinderCenter/*#i*/;","uniform vec3 cylinderAxisU/*#i*/;","uniform vec3 cylinderAxisV/*#i*/;","// UNROLL_CLIPPINGCYLINDER_END","#endif","#ifdef USE_SCISSORPOLYGON","// UNROLL_SCISSORPOLYGON","#ifndef PDSFX","  varying vec4 scissorClipPos;","#endif","// UNROLL_SCISSORPOLYGON_END","#endif",""].join("\n"),clip_vertex:["#ifdef USE_CLIPPINGPLANES","if(nbClipPlanes > 0) {","clipDist[ 0 ] = dot( mvPosition.xyz, clipPlaneEquations[ 0 ].xyz ) + clipPlaneEquations[ 0 ].w;","clipDist[ 1 ] = dot( mvPosition.xyz, clipPlaneEquations[ 1 ].xyz ) + clipPlaneEquations[ 1 ].w;","clipDist[ 2 ] = dot( mvPosition.xyz, clipPlaneEquations[ 2 ].xyz ) + clipPlaneEquations[ 2 ].w;","clipDist[ 3 ] = dot( mvPosition.xyz, clipPlaneEquations[ 3 ].xyz ) + clipPlaneEquations[ 3 ].w;","clipDist[ 4 ] = dot( mvPosition.xyz, clipPlaneEquations[ 4 ].xyz ) + clipPlaneEquations[ 4 ].w;","clipDist[ 5 ] = dot( mvPosition.xyz, clipPlaneEquations[ 5 ].xyz ) + clipPlaneEquations[ 5 ].w;","}","#endif","#if defined(USE_CLIPPINGPOLYGON) || defined(USE_SCISSORPOLYGON)","vec3 positionWorld = (modelMatrix*vec4(position.xyz, 1)).xyz;","#endif","#ifdef USE_CLIPPINGPOLYGON","// UNROLL_CLIPPINGPOLYGON","for(int i=0; i < NB_CLIPPINGPOLYGON; i++) {","  extrusionPlaneUV/*#i*/[i] = vec2(dot(mvPosition.xyz, extrusionPlaneU/*#i*/[i]), dot(mvPosition.xyz, extrusionPlaneV/*#i*/[i]));","}","// UNROLL_CLIPPINGPOLYGON_END","#endif","#ifdef USE_SCISSORPOLYGON","#ifndef PDSFX","  scissorClipPos = gl_Position;","#endif","#endif","#ifdef USE_CLIPPINGCYLINDER","// UNROLL_CLIPPINGCYLINDER","vec3 posWorldCylinder/*#i*/ = (modelMatrix * vec4(position.xyz, 1)).xyz - cylinderCenter/*#i*/;","cylinderAxisUV/*#i*/ = vec2(dot(posWorldCylinder/*#i*/, cylinderAxisU/*#i*/), dot(posWorldCylinder/*#i*/, cylinderAxisV/*#i*/));","// UNROLL_CLIPPINGCYLINDER_END","#endif",""].join("\n"),clip_pars_fragment:["#ifdef USE_CLIPPINGPLANES","uniform lowp int nbClipPlanes;","varying float clipDist[ 6 ];","uniform int clipPlaneActive[ 6 ];","uniform lowp float clipFrontOpacity;","uniform lowp float clipBackOpacity;","#endif","#ifdef USE_CLIPPINGPOLYGON","// UNROLL_CLIPPINGPOLYGON","uniform sampler2D polygonPoints/*#i*/;","uniform int polygonSize/*#i*/[NB_CLIPPINGPOLYGON];","varying vec2 extrusionPlaneUV/*#i*/[NB_CLIPPINGPOLYGON];","// UNROLL_CLIPPINGPOLYGON_END","#endif","#ifdef USE_SCISSORPOLYGON","#ifndef PDSFX","  varying vec4 scissorClipPos;","#endif","// UNROLL_SCISSORPOLYGON","uniform sampler2D scissorPoints/*#i*/;","uniform int scissorSize/*#i*/[NB_SCISSOR/*#i*/];","// UNROLL_SCISSORPOLYGON_END","#endif","#if defined(USE_CLIPPINGPOLYGON) || defined(USE_SCISSORPOLYGON)","vec2 getPolygonPoint(const sampler2D sampler, const int size, const in int index) {","    return texture2D(sampler, vec2((float(index)+0.5)*1.0/float(size),0.5)).rg;","}","","bool isPointInsidePolygon(const sampler2D sampler, const int size, const in vec2 point, const int offset, const int totalSize) {","    vec2 previousPoint, currentPoint;","    previousPoint = getPolygonPoint(sampler, totalSize, size-1+offset);","    bool result = false;","    for(int i=0; i < MAX_POLYGON_SIZE;i++) {","        if(i < size) {","            currentPoint = getPolygonPoint(sampler, totalSize, i+offset);","            if ( ((currentPoint.y>point.y) != (previousPoint.y>point.y)) &&","                 (point.x < (previousPoint.x-currentPoint.x) * (point.y-currentPoint.y) / (previousPoint.y-currentPoint.y) + currentPoint.x) ) {","                result = !result;","            }","            previousPoint = currentPoint;","        }","    }","    return result;","}","#endif","","#ifdef USE_CLIPPINGCYLINDER","// UNROLL_CLIPPINGCYLINDER","varying vec2 cylinderAxisUV/*#i*/;","uniform int cylinderClipZone/*#i*/;","// UNROLL_CLIPPINGCYLINDER_END","#endif",""].join("\n"),clip_fragment:["#ifdef USE_CLIPPINGPLANES","float clipOpacity = -1.0;","if(nbClipPlanes > 0) {","if (0 < nbClipPlanes && clipDist[ 0 ] < 0.0 && clipPlaneActive[ 0 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 0 < nbClipPlanes && clipPlaneActive[ 0 ] > 0) { clipOpacity = clipFrontOpacity; }","if (1 < nbClipPlanes && clipDist[ 1 ] < 0.0 && clipPlaneActive[ 1 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 1 < nbClipPlanes && clipPlaneActive[ 1 ] > 0) { clipOpacity = clipFrontOpacity; }","if (2 < nbClipPlanes && clipDist[ 2 ] < 0.0 && clipPlaneActive[ 2 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 2 < nbClipPlanes && clipPlaneActive[ 2 ] > 0) { clipOpacity = clipFrontOpacity; }","if (3 < nbClipPlanes && clipDist[ 3 ] < 0.0 && clipPlaneActive[ 3 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 3 < nbClipPlanes && clipPlaneActive[ 3 ] > 0) { clipOpacity = clipFrontOpacity; }","if (4 < nbClipPlanes && clipDist[ 4 ] < 0.0 && clipPlaneActive[ 4 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 4 < nbClipPlanes && clipPlaneActive[ 4 ] > 0) { clipOpacity = clipFrontOpacity; }","if (5 < nbClipPlanes && clipDist[ 5 ] < 0.0 && clipPlaneActive[ 5 ] > 0) { clipOpacity = clipBackOpacity; }","else if (clipOpacity == -1.0 && 5 < nbClipPlanes && clipPlaneActive[ 5 ] > 0) { clipOpacity = clipFrontOpacity; }","if(clipOpacity == 0.0) discard;","}","#endif","#ifdef USE_CLIPPINGPOLYGON","int offset_polygon;","// UNROLL_CLIPPINGPOLYGON","offset_polygon = 0;","int totalSize_polyon = 0;","for(int ipolygon = 0; ipolygon < NB_CLIPPINGPOLYGON/*#i*/; ipolygon++) {","  totalSize_polyon += polygonSize/*#i*/[ipolygon];","}","for(int ipolygon = 0; ipolygon < NB_CLIPPINGPOLYGON/*#i*/; ipolygon++) {","  int size = polygonSize/*#i*/[ipolygon];","  if(size > 0) {","    if(!isPointInsidePolygon(polygonPoints/*#i*/, polygonSize/*#i*/[ipolygon], extrusionPlaneUV/*#i*/[ipolygon], offset_polygon, totalSize_polyon)) {","      discard;","    }","    offset_polygon+=size;","  }","}","// UNROLL_CLIPPINGPOLYGON_END","#endif","#ifdef USE_SCISSORPOLYGON","int offset_scissor;","// UNROLL_SCISSORPOLYGON","offset_scissor = 0;","int totalSize_scissor = 0;","for(int iscissor = 0; iscissor < NB_SCISSOR/*#i*/; iscissor++) {","  totalSize_scissor += scissorSize/*#i*/[iscissor];","}","for(int iscissor = 0; iscissor < NB_SCISSOR/*#i*/; iscissor++) {","  int size = scissorSize/*#i*/[iscissor];","#ifdef PDSFX","  vec4 clipSpacePosition = vGetClipSpacePosition();","#else","  vec4 clipSpacePosition = scissorClipPos;","#endif","  vec2 position2d = clipSpacePosition.xy / clipSpacePosition.w;","  if(size > 0) {","    if(!isPointInsidePolygon(scissorPoints/*#i*/, scissorSize/*#i*/[iscissor], position2d, offset_scissor, totalSize_scissor)) {","      discard;","    }","    offset_scissor+=size;","  }","}","// UNROLL_SCISSORPOLYGON_END","#endif","","#ifdef USE_CLIPPINGCYLINDER","// UNROLL_CLIPPINGPOLYGON","if(cylinderClipZone/*#i*/ != 0) {","\tbool isInside = dot(cylinderAxisUV/*#i*/, cylinderAxisUV/*#i*/) <= 1.0;","\tbool removeInside = cylinderClipZone/*#i*/ < 0;","\tif(isInside == removeInside) discard;","}","// UNROLL_CLIPPINGPOLYGON_END","#endif",""].join("\n")}}),define("DS/Shaders/ShadowingShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{shadowmap_pars_fragment:["#if defined (USE_SHADOWMAP) || defined(USE_SHADOWMAP_CUBE)","float unpackDepthESM( const in vec4 rgba_depth ) {","\tfloat depth = unpackRGB(rgba_depth.xyz) * pow(10.0,rgba_depth.w*255.0);","\treturn depth;","}","float unpackDepth( const in vec4 rgba_depth ) {","return unpackRGBA(rgba_depth);","}","float randomValue(vec3 scale, float seed) {","return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","#endif","#ifdef USE_SHADOWMAP","uniform sampler2D shadowMap[ MAX_SHADOWS ];","#ifdef USE_TRANSPARENTSHADOWMAP","uniform sampler2D transparentShadowMap[ MAX_SHADOWS ];","#if MAX_DIR_LIGHTS > 0","uniform vec3 directionalLightColorNoIntensity[ MAX_DIR_LIGHTS ];","#endif","#if MAX_SPOT_LIGHTS > 0","uniform vec3 spotLightColorNoIntensity[ MAX_SPOT_LIGHTS ];","#endif","#endif","uniform vec2 shadowMapSize[ MAX_SHADOWS ];","uniform float shadowDarkness[ MAX_SHADOWS ];","uniform float shadowBias[ MAX_SHADOWS ];","#ifdef USE_SUBSURFACE","uniform float shadowMapNear[ MAX_SHADOWS ];","uniform float shadowMapFar[ MAX_SHADOWS ];","#endif","#define SHADOWS_DIR_END MAX_SHADOWS_DIR","#define SHADOWS_SPOT_START SHADOWS_DIR_END","#define SHADOWS_SPOT_END SHADOWS_SPOT_START + MAX_SHADOWS_SPOT","#define SHADOWS_DIR_IBL_START SHADOWS_SPOT_END","#define SHADOWS_DIR_IBL_END SHADOWS_DIR_IBL_START + MAX_SHADOWS_DIR_IBL","#define SHADOWS_CASTABLE_END SHADOWS_DIR_IBL_START","#if defined(SHADOWMAP_TYPE_PCF_POISSON) ||defined(SHADOWMAP_TYPE_PCF_INTERPOL)","#if defined(SHADOWMAP_QUALITY_MEDIUM)","uniform vec2 poissonDisk[25];","const int poissonCount = 25;","const float poissonInvSamples = 0.04;","#elif defined(SHADOWMAP_QUALITY_HIGH)","uniform vec2 poissonDisk[49];","const int poissonCount = 49;","const float poissonInvSamples = 0.020408;","#else","uniform vec2 poissonDisk[9];","const int poissonCount = 9;","const float poissonInvSamples = 0.111111;","#endif","#endif","#ifndef DECAL","varying vec4 vShadowCoord[ MAX_SHADOWS ];","#else","vec4 vShadowCoord[ MAX_SHADOWS ];","uniform mat4 shadowMatrix[ MAX_SHADOWS ];","uniform vec3 shadowCameraPosition[ MAX_SHADOWS ];","uniform vec3 lowPartShadowCameraPosition[ MAX_SHADOWS ];","#endif","#if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED) ","float esmLinearSampling(sampler2D shadowMap, vec2 coord,vec2 shadowMapSize,vec2 invSize) {","#ifdef USE_UINT_ESM","   vec2 fractCoord = fract(coord*shadowMapSize + 0.5);","   vec2 centroidUV = (coord*shadowMapSize - fractCoord) * invSize;","   float lb = unpackDepthESM(texture2D(shadowMap, centroidUV));","   float lt = unpackDepthESM(texture2D(shadowMap, centroidUV + vec2(0.0, invSize.y)));","   float rb = unpackDepthESM(texture2D(shadowMap, centroidUV + vec2(invSize.x, 0.0)));","   float rt = unpackDepthESM(texture2D(shadowMap, centroidUV + invSize));","   float a = mix(lb, lt, fractCoord.y);","   float b = mix(rb, rt, fractCoord.y);","   return mix(a, b, fractCoord.x);","#else","\treturn texture2D(shadowMap, coord).x;","#endif","}","float compESM(sampler2D shadowMap, vec2 coord, float depthFrag, vec2 shadowMapSize, vec2 shadowPixelSize) {","float result = esmLinearSampling(shadowMap, coord,shadowMapSize,shadowPixelSize) * exp(-80.0 * depthFrag);","result *= result * result;","return result;","}","float texture2DESMToPCFCompare(sampler2D shadowMap, vec2 coord, float depthFrag, vec2 shadowMapSize, vec2 shadowPixelSize) {","float depthShadowMap = log(esmLinearSampling(shadowMap, coord,shadowMapSize,shadowPixelSize)) / 80.0;","return step(depthShadowMap, depthFrag);","}","float texture2DShadowESMLerp(sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowPixelSize, vec2 coord, float depthFrag) {","vec2 fractCoord = fract(coord * shadowMapSize + 0.5);","vec2 centroidUV = (coord * shadowMapSize - fractCoord) * shadowPixelSize;","float lb = clamp(compESM(shadowMap, centroidUV, depthFrag,shadowMapSize,shadowPixelSize), 0.0, 1.0);","float lt = clamp(compESM(shadowMap, centroidUV + vec2(0.0, shadowPixelSize.y), depthFrag,shadowMapSize,shadowPixelSize), 0.0, 1.0);","float rb = clamp(compESM(shadowMap, centroidUV + vec2(shadowPixelSize.x, 0.0), depthFrag,shadowMapSize,shadowPixelSize), 0.0, 1.0);","float rt = clamp(compESM(shadowMap, centroidUV + shadowPixelSize, depthFrag,shadowMapSize,shadowPixelSize), 0.0, 1.0);","float a = mix(lb, lt, fractCoord.y);","float b = mix(rb, rt, fractCoord.y);","return 1.0 - mix(a, b, fractCoord.x);","}","#endif","float texture2DCompare(sampler2D shadowMap, vec2 coord, float depthFrag) {","float depthShadowMap = unpackDepth(texture2D(shadowMap, coord));","return step(depthShadowMap, depthFrag);","}","float texture2DShadowLerp(sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowPixelSize, vec2 coord, float depthFrag) {","vec2 fractCoord = fract(coord * shadowMapSize + 0.5);","vec2 centroidUV = (coord * shadowMapSize - fractCoord) * shadowPixelSize;","float lb = texture2DCompare(shadowMap, centroidUV, depthFrag);","float lt = texture2DCompare(shadowMap, centroidUV + vec2(0.0, shadowPixelSize.y), depthFrag);","float rb = texture2DCompare(shadowMap, centroidUV + vec2(shadowPixelSize.x, 0.0), depthFrag);","float rt = texture2DCompare(shadowMap, centroidUV + shadowPixelSize, depthFrag);","float a = mix(lb, lt, fractCoord.y);","float b = mix(rb, rt, fractCoord.y);","return mix(a, b, fractCoord.x);","}","#if defined( SHADOWMAP_TYPE_PCF )","float getExposurePCF(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize) {","float shadow = 0.0;","#if defined( SHADOWMAP_QUALITY_LOW )","const float shadowDelta = 1.0 / 9.0;","const int fetchCount = 3;","#elif defined( SHADOWMAP_QUALITY_MEDIUM )","const float shadowDelta = 1.0 / 25.0;","const int fetchCount = 5;","#elif defined( SHADOWMAP_QUALITY_HIGH )","const float shadowDelta = 1.0 / 49.0;","const int fetchCount = 7;","#endif","float xPixelOffset = 1.0 / shadowMapSize.x;","float yPixelOffset = 1.0 / shadowMapSize.y;","float dx0 = -1.25 * float((fetchCount-1)/2) *xPixelOffset;","float dy0 = -1.25 * float((fetchCount-1)/2) *yPixelOffset;","float dx1 = 1.25 * xPixelOffset;","float dy1 = 1.25 * yPixelOffset;","float fDepth;","vec2 delta = vec2(dx0,dy0);","for  (int i = 0; i < fetchCount; i ++) {","for  (int j = 0; j < fetchCount; j ++) {","shadow += shadowDelta * texture2DCompare(shadowMap,shadowCoord.xy + delta,shadowCoord.z);","delta.y +=dy1;","}","delta.y =dy0;","delta.x +=dx1;","}","return shadow;","}","#elif defined( SHADOWMAP_TYPE_PCF_SOFT )","float getExposurePCFSoft(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize){","float shadow = 0.0;","float xPixelOffset = 1.0 / shadowMapSize.x;","float yPixelOffset = 1.0 / shadowMapSize.y;","float dx0 = -1.0 * xPixelOffset;","float dy0 = -1.0 * yPixelOffset;","float dx1 = 1.0 * xPixelOffset;","float dy1 = 1.0 * yPixelOffset;","mat3 shadowKernel;","vec2 delta = vec2(dx0,dy0);","for  (int i = 0; i < 3; i ++) {","for  (int j = 0; j < 3; j ++) {","shadowKernel[i][j]= 0.25 * texture2DCompare(shadowMap,shadowCoord.xy + delta,shadowCoord.z);","delta.y +=dy1;","}","delta.y =dy0;","delta.x +=dx1;","}","vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize.xy );","shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );","shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );","vec4 shadowValues;","shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );","shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );","shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );","shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );","shadow = dot( shadowValues, vec4( 1.0 ) );","return shadow;","}","#elif defined( SHADOWMAP_TYPE_PCF_INTERPOL )","float getExposurePCFInterpol(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize){","float shadow = 0.0;","const float dimFilter = 4.0;","const float sizeFilter = dimFilter * dimFilter;","const float shadowDelta = 1.0 / sizeFilter;","vec2 shadowPixelSize = 1.0 / shadowMapSize;","for (float xFilter = -0.5 * dimFilter + 0.5; xFilter <= 0.5 * dimFilter; xFilter += 1.0) {","for (float yFilter = -0.5 * dimFilter + 0.5; yFilter <= 0.5 * dimFilter; yFilter += 1.0) {","shadow += texture2DShadowLerp(shadowMap, shadowMapSize, shadowPixelSize, shadowCoord.xy + shadowPixelSize * vec2(xFilter, yFilter), shadowCoord.z);","}","}","shadow *= shadowDelta;","return shadow;","}","#elif defined( SHADOWMAP_TYPE_PCF_POISSON )","float getExposurePCFPoisson(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize) {","float shadow = 0.0;","float xPixelOffset = 1.0/ shadowMapSize.x;","float yPixelOffset = 1.0 / shadowMapSize.y;","float randAngle = randomValue(shadowCoord.xyz,fract(shadowCoord.x*shadowCoord.y)) * 2.0 * 3.14159265359;","for  (int i = 0; i < poissonCount; i ++) {","vec2 p = poissonDisk[i];","float posX = (cos(randAngle)*p.x-sin(randAngle)*p.y)*xPixelOffset;","float posY = (sin(randAngle)*p.x+cos(randAngle)*p.y)*yPixelOffset;","shadow += texture2DCompare(shadowMap,shadowCoord.xy + vec2(posX,posY),shadowCoord.z);","}","shadow *= poissonInvSamples;","return shadow;","}","#elif defined( SHADOWMAP_TYPE_PCF_OPTI )","float getExposurePCFOpti(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize) {","float shadow = 0.0;","vec2 fractCoord = fract(shadowCoord.xy * shadowMapSize + 0.5);","vec2 pixelOffset = vec2(1.0) / shadowMapSize;","vec2 base_uv = (shadowCoord.xy * shadowMapSize - fractCoord) * pixelOffset;","#if defined(SHADOWMAP_QUALITY_LOW)","float uw0 = (3.0 - 2.0 * fractCoord.x);","float uw1 = (1.0 + 2.0 * fractCoord.x);","float u0 = ((2.0 - fractCoord.x) / uw0 - 1.0) * pixelOffset.x;","float u1 = (fractCoord.x / uw1 + 1.0) * pixelOffset.x;","float vw0 = (3.0 - 2.0 * fractCoord.y);","float vw1 = (1.0 + 2.0 * fractCoord.y);","float v0 = ((2.0 - fractCoord.y) / vw0 - 1.0) * pixelOffset.y;","float v1 = (fractCoord.y / vw1 + 1.0) * pixelOffset.y;","shadow += uw0 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v0), shadowCoord.z);","shadow += uw1 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v0), shadowCoord.z);","shadow += uw0 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v1), shadowCoord.z);","shadow += uw1 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v1), shadowCoord.z);","shadow *= 0.0625;","#elif defined(SHADOWMAP_QUALITY_MEDIUM)","float uw0 = (4.0 - 3.0 * fractCoord.x);","float uw1 = 7.0;","float uw2 = (1.0 + 3.0 * fractCoord.x);","float u0 = ((3.0 - 2.0 * fractCoord.x) / uw0 - 2.0) * pixelOffset.x;","float u1 = ((3.0 + fractCoord.x) / uw1) * pixelOffset.x;","float u2 = (fractCoord.x / uw2 + 2.0) * pixelOffset.x;","float vw0 = (4.0 - 3.0 * fractCoord.y);","float vw1 = 7.0;","float vw2 = (1.0 + 3.0 * fractCoord.y);","float v0 = ((3.0 - 2.0 * fractCoord.y) / vw0 - 2.0) * pixelOffset.y;","float v1 = ((3.0 + fractCoord.y) / vw1) * pixelOffset.y;","float v2 = (fractCoord.y / vw2 + 2.0) * pixelOffset.y;","shadow += uw0 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v0), shadowCoord.z);","shadow += uw1 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v0), shadowCoord.z);","shadow += uw2 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v0), shadowCoord.z);","shadow += uw0 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v1), shadowCoord.z);","shadow += uw1 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v1), shadowCoord.z);","shadow += uw2 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v1), shadowCoord.z);","shadow += uw0 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v2), shadowCoord.z);","shadow += uw1 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v2), shadowCoord.z);","shadow += uw2 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v2), shadowCoord.z);","shadow *= 0.0069444;","#elif defined(SHADOWMAP_QUALITY_HIGH)","float uw0 = (5.0 * fractCoord.x - 6.0);","float uw1 = (11.0 * fractCoord.x - 28.0);","float uw2 = -(11.0 * fractCoord.x + 17.0);","float uw3 = -(5.0 * fractCoord.x + 1.0);","float u0 = ((4.0 * fractCoord.x - 5.0) / uw0 - 3.0) * pixelOffset.x;","float u1 = ((4.0 * fractCoord.x - 16.0) / uw1 - 1.0) * pixelOffset.x;","float u2 = (-(7.0 * fractCoord.x + 5.0) / uw2 + 1.0) * pixelOffset.x;","float u3 = (-fractCoord.x / uw3 + 3.0) * pixelOffset.x;","float vw0 = (5.0 *fractCoord.y - 6.0);","float vw1 = (11.0 *fractCoord.y - 28.0);","float vw2 = -(11.0 *fractCoord.y + 17.0);","float vw3 = -(5.0 *fractCoord.y + 1.0);","float v0 = ((4.0 *fractCoord.y - 5.0) / vw0 - 3.0) * pixelOffset.y;","float v1 = ((4.0 *fractCoord.y - 16.0) / vw1 - 1.0) * pixelOffset.y;","float v2 = (-(7.0 *fractCoord.y + 5.0) / vw2 + 1.0) * pixelOffset.y;","float v3 = (-fractCoord.y / vw3 + 3.0) * pixelOffset.y;","shadow += uw0 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v0), shadowCoord.z) ;","shadow += uw1 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v0), shadowCoord.z);","shadow += uw2 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v0), shadowCoord.z);","shadow += uw3 * vw0 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u3,v0), shadowCoord.z);","shadow += uw0 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v1), shadowCoord.z);","shadow += uw1 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v1), shadowCoord.z);","shadow += uw2 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v1), shadowCoord.z);","shadow += uw3 * vw1 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u3,v1), shadowCoord.z);","shadow += uw0 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v2), shadowCoord.z);","shadow += uw1 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v2), shadowCoord.z);","shadow += uw2 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v2), shadowCoord.z);","shadow += uw3 * vw2 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u3,v2), shadowCoord.z);","shadow += uw0 * vw3 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0,v3), shadowCoord.z);","shadow += uw1 * vw3 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1,v3), shadowCoord.z);","shadow += uw2 * vw3 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2,v3), shadowCoord.z);","shadow += uw3 * vw3 * texture2DShadowLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u3,v3), shadowCoord.z);","shadow *= 0.0003698225;","#endif","return shadow;","}","#elif defined( SHADOWMAP_TYPE_ESM )","float getExposureESM(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize) {","float shadow = 0.0;","float depthFragOffset = shadowCoord.z;","vec2 pixelOffset = 1.0 / shadowMapSize.xy;","shadow = compESM(shadowMap, shadowCoord.xy, depthFragOffset,shadowMapSize,pixelOffset);","float zMaxNeighbor = 0.0;","vec2 coordDetect = shadowCoord.xy + vec2(-pixelOffset.x, pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(pixelOffset.x, pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(-pixelOffset.x, -pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(pixelOffset.x, -pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(pixelOffset.x, 0.0);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(0.0, pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(-pixelOffset.x, 0.0);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","coordDetect = shadowCoord.xy + vec2(0.0, -pixelOffset.y);","zMaxNeighbor = max(zMaxNeighbor, esmLinearSampling(shadowMap, coordDetect,shadowMapSize,pixelOffset));","zMaxNeighbor = log(zMaxNeighbor) * 0.0125;","if(zMaxNeighbor < 0.9999999 && (shadowCoord.z + 0.015) < zMaxNeighbor) {","shadow = 0.0;","vec2 fractCoord = fract(shadowCoord.xy * shadowMapSize + 0.5);","vec2 base_uv = (shadowCoord.xy * shadowMapSize - fractCoord) * pixelOffset;","float uw0 = (4.0 - 3.0 * fractCoord.x);","float uw1 = 7.0;","float uw2 = (1.0 + 3.0 * fractCoord.x);","float u0 = ((3.0 - 2.0 * fractCoord.x) / uw0 - 2.0) * pixelOffset.x;","float u1 = ((3.0 + fractCoord.x) / uw1) * pixelOffset.x;","float u2 = (fractCoord.x / uw2 + 2.0) * pixelOffset.x;","float vw0 = (4.0 - 3.0 * fractCoord.y);","float vw1 = 7.0;","float vw2 = (1.0 + 3.0 * fractCoord.y);","float v0 = ((3.0 - 2.0 * fractCoord.y) / vw0 - 2.0) * pixelOffset.y;","float v1 = ((3.0 + fractCoord.y) / vw1) * pixelOffset.y;","float v2 = (fractCoord.y / vw2 + 2.0) * pixelOffset.y;","shadow += uw0 * vw0 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0, v0), depthFragOffset);","shadow += uw1 * vw0 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1, v0), depthFragOffset);","shadow += uw2 * vw0 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2, v0), depthFragOffset);","shadow += uw0 * vw1 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0, v1), depthFragOffset);","shadow += uw1 * vw1 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1, v1), depthFragOffset);","shadow += uw2 * vw1 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2, v1), depthFragOffset);","shadow += uw0 * vw2 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0, v2), depthFragOffset);","shadow += uw1 * vw2 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1, v2), depthFragOffset);","shadow += uw2 * vw2 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u2, v2), depthFragOffset);","shadow *= 0.0069444;","shadow = clamp(shadow * 2.0, 0.0, 1.0);","} else {","shadow *= shadow * shadow;","shadow = 1.0 - clamp(shadow, 0.0, 1.0);","}","return shadow;","}","#elif defined( SHADOWMAP_TYPE_ESM_IMPROVED )","float getExposureESMImproved(sampler2D shadowMap,vec3 shadowCoord, vec2 shadowMapSize) {","float shadow = 0.0;","float depthFragOffset = shadowCoord.z;","vec2 uv = shadowCoord.xy * shadowMapSize;","vec2 pixelOffset = 1.0 / shadowMapSize.xy;","vec2 base_uv = floor(uv + 0.5);","vec2 fractCoord = uv + 0.5 - base_uv;","base_uv = (base_uv - 0.5) * pixelOffset;","float uw0 = (3.0 - 2.0 * fractCoord.x);","float uw1 = (1.0 + 2.0 * fractCoord.x);","float u0 = ((2.0 - fractCoord.x) / uw0 - 1.0) * pixelOffset.x;","float u1 = (fractCoord.x / uw1 + 1.0 ) * pixelOffset.x;","float vw0 = (3.0 - 2.0 * fractCoord.y);","float vw1 = (1.0 + 2.0 * fractCoord.y);","float v0 = ((2.0 - fractCoord.y) / vw0 - 1.0) * pixelOffset.y;","float v1 = (fractCoord.y / vw1 + 1.0) * pixelOffset.y;","shadow += uw0 * vw0 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0, v0), depthFragOffset);","shadow += uw1 * vw0 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1, v0), depthFragOffset);","shadow += uw0 * vw1 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u0, v1), depthFragOffset);","shadow += uw1 * vw1 * texture2DShadowESMLerp(shadowMap, shadowMapSize, pixelOffset, base_uv + vec2(u1, v1), depthFragOffset);","shadow *= 0.0625;","shadow = clamp(shadow * 1.5, 0.0, 1.0);","return shadow;","}","#endif","float getExposure(vec4 vShadowCoord,sampler2D shadowMap,float shadowBias,vec2 shadowMapSize) {","vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;","bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","float exposureResult = 0.0;","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","if ( frustumTest ) {","shadowCoord.z += shadowBias;","#if defined( SHADOWMAP_TYPE_PCF )","exposureResult = getExposurePCF(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_PCF_SOFT )","exposureResult = getExposurePCFSoft(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_PCF_INTERPOL )","exposureResult = getExposurePCFInterpol(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_PCF_POISSON )","exposureResult = getExposurePCFPoisson(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_PCF_OPTI )","exposureResult = getExposurePCFOpti(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_ESM )","exposureResult = getExposureESM(shadowMap,shadowCoord,shadowMapSize);","#elif defined( SHADOWMAP_TYPE_ESM_IMPROVED )","exposureResult = getExposureESMImproved(shadowMap,shadowCoord,shadowMapSize);","#else","exposureResult = texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);","#endif","}","return max(1.0-exposureResult,0.0);","}","getExposureFromIndexPlaceholder","#ifdef SHADOWMAP_CASCADE","float getExposureCascaded(vec4 vShadowCoord[MAX_SHADOWS],sampler2D shadowMap[MAX_SHADOWS],float shadowBias[MAX_SHADOWS],vec2 shadowMapSize[MAX_SHADOWS],inout vec4 transparentExposure) {","float exposure = 1.0;","int inFrustumCount = 0;","#ifdef SHADOWMAP_DEBUG","vec3 frustumColors[3];","frustumColors[0] = vec3( 1.0, 0.5, 0.0 );","frustumColors[1] = vec3( 0.0, 1.0, 0.8 );","frustumColors[2] = vec3( 0.0, 0.5, 1.0 );","#endif","cascadedunrolledloop","return exposure;","}","#endif","#endif","#ifdef USE_SHADOWMAP_CUBE","uniform samplerCube shadowMapCube[ MAX_SHADOWS_CUBE ];","#ifdef USE_TRANSPARENTSHADOWMAP","uniform samplerCube transparentShadowMapCube[ MAX_SHADOWS_CUBE ];","#if MAX_POINT_LIGHTS > 0","uniform vec3 pointLightColorNoIntensity[ MAX_POINT_LIGHTS ];","#endif","#endif","uniform float shadowDarknessCube[ MAX_SHADOWS_CUBE ];","uniform float shadowBiasCube[ MAX_SHADOWS_CUBE ];","uniform float shadowNearCube[ MAX_SHADOWS_CUBE ];","uniform float shadowFarCube[ MAX_SHADOWS_CUBE ];","uniform float shadowMapSizeCube[ MAX_SHADOWS_CUBE ];","uniform vec3 shadowPointPosition[ MAX_SHADOWS_CUBE ];","float textureCubeCompare(samplerCube shadowMap, vec3 coord, float depthFrag) {","float depthShadowMap = unpackDepth(textureCube(shadowMap, coord));","return step(depthShadowMap, depthFrag);","}","#if defined(SHADOWMAP_TYPE_ESM) || defined(SHADOWMAP_TYPE_ESM_IMPROVED) ","float esmLinearSamplingCube(samplerCube shadowMap, vec3 coord,float shadowMapSize) {","#ifdef USE_UINT_ESM","\tvec3 absCoord = abs(coord);","\tfloat mainComp = max(max(absCoord.x,absCoord.y),absCoord.z);","\tvec3 mainDir = step(vec3(mainComp),absCoord);","\tif(dot(mainDir,vec3(1.0))>1.0){","\t\treturn unpackDepthESM(textureCube(shadowMap, coord));","\t}else{","\t\tfloat smSize=shadowMapSize; ","\t\tvec2 uv;","\t\tvec3 uv3;","\t\tfloat lengthRatio;","\t\tif(mainDir.x == 1.0){","\t\t\tuv = coord.yz;","\t\t\tlengthRatio = abs(coord.x);","\t\t}else if(mainDir.y == 1.0){","\t\t\tuv = coord.xz;","\t\t\tlengthRatio = abs(coord.y);","\t\t}else{","\t\t\tuv = coord.xy;","\t\t\tlengthRatio = abs(coord.z);","\t\t}","\t\tuv/=lengthRatio;","\t\tuv = (uv+vec2(1.0))/vec2(2.0);","\t\tvec2 invSize = vec2(1.0/smSize);","   \tvec2 fractCoord = fract(uv*smSize + vec2(0.5));","   \tvec2 centroidUV = (uv*smSize - fractCoord) * invSize;","\t\tvec2 ltUv =centroidUV + vec2(0.0, invSize.y);","\t\tvec2 rbUv =centroidUV + vec2(invSize.x, 0.0);","\t\tvec2 rtUv =centroidUV + invSize;","\t\tcentroidUV = (centroidUV*2.0)-1.0;","\t\tltUv = (ltUv*2.0)-1.0;","\t\trbUv = (rbUv*2.0)-1.0;","\t\trtUv = (rtUv*2.0)-1.0;","\t\tcentroidUV *= lengthRatio;","\t\tltUv *= lengthRatio;","\t\trbUv *= lengthRatio;","\t\trtUv *= lengthRatio;","   \tvec3 centroidCoord;","\t\tvec3 ltCoord;","\t\tvec3 rbCoord;","\t\tvec3 rtCoord;","\t\tif(mainDir.x == 1.0){","   \t\tcentroidCoord = normalize(vec3(coord.x,centroidUV));","\t\t\tltCoord = normalize(vec3(coord.x,ltUv));","\t\t\trbCoord = normalize(vec3(coord.x,rbUv));","\t\t\trtCoord = normalize(vec3(coord.x,rtUv));","\t\t}else if(mainDir.y == 1.0){","   \t\tcentroidCoord = normalize(vec3(centroidUV.x,coord.y,centroidUV.y));","\t\t\tltCoord = normalize(vec3(ltUv.x,coord.y,ltUv.y));","\t\t\trbCoord = normalize(vec3(rbUv.x,coord.y,rbUv.y));","\t\t\trtCoord = normalize(vec3(rtUv.x,coord.y,rtUv.y));","\t\t}else{","   \t\tcentroidCoord = normalize(vec3(centroidUV,coord.z));","\t\t\tltCoord = normalize(vec3(ltUv,coord.z));","\t\t\trbCoord = normalize(vec3(rbUv,coord.z));","\t\t\trtCoord = normalize(vec3(rtUv,coord.z));","\t\t}","   \tfloat lb = unpackDepthESM(textureCube(shadowMap, centroidCoord));","   \tfloat lt = unpackDepthESM(textureCube(shadowMap, ltCoord));","   \tfloat rb = unpackDepthESM(textureCube(shadowMap, rbCoord));","   \tfloat rt = unpackDepthESM(textureCube(shadowMap, rtCoord));","   \tfloat a = mix(lb, rb, fractCoord.x);","   \tfloat b = mix(lt, rt, fractCoord.x);","   \treturn mix(a, b, fractCoord.y);","   }","#else","\treturn textureCube(shadowMap, coord).x;","#endif","}","float compESMCube(samplerCube shadowMap, vec3 coord, float depthFrag,float shadowMapSize) {","float result = esmLinearSamplingCube(shadowMap, coord,shadowMapSize) * exp(-80.0 * depthFrag);","result *= result * result * result * result;","result = clamp(result,0.0,1.0);","return 1.0-result;","}","#endif","#if defined (SHADOWMAP_TYPE_PCF_OPTI) || defined (SHADOWMAP_TYPE_PCF_POISSON) || defined (SHADOWMAP_TYPE_PCF)","float getExposureCubePCF(vec3 normPointVector,float shadowMapSize,samplerCube shadowMapCube,float depth) {","vec3 rndseed = vec3(12.9898,78.233,45.5432);","vec3 randomDir = vec3( dot(normPointVector,rndseed) , dot(normPointVector.yzx,rndseed) , dot(normPointVector.zxy,rndseed) );","randomDir = fract(sin(randomDir) * 43758.5453);","float pixelSize = 2.0 / shadowMapSize;","vec3 xvec = normalize(cross(normPointVector,randomDir))* pixelSize *1.1;","vec3 yvec = normalize(cross(normPointVector,xvec))* pixelSize *1.1;","float inShadow = 0.0;","inShadow += textureCubeCompare(shadowMapCube,normPointVector+xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+xvec-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-xvec-yvec,depth);","#if defined(SHADOWMAP_QUALITY_HIGH) || defined(SHADOWMAP_QUALITY_MEDIUM)","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*xvec-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*xvec-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*yvec+xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*yvec-xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*yvec+xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*yvec-xvec,depth);","#endif","#if defined(SHADOWMAP_QUALITY_HIGH)","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*xvec-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*xvec+yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*xvec-yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*yvec+xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+3.0*yvec-xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*yvec+xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-3.0*yvec-xvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*xvec+2.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector+2.0*xvec-2.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*xvec-2.0*yvec,depth);","inShadow += textureCubeCompare(shadowMapCube,normPointVector-2.0*xvec+2.0*yvec,depth);","#endif","#if defined(SHADOWMAP_QUALITY_LOW)","inShadow = inShadow/ 8.0;","#elif defined(SHADOWMAP_QUALITY_MEDIUM)","inShadow = inShadow/ 20.0;","#else","inShadow = inShadow/ 36.0;","#endif","return inShadow;","}","#endif","#ifdef DECAL","vec4 decalShadowCubeWorldPosition;","#endif","float getExposure(vec3 pointPosition,samplerCube shadowMap,float shadowBias,float shadowMapSize,float shadowNear, float shadowFar) {","vec4 lPosition =  vec4( pointPosition, 1.0 );","#ifdef DECAL","vec3 pointVector = decalShadowCubeWorldPosition.xyz-lPosition.xyz;","#else","vec3 pointVector = vWorldPosition.xyz-lPosition.xyz;","#endif","float exposureResult = 0.0;","vec3 absVector = abs(pointVector);","float localZComp = max(absVector.x,max(absVector.y,absVector.z));","float normZComp = (shadowFar+shadowNear)/(shadowFar-shadowNear)-(2.0*shadowFar*shadowNear)/(shadowFar-shadowNear)/localZComp;","normZComp = (normZComp + 1.0) * 0.5;","float depthCube = normZComp +shadowBias;","vec3 normPointVector = normalize( pointVector );","#if defined (SHADOWMAP_TYPE_PCF_OPTI) || defined (SHADOWMAP_TYPE_PCF_POISSON) || defined (SHADOWMAP_TYPE_PCF)","exposureResult = getExposureCubePCF(normPointVector,shadowMapSize,shadowMap,depthCube);","#elif defined (SHADOWMAP_TYPE_ESM)","exposureResult = compESMCube(shadowMap, normPointVector, depthCube,shadowMapSize);","#else","exposureResult = textureCubeCompare(shadowMap,normPointVector,depthCube);","#endif","return 1.0-exposureResult;","}","getExposureFromIndexCubePlaceholder","#endif"].join("\n"),shadowmap_fragment:["float shadowExposure = 1.0;","vec4 transparentExposure = vec4(1.0);","#if defined(USE_SHADOWMAP) || defined(USE_SHADOWMAP_CUBE)","#ifdef USE_SHADOWMAP","float currentExposure = 1.0;","vec4 currentTransparentExposure = vec4(1.0);","#ifdef SHADOWMAP_CASCADE","currentExposure  = getExposureCascaded(vShadowCoord,shadowMap,shadowBias,shadowMapSize,currentTransparentExposure);","#else","currentExposure = getExposure(vShadowCoord[ 0 ],shadowMap[ 0 ],shadowBias[ 0 ],shadowMapSize[ 0 ]);","#ifdef USE_TRANSPARENTSHADOWMAP","currentTransparentExposure = getTransparentExposureFromIndex(0);","#endif","#endif","if (currentExposure < 1.0) {","shadowExposure *=1.0 - (shadowDarkness[ 0 ] * (1.0-currentExposure));","}","transparentExposure *= vec4(1.0) - (shadowDarkness[ 0 ] * (vec4(1.0)-currentTransparentExposure));","#ifdef SHADOWMAP_CASCADE","if (MAX_SHADOWS>MAX_SHADOWS_DIR){","for( int i = MAX_SHADOWS_DIR; i < MAX_SHADOWS; i ++ ) {","float currentExposure = 1.0;","currentExposure = getExposureFromIndex(i);","#ifdef USE_TRANSPARENTSHADOWMAP","currentTransparentExposure = getTransparentExposureFromIndex(i);","#endif","if (currentExposure < 1.0) {","shadowExposure *=1.0 - (shadowDarkness[ i ] * (1.0-currentExposure));","}","transparentExposure *= vec4(1.0) - (shadowDarkness[ i ] * (vec4(1.0)-currentTransparentExposure));","}","}","#else","if (MAX_SHADOWS>1){","for( int i = 1; i < MAX_SHADOWS; i ++ ) {","float currentExposure = 1.0;","currentExposure = getExposureFromIndex(i);","#ifdef USE_TRANSPARENTSHADOWMAP","currentTransparentExposure = getTransparentExposureFromIndex(i);","#endif","if (currentExposure < 1.0) {","shadowExposure *=1.0 - (shadowDarkness[ i ] * (1.0-currentExposure));","}","transparentExposure *= vec4(1.0) - (shadowDarkness[ i ] * (vec4(1.0)-currentTransparentExposure));","}","}","#endif","#endif","#ifdef USE_SHADOWMAP_CUBE","for ( int i = 0; i < MAX_SHADOWS_CUBE; i ++ ) {","float currentExposure = getExposureFromIndexCube(i);","vec4 currentTransparentExposure = vec4(1.0);","#ifdef USE_TRANSPARENTSHADOWMAP","currentTransparentExposure = getTransparentExposureFromIndexCube(i);","#endif","if (currentExposure < 1.0) {","shadowExposure *= 1.0 - (shadowDarknessCube[ i ] * (1.0-currentExposure));","}","transparentExposure *= vec4(1.0) - (shadowDarknessCube[ i ] * (vec4(1.0)-currentTransparentExposure));","}","#endif","#endif","gl_FragColor.xyz *= transparentExposure.rgb * min(shadowExposure,transparentExposure.a);"].join("\n"),shadowmap_pars_vertex:["#ifdef USE_SHADOWMAP","#ifndef DECAL","varying vec4 vShadowCoord[ MAX_SHADOWS ];","uniform mat4 shadowMatrix[ MAX_SHADOWS ];","uniform vec3 shadowCameraPosition[ MAX_SHADOWS ];","uniform vec3 lowPartShadowCameraPosition[ MAX_SHADOWS ];","#endif","#endif"].join("\n"),shadowmap_vertex:["#if defined(USE_SHADOWMAP) && !defined(DECAL)","#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined( PHYSICALDS ) || defined ( USE_SHADOWMAP )","#if defined(USE_SKINNING) && !defined( USE_DISPLACEMENTMAP )","vec4 oldPosition = skinned;","#endif","#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING ) && !defined( USE_DISPLACEMENTMAP )","vec4 oldPosition = vec4( morphed, 1.0 );","#endif","#if defined(USE_DISPLACEMENTMAP)","vec4 oldPosition = vec4( displacedPosition, 1.0 );","#endif","#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING ) && !defined( USE_DISPLACEMENTMAP )","vec4 oldPosition = vec4( position, 1.0 );","#endif","#endif","for( int i = 0; i < MAX_SHADOWS; i ++ ) {","vShadowCoord[ i ] = computeShadowCoord(oldPosition.xyz, shadowMatrix[i],shadowCameraPosition[i],lowPartShadowCameraPosition[i]);","}","#endif"].join("\n")}}),define("DS/Shaders/ScenegraphShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{gpu_scenegraph_nodes:["#ifdef BILLBOARD","uniform mat4 modelInvRotMatrix;","uniform int billboardType;","uniform int billboardRotationEnabled;","uniform mat4 billboardRotation;","uniform vec3 billCameraPos;","uniform vec3 billCameraLookAt;","uniform vec3 billCameraUp;","mat4 lookAt(vec3 eye, vec3 target, vec3 up) {","vec3 z = eye - target;","if (length(z) < 1e-6) {","z.z = 1.0;","}","z = normalize(z);","vec3 x = cross(up, z);","if (length(x) < 1e-6) {","z.x += 0.001;","x = cross(up, z);","}","x = normalize(x);","vec3 y = cross(z,x);","return mat4(vec4(x, 0.0), vec4(y, 0.0), vec4(z, 0.0), vec4(0.0,0.0,0.0,1.0));","}","uniform vec3 billboardAxis;","uniform mat4 invViewMatrix;","uniform mat4 invProjectionMatrix;","vec3 applyProjection(vec4 vector, mat4 proj) {","vec4 res = proj * vector;","return res.xyz / max(abs(res.w),1e-6);","}","mat4 getBillboardMatrix() {","vec3 cameraTarget = billCameraLookAt + billCameraPos;","mat4 billMat;","if (billboardType == 1) {","billMat = lookAt(billCameraPos, cameraTarget, billCameraUp);","} else {","vec3 axis = normalize((modelMatrix * vec4(billboardAxis, 0.0)).xyz);","vec3 objToCam = vec3(0.0);","if (billboardType == 3) {","vec3 worldPosOrigin = modelMatrix[3].xyz;","objToCam = worldPosOrigin - billCameraPos;","vec3 tmp = worldPosOrigin + axis;","mat4 proj = projectionMatrix * viewMatrix;","vec3 projOrig = applyProjection(vec4(worldPosOrigin,1.0), proj);","tmp = applyProjection(vec4(tmp,1.0), proj);","tmp.z = projOrig.z;","tmp = applyProjection(vec4(tmp,1.0), invViewMatrix * invProjectionMatrix);","tmp -= worldPosOrigin;","axis = normalize(tmp);","} else {","objToCam = billCameraLookAt;","}","objToCam = normalize(objToCam);","vec3 crossX = cross(objToCam, axis);","if (length(crossX) < 1e-6) {","crossX = abs(objToCam.z) < 0.999 ? cross(vec3(0.0,0.0,1.0), objToCam) : cross(vec3(1.0,0.0,0.0), objToCam);","}","crossX = normalize(crossX);","vec3 crossY = normalize(cross(axis, crossX));","billMat = mat4(vec4(crossX, 0.0), vec4(crossY, 0.0), vec4(axis, 0.0), vec4(0.0,0.0,0.0,1.0));","}","if (billboardRotationEnabled == 1) {","return modelInvRotMatrix * billMat * billboardRotation;","} else {","return modelInvRotMatrix * billMat;","}","}","#endif","#ifdef FIXED_SIZE","#ifdef FIXED_SIZE_CENTER","uniform vec4 fixedSizeCenterRatio;","#else","uniform float fixedSizeRatio;","#endif","uniform float cameraConstant;","vec2 getScale() {","vec3 xAxis = vec3(modelViewMatrix[0][0],modelViewMatrix[1][0],modelViewMatrix[2][0]);","vec3 yAxis = vec3(modelViewMatrix[0][1],modelViewMatrix[1][1],modelViewMatrix[2][1]);","vec3 zAxis = vec3(modelViewMatrix[0][2],modelViewMatrix[1][2],modelViewMatrix[2][2]);","float radius = max(length(xAxis),max(length(yAxis),length(zAxis)));","float screenRadius = 1.0;","if (projectionMatrix[3][3] > 0.5) {","screenRadius = radius;","} else {","vec4 aux = computeModelViewPosition(vec3(0.0));","float constant = abs(aux.z);","screenRadius = radius / constant;","}","#ifdef FIXED_SIZE_CENTER","float scaleFactorCenter = 1.0 / screenRadius * cameraConstant;","if (projectionMatrix[3][3] > 0.5) {","screenRadius = radius;","} else {","vec4 aux2 = computeModelViewPosition(scaleFactorCenter*fixedSizeCenterRatio.xyz);","float constant2 = abs(aux2.z);","screenRadius = radius / constant2;","}","float scaleFactor = fixedSizeCenterRatio.w / screenRadius * cameraConstant;","#else","float scaleFactor = fixedSizeRatio / screenRadius * cameraConstant;","float scaleFactorCenter = scaleFactor;","#endif","return vec2(scaleFactor, scaleFactorCenter);","}","#endif","#if defined(BILLBOARD) || defined(FIXED_SIZE)","struct SimpleNodeData {","mat4 billboardMatrix;","float fixedSizeScale;","float fixedSizeScaleCenter;","};","SimpleNodeData simpleNodeData;","bool simpleSizeDataSet = false;","void setSimpleNodeData() {","if (simpleSizeDataSet) return;","#ifdef BILLBOARD","simpleNodeData.billboardMatrix = getBillboardMatrix();","#endif","#ifdef FIXED_SIZE","vec2 fixedSizeData = getScale();","simpleNodeData.fixedSizeScale = fixedSizeData.x;","simpleNodeData.fixedSizeScaleCenter = fixedSizeData.y;","#endif","simpleSizeDataSet = true;","}","#endif","vec3 auxPosMV;","vec3 auxPosMVP;","vec4 auxPosMVPFunc;","vec3 MVUnit;"].join("\n"),decompress_normals_pars:["vec2 unpack_2unorm12_in_2floats(in float iEncodedNormal) {","vec2 res;","res.x = floor(iEncodedNormal/4096.0)/4095.0;","res.y = mod(iEncodedNormal, 4096.0)/4095.0;","return res;","}","float signNotZero(in float k) {","return k >= 0.0 ? 1.0 : -1.0;","}","vec2 signNotZero(in vec2 v) {","return vec2( signNotZero(v.x), signNotZero(v.y) );","}","vec3 decodeOct24Normal(in vec2 iEncodedNormal) {","float x = iEncodedNormal.x*2.0 - 1.0;","float y = iEncodedNormal.y*2.0 - 1.0;","vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));","if (v.z <= 0.0) {","vec2 sgn = signNotZero(v.xy);","v.xy = - abs(v.yx)*sgn + sgn;","}","return normalize(v);","}","vec3 decodeOct24Normal(in float iEncodedNormal) {","return decodeOct24Normal(unpack_2unorm12_in_2floats(iEncodedNormal));","}"].join("\n"),decompress_vertices_pars:["vec3 unpack_3unorm16_in_3floats(in vec2 iEncodedPosition) {","vec3 res;","res.x = floor(iEncodedPosition.x/256.0);","res.y = mod(iEncodedPosition.x, 256.0) *256.0 + mod(iEncodedPosition.y, 256.0);","res.z = floor(iEncodedPosition.y/256.0);","return res;","}","vec3 decodePosition(in vec2 iEncodedPosition, in vec3 quantized, in vec3 offset) {","vec3 res = unpack_3unorm16_in_3floats(iEncodedPosition);","return quantized * (res + offset);","}"].join("\n"),decompress_colors_pars:["vec4 unpack_4unorm8_in_4floats(in vec2 iEncodedColor) {","vec4 res;","res.x = floor(iEncodedColor.x/65536.0);","res.y = mod(floor(iEncodedColor.x/256.0), 256.0);","res.z = mod(iEncodedColor.x, 256.0);","res.w = iEncodedColor.y;","return res;","}","vec4 decodeColor(in vec2 iEncodedColor) {","vec4 res = unpack_4unorm8_in_4floats(iEncodedColor);","return res / 255.0;","}"].join("\n"),decompress_uvs_pars:["vec2 unpack_2unorm16_in_2floats(in vec2 iEncodedUV) {","vec2 res;","res.x = floor(iEncodedUV.x/256.0);","res.y = mod(iEncodedUV.x, 256.0) *256.0 + mod(iEncodedUV.y, 256.0);","return res;","}","vec2 decodeUV(in vec2 iEncodedUV) {","vec2 res = unpack_2unorm16_in_2floats(iEncodedUV);","return res / 65535.0;","}"].join("\n")}}),define("DS/Shaders/FogShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";return{fog_pars_vertex:"\n\t\t\t#if defined(USE_BACKGROUNDVIEWMODE_FOG)\n\t\t\t\tvarying float bvm_depth;\n\t\t\t#endif\n\t\t",fog_vertex:"\n\t\t\t#if defined(USE_BACKGROUNDVIEWMODE_FOG)\n\t\t\t\tbvm_depth = gl_Position.w;\n\t\t\t#endif\n\t\t",fog_pars_fragment:"\n\t\t\t#if defined(USE_BACKGROUNDVIEWMODE_FOG)\n\t\t\t\tuniform vec4 background_view_mode_control;\n\t\t\t\tuniform vec2 background_view_mode_near_far;\n\t\t\t\tvarying float bvm_depth;\n\t\t\t#endif\n\t\t",fog_fragment:"\n\t\t\t#if defined(USE_BACKGROUNDVIEWMODE_FOG)\n\t\t\t\tif(background_view_mode_control.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\tfloat isOrtho = projectionMatrix[2].w < 0.0 ? 0.0 : 1.0;\n\t\t\t\t\tfloat bvm_fog_depth = (bvm_depth - background_view_mode_near_far.x) / (background_view_mode_near_far.y - background_view_mode_near_far.x);\n\t\t\t\t\tfloat fog_mix = gl_FragCoord.z * gl_FragCoord.w * isOrtho + (1.0 - isOrtho) * bvm_fog_depth;\n\t\t\t\t\tfog_mix = min(max(fog_mix, 0.0), 1.0);\n\t\t\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * (1.0 - fog_mix) + background_view_mode_control.xyz * fog_mix;\n\t\t\t\t}\n\t\t\t#endif\n\t\t"}}),define("DS/Shaders/VerticeShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";var t=["#if defined(USE_TANGENT_BINORMAL)","varying vec3 vTangent;","varying vec3 vBinormal;","#endif"].join("\n"),o=["vec4 mvPosition;","#if defined(USE_SKINNING) && !defined( USE_DISPLACEMENTMAP ) ",e.getModelViewTransformationChunk("mvPosition","skinned"),"#endif","#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS ) && !defined( USE_DISPLACEMENTMAP )",e.getModelViewTransformationChunk("mvPosition","vec4( morphed, 1.0 )"),"#endif","#if defined(USE_DISPLACEMENTMAP)",e.getModelViewTransformationChunk("mvPosition","vec4( displacedPosition, 1.0 )"),"#endif","#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS ) && ! defined( USE_DISPLACEMENTMAP )",e.getModelViewTransformationChunk("mvPosition","vec4( position, 1.0 )"),"#endif","mvPosition.w = 1.0;"].join("\n"),a=["ProcessViewTangentSpace(_viewTangentSpace);","mvPosition.xyz = _viewTangentSpace.Position;","#ifdef USE_SIZEATTENUATION","mvPosForAttenuation = mvPosition.xyz;","#endif","#if defined(USE_TANGENT_BINORMAL)","vTangent = _viewTangentSpace.Tangent;","vBinormal = _viewTangentSpace.Binormal;","#endif"].join("\n");return{basic_pars:["varying vec3 vViewPosition;","varying vec3 vNormal;"].join("\n"),tangent_Binormal_pars:t,basic_vertex:[e.model_view_transformation_vertex,e.model_view_normal_vertex,"vNormal = mvNormal;","vViewPosition = normalize(-mvPosition.xyz);","gl_Position = projectionMatrix * mvPosition;"].join("\n"),tangent_Binormal_vertex:["#if defined(USE_TANGENT_BINORMAL)","tangent = _DStangent;","binormal = _DSbinormal;","#ifdef USE_SKINNING","vec3 objectTangent = vec3(skinMatrix * vec4( tangent, 0.0 ));","#else","vec3 objectTangent = tangent;","#endif","vec3 mvTangent;","if (use_normal_matrix)","mvTangent = normalMatrix * objectTangent;","else {",e.getModelViewUnitVectorTransformationChunk("mvTangent","objectTangent"),"}","vTangent = normalize( mvTangent );","#ifdef PDSFX","_viewTangentSpace.Tangent = vTangent;","#endif","#ifdef USE_SKINNING","vec3 objectBinormal = vec3(skinMatrix * vec4( binormal, 0.0 ));","#else","vec3 objectBinormal = binormal;","#endif","vec3 mvBinormal;","if (use_normal_matrix)","mvBinormal = normalMatrix * objectBinormal;","else {",e.getModelViewUnitVectorTransformationChunk("mvBinormal","objectBinormal"),"}","vBinormal = normalize( mvBinormal );","#ifdef PDSFX","_viewTangentSpace.Binormal = vBinormal;","#endif","#endif"].join("\n"),basic_fragment:["float Pi = 3.14159265358979323846264;","vec3 normal = normalize( vNormal );","vec3 viewPosition = normalize( vViewPosition );","normal *= sign( dot( normal, -viewPosition ) );"].join("\n"),tangent_Binormal_pars_fragment:[t,"#if defined(USE_TANGENT_BINORMAL)","void computeGPUTB(in vec3 i_viewPosition,vec3 i_normal,inout vec3 io_tangent,inout vec3 io_binormal){","vec3 p_x = dFdx( -i_viewPosition.xyz );","vec3 p_y = dFdy( -i_viewPosition.xyz );","#if defined( NEEDS_UVTOUSE )","vec2 tc_x = dFdx( uvToUse.st );","vec2 tc_y = dFdy( uvToUse.st );","#else","vec2 tc_x = vec2(0.0);","vec2 tc_y = vec2(0.0);","#endif","float alphaT = step(0.00001, abs(tc_x.y) + abs(tc_y.y));","float alphaB = step(0.00001, abs(tc_x.x) + abs(tc_y.x));","float alphaBT = 1.0 - max(alphaB, alphaT);","tc_x.y = alphaT * tc_x.y - (1.0 - alphaT)*(alphaB * tc_y.x);","tc_y.y = alphaT * tc_y.y + (1.0 - alphaT)*(alphaB * tc_x.x) + alphaBT;","tc_x.x = alphaB * tc_x.x - (1.0 - alphaB)*(alphaT * tc_y.y) + alphaBT;","tc_y.x = alphaB * tc_y.x + (1.0 - alphaB)*(alphaT * tc_x.y);","float texDet = 1.0;","io_tangent = normalize(  p_x * tc_y.y - p_y * tc_x.y );","io_binormal = normalize(  p_y * tc_x.x - p_x * tc_y.x);","vec3 x = cross(i_normal,io_tangent);","io_tangent = normalize(cross(x,i_normal)*texDet);","x = cross(io_binormal,i_normal);","io_binormal = normalize(cross(i_normal,x)*texDet);","}","bool isVectorValid(in vec3 vector){","\treturn (( vector.x < 0.0 || 0.0 < vector.x || vector.x == 0.0 ) && ( vector.y < 0.0 || 0.0 < vector.y || vector.y == 0.0 ) && ( vector.z < 0.0 || 0.0 < vector.z || vector.z == 0.0 ) && length(vector)!=0.0);","}","#endif"].join("\n"),tangent_Binormal_fragment:["#if defined(USE_TANGENT_BINORMAL)","vec3 fragmentTangent;","vec3 fragmentBinormal;","#if defined(PDSFX)","vec3 viewPositionTB = vViewPosition;","vec3 normalTB = _DSvNormal;","#elif defined(DECAL)","vec3 viewPositionTB = dViewPosition;","vec3 normalTB = decalNormal;","#else","vec3 viewPositionTB = vViewPosition;","vec3 normalTB = vNormal;","#endif","#ifdef GPU_TANGENT_BINORMAL","computeGPUTB(viewPositionTB,normalTB,fragmentTangent,fragmentBinormal);","#else","#ifdef PDSFX","\tfragmentTangent =  _DSviewTangent ;","\tfragmentBinormal = _DSviewBinormal ;","#else","\tfragmentTangent = vTangent;","\tfragmentBinormal = vBinormal;","#endif","#endif","#if defined(MAPPING_OPERATOR) && defined(USE_MAPPING_OPERATOR_FRAGMENT) && !defined(DECAL)","if(mappingType>0){","fragmentTangent = normalize( tangent );","fragmentBinormal = normalize( binormal );","if (use_normal_matrix){","fragmentTangent = normalMatrix * fragmentTangent;","fragmentBinormal = normalMatrix * fragmentBinormal;","}else {",e.getModelViewUnitVectorTransformationChunk("fragmentTangent","fragmentTangent"),e.getModelViewUnitVectorTransformationChunk("fragmentBinormal","fragmentBinormal"),"}","}","#endif","if(!isVectorValid(fragmentTangent) || !isVectorValid(fragmentBinormal) ){","computeGPUTB(viewPositionTB,normalTB,fragmentTangent,fragmentBinormal);","}","\ttangent = normalize(fragmentTangent);","\tbinormal = normalize(fragmentBinormal);","#endif"].join("\n"),worldpos_vertex:["#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined( PHYSICALDS ) || defined ( USE_SHADOWMAP )","#if defined(USE_SKINNING) && !defined( USE_DISPLACEMENTMAP )","vec4 worldPosition = modelMatrix * skinned;","#endif","#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING ) && !defined( USE_DISPLACEMENTMAP )","vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );","#endif","#if defined(USE_DISPLACEMENTMAP)","vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );","#endif","#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING ) && !defined( USE_DISPLACEMENTMAP )","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","#endif","#endif"].join("\n"),morphtarget_pars_vertex:["#ifdef USE_MORPHTARGETS","#ifndef USE_MORPHNORMALS","uniform float morphTargetInfluences[ 8 ];","#else","uniform float morphTargetInfluences[ 4 ];","#endif","#endif"].join("\n"),morphtarget_vertex:["#ifdef USE_MORPHTARGETS","vec3 morphed = vec3( 0.0 );","morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];","morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];","morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];","morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];","#ifndef USE_MORPHNORMALS","morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];","morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];","morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];","morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];","#endif","morphed += position;","#endif"].join("\n"),morphnormal_vertex:["#ifdef USE_MORPHNORMALS","vec3 morphedNormal = vec3( 0.0 );","morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];","morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];","morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];","morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];","morphedNormal += normal;","#endif"].join("\n"),skinning_pars_vertex:["#ifdef USE_SKINNING","#ifdef USE_SKINNING_ANGLES","mat4 getMatrixFromEulerAngles(const in vec3 angles, const in vec3 offset) {","float cosx = cos(angles.y);","float cosy = cos(angles.z);","float cosz = cos(angles.x);","float sinx = sin(angles.y);","float siny = sin(angles.z);","float sinz = sin(angles.x);","float a11, a12, a13, a21, a22, a23, a31, a32, a33;","float cosycosz = cosy*cosz;","float sinxsiny = sinx*siny;","a11 = cosycosz - sinxsiny*sinz;","a12 = -cosx*sinz;","a13 = cosz*siny + cosy*sinx*sinz;","a21 = cosz*sinxsiny + cosy*sinz;","a22 = cosx*cosz;","a23 = siny*sinz - cosycosz*sinx;","a31 = -cosx*siny;","a32 = sinx;","a33 = cosx*cosy;","mat4 bone = mat4(","vec4(a11, a21, a31, 0.0),","vec4(a12, a22, a32, 0.0),","vec4(a13, a23, a33, 0.0),","vec4(offset, 1.0));","return bone;","}","#endif","#ifdef IS_MULTI_INSTANCED","uniform sampler2D skinningInstancingMaps[NB_INSTANCING_SKIN_MAPS];","mat4 getBoneMatrix( const in float i ) {","if (i >= 0.0) {","float real_instanceId = instanceId/5.0 -1.0;","#ifdef USE_SKINNING_ANGLES","float matId = real_instanceId * NB_BONES * 2.0 + 2.0 * i;","#else","float matId = real_instanceId * NB_BONES * 4.0 + 4.0 * i;","#endif","int texId = int(floor(matId/(MAX_MAP_SIZE*MAX_MAP_SIZE)));","float dx, dy;","float x, y;","float xyInTex = matId - float(texId) * (MAX_MAP_SIZE*MAX_MAP_SIZE);","if (texId == NB_INSTANCING_SKIN_MAPS - 1) {","dx = 1.0 / LAST_INSTANCING_SKIN_MAP_SIZE_X;","dy = 1.0 / LAST_INSTANCING_SKIN_MAP_SIZE_Y;","y = floor(xyInTex/LAST_INSTANCING_SKIN_MAP_SIZE_X);","x = xyInTex - y*LAST_INSTANCING_SKIN_MAP_SIZE_X;","} else {","dx = 1.0 / MAX_MAP_SIZE;","dy = 1.0 / MAX_MAP_SIZE;","y = floor(xyInTex/MAX_MAP_SIZE);","x = xyInTex - y*MAX_MAP_SIZE;","}","vec3 v0, v1, v2, v3;","v0 = texture2D( skinningInstancingMaps[texId], vec2( dx * ( x + 0.5 ), dy * ( y + 0.5 ) ) ).xyz;","v1 = texture2D( skinningInstancingMaps[texId], vec2( dx * ( x + 1.5 ), dy * ( y + 0.5 ) ) ).xyz;","#ifndef USE_SKINNING_ANGLES","v2 = texture2D( skinningInstancingMaps[texId], vec2( dx * ( x + 2.5 ), dy * ( y + 0.5 ) ) ).xyz;","v3 = texture2D( skinningInstancingMaps[texId], vec2( dx * ( x + 3.5 ), dy * ( y + 0.5 ) ) ).xyz;","#endif","#ifdef USE_SKINNING_ANGLES","vec3 offset = v0;","vec3 angles = v1;","mat4 bone = getMatrixFromEulerAngles(angles, offset);","#else","mat4 bone = mat4(vec4(v0, 0.0), vec4(v1, 0.0), vec4(v2, 0.0), vec4(v3, 1.0));","#endif","return bone;","} else ","return mat4(1.0);","}","#else","uniform sampler2D skinningMap;","mat4 getBoneMatrix( const in float i ) {","if (i >= 0.0) {","#ifdef USE_SKINNING_ANGLES","float j = i * 2.0;","#else","float j = i * 4.0;","#endif","float x = mod( j, N_BONE_PIXEL_X );","float y = floor( j / N_BONE_PIXEL_X );","const float dx = 1.0 / N_BONE_PIXEL_X;","const float dy = 1.0 / N_BONE_PIXEL_Y;","y = dy * ( y + 0.5 );","vec3 v0 = texture2D( skinningMap, vec2( dx * ( x + 0.5 ), y ) ).xyz;","vec3 v1 = texture2D( skinningMap, vec2( dx * ( x + 1.5 ), y ) ).xyz;","#ifndef USE_SKINNING_ANGLES","vec3 v2 = texture2D( skinningMap, vec2( dx * ( x + 2.5 ), y ) ).xyz;","vec3 v3 = texture2D( skinningMap, vec2( dx * ( x + 3.5 ), y ) ).xyz;","#endif","#ifdef USE_SKINNING_ANGLES","vec3 offset = v0;","vec3 angles = v1;","mat4 bone = getMatrixFromEulerAngles(angles, offset);","#else","mat4 bone = mat4(vec4(v0, 0.0), vec4(v1, 0.0), vec4(v2, 0.0), vec4(v3, 1.0));","#endif","return bone;","} else ","return mat4(1.0);","}","#endif","#endif"].join("\n"),skinbase_vertex:["#ifdef USE_SKINNING","mat4 boneMatX = getBoneMatrix( skinIndex.x );","mat4 boneMatY = getBoneMatrix( skinIndex.y );","mat4 boneMatZ = getBoneMatrix( skinIndex.z );","mat4 boneMatW = getBoneMatrix( skinIndex.w );","mat4 skinMatrix = skinWeight.x * boneMatX;","skinMatrix \t+= skinWeight.y * boneMatY;","skinMatrix \t+= skinWeight.z * boneMatZ;","skinMatrix \t+= skinWeight.w * boneMatW;","#endif"].join("\n"),skinning_vertex:["#ifdef USE_SKINNING","#ifdef USE_MORPHTARGETS","vec4 skinVertex = vec4( morphed, 1.0 );","#else","vec4 skinVertex = vec4( position, 1.0 );","#endif","vec4 skinned  = skinMatrix * skinVertex;","#endif"].join("\n"),skinnormal_vertex:["#ifdef USE_SKINNING","#ifdef USE_MORPHNORMALS","vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );","#else","vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );","#endif","#endif"].join("\n"),default_vertex:[o,"#ifdef PDSFX","_viewTangentSpace.Position = mvPosition.xyz;",a,"#endif","gl_Position = projectionMatrix * mvPosition;"].join("\n"),default_vertex_with_normal:[o].join("\n"),defaultnormal_vertex:["vec3 objectNormal;","#if defined(USE_SKINNING) && !defined( USE_DISPLACEMENTMAP )","objectNormal = skinnedNormal.xyz;","#endif","#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS ) && !defined( USE_DISPLACEMENTMAP )","objectNormal = morphedNormal;","#endif","#if defined( USE_DISPLACEMENTMAP )","objectNormal = displacedNormal;","#endif","#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS ) && !defined( USE_DISPLACEMENTMAP )","objectNormal = normal;","#endif","#ifdef FLIP_SIDED","objectNormal = -objectNormal;","#endif","if (length(objectNormal) < 1e-6) {","if (projectionMatrix[3][3] > 0.5) {","objectNormal = vec3(0.0,0.0,1.0);","} else {","objectNormal = normalize(-mvPosition.xyz);","}","#if defined(BILLBOARD) || defined(FIXED_SIZE)","setSimpleNodeData();","#endif","objectNormal = (vec4(objectNormal, 0.0) * modelViewMatrix).xyz;","#if defined(BILLBOARD)","objectNormal = (vec4(objectNormal, 0.0) * simpleNodeData.billboardMatrix).xyz;","#endif","objectNormal = normalize(objectNormal);","}","vec3 transformedNormal;","if (use_normal_matrix)","transformedNormal = normalMatrix * objectNormal;","else {",e.getModelViewUnitVectorTransformationChunk("transformedNormal","objectNormal"),"}","transformedNormal = normalize(transformedNormal);","#ifdef PDSFX","_viewTangentSpace.Position = mvPosition.xyz;","_viewTangentSpace.Normal = transformedNormal;",a,"#endif","gl_Position = projectionMatrix * mvPosition;"].join("\n")}}),define("DS/Shaders/AdvancedHighlightShaderSinglePass",["DS/Visualization/ThreeJS_R57","DS/Shaders/AdvancedHighlightShader"],function(e,t){"use strict";return{HighlightFace:{uniforms:e.UniformsUtils.merge([e.UniformsLib.clipPlanes,{map:{type:"t",value:null},rgbaDepth:{type:"t",value:null},offsetAlphaMap:{type:"v2",value:new e.Vector4(0,0)},repeatAlphaMap:{type:"v2",value:new e.Vector4(1,1)},iHighlightColor:{type:"v4",value:new e.Vector4(0,.6,1,1)},iHighlightIntensity:{type:"v2",value:new e.Vector2(1,-1)}}]),vertexShaderPars:["varying vec3 vMVNormal;","varying vec3 vMVPosition;","#if HIGHLIGHT_POLITE == 1","varying vec4 cP;","#endif"].join("\n"),vertexShaderBody:["    vMVNormal = mvNormal;","    vMVPosition = -mvPosition.xyz;","#if HIGHLIGHT_POLITE == 1","cP = gl_Position;","#endif"].join("\n"),fragmentShaderPars:["varying vec3 vMVNormal;","varying vec3 vMVPosition;","varying float reflectionFactor;","uniform vec4 iHighlightColor;","uniform vec2 iHighlightIntensity;","#if HIGHLIGHT_POLITE == 1","uniform sampler2D rgbaDepth;","varying vec4 cP;","#endif",t._computeDepthChunk].join("\n"),fragmentShaderBody:["vec3 I = vec3(0.0, 0.0, 1.0);","    if (!(projectionMatrix[3][3] > 0.0)) {","       I = normalize( vMVPosition.xyz );","    }","float reflectionFactor = abs(dot(normalize(vMVNormal),I));","#if HIGHLIGHT_POLITE == 1","float depthValue = getFaceDepthValue();","reflectionFactor = noZ == 1 ? 0.8 : depthValue < 0.5 ? (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141 : reflectionFactor;","gl_FragColor = vec4( iHighlightColor.xyz * reflectionFactor, depthValue > 0.5 ? iHighlightIntensity.y : iHighlightIntensity.x);","#else","reflectionFactor = 1.0 - reflectionFactor;","  gl_FragColor = vec4( iHighlightColor.xyz, (0.6 * reflectionFactor * reflectionFactor + 0.2) * iHighlightIntensity.x );","#endif","\tgl_FragColor.a = min(gl_FragColor.a, 1.0);"].join("\n"),vertexShader:[e.ShaderChunk.clip_pars_vertex,e.ShaderChunk.skinning_pars_vertex,"#ifndef PDSFX","varying vec3 vMVNormal;","varying vec3 vMVPosition;","#endif","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform vec2 offsetAlphaMap;","uniform vec2 repeatAlphaMap;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","#if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)","varying vec4 cP;","#endif","void main() {",e.ShaderChunk.PDSFX_start_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.default_vertex_with_normal,e.ShaderChunk.defaultnormal_vertex,"#ifndef PDSFX","vMVNormal = transformedNormal;","vMVPosition = -mvPosition.xyz;","#endif","#ifdef USE_MAP_ALPHATEST","    vUvMap = uv * repeatAlphaMap + offsetAlphaMap;","#endif","    gl_Position = projectionMatrix * mvPosition;",e.ShaderChunk.clip_vertex,"#if HIGHLIGHT_POLITE == 1 && !defined(PDSFX)","cP = gl_Position;","#endif",e.ShaderChunk.PDSFX_end_vertex,"#ifdef PDSFX_USE_MAP","vUv = uv;","#endif","}"].join("\n"),fragmentShader:[e.ShaderChunk.clip_pars_fragment,"#ifndef PDSFX","varying vec3 vMVNormal;","varying vec3 vMVPosition;","#endif","uniform vec4 iHighlightColor;","uniform vec2 iHighlightIntensity;","#ifdef USE_MAP_ALPHATEST","varying vec2 vUvMap;","uniform sampler2D map;","#endif","#ifdef PDSFX_USE_MAP","varying vec2 vUv;","#endif","#if HIGHLIGHT_POLITE == 1","uniform sampler2D rgbaDepth;","#ifndef PDSFX","varying vec4 cP;","#else","vec4 cP;","#endif","#endif",t._computeDepthChunk,"void main() {",e.ShaderChunk.PDSFX_map_fragment,"#ifdef PDSFX","ComputeCommonValues();",e.ShaderChunk.PDSFX_discard_fragment,e.ShaderChunk.PDSFX_viewNormal_fragment,"vec3 mvPosition = ComputeViewPosition();","vec3 I = vec3(0.0, 0.0, 1.0);","if (!(projectionMatrix[3][3] > 0.0)) {","I = normalize( -mvPosition.xyz );","}","float reflectionFactor = abs( dot( I, _DSvNormal ) );","#if HIGHLIGHT_POLITE == 1","cP = _DSclipPosition;","#endif","#else","vec3 I = vec3(0.0, 0.0, 1.0);","if (!(projectionMatrix[3][3] > 0.0)) {","I = normalize( vMVPosition.xyz );","}","float reflectionFactor = abs(dot(normalize(vMVNormal), I));","#endif",e.ShaderChunk.clip_fragment,"#ifdef USE_MAP_ALPHATEST","   float alpha2 = texture2D( map, vUvMap ).w;","   if ( alpha2 < ALPHATEST ) discard;","#endif","#if HIGHLIGHT_POLITE == 1","float depthValue = getFaceDepthValue();","reflectionFactor = noZ == 1 ? 0.8 : depthValue < 0.5 ? (1.0 - 1.0 / 3.141) * reflectionFactor + 1.0/3.141 : reflectionFactor;","gl_FragColor = vec4( iHighlightColor.xyz * reflectionFactor, depthValue > 0.5 ? iHighlightIntensity.y : iHighlightIntensity.x);","#else","reflectionFactor = 1.0 - reflectionFactor;","  gl_FragColor = vec4( iHighlightColor.xyz, (0.6 * reflectionFactor*reflectionFactor + 0.2) * iHighlightIntensity.x );","#endif","\tgl_FragColor.a = min(gl_FragColor.a, 1.0);","}"].join("\n")}}}),define("Shaders/AdvancedHighlightShaderSinglePass",["DS/Shaders/AdvancedHighlightShaderSinglePass","DS/DSMigration/DSMigration"],function(e,t){return t.deprecateModule("Shaders/AdvancedHighlightShaderSinglePass"),e}),define("DS/Shaders/PDSFXShaders",["DS/Shaders/DefaultShaders"],function(e){"use strict";var t={PDSFX_header_vertex:["#ifdef CPU_PATTERN","#define PDSFX_PIXEL_LINEDISTANCE","#endif","#ifdef COMPRESSED_VERTICES","attribute vec2 _DSposition;","#else","attribute vec3 _DSposition;","#endif","#ifdef COMPRESSED_NORMALS","attribute float _DSnormal;","#else","attribute vec3 _DSnormal;","#endif","attribute vec2 _DSuv;","attribute vec2 _DSuv2;","attribute vec3 _DStangent;","attribute vec3 _DSbinormal;",["vec3 _DS_position;","vec3 _DS_normal;","vec2 _DS_uv;","vec2 _DS_uv2;","vec3 position;","vec3 normal;","vec2 uv;","vec2 uv2;","vec3 tangent;","vec3 binormal;"].join("\n"),"#ifdef USE_DASHEDLINE","attribute vec2 _DSlineDistance;","#ifdef WORLD_SIZE_PATTERN2","attribute vec2 patternStartEnd;","#endif","vec2 lineDistance;","#else","vec2 _DSlineDistance;","#endif","#ifdef USE_WIDELINE","attribute vec3 _DSpreviousPos;","attribute vec3 _DSfollowingPos;","vec3 previousPos;","vec3 followingPos;","#else","vec3 _DSpreviousPos;","vec3 _DSfollowingPos;","#endif"].join("\n"),PDSFX_start_vertex:["","#ifdef COMPRESSED_VERTICES","position = decodePosition(_DSposition, quantizedVector, offsetVector);","#endif","#ifdef COMPRESSED_NORMALS","normal = decodeOct24Normal(_DSnormal);","#endif","#ifdef COMPRESSED_UVS","uv = decodeUV(_DSuv);","uv2 = decodeUV(_DSuv2);","#endif","#if defined(COMPRESSED_COLORS)","color = decodeColor(_DScolor);","#endif","#ifdef PDSFX","#ifdef COMPRESSED_VERTICES","_DS_position = position;","#else","_DS_position = _DSposition;","#endif","#ifdef COMPRESSED_NORMALS","_DS_normal = normal;","#else","_DS_normal = _DSnormal;","#endif","#ifdef COMPRESSED_UVS","_DS_uv = uv;","_DS_uv2 = uv2;","#else","_DS_uv = _DSuv;","_DS_uv2 = _DSuv2;","#endif","ComputeCommonValues();","position = ComputeObjectPosition();","normal = ComputeObjectNormal();","#ifdef USE_DASHEDLINE","lineDistance = _DSlineDistance;","#endif","#ifdef USE_WIDELINE","previousPos = ComputeObjectPreviousPosition();","followingPos = ComputeObjectFollowingPosition();","#endif","#ifdef USE_DASHEDLINE","ProcessLineDistance(lineDistance);","#endif","uv = ComputeObjectTexCoord0().xy;","uv2 = ComputeObjectTexCoord1().xy;","#if defined(USE_TANGENT_BINORMAL)","tangent = ComputeObjectTangent();","binormal = ComputeObjectBinormal();","#endif","TangentSpace _viewTangentSpace;","vec3 _MVNormal;","#if defined( NEEDS_UVTOUSE )","#if defined (MAPPING_OPERATOR)","_DSmappingUVTransformation = mappingUVTransformation;","#endif","#endif","#endif",""].join("\n"),PDSFX_start_particle_vertex:["#ifdef PDSFX","_DSsize_ = size;","_DSscale_ = scale;","#endif"].join("\n"),PDSFX_point_size_vertex:["#ifdef PDSFX","gl_PointSize = ComputePointSize();","#else","#ifdef USE_SIZEATTENUATION","gl_PointSize = size * ( scale / length( mvPosition.xyz ) );","#else","gl_PointSize = size;","#endif","#endif","#if defined(PRIMITIVE_HIGHLIGHT) && defined(MOBILE_HIGHLIGHT_MODE)","gl_PointSize += 2.0;","#endif"].join("\n"),PDSFX_end_vertex:["","#ifdef PDSFX","#ifdef LINE_DS_VERTEX","vec4 copy_gl_Position = vec4(gl_Position);","ProcessClipSpacePosition(copy_gl_Position);","#else","ProcessClipSpacePosition(gl_Position);","#endif","ComputeVaryingValues();","_DSclipPosition = gl_Position;","_DSviewPosition = _viewTangentSpace.Position;","_DSviewNormal = _viewTangentSpace.Normal;","_DSviewTangent = _viewTangentSpace.Tangent;","_DSviewBinormal = _viewTangentSpace.Binormal;","#endif","#ifndef DEFERRABLE_MATERIAL","#ifdef PICKING_INSTANCING","if (instanceId > 16777215.0) vInstancePickingColor = vec3(0.0);","else {","vInstancePickingColor.r = floor(instanceId / 65536.0);","vInstancePickingColor.g = floor((instanceId - vInstancePickingColor.r * 65536.0) / 256.0);","vInstancePickingColor.b = floor(instanceId - vInstancePickingColor.r * 65536.0 - vInstancePickingColor.g * 256.0);","vInstancePickingColor /= 255.0;","}","#endif","#ifdef SPECIAL_PICKING_INSTANCING","vInstancePickingColor = specialMeshPicking;","#endif","#endif",""].join("\n")},o={PDSFXComputeCommonValues_VS:["void ComputeCommonValues() {","}"].join("\n"),PDSFXComputeObjectPosition_VS:["vec3 ComputeObjectPosition() {","\treturn _DS_position;","}"].join("\n"),PDSFXComputeObjectPreviousPosition_VS:["vec3 ComputeObjectPreviousPosition() {","\treturn _DSpreviousPos;","}"].join("\n"),PDSFXComputeObjectFollowingPosition_VS:["vec3 ComputeObjectFollowingPosition() {","\treturn _DSfollowingPos;","}"].join("\n"),PDSFXComputeObjectNormal_VS:["vec3 ComputeObjectNormal() {","\treturn _DS_normal;","}"].join("\n"),PDSFXComputeObjectTexCoord0_VS:["vec4 ComputeObjectTexCoord0() {","\treturn vec4(_DS_uv, 0.0, 0.0);","}"].join("\n"),PDSFXComputeObjectTexCoord1_VS:["vec4 ComputeObjectTexCoord1() {","\treturn vec4(_DS_uv2, 0.0, 0.0);","}"].join("\n"),PDSFXComputeObjectTexCoord2_VS:["vec4 ComputeObjectTexCoord2() {","\treturn vec4(0.0);","}"].join("\n"),PDSFXComputeObjectTangent_VS:["vec3 ComputeObjectTangent() {","\treturn _DStangent;","}"].join("\n"),PDSFXComputeObjectBinormal_VS:["vec3 ComputeObjectBinormal() {","\treturn _DSbinormal;","}"].join("\n"),PDSFXProcessViewTangentSpace_VS:["void ProcessViewTangentSpace(inout TangentSpace ioWorldViewTS) {","}"].join("\n"),PDSFXProcessLineDistance_VS:["void ProcessLineDistance(inout vec2 lineDistance) {","}"].join("\n"),PDSFXProcessClipSpacePosition_VS:["void ProcessClipSpacePosition(inout vec4 ioPosition) {","}"].join("\n"),PDSFXComputePointSize_VS:["float ComputePointSize() {","#ifdef USE_SIZEATTENUATION","return _DSsize_ * ( _DSscale_ / length( mvPosForAttenuation.xyz ) );","#else","return _DSsize_;","#endif","}"].join("\n"),PDSFXComputeVaryingValues_VS:["void ComputeVaryingValues() {","}"].join("\n"),PDSFXComputeHalfWidth_VS:["float ComputeHalfWidth() {","return _DShalfWidth_;","}"].join("\n")},a={PDSFX_albedo_pars_fragment:["#ifdef PDSFX","uniform vec3 _DSalbedo;","vec3 diffuse;","#else","uniform vec3 diffuse;","#endif"].join("\n"),PDSFX_opacity_pars_fragment:["#ifdef PDSFX","uniform float _DSopacity;","float opacity;","#else","uniform float opacity;","#endif"].join("\n"),PDSFX_emissive_pars_fragment:["#ifdef PDSFX","uniform vec3 _DSemissive;","vec3 emissive;","#else","uniform vec3 emissive;","#endif"].join("\n"),PDSFX_specular_pars_fragment:["#ifdef PDSFX","uniform vec3 _DSspecular;","vec3 specular;","#else","uniform vec3 specular;","#endif"].join("\n"),PDSFX_albedo_fragment:["_DSalbedo_ = _DSalbedo;","diffuse = ComputeAlbedo();"].join("\n"),PDSFX_opacity_fragment:["_DSopacity_ = _DSopacity;","opacity = ComputeOpacity();"].join("\n"),PDSFX_emissive_fragment:["_DSemissive_ = _DSemissive;","emissive = ComputeEmissive();"].join("\n"),PDSFX_specular_fragment:["_DSspecular_ = _DSspecular;","specular = ComputeSpecularReflectance();"].join("\n")},i={PDSFX_map_fragment:["#ifdef PDSFX_USE_MAP","_uvToUse = vUv;","#ifdef PHYSICALDS","_uvToUse2 = vUv2;","#endif","#endif"].join("\n"),PDSFX_mapping_fragment:["#if defined( NEEDS_UVTOUSE )","#if defined (MAPPING_OPERATOR)","_DSmappingUVTransformation = mappingUVTransformation;","#endif","#endif"].join("\n"),PDSFX_discard_fragment:["bool isDiscarded = ComputeDiscard();","if (isDiscarded) discard;"].join("\n"),PDSFX_viewNormal_fragment:["vec3 _DSvNormal = ComputeViewNormal();"].join("\n"),PDSFX_end_fragment:["#ifdef PDSFX","ProcessFinalColor(gl_FragColor);","#endif","#ifndef DEFERRABLE_MATERIAL","#if defined(PICKING_INSTANCING) || defined(SPECIAL_PICKING_INSTANCING)","gl_FragColor = vec4(vInstancePickingColor, 1.0);","#endif","#endif"].join("\n")},r=[],n={PDSFXComputeCommonValues_FS:["void ComputeCommonValues() {","}"].join("\n"),PDSFXComputeDiscard_FS:["bool ComputeDiscard() {","\treturn false;","}"].join("\n"),PDSFX_ComputeDiffuseTexel_FS:["vec4 _ComputeDiffuseTexel() {","\treturn vec4(1.0);","}"].join("\n"),PDSFXComputeViewPosition_FS:["vec3 ComputeViewPosition() {","\treturn _DSviewPosition;","}"].join("\n"),PDSFXComputeViewNormal_FS:["vec3 ComputeViewNormal() {","\treturn normalize(_DSviewNormal);","}"].join("\n"),PDSFXProcessFinalColor_FS:["void ProcessFinalColor(inout vec4 ioFinalColor) {","}"].join("\n"),PDSFXProcessLinePattern_FS:["void ProcessLinePattern(inout float patternValue, in float currentPixelDistance) {","}"].join("\n")},l=function(e,t,o){var a=[o+" "+e+"() {","return "+t+";","}"].join("\n");r.push(o+" "+t+";"),n["PDSFX"+e+"_FS"]=a},s=function(e,t){l(e,t,"float")},f=function(e,t){l(e,t,"vec3")};s("ComputeHalfWidth","_DShalfWidth_"),s("ComputeOpacity","_DSopacity_"),s("ComputeTransparency","_DStransparency_"),s("ComputeRoughness","_DSroughness_"),f("ComputeEmissive","_DSemissive_"),f("ComputeSpecularReflectance","_DSspecular_"),f("ComputeAlbedo","_DSalbedo_");var c={PDSFX_common_pars:["/**** PDSFX Common Getters ****/","","float _DSsize_;","","mat4 vGetWorldViewMatrix() {","return modelViewMatrix;","}","","uniform mat4 modelViewInvTranspMatrix;","mat4 vGetWorldViewInvTranspMatrix() {","return modelViewInvTranspMatrix;","}","","mat4 vGetViewMatrix() {","return viewMatrix;","}","","mat4 vGetProjectionMatrix() {","return projectionMatrix;","}","","mat4 vGetViewProjectionMatrix() {","return projectionMatrix * viewMatrix;","}","","uniform mat4 viewInvMatrix;","mat4 vGetViewInvMatrix() {","return viewInvMatrix;","}","","uniform mat4 projectionInvMatrix;","mat4 vGetProjectionInvMatrix() {","return projectionInvMatrix;","}","","mat4 vGetViewProjectionInvMatrix() {","return viewInvMatrix * projectionInvMatrix;","}","","uniform mat4 viewInvTranspMatrix;","mat4 vGetViewInvTranspMatrix() {","return viewInvTranspMatrix;","}","","mat3 _DSmappingUVTransformation;","mat4 vGetTextureMatrix() {","#if defined( NEEDS_UVTOUSE )","#if defined (MAPPING_OPERATOR)","mat4 matrix;","matrix[0] = vec4(_DSmappingUVTransformation[0], 0.0);","matrix[1] = vec4(_DSmappingUVTransformation[1], 0.0);","matrix[2] = vec4(_DSmappingUVTransformation[2], 0.0);","return matrix;","#endif","#endif","return mat4(1.0);","}","","vec3 vGetWorldEyePos() {","return cameraPosition;","}","","vec3 vGetLowlightColor() {","return vec3(0.0);","}","","float vGetDefaultPointSize() {","return _DSsize_;","}","","uniform vec3 nearFarLogFactor;","vec3 vGetNearFarLogFactor() {","return nearFarLogFactor;","}","","uniform vec2 viewportSize;","ivec2 vGetViewportSize() {","return ivec2(viewportSize);","}","","mat3 vGet3x3WorldMatrix() {","return mat3(modelMatrix);","}","","uniform mat4 modelInvTranspMatrix;","mat3 vGet3x3WorldInvTranspMatrix() {","return mat3(modelInvTranspMatrix);","}",""].join("\n"),PDSFX_attribute_getters_vertex:["","float _DSscale_;","#ifdef USE_SIZEATTENUATION","vec3 mvPosForAttenuation;","#endif","","int vGetInstanceID() {","#ifdef IS_MULTI_INSTANCED","\treturn int(instanceId/5.0 - 1.0);","#else","\treturn 0;","#endif","}","","vec3 vGetAttribPosition() {","return _DS_position;","}","vec3 vGetAttribPreviousPosition() {","return _DSpreviousPos;","}","vec3 vGetAttribFollowingPosition() {","return _DSfollowingPos;","}","","vec3 vGetAttribNormal() {","return _DS_normal;","}","","vec3 vGetAttribColor() {","return color.xyz;","}","float _vGetAttribColorAlpha() {","return color.a;","}","","vec4 vGetAttribTexCoord0() {","return vec4(_DS_uv, 0.0, 0.0);","}","","vec4 vGetAttribTexCoord1() {","return vec4(_DS_uv2, 0.0, 0.0);","}","","vec4 vGetAttribTexCoord2() {","return vec4(0.0);","}","","vec3 vGetAttribTangent() {","return _DStangent;","}","","vec3 vGetAttribBinormal() {","return _DSbinormal;","}","float _DShalfWidth_;",""].join("\n"),PDSFX_varying_getters_fragment:["#ifdef PDSFX","","vec4 vGetFragCoord() {","return gl_FragCoord;","}","","void vSetFragDepth(in float iDepth) {","#ifdef GLSL300ES","gl_FragDepth = iDepth;","#endif","#ifdef FRAG_DEPTH_EXT","gl_FragDepthEXT = iDepth;","#endif","}","","bool vIsFrontFacing() {","return gl_FrontFacing;","}","","vec2 vGetPointCoord() {","return gl_PointCoord;","}","","vec3 vGetViewPosition() {","return _DSviewPosition;","}","","vec3 vGetViewNormal() {","return normalize(_DSviewNormal);","}","","vec3 vGetViewTangent() {","return normalize(_DSviewTangent);","}","","vec3 vGetViewBinormal() {","return normalize(_DSviewBinormal);","}","","vec2 _uvToUse;","vec4 vGetTexCoord0() {","#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","return vec4(_uvToUse, 0.0, 0.0);","#else","return vec4(0.0);","#endif","}","","vec2 _uvToUse2;","vec4 vGetTexCoord1() {","#if defined( NEEDS_UVTOUSE ) || defined(PDSFX_USE_MAP)","return vec4(_uvToUse2, 0.0, 0.0);","#else","return vec4(0.0);","#endif","}","","vec4 vGetTexCoord2() {","return vec4(0.0);","}","","vec4 vGetClipSpacePosition() {","return _DSclipPosition;","}",r.join("\n"),"#endif",""].join("\n"),PDSFX_varyings_pars:["","#ifdef PDSFX","varying vec3 _DSviewPosition;","varying vec3 _DSviewNormal;","varying vec3 _DSviewTangent;","varying vec3 _DSviewBinormal;","varying vec4 _DSclipPosition;","#endif",""].join("\n")},v={PDSFX_halfWidth_pars_vertex_fragment:["#ifdef PDSFX","uniform float _DShalfWidth;","float halfWidth;","#else","uniform float halfWidth;","#endif","float getHalfWidth() {","#if defined(PRIMITIVE_HIGHLIGHT) && defined(MOBILE_HIGHLIGHT_MODE)","return halfWidth > 0.5 ? halfWidth + 0.5 : halfWidth;","#else","return halfWidth;","#endif","}"].join("\n"),PDSFX_halfWidth_fragment_vertex:["#ifdef USE_WIDELINE","_DShalfWidth_ = _DShalfWidth;","halfWidth = ComputeHalfWidth();","#endif"].join("\n")};return Object.assign(v,c),Object.assign(v,t),Object.assign(v,o),Object.assign(v,a),Object.assign(v,i),Object.assign(v,n),v}),define("DS/Shaders/LineDSShaders",["DS/Shaders/DefaultShaders","DS/Shaders/PDSFXShaders"],function(e,t){"use strict";var o=["   bool isNull(float x) {","       return abs(x) < 1e-6;","   }","   vec2 vNormalize(in vec2 v) {","       float len = length(v);","       if (!isNull(len)) {","           return v/len;","       }","       return vec2(0.0);","   }","   vec3 vNormalize(in vec3 v) {","       float len = length(v);","       if (!isNull(len)) {","           return v/len;","       }","       return vec3(0.0);","   }","   vec4 vNormalize(in vec4 v) {","       float len = length(v);","       if (!isNull(len)) {","           return v/len;","       }","       return vec4(0.0);","   }"].join("\n"),a={dashedParsVertex:["#ifdef USE_DASHEDLINE","   varying vec2 vLineDistance;","#ifdef WORLD_SIZE_PATTERN","       varying vec2 vPatternStartEnd;","       varying vec3 vPointCurr;","   #ifdef USE_WIDELINE","       varying vec3 vPointNext;","       varying vec3 vPointPrec;","       varying float vLineDistanceAlt;","       varying float resetSecondDist;","       varying vec3 vConstantNext;","       varying vec3 vConstantCurr;","       varying vec3 vConstantPrec;","   #endif","#else","   #ifdef USE_WIDELINE","       varying vec2 vPointNext;","       varying vec2 vPointPrec;","       varying float vLineDistanceAlt;","       varying vec2 vLineDistanceLeft;","       varying vec2 vLineDistanceRight;","       varying float resetSecondDist;","       varying vec2 vConstantNext;","       varying vec2 vConstantCurr;","       varying vec2 vConstantPrec;","   #endif","#endif","#endif"].join("\n"),wideParsVertex:["#ifdef USE_WIDELINE",t.PDSFX_halfWidth_pars_vertex_fragment,"       float getSegmentDepthValue(in vec3 dir, in vec3 posToComp) {","           vec3 nDir = vNormalize(dir);","           return min(1e18,(dot(posToComp,nDir) * nDir).z);","       }","       float getFinalZ(in bool clipped, in bvec2 precNext, in vec3 pmvPosition, in vec3 pmvPositionPrec, in vec3 pmvPositionSuiv, in vec2 pos, in float oldW, in vec3 mvPosition, in float worldSizeToPixel) {","\t\t\tvec3 computedPosition = vec3(pos.x, pos.y,pmvPosition.z);","\t\t\tfloat finalZ = pmvPosition.z;","       #ifndef USE_POLYGON_BORDER_MODE","           if (!clipped) {","\t\t\t\treturn finalZ;","           }","\t\t\tif (precNext.x) {","\t\t\t\tfinalZ = getSegmentDepthValue(pmvPosition.xyz - pmvPositionPrec.xyz,computedPosition.xyz - pmvPosition.xyz) + pmvPosition.z;","\t\t\t} else if (precNext.y) {","\t\t\t\tfinalZ = getSegmentDepthValue(pmvPositionSuiv.xyz - pmvPosition.xyz,computedPosition.xyz - pmvPosition.xyz) + pmvPosition.z;","\t\t\t}","\t\t\treturn finalZ;","       #else","           vec3 precDir, nextDir;","           if (precNext.y) {","               nextDir = pmvPositionSuiv.xyz - pmvPosition.xyz;","           }","           if (precNext.x) {","               precDir = pmvPosition.xyz - pmvPositionPrec.xyz;","           }","           if (precNext.x && precNext.y && length(cross(nextDir,precDir)) > 1e-6) {","               vec4 equationP = getPlanEquation(nextDir,precDir,pmvPosition.xyz);","               finalZ = - (equationP.x * computedPosition.x + equationP.y * computedPosition.y + equationP.w)/equationP.z;","               vec3 mvComputedPos = getViewSpaceConvertedPosition(pos, vec2(finalZ,1.0),oldW);","               vec3 positionToComputed = mvComputedPos.xyz - mvPosition;","               if (abs(positionToComputed.z) > 10.0*getHalfWidth() / worldSizeToPixel) {","                   mvComputedPos.z = mvPosition.z + 10.0*getHalfWidth() / worldSizeToPixel * sign(positionToComputed.z);","               }","               vec4 mvpComputedPos = projectionMatrix * vec4(mvComputedPos,1.0);","               mvpComputedPos /= abs(mvpComputedPos.w);","               finalZ = mvpComputedPos.z;","           } else if (precNext.x) {","               finalZ = getSegmentDepthValue(precDir,computedPosition.xyz - pmvPosition.xyz) + pmvPosition.z;","           } else if (precNext.y) {","               finalZ = getSegmentDepthValue(nextDir,computedPosition.xyz - pmvPosition.xyz) + pmvPosition.z;","           }","           return 0.99999*finalZ;","       #endif","       }","#endif"].join("\n"),roundCapParsVertex:["#ifdef USE_ROUNDCAP","   varying vec2 infos;","   varying vec2 centerLeft;","   varying vec2 centerCap;","   varying vec2 centerRight;","#endif"].join("\n"),roundJoinParsVertex:["#ifdef USE_ROUNDJOIN","   varying vec4 centerJoin;","   varying vec4 centerRightJoin;","   varying vec4 centerLeftJoin;","#endif"].join("\n"),polygonBorderModeParsVertex:["   #if defined(USE_POLYGON_BORDER_MODE) || (defined(USE_DASHEDLINE) && defined(WORLD_SIZE_PATTERN))","       vec4 getPlanEquation(in vec3 v1, in vec3 v2, in vec3 randomPosition) {","           vec3 normal = cross(v1,v2);","           normal = vNormalize(normal);","           float d;","           d = -dot(normal,randomPosition);","           return vec4(normal,d);","       }","","       vec3 getViewSpaceConvertedPosition(in vec2 pos, in vec2 zw, in float w){","           vec4 res = vec4(pos,zw);","           res *= w;","           res.y *= pixelSize.y/pixelSize.x;","           mat4 inverseProjection = mat4(projectionMatrix);","           if (! isNull(projectionMatrix[3][3]) ) {","               inverseProjection[0][0] = 1.0 / projectionMatrix[0][0];","               inverseProjection[1][1] = 1.0 / projectionMatrix[1][1];","               inverseProjection[2][2] = 1.0 / projectionMatrix[2][2];","               inverseProjection[3][2] = -projectionMatrix[3][2] / projectionMatrix[2][2];","               inverseProjection[3][3] = 1.0;","           } else {","               inverseProjection[0][0] = 1.0 / projectionMatrix[0][0];","               inverseProjection[1][1] = 1.0 / projectionMatrix[1][1];","               inverseProjection[2][2] = 0.0;","               inverseProjection[2][3] = 1.0 / projectionMatrix[3][2];","               inverseProjection[3][2] = 1.0 / projectionMatrix[2][3];","               inverseProjection[3][3] = -projectionMatrix[2][2] / (projectionMatrix[3][2] * projectionMatrix[2][3]);","           }","           res = inverseProjection * res;","           return res.xyz/res.w;","       }","   #endif"].join("\n"),wideParsFragment:["#ifdef USE_WIDELINE",t.PDSFX_halfWidth_pars_vertex_fragment,"#endif"].join("\n"),dashedParsFragment:["#ifdef USE_DASHEDLINE","   uniform float dashSize;","   uniform float scale;","   uniform float totalSize;","   uniform float patternOffset;","   #ifdef PATTERN_LENGTH","       uniform float dashPattern[PATTERN_LENGTH];","   #endif","   varying vec2 vLineDistance;","#ifdef WORLD_SIZE_PATTERN","varying vec2 vPatternStartEnd;","varying vec3 vPointCurr;","   #ifdef USE_WIDELINE","       varying vec3 vPointNext;","       varying vec3 vPointPrec;","       varying float vLineDistanceAlt;","       varying float resetSecondDist;","       varying vec3 vConstantCurr;","       varying vec3 vConstantNext;","       varying vec3 vConstantPrec;","   #endif","   float getDistance(in vec3 next, in vec3 prev) {","       vec3 resPoint = vec3(0.0);","       vec3 direction = next-prev;","       float lxy = length(direction.xy);","       vec2 dirXY = vNormalize(direction.xy);","       resPoint.xy = dot(vPointCurr.xy - prev.xy, dirXY) * dirXY;","       resPoint.z = length(resPoint.xy) / lxy * direction.z;","       return clamp(length(resPoint), 0.0, length(direction));","   }","   float getDistance(in vec3 next, in vec3 prev, in vec3 origin) {","       vec3 resPoint = vec3(0.0);","       vec3 direction = next-prev;","       float lxy = length(direction.xy);","       vec2 dirXY = vNormalize(direction.xy);","       resPoint.xy = dot(vPointCurr.xy - origin.xy, dirXY) * dirXY;","       resPoint.z = length(resPoint.xy) / lxy * direction.z;","       return clamp(length(resPoint), 0.0, length(direction));","   }","#else","   #ifdef USE_WIDELINE","       varying vec2 vPointNext;","       varying vec2 vPointPrec;","       varying float vLineDistanceAlt;","       varying vec2 vLineDistanceLeft;","       varying vec2 vLineDistanceRight;","       varying float resetSecondDist;","       varying vec2 vConstantNext;","       varying vec2 vConstantCurr;","       varying vec2 vConstantPrec;","   #endif","   float getDistance(in vec2 next, in vec2 prev) {","       float res = 0.0;","       vec2 direction = next-prev;","       float l = length(direction);","       res = dot(gl_FragCoord.xy  - prev, direction)/(l*l);","       return res * (vLineDistance.y - vLineDistance.x);","   }","   float getDistance(in vec2 next, in vec2 prev, in vec2 origin, in float ratio) {","       float res = 0.0;","       vec2 direction = next-prev;","       float l = length(direction);","       res = dot(gl_FragCoord.xy - origin, direction)/(l*l);","       return res* ratio;","   }","#endif","   #ifdef PATTERN_LENGTH","       vec3 getPatternInfo(in float dist) {","           int index = 0;","           float prec = 0.0, cur = 0.0;","           for (int i = 0; i < PATTERN_LENGTH; i++) {","               cur = max(scale,1e-6)*dashPattern[i];","               if (cur > dist) {","                   break;","               }","               prec = cur;","               index++;","           }","           return vec3(float(index),prec,cur);","       }","\t\tfloat getPatternDistance(in float dist) {","           #ifdef USE_BUTTCAP","           \treturn dist + patternOffset;","\t\t\t#else","\t\t\t\t#if !defined(USE_WIDELINE) || defined(WORLD_SIZE_PATTERN)","           \t   return dist + patternOffset;","               #else","           \t   return dist + getHalfWidth() + patternOffset;","\t\t\t\t#endif","           #endif","\t\t}","       float getPatternAlpha(in float dist) {","           float mDist = mod( dist, max(scale,1e-6)*totalSize );","           #ifdef WORLD_SIZE_PATTERN2","if (vPatternStartEnd.x > -0.5) {","mDist -= vPatternStartEnd.x;","if (mDist < 0.0 || mDist > vPatternStartEnd.y - vPatternStartEnd.x) {","return 1.0;","}","}","           #endif","           vec3 patternInfo = getPatternInfo(mDist);","\t\t\t#ifdef DASHEDLINE_INVERTED","           \tif (abs(mod(patternInfo.x,2.0)) < 0.5) {","               \treturn 1.0;","           \t}","\t\t\t\treturn 0.0;","\t\t\t#else","           \tif (abs(mod(patternInfo.x,2.0)) < 0.5) {","               \treturn 0.0;","           \t}","\t\t\t\treturn 1.0;","\t\t\t#endif","       }","   #endif","#endif"].join("\n"),roundCapParsFragment:["#ifdef USE_ROUNDCAP","   varying vec2 infos;","   varying vec2 centerLeft;","   varying vec2 centerCap;","   varying vec2 centerRight;","   bool doLeftCap(in bool leftSide) {","       bool leftCap = leftSide && infos.x < 0.0;","       if (!leftCap) {","           return false;","       }","       float distanceL = length(gl_FragCoord.xy - centerLeft)/getHalfWidth();","       if (distanceL > 1.0) {","           discard;","       }","       return true;","   }","   bool doRightCap(in bool rightSide) {","       bool rightCap = rightSide  && infos.x > length(centerRight - centerCap);","       if (!rightCap) {","           return false;","       }","       float distanceR = length(gl_FragCoord.xy - centerRight) / getHalfWidth();","       if (distanceR > 1.0) {","            discard;","       }","\t\treturn true;","   }","   void doRoundCap() {","       bool centerSide = abs(length(fwidth(centerCap))) < 1e-2;","       bool capToCap = abs(fwidth(infos.y)) < 1e-2 && infos.y > 0.0;","       bool leftSide = abs(length(fwidth(centerLeft))) < 1e-2 ;","       bool rightSide = abs(length(fwidth(centerRight))) < 1e-2 ;","       bool toTreat = ! (leftSide && rightSide && centerSide) || capToCap;","       if (!toTreat) {","           return;","       }","       bool leftCap = doLeftCap(leftSide);","       bool rightCap = doRightCap(rightSide && centerSide);","   }","#endif"].join("\n"),roundJoinParsFragment:["#ifdef USE_ROUNDJOIN","   varying vec4 centerJoin;","   varying vec4 centerRightJoin;","   varying vec4 centerLeftJoin;","   void doCentralJoin() {","       float distanceJoin = 0.0;","       float varJoinC = 0.0;","       if (dot(gl_FragCoord.xy - centerJoin.xy, centerJoin.zw) <= 0.0) {","           return;","       }","       distanceJoin = length(gl_FragCoord.xy - centerJoin.xy) / getHalfWidth();","       if (distanceJoin > 1.0) {","           discard;","       }","   }","   void doSideJoins() {","       bool rightJoin = abs(length(fwidth(centerRightJoin))) < 1e-2 && dot(gl_FragCoord.xy - centerRightJoin.xy, centerRightJoin.zw) > 0.0;","       bool leftJoin =  abs(length(fwidth(centerLeftJoin))) < 1e-2 && dot(gl_FragCoord.xy - centerLeftJoin.xy, centerLeftJoin.zw) > 0.0;","       float distanceRight = 0.0;","       float distanceLeft = 0.0;","       float varJoinR = 0.0;","       float varJoinL = 0.0;","       if (rightJoin) {","           distanceRight = length(gl_FragCoord.xy - centerRightJoin.xy) / getHalfWidth();","           if (distanceRight > 1.0) {","               discard;","           }","       }","       if (leftJoin) {","           distanceLeft = length(gl_FragCoord.xy - centerLeftJoin.xy) / getHalfWidth();","           if (distanceLeft > 1.0) {","               discard;","           }","       }","   }","   void doRoundJoins() {","       bool isOnJoin = abs(length(fwidth(centerJoin))) < 1e-2;","       if (isOnJoin) {","           doCentralJoin();","           return;","       }","       doSideJoins();","    }","#endif"].join("\n"),dashedLineInWide:["   #ifdef USE_DASHEDLINE","       vLineDistanceAlt = vLineDistance.x;","#ifdef WORLD_SIZE_PATTERN","       vConstantNext = getViewSpaceConvertedPosition(pmvPositionSuiv.xy, vec2(pmvPositionSuiv.z, pmvPositionSuiv.w), oldWSuiv);","       vConstantPrec = getViewSpaceConvertedPosition(pmvPositionPrec.xy, vec2(pmvPositionPrec.z, pmvPositionPrec.w), oldWPrec);","       vConstantCurr = getViewSpaceConvertedPosition(pmvPosition.xy, vec2(pmvPosition.z, pmvPosition.w), oldW);","          vLineDistance.x = lineDistance.x* modelMatrixScaleX;","          vLineDistance.y = lineDistance.y* modelMatrixScaleX;","       resetSecondDist = 0.0;","       if (!parity){","          vLineDistanceAlt = vLineDistance.y;","          vPointPrec = vConstantPrec.xyz;","          vPointNext = vConstantCurr.xyz;","       } else {","          vLineDistanceAlt = vLineDistance.x;","          vPointPrec = vConstantCurr.xyz;","          vPointNext = vConstantNext.xyz;","          if (abs(lineDistance.x - lineDistance.y) < 1e-6) {","               resetSecondDist = 1.0;","          }","       }","#else","\t\tvec4 mvpPositionPrec = projectionMatrix * mvPositionPrec; ","       vec4 mvpPosition = projectionMatrix * mvPosition;","       vec4 mvpPositionSuiv = projectionMatrix * mvPositionSuiv;","       vConstantNext = (mvpPositionSuiv.xy / mvpPositionSuiv.w + 1.0)/ pixelSize;","       vConstantPrec = (mvpPositionPrec.xy / mvpPositionPrec.w + 1.0) / pixelSize;","       vConstantCurr = (mvpPosition.xy / mvpPosition.w + 1.0) / pixelSize;","\t#ifdef CPU_PATTERN","       vLineDistance.x = lineDistance.x ;","       vLineDistance.y = lineDistance.y ;","\t#endif","       float worldSizeToPixelPrec = computeWorldSizeToPixel(mvpPositionPrec);","       float worldSizeToPixelNext = computeWorldSizeToPixel(mvpPositionSuiv);","       resetSecondDist = 0.0;","       if (!parity){","           vLineDistanceAlt = vLineDistance.y;","           vPointPrec = vConstantPrec;","           vPointNext = vConstantCurr;","\t#ifdef CPU_PATTERN","           vLineDistanceLeft.x = lineDistance.x;","           vLineDistanceLeft.y = lineDistance.y;","           vLineDistanceRight.x = lineDistance.y;","           vLineDistanceRight.y = (lineDistance.y + length(vConstantNext.xy - vConstantCurr.xy));","\t#else","           vLineDistance.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;","           vLineDistance.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;","           vLineDistanceLeft.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelPrec;","           vLineDistanceLeft.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;","           vLineDistanceRight.x = lineDistance.y * modelMatrixScaleX * worldSizeToPixelCurr;","           vLineDistanceRight.y = (lineDistance.y + length(followingPos.xyz - position.xyz)) * modelMatrixScaleX * worldSizeToPixelNext;","\t#endif","       } else {","           vLineDistanceAlt = vLineDistance.x;","           vPointPrec = vConstantCurr;","           vPointNext = vConstantNext;","\t#ifdef CPU_PATTERN","           vLineDistanceLeft.x = (lineDistance.x - length(vConstantCurr.xy - vConstantPrec.xy));","           vLineDistanceLeft.y = lineDistance.x;","           vLineDistanceRight.x = lineDistance.x;","           vLineDistanceRight.y = lineDistance.y;","\t#else","           vLineDistance.x = lineDistance.x * modelMatrixScaleX* worldSizeToPixelCurr;","           vLineDistance.y = lineDistance.y * modelMatrixScaleX* worldSizeToPixelNext;","           vLineDistanceLeft.x = (lineDistance.x - length(position.xyz - previousPos.xyz)) * modelMatrixScaleX * worldSizeToPixelPrec;","           vLineDistanceLeft.y = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;","           vLineDistanceRight.x = lineDistance.x * modelMatrixScaleX * worldSizeToPixelCurr;","           vLineDistanceRight.y = lineDistance.y * modelMatrixScaleX * worldSizeToPixelNext;","\t#endif","           if (isNull(lineDistance.x - lineDistance.y)) {","\t\t\t#ifdef CPU_PATTERN","               vLineDistanceRight.y += length(vConstantNext.xy -  vConstantCurr.xy );","\t\t\t#else","               vLineDistanceRight.y += length(followingPos.xyz -  position.xyz )* modelMatrixScaleX * worldSizeToPixelNext;","\t\t\t#endif","               resetSecondDist = 1.0;","           }","       }","#endif","   #endif"].join("\n"),roundCapVertex:["#ifdef USE_ROUNDCAP","       vec2 following = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ pixelSize;","       vec2 previous = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / pixelSize;","       vec2 current = (mvpPositionR.xy / mvpPositionR.w + 1.0) / pixelSize;","       vec2 computedCurrent = (auxVec.xy + 1.0) / pixelSize;","   if (!bPrecCurr) {","       centerLeft = current.xy;","       centerCap = current.xy;","       centerRight = following.xy;","       infos.x = -getHalfWidth();","       infos.y = 1.0;","   } else if (!bCurrNext) {","       centerLeft = previous.xy;","       centerCap = previous.xy;","       centerRight = current.xy;","       infos.x = length(current.xy-previous.xy) + getHalfWidth();","       infos.y = 1.0;","   } else {","       infos.y = 0.0;","       centerLeft = previous.xy;","       centerCap = current.xy;","       centerRight = following.xy;","       if (parity) {","           infos.x = dot(computedCurrent.xy - current.xy,  vNormalize(following.xy - current.xy));","       } else {","           infos.x = length(current.xy - previous.xy) + dot(computedCurrent.xy - current.xy, vNormalize(current.xy - previous.xy));","       }","   }","#endif"].join("\n"),roundJoinVertex:["#ifdef USE_ROUNDJOIN","   vec2 followingJoin = (mvpPositionSuivR.xy / mvpPositionSuivR.w + 1.0)/ pixelSize;","   vec2 previousJoin = (mvpPositionPrecR.xy / mvpPositionPrecR.w + 1.0) / pixelSize;","   vec2 currentJoin = (mvpPositionR.xy / mvpPositionR.w + 1.0) / pixelSize;","   centerLeftJoin = vec4(0.0);","   centerRightJoin = vec4(0.0);","   centerJoin = vec4(0.0);","   if (!bPrecCurr) {","       centerLeftJoin.xy = followingJoin.xy;","       centerJoin.xy = currentJoin.xy;","       centerRightJoin.xy = followingJoin.xy;","       centerRightJoin.zw = dirCurrNext;","   } else if (!bCurrNext) {","       centerLeftJoin.xy = previousJoin.xy;","       centerJoin.xy = currentJoin.xy;","       centerRightJoin.xy = previousJoin.xy;","       centerLeftJoin.zw = -dirPrecCurr;","   } else {","       if (parity) {","           centerLeftJoin.xy = currentJoin.xy;","           centerJoin.xy = currentJoin.xy;","           centerRightJoin.xy = followingJoin.xy;","           centerLeftJoin.zw = -dirCurrNext;","           centerRightJoin.zw = dirCurrNext;","           centerJoin.zw = -dir;","       } else {","           centerLeftJoin.xy = previousJoin.xy;","           centerJoin.xy = currentJoin.xy;","           centerRightJoin.xy = currentJoin.xy;","           centerLeftJoin.zw = -dirPrecCurr;","           centerRightJoin.zw = dirPrecCurr;","           centerJoin.zw = -dir;","       }","   }","#endif"].join("\n"),wideLineExtrusion:["   if (bPrecCurr){","       dirPrecCurr = pmvPosition.xy - pmvPositionPrec.xy;","       dirPrecCurr = vNormalize(dirPrecCurr);","       posPrecCurr = pmvPosition.xy + offset * orientation * vec2(-dirPrecCurr.y, dirPrecCurr.x);","   } else if (bCurrNext) {","       dirPrecCurr = pmvPosition.xy - pmvPositionSuiv.xy;","       dirPrecCurr = vNormalize(dirPrecCurr);","       posPrecCurr = pmvPosition.xy + offset * dirPrecCurr.xy;","   }","","   if (bCurrNext){","       dirCurrNext = pmvPositionSuiv.xy - pmvPosition.xy;","       dirCurrNext = vNormalize(dirCurrNext);","       posCurrNext = pmvPosition.xy + offset * orientation * vec2(-dirCurrNext.y, dirCurrNext.x);","   } else if (bPrecCurr) {","       dirCurrNext = pmvPosition.xy - pmvPositionPrec.xy;","       dirCurrNext = vNormalize(dirCurrNext);","       posCurrNext = pmvPosition.xy + offset * dirCurrNext.xy;","   }","","   vec2 dir = vNormalize(dirCurrNext.xy - dirPrecCurr.xy);","   bool col = false;","   if ( bPrecCurr && bCurrNext){","       if (isNull(length(dir))){","           dir = vec2(-dirCurrNext.y, dirCurrNext.x);","           col = true;","       }","       bool realCol = length(vNormalize(followingPos.xyz - position.xyz) - vNormalize(position.xyz - previousPos.xyz)) < 1e-2;","       float sinAlpha = dir.y * dirPrecCurr.x - dir.x * dirPrecCurr.y;","       float alpha = asin(abs(sinAlpha));","       float distPoints = min(distance(pmvPosition.xy, pmvPositionPrec.xy), distance(pmvPosition.xy, pmvPositionSuiv.xy)) + offset;","       float dist = offset/ sinAlpha;","       if (sign(sinAlpha) == -orientation) {","           if ( alpha < radians(45.0)) {","           #if defined(USE_ROUNDJOIN)","               if (parity){","                   pos = pmvPosition.xy - sign(sinAlpha) * offset * vec2(-dirCurrNext.y,dirCurrNext.x);","                   pos -= offset * dirCurrNext;","               } else {","                   pos = pmvPosition.xy - sign(sinAlpha) *offset * vec2(-dirPrecCurr.y,dirPrecCurr.x);","                   pos += offset * dirPrecCurr;","               }","           #else","               if (parity){","                   pos = posCurrNext - offset * dirCurrNext;","               } else {","                   pos = posPrecCurr + offset * dirPrecCurr;","               }","           #endif","           } else {","               pos = pmvPosition.xy - dir *abs(dist);","           }","           if (col && !realCol) {","               if (parity){","                   pos += dist * dirCurrNext*orientation;","               } else {","                   pos -= dist * dirPrecCurr *orientation;","               }","           }","       } else {","           if (max(distPoints, offset) < abs(dist)){","               dist = max(distPoints - offset, offset)*sign(sinAlpha);","               if (alpha < radians(22.5)){","                   if (parity){","                       pos = posCurrNext + dist * dirCurrNext*orientation;","                   } else {","                       pos = posPrecCurr - dist * dirPrecCurr *orientation;","                   }","                   if (col && !realCol) {","                       if (parity){","                           pos += dist * dirCurrNext*orientation;","                       } else {","                           pos -= dist * dirPrecCurr *orientation;","                       }","                   }","               } else {","                   pos = pmvPosition.xy + dir * max(distPoints, offset);","                   if (col && !realCol) {","                       if (parity){","                           pos += dist * dirCurrNext*orientation;","                       } else {","                           pos -= dist * dirPrecCurr *orientation;","                       }","                   }","               }","           } else {","               pos = pmvPosition.xy + dir *abs(dist);","               if (col && !realCol) {","                   if (parity){","                       pos += dist * dirCurrNext*orientation;","                   } else {","                       pos -= dist * dirPrecCurr *orientation;","                   }","               }","           }","       }","   } else if(bPrecCurr || bCurrNext) {","       #if defined(USE_BUTTCAP)","           pos = pmvPosition.xy + offset * vec2(-dirCurrNext.y, dirCurrNext.x)*orientation;","\t\t#else","\t\t\tpos = (posCurrNext - pmvPosition.xy)  + posPrecCurr;","\t\t#endif","   } else {","       pos = pmvPosition.xy + offset;","   }"].join("\n"),wideLineClip:["       bool clipped = false;","       vec3 testClip = vec3(sign(pmvPositionPrec.w + pmvPositionPrec.z), sign(pmvPosition.w + pmvPosition.z), sign(pmvPositionSuiv.w + pmvPositionSuiv.z));","       if (bPrecCurr && testClip.x * testClip.y < 0.0 ){","           float a = (pmvPositionPrec.w + pmvPositionPrec.z)/((pmvPositionPrec.w + pmvPositionPrec.z) - (pmvPosition.w + pmvPosition.z));","           if (testClip.x < 0.0) {","               pmvPositionPrec = (1.0 - a) * pmvPositionPrec + a * pmvPosition;","               clipped = true;","           } else if (mod(sideExtrusion,2.0) == 1.0) {","              pmvPosition = (1.0 - a) * pmvPositionPrec + a * pmvPosition;","               pmvPositionSuiv = pmvPosition;","               bCurrNext = false;","               clipped = true;","           }","       }","       if (bCurrNext && testClip.y * testClip.z < 0.0 ){","           float a = (pmvPosition.w + pmvPosition.z)/((pmvPosition.w + pmvPosition.z) - (pmvPositionSuiv.w + pmvPositionSuiv.z));","           if (testClip.z < 0.0) {","               pmvPositionSuiv = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;","               clipped = true;","           } else if (mod(sideExtrusion,2.0) == 0.0){","               pmvPosition = (1.0 - a) * pmvPosition + a * pmvPositionSuiv;","               pmvPositionPrec = pmvPosition;","               bPrecCurr = false;","               clipped = true;","           }","       }","#if defined(USE_ROUNDCAP) || defined(USE_ROUNDJOIN)","       vec4 mvpPositionPrecR = pmvPositionPrec; ","       vec4 mvpPositionR = pmvPosition;","       vec4 mvpPositionSuivR = pmvPositionSuiv;","#endif"].join("\n")};return{LineShaders:{lines_pars_vertex:["#define LINE_DS_VERTEX","   uniform vec2 pixelSize;","   float computeWorldSizeToPixel(in vec4 pos) {","      return abs(projectionMatrix[0][0]/pos.w)/pixelSize.x;","   }",o,a.dashedParsVertex,a.polygonBorderModeParsVertex,a.wideParsVertex,a.roundCapParsVertex,a.roundJoinParsVertex].join("\n"),lines_vertex:["#if defined(USE_DASHEDLINE) || defined(USE_WIDELINE)","\tfloat worldSizeToPixelCurr = computeWorldSizeToPixel(gl_Position);","#endif","#ifdef USE_DASHEDLINE","\t#ifndef CPU_PATTERN","\t\tfloat modelMatrixScaleX = length(modelMatrix[0]);","#ifdef FIXED_SIZE","modelMatrixScaleX *= simpleNodeData.fixedSizeScale;","#endif","#ifdef WORLD_SIZE_PATTERN","\t\tvLineDistance = modelMatrixScaleX * lineDistance;","#else","\t\tvLineDistance = worldSizeToPixelCurr * modelMatrixScaleX * lineDistance;","#endif","\t#else","\t\tvLineDistance = lineDistance;","\t#endif","#endif","#ifdef USE_DASHEDLINE","#ifdef WORLD_SIZE_PATTERN","   vPointCurr = mvPosition.xyz;","#endif","#ifdef WORLD_SIZE_PATTERN2","   vPatternStartEnd = patternStartEnd;","#endif","#endif","#ifdef USE_WIDELINE",e.getModelViewTransformationChunk("mvPosition","vec4(position, 1.0)"),e.getModelViewTransformationChunk("vec4 mvPositionPrec","vec4(previousPos.xyz, 1.0)"),e.getModelViewTransformationChunk("vec4 mvPositionSuiv","vec4(followingPos.xyz, 1.0)"),"   vec4 pmvPosition = projectionMatrix * mvPosition;","   vec4 pmvPositionPrec = projectionMatrix * mvPositionPrec;","   vec4 pmvPositionSuiv = projectionMatrix * mvPositionSuiv;","","   vec3 eps = vec3(1e-6);","   bool bPrecCurr = !all(lessThan(abs(position.xyz - previousPos.xyz), eps));","   bool bCurrNext = !all(lessThan(abs(followingPos.xyz - position.xyz), eps));","",a.wideLineClip,"   pmvPosition.y *= pixelSize.x/pixelSize.y;","   pmvPositionPrec.y *= pixelSize.x/pixelSize.y;","   pmvPositionSuiv.y *= pixelSize.x/pixelSize.y;","   float oldW = abs(pmvPosition.w);","   float oldWPrec = abs(pmvPositionPrec.w);","   float oldWSuiv = abs(pmvPositionSuiv.w);","   pmvPosition /= oldW;","   pmvPositionPrec /= oldWPrec;","   pmvPositionSuiv /= oldWSuiv;","","   float offset = getHalfWidth()  * pixelSize.x ;","   vec2 pos, posPrecCurr, posCurrNext;","   vec2 dirPrecCurr, dirCurrNext;","   float orientation = sign(sideExtrusion);","   bool parity = mod(sideExtrusion,2.0) < 0.5;","","   if (isNull(length(pmvPosition.xy - pmvPositionPrec.xy))) {","       bPrecCurr = false;","   }","   if (isNull(length(pmvPositionSuiv.xy - pmvPosition.xy))) {","       bCurrNext = false;","   }",a.wideLineExtrusion,"#if defined(USE_DASHEDLINE) || defined(USE_ROUNDCAP) || defined(USE_ROUNDJOIN)","       vec3 auxVec = vec3(pos.x, pos.y * pixelSize.y/pixelSize.x,0.0);","#endif","#ifdef USE_DASHEDLINE","#ifdef WORLD_SIZE_PATTERN","   vPointCurr = getViewSpaceConvertedPosition(pos.xy, vec2(pmvPosition.z, pmvPosition.w), oldW);","#endif","#endif","   float finalZ = getFinalZ(clipped,bvec2(bPrecCurr && !col,bCurrNext), pmvPosition.xyz, pmvPositionPrec.xyz, pmvPositionSuiv.xyz, pos, oldW, mvPosition.xyz,worldSizeToPixelCurr);",a.dashedLineInWide,a.roundCapVertex,a.roundJoinVertex,"   gl_Position = vec4(pos.x, pos.y * pixelSize.y/pixelSize.x,finalZ, pmvPosition.w);","#endif"].join("\n"),lines_pars_fragment:[t.PDSFX_albedo_pars_fragment,t.PDSFX_opacity_pars_fragment,o,a.wideParsFragment,a.dashedParsFragment,a.roundCapParsFragment,a.roundJoinParsFragment].join("\n"),lines_fragment:["#ifdef USE_DASHEDLINE","       float dist = vLineDistance.x;","       float dist2 = 0.0;","   #ifdef USE_WIDELINE","       bool isConnection = length(fwidth(vConstantCurr)) < 1e-10;","       bool resetDist2 = fwidth(resetSecondDist) > 1e-2;","\t\tif (!isConnection){","           dist += getDistance(vPointNext,vPointPrec);","\t\t} else  {","#ifdef WORLD_SIZE_PATTERN","           dist = vLineDistanceAlt + getDistance(vConstantCurr,vConstantPrec, vConstantCurr);","           dist2 = getDistance(vConstantNext,vConstantCurr, vConstantCurr);","#else","           dist = vLineDistanceAlt + getDistance(vConstantCurr,vConstantPrec, vConstantCurr, vLineDistanceLeft.y - vLineDistanceLeft.x);","           dist2 = getDistance(vConstantNext,vConstantCurr, vConstantCurr, vLineDistanceRight.y - vLineDistanceRight.x);","#endif","\t\t\tdist2 += resetDist2 ? 0.0 : vLineDistanceAlt;","\t\t}","   #endif","   #ifdef PATTERN_LENGTH","\t\tfloat ajdustedDist = getPatternDistance(dist);","       float patternAlpha = getPatternAlpha(ajdustedDist);","       #ifdef PDSFX","           ProcessLinePattern(patternAlpha, ajdustedDist);","       #endif","       if (abs(dist2) > 1e-6) {","\t\t\tfloat ajdustedDist2 = getPatternDistance(dist2);","           float patternAlpha2 = getPatternAlpha(ajdustedDist2);","           #ifdef PDSFX","               ProcessLinePattern(patternAlpha2, ajdustedDist2);","           #endif","           patternAlpha = min(patternAlpha, patternAlpha2);","       }","       if (patternAlpha > 0.5) {","           discard;","       }","   #endif","#endif","#ifdef USE_ROUNDCAP","   doRoundCap();","#endif","#ifdef USE_ROUNDJOIN","   doRoundJoins();","#endif"].join("\n")},LineShaderLib:a}});