define("DS/CSIJSONToolsWeb/CSICodeGenerator",[],function(){"use strict";const n={};return n.generateCppFunction=function(n,e,r,t,i){return 1===i?{ok:function(n,e,r){return`#include "${r}.h"\n\n#include "CATUnicodeString.h"\n\n#include "CSIChannel.h"\n#include "CSINode.h"\n#include "CSIParameters.h"\n\n${r}::${r}(CSI::Node& node) : node_{node} {}\n\nHRESULT ${r}::OnCall(const CSI::Parameters& inputs, CSI::Channel& origin) {\n  // implement your function here\n}\n\nextern "C" {\nDSYExport CSI::FunctionInterface* createFunctionInstance(CSI::Node& node, const CATUnicodeString& name, int32_t version) {\n  if (name == "${n}" && version == ${e})\n    return new ${r}(node);\n  return nullptr;\n}\n\nDSYExport void deleteFunctionInstance(CSI::FunctionInterface* funInstance) { delete funInstance; }\n}\n`}(n,e,r)}:2===i?{ok:function(n,e,r,t){return`#include "${r}.h"\n\n#include "CSIChannel.h"\n#include "CSINode.h"\n#include "CSIParameters.h"\n\n${r}::${r}(CSI::Node& node) : node_{node} {}\n\nHRESULT ${r}::OnCall(const CSI::Parameters& inputs, CSI::Channel& origin) {\n  // implement your function here\n}\n\nCSI_INSTANTIATE_FUNCTION_WITH_NODE(${r}, ${t}, ${n}, ${e})\n`}(n,e,r,t)}:{err:new Error("Invalid implementation version: must be 1 or 2")}},n.generateHppFunction=function(n){return`#ifndef ${n}_h\n#define ${n}_h\n\n#include "CSIFunctionInterface.h"\n\nnamespace CSI {\nclass Channel;\nclass Node;\nclass Parameters;\n} // namespace CSI\n\nclass ${n} : public CSI::FunctionInterface {\npublic:\n  explicit ${n}(CSI::Node& node);\n\n  HRESULT OnCall(const CSI::Parameters& inputs, CSI::Channel& origin) override;\n\nprivate:\n  CSI::Node& node_;\n};\n\n#endif // ${n}_h\n`},n.generateJavaFunction=function(n,e){return`package ${e};\n\nimport com.dassault_systemes.csicommandbinder.Channel;\nimport com.dassault_systemes.csicommandbinder.FunctionInterface;\nimport com.dassault_systemes.csicommandbinder.Node;\nimport com.dassault_systemes.csiparameters.Parameters;\n\npublic class ${n} implements FunctionInterface {\n\n  private final Node node_;\n\n  public ${n}(Node node) {\n    node_ = node;\n  }\n\n  @Override\n  public void onCall(Parameters inputs, Channel origin) {\n    // implement your function here\n  }\n}\n`},n.LanguageEnum={CPP:1,JAVA:2},n.parseFunctionJsonDecl=function(e){let r={};try{r=JSON.parse(e)}catch(n){return{err:new Error("Invalid JSON: syntax is invalid")}}switch(r.grammarVersion){case 2:case 3:{if(!r.hasOwnProperty("implementation"))return{err:new Error("Invalid JSON: missing implementation field")};if(!r.implementation.hasOwnProperty("version"))return{err:new Error("Invalid JSON: missing implementation version field")};if(!r.implementation.hasOwnProperty("settings"))return{err:new Error("Invalid JSON: missing implementation settings field")};const e=r.implementation.version;if(r.implementation.settings.hasOwnProperty("javaClassPath")){const[t,i]=r.implementation.settings.javaClassPath.split(/\.(?=[^.]+$)/);return{ok:{language:n.LanguageEnum.JAVA,version:e,packageName:t,className:i}}}return r.implementation.settings.hasOwnProperty("library")?{ok:{language:n.LanguageEnum.CPP,version:e}}:{err:new Error("Invalid JSON: missing implementation library or javaClassPath field")}}default:return{err:new Error("Invalid JSON: grammarVersion must be 2 or 3")}}},n});