FromProcessReferenceCouldNotBeRetrieved=无法检索源流程参考。
ToProcessReferenceCouldNotBeRetrieved=无法检索目标流程参考。
AlternateRelationCouldNotBeCreated=无法创建替代关系。
ProcessReferenceCouldNotBeRetrieved=无法检索流程参考。
ResourceReferenceCouldNotBeRetrieved=无法检索资源参考。
FirstReferenceCouldNotBeRetrieved=无法检索第一个参考。
SecondReferenceCouldNotBeRetrieved=无法检索第二个参考。
LinkAlreadyExists=链接已存在。
GenericServerError=通用服务器错误。
BlockingInstances=该参考仍在删除范围之外实例化。您需要先移除现有实例，才能删除该参考。
ReorderInstancesFailed=实例指令无法存储在数据库中。
XMLDocumentRetrievalError=查找包含 XML 文件的文档时出错。

# CIM (reroute) failure errMsgs
ImplLinkUnderMultipleScopes=制造项目存在于多个范围中。从上面第一个范围开始修订并替换所有未限定范围的父项。
RootMfgItemIsNotValid=提供的制造参考无效
RootProductIsNotValid=提供的产品参考无效
ParentMfgIsReadOnly=MBOM 更新无法完成，因为父制造项目 {0} 处于只读状态
RootMfgIsReadOnly=MBOM 更新无法完成，因为根制造项目 {0} 的当前状态不允许对 MBOM 结构进行任何修改
MfgIsReadOnly=MBOM 更新无法完成，因为制造项目 {0} 处于只读状态
MBOMUpdateFail_CandPrdMultipleScopes=无法处理产品“{0}”，因为制造项目“{1}”的候选产品“{2}”具有多个制造项目范围 [{3}]
MBOMUpdateWarn_CandPrdMultiScopesButOneSel=制造项目“{0}”的候选产品“{1}”具有多个制造项目范围 [{2}]，考虑将其中第一个创建的“{3}”进行重设！
MBOMUpdateFail_MultipleCandProducts=“{1}”制造项目存在多个候选产品“{0}”。“更改影响管理”是建议用于此制造项目的命令。
MBOMUpdateWarn_MultipleCandPrdsButOneSel=找到“{1}”制造项目的多个候选产品“{0}”，考虑将其中最新的“{2}”进行重设！
MBOMUpdateFail_InvalidMbomUpdateAction1=发送的 MBOM 更新操作“{0}”无效
MBOMUpdateFail_InvalidMbomUpdateAction2=为“{1}”发送的 MBOM 更新操作“{0}”无效
CandPrdMultipleScopes=候选产品“{0}”具有多个制造项目范围
MultipleCandPrd=“{1}”制造项目存在多个候选产品“{0}”。“更改影响管理”是建议用于此制造项目的命令。
InvalidMbomUpdateAction=为 {0} 发送的无效 MBOM 更新操作
BranchCreationFailed=新分支创建失败
UpdateMfgItemErr_RerouteSLFail_ItemROState=无法重设范围链接，因为制造项目“{0}”处于只读状态
MBOMUpdateFail_CandPrdMultipleScopes=无法处理产品“{0}”，因为制造项目“{1}”的候选产品“{2}”具有多个制造项目范围
MBOMUpdateFail_InvalidMbomUpdateAction1=发送的 MBOM 更新操作“{0}”无效
MBOMUpdateFail_InvalidMbomUpdateAction2=为“{1}”发送的 MBOM 更新操作“{0}”无效
MBOMUpdateFail_RerouteILWithEff=“仅重新路由”选项不适用于“根据适用情况以演变或 CA 工作”。演变实例是建议的操作。
MBOMUpdateFail_EvolveInstWithoutEff=演变实例只能根据适用情况以演变或 CA 工作。请设置根据适用情况以演变或 CA 工作，然后重试。

# Replace Command properties
ReplaceMfgItemScopedWithDifferentProduct=替换操作被忽略，{0} 的范围被限定至另一产品
ReplaceMfgItemParentIsReadOnly=替换操作被忽略，{0} 未处于读写成熟度状态
ReplaceByLatestNoLatestRevision=替换操作被忽略，{0} 已是最新修订版
ReplaceSelectedItemIsNotMfgItem=替换操作被忽略，{0} 不是制造项目
ReplaceOperationSuccess=成功将 {0} 替换为 {1}。
ReplaceOperationFailed=将 {0} 替换为 {1} 失败。
ReplaceInstanceDoesNotExist=替换失败。所选实例不存在。
ReplaceBySelectedRefDoesNotExist=替换 {0} 失败。参考不存在。
ReplaceMfgProcessParentIsReadOnly=替换操作被忽略，{0} 的父项处于读写成熟度状态
ReplaceOperationWarning=替换选定项目“{0}”将删除其子项的实施链接。子实施链接需要使用 CIM 手动处理。

# MBOM update initial validation check errorMsgs
MBOMUpdateFailure_NoUpdateMode=无法完成 MBOM 更新，因为未指定 MBOM 更新模式
MBOMUpdateFailure_InvalidUpdateMode=无法完成 MBOM 更新，因为指定的 MBOM 更新模式不正确。它可以是“mbomPull”、“ebomPush”或“flowdown”
MBOMUpdateFailure_NoRootMfgItem=无法完成 MBOM 更新，因为未指定制造项目
MBOMUpdateFailure_InvalidRootMfgItem=无法检索根制造项目。请为“rootMfgItemID”指定有效值！
MBOMUpdateFailure_RootMfgItemIsNotMFG=为“rootMfgItemID”指定的值应该是 MFG 类型，但它是类型“{0}”！
MBOMUpdateFail_RootCnfgdWithEvolNUpdateWithoutEff=无法完成 MBOM 更新，因为根制造项目配置有演变但未在有效性下完成更新！
MBOMUpdateFail_RootChgCntrldNUpdateWithoutMCA=无法完成 MBOM 更新，因为根制造项目由 CA“{0}”控制，但未使用工作条件 CA 完成更新！
MBOMUpdateFail_RootCntrldByCA_ButDiffInputCA=无法完成 MBOM 更新，因为根制造项目由给定工作条件 CA 之外的 CA“{0}”控制！
MBOMUpdateFailure_NewRevOfRootFailed=无法完成 MBOM 更新，因为无法创建制造项目的新修订版
MBOMUpdateFailure_NoRootProduct=无法完成 MBOM 更新，因为未指定根产品并且制造项目未被限定至任何产品
MBOMUpdateFailure_InvalidRootProduct=无法检索根产品。请为“rootProductID”指定有效值！
MBOMUpdateFailure_RootProductIsNotPRD=为“rootProductID”指定的值应该是产品类型，但它是类型“{0}”！
MBOMUpdateFailure_PushModeNoEngCA=无法完成 MBOM 更新，因为未指定 EngCA。请为“engChangeActionID”指定有效值！
MBOMUpdateFail_FlowdownSupportVarMissing=请设置变量“MBOMUpdate_FlowdownSupport=1”以启用“传递模式”和\\或“更新报告”
MBOMUpdateFail_ReviseBehvrChkInvalidOption=为“reviseBehaviorChecks”指定的值无效。请指定“{0}”中的任一有效值！
MBOMUpdateFailure_CommitFailed=MBOM 更新无法提交！

# MBOM update further validation check errorMsgs
PullModeMBOMUpdateFail_RootsNotScoped=无法完成 MBOM 更新，因为给定的产品和制造项目之间不存在范围
PushModeMBOMUpdateFail_CAFactoryNull=无法获取“ChangeActionFactory”。请联系管理员！
PushModeMBOMUpdateFail_InvalidEngCA=无法从给定 EngCA-PID“{0}”检索工程 CA。请为“engChangeActionID”指定有效值！
PushModeMBOMUpdateFail_InvalidEngCAState=无法完成 MBOM 更新，因为给定工程 CA 未处于“完成”状态
PushModeMBOMUpdateFail_RootMfgNotScoped=无法完成 MBOM 更新，因为制造项目没有限定的产品
PushModeMBOMUpdateFail_RootMfgManyScope=无法完成 MBOM 更新，因为制造项目具有多个限定的产品

FlowdownMBOMUpdateFail_NoMfgCA=无法完成 MBOM 更新，因为未指定 MfgCA。请在 HTTP 请求标头的“DS-Change-Authoring-Context”中指定有效值！
FlowdownMBOMUpdateFail_InvalidMfgCA=无法从给定 MfgCA-PID“{0}”检索制造 CA。请在 HTTP 请求标头的“DS-Change-Authoring-Context”中指定有效值！
FlowdownMBOMUpdateWarn_NoProposedChanges=指定的制造 CA 没有传递更改。请从一个或多个工程 CA 使用具有传递更改的制造 CA 尝试！

# MfgCA validation check errorMsgs
MfgCAError_InvalidMfgCAFormat=指定的制造 CA“{0}”未采用正确格式。请采用格式“pid:<MfgCA-PID>”指定
MfgCAError_InvalidMfgCA=无法从给定 MfgCA-PID“{0}”检索制造 CA。请为 MfgCA-PID 指定有效值！
MfgCAError_WorkUnderNotAllowed=给定 Mfg.CA 不允许工作条件：“{0}”
MfgCAError_ApplicabilityFetchFailed=无法获取给定 Mfg.CA 的适用性表达式：“{0}”
MfgCAError_NoApplicability=给定 Mfg.CA 没有关联的适用性。请指定具有适用性的 Mfg.CA！
MfgCAError_InvalidApplicabilityExpn=给定 Mfg.CA 的适用性表达式无效：“{0}”

# MBOM update failure errMsgs
MBOMUpdateFail_InvalidMbomUpdateAction1=发送的 MBOM 更新操作“{0}”无效
MBOMUpdateFail_RootMfgIsReadOnly=MBOM 更新无法完成，因为根制造项目“{0}”的当前状态不允许对 MBOM 结构进行任何修改
MBOMUpdateFail_ParentMfgIsReadOnly=MBOM 更新无法完成，因为父“{0}”处于只读状态
MBOMUpdateFail_ParentCnfgdWithEvolNUpdateWithoutEff=无法处理产品“{0}”，因为制造项目“{1}”的父“{2}”配置有演变，但未在有效性下完成更新
MBOMUpdateFail_CandPrdMultipleScopes=无法处理产品“{0}”，因为制造项目“{1}”的候选产品“{2}”具有多个制造项目范围
MBOMUpdateFail_ManyResultingPrdFound=制造项目“{0}”具有多个关联的 resultingProduct
MBOMUpdateFail_MfgPartSLCreationNotSupported=不支持为制造零件创建范围链接
MBOMUpdateFail_CC_CAPID_UnknownValue=遇到用于控制制造项目“{1}”的 CA PID 的未知值“{0}”
MBOMUpdateFail_GetChangeControlInfoFailed=无法检索要更新的项目的更改控制信息
# Note: Below ReviseErr* msgKeys can't be changed since they are enum names in ReviseAllowedStatus. So they have to be always in sync, if changed at one place then have to be changed at both places!!
ReviseErr_ItemCntrldByCA_ButNoInputCA=修订失败，因为制造项目“{0}”由 CA“{1}”控制，但未使用工作条件 CA 完成更新 
ReviseErr_ItemCntrldByCA_ButDiffInputCA=修订失败，因为制造项目“{0}”由给定工作条件 CA 之外的 CA“{1}”控制
ReviseErr_ItemCntrldByInputCA_ButIsInROState=修订失败，因为用户没有修订制造项目“{0}”的访问权限 
MBOMUpdtWarn_ItemCfgdWithEvolReviseIgnored=制造项目“{0}”配置有演变，因此项目修订被忽略
# Note: Below UpdateErr* msgKeys can't be changed since they are enum names in UpdateAllowedStatus. So they have to be always in sync, if changed at one place then have to be changed at both places!!
UpdateErr_ItemCntrldByCA_ButNoInputCA=更新失败，因为 {0}“{1}”由 CA“{2}”控制，但未使用工作条件 CA 完成更新
UpdateErr_ItemCntrldByCA_ButDiffInputCA=更新失败，因为 {0}“{1}”由给定工作条件 CA 之外的 CA“{2}”控制
UpdateErr_ItemCntrldByInputCA_ButIsInROState=更新失败，因为用户没有修改 {0}“{1}”的访问权限
UpdateErr_ItemNotCntrldByCA_AndIsInROState=更新失败，因为用户没有修改 {0}“{1}”的访问权限

MBOMUpdateFail_DuringExpand=展开 {0}“{1}”时发现异常
MBOMUpdateFail_ExpandCacheCreation=为 {0}“{1}”创建 expandCache 时发现异常
PushModeMBOMUpdate_GetRealizedObjsFailed=从给定 CA 获取已实现对象时发生异常
PullModeMBOMUpdateFail_UpdateMapPrepartn=在查找增量更改和准备 mbomUpdateMap 时捕获到异常
PushModeMBOMUpdate_MultipleCandPathsFound=为给定的候选产品“{0}”找到了多个候选产品 occPath 

# Fasten update failure errMsgs
FastenUpdateFail_NotPushModeUpdate=无法进行紧固更新，因为更新既不是在 flowdown 模式下完成，也不是在 ebomPush 模式下完成
FastenUpdateFail_NewCaseInvalidOption=为“fastenUpdateForNewFastener”指定的值无效。请指定“{0}”中的任一有效值！
FastenCreateFail_NoImpactedMfgPartFound=无法处理新紧固件“{0}”，因为受影响制造零件不可用于紧固 {1}
FastenUpdateFail_CommitFailed=紧固更新无法提交！
FastenNewOptn1Fail_ParentCnfgdWithEvolNUpdateWithoutEff=无法实例化紧固件“{1}”的紧固“{0}”，因为父“{2}”配置有演变，但未在有效状态下完成更新
NewFastenerWarnMsg_ChoosenOneAmongMany=找到 {0} 个紧固件接合与给定紧固件“{2}”相同的零件“{1}”。其中，选择了实施紧固“{4}”的“{3}”，而其余紧固件“{5}”被忽略
NewFastenerWarn_Ignored_NoStackingPartsFoundForMCXConn=新紧固件警告：正在忽略新紧固件实例，因为未找到 MCX 连接 {0} 的堆叠零件
NewFastenerWarn_Ignored_MCXIntersectedListEmpty=新紧固件警告：正在忽略新紧固件实例，因为 intersectedMCXList 为空
NewFastenerErr_FastenerInstanceNotFound=新紧固件错误：实例在数据库中不可用于新紧固件 instancePID {0}
NewFastenerErr_FailToGetSiblingFasteners=新紧固件错误：无法从新紧固件实例 {1} 的束紧固件 {0} 中获取同级紧固件
NewFastenerWarn_Ignored_InvalidPartIDForBundleConn=新紧固件警告：正在忽略连接 {0}，因为为新紧固件实例 {2} 找到的接合零件 instancePID {1} 无效
NewFastenerErr_FailToGetJoiningPartsFrmBundle=新紧固件错误：无法从新紧固件实例 {1} 的束紧固件 {0} 中获取接合零件

# MBOM update report errMsgs
UpdateMfgItemErr_BIStatusFail=获取 BI 状态失败
UpdateMfgItemErr_UpdateFailed=执行更新失败
UpdateMfgItemErr_DeleteInstFailed=删除实例失败
UpdateMfgItemErr_RerouteSLFailed=重设范围链接失败
UpdateMfgItemErr_NoCandOccRefPaths=未找到候选 occRef 路径！
UpdateMfgItemErr_RerouteILFailed=重设实施链接失败
UpdateMfgItemErr_ReviseMfgPartsFailed=修订一个或多个制造零件失败
UpdateMfgItemErr_ReplaceFail_ParentROState=替换“{0}”失败，因为父“{1}”处于只读状态
UpdateMfgItemErr_DeleteFail_ParentROState=删除“{0}”失败，因为父“{1}”处于只读状态
UpdateMfgItemErr_EvolveFail_ParentROState=演变“{0}”失败，因为父“{1}”处于只读状态

ObjectProcessedInPreviousRunMsg=正在忽略此对象，因为已在上一个运行中更新它
ObjectProcessedByUserMsg=正在忽略此对象，因为用户已处理它
ObjectUnderScopedSubAsslyORImplingMfgNotFound=被忽略，因为实施制造项目存在于界定范围的子装配体下，或者未找到实施此产品的制造项目 
noAttrValueFound=未找到属性值

# CreateMfgItems resultReport errMsgs
createMfgItemErrorMsgRootMfgItemIsNotValid=提供的制造参考无效
createMfgItemErrorMsgRootProductIsNotValid=提供的产品参考无效
createMfgItemErrorMsgBLReplyIsIgnore=因 BL 请求而忽略
createMfgItemErrorMsgBLDidntProvideAnyInfo=因 BL 未提供所需信息而忽略
createMfgItemErrorMsgProductHasMultipleScopes=因产品具有多个范围而忽略
createMfgItemWarn_PrdHasManyScopesButOneSel=产品具有多个制造项目范围 [{0}]，考虑其中第一个创建的“{1}”！
createMfgItemErrorMsgScopeNotFound=无法找到被忽略的范围
createMfgItemErrorMsgException=因出现异常情况而被忽略。  
createMfgItemErrorMsgExceptionWhileCreatingInst=实例创建失败，无异常情况 
createMfgItemErrorMsgExceptionWhileCreatingInstAndLink=创建实例和链接时，出现异常情况
createMfgItemErrorMsgExternalJavaIgnoreAsBLNotAvilable=被忽略，因为外部 Java 开放性请求了 EKL 但它不可用
createMfgItemErrorMsg_ParentWorkUnderStatus_isNotValid_As_NoInputCA_ButAggMfgIsControlledByCA=被忽略，因为聚集制造项目由更改操作控制，但输入中未提供更改操作
createMfgItemErrorMsg_ParentWorkUnderStatus_isNotValid_As_InputCA_AggMfgCA_AreDifferernt=被忽略，因为聚集制造项目由不同于输入中提供的更改操作控制


# License error
licenceError=未将 {0} 中的任何许可证分派给用户：{1}。请联系您的系统管理员。

noAttrValueFound=未找到属性值

# BL error
BLError=操作因 BL 检查而失败：{0}。
NoBLMessage=未找到 BL 消息

RPLinkCreationFailed=无法创建新结果产品链接
ScopeLinkDeletionFailed=不能删除范围链接
RPLinkDeletionFailed=不能删除结果产品链接

# Create Ref error
InvalidDimensionType=发送的尺寸类型无效 - {0}

# Scope Link creation
createScopeLinkError=无法创建新范围链接
createScopeLinkErrorIncompatibleExistingIL=由于现有实施链接不兼容，无法创建范围链接。请先从 {0} 参考的实例删除实施链接。
createScopeLinkErrorNotAuthorizedByBL=由于 BL 授权失败，无法创建范围链接
createScopeLinkErrorBLFailure=由于 BL 内部故障，无法创建范围链接
createScopeLinkErrorPatternNOTAuthorized=由于数据模式未经授权，无法创建范围链接

# Partial Scope Link creation
SLAlreadyExistingSolved=部分范围链接已存在，无法创建部分范围链接 
SLAlreadyExistingBroken=部分范围链接已存在且已损坏，无法创建部分范围链接
invalidArg=输入未正确估值。
createPartialScopeLinkErrorBLFailure=由于 BL 内部故障，无法创建部分范围链接
createPartialScopeLinkErrorNotAuthorizedByBL=由于 BL 授权失败，无法创建部分范围链接
createPartialScopeLinkErrorIncompatibleExistingIL=由于现有实施链接不兼容，无法创建部分范围链接。请先从 {0} 参考的实例删除实施链接。
createPartialScopeLinkError=无法创建新部分范围链接

managePartialScopeFail_InvalidOption=为“部分范围操作”指定的值无效。请指定“{0}”中的任一有效值！

# MFN AltSubBL Related Messages
AltSubBLErr_NoBLExistis=AltSubBL EKL 脚本不存在
AltSubBLErr_ExecutionFailed=AltSubBL 执行失败
AltSubBLErr_FailedToReadOutput=从 AltSub-BLResult 读取输出失败
AltSubBLErr_InvalidOPListSize=BL 输出列表大小不匹配！大小有 OutputListOfEngItemReference-{0}、OutputListOfContextsInstance-{1}、OutputListOfContextsReference-{2}、OutputListOfStatus-{3}、OutputListOfRelationType-{4}。
AltSubBLErr_EngItemRefPIDEmpty=未为“AltSub-EngItemRef”指定值
AltSubBLErr_StatusInvalidOption=为“AltSub-Status”指定的值“{0}”无效
AltSubBLErr_RelTypeInvalidOption=为“AltSub-RelationType”指定的值“{0}”无效
AltSubBLErr_InvalidRefInstContext=ReferenceContext 和/或 InstanceContext 与预期不符
AltSubBLSuggn_ForContextOfRefSubstitue=（ReferenceContext 应有有效值并且 InstanceContext 应为空）
AltSubBLSuggn_ForContextOfInstSubstitue=（ReferenceContext 应为空并且 InstanceContext 应有有效值）
AltSubBLSuggn_ForContextOfAlternate=（ReferenceContext 和 InstanceContext 应为空）
